"use strict";(self.webpackChunk_antv_x6_sites=self.webpackChunk_antv_x6_sites||[]).push([[9706],{41392:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(6267),t(1706)),p=t(71117),u=t(44170),s=t(60759),v={"docs-api-graph-background-demo-api-graph-background":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,25376))}))),asset:{type:"BLOCK",id:"docs-api-graph-background-demo-api-graph-background",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(61433).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(95027).Z},"./settings.tsx":{type:"FILE",value:t(13388).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":p,"./settings.tsx":u,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/api/background/playground/index.less":p,"/home/runner/work/X6/X6/site/src/api/background/playground/settings.tsx":u,antd:s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},86161:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(82671),t(1706)),p=t(46997),u=t(25508),s=t(60759),v={"docs-api-graph-coordinate-demo-api-graph-coord":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,82337))}))),asset:{type:"BLOCK",id:"docs-api-graph-coordinate-demo-api-graph-coord",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(46813).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(26674).Z},"./settings.tsx":{type:"FILE",value:t(17534).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":p,"./settings.tsx":u,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/api/coord/playground/index.less":p,"/home/runner/work/X6/X6/site/src/api/coord/playground/settings.tsx":u,antd:s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},62442:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(84421);var n={}},70698:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(23799),t(1706)),p=t(22222),u=t(79193),s=t(60759),v={"docs-api-graph-grid-demo-api-graph-grid":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,48e3))}))),asset:{type:"BLOCK",id:"docs-api-graph-grid-demo-api-graph-grid",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(80973).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(44848).Z},"./settings.tsx":{type:"FILE",value:t(55029).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":p,"./settings.tsx":u,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/api/grid/playground/index.less":p,"/home/runner/work/X6/X6/site/src/api/grid/playground/settings.tsx":u,antd:s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},44708:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(61579),t(1706)),p=t(31472),u=t(76497),s=t(60759),v={"docs-api-graph-mousewheel-demo-api-graph-mousewheel":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,75087))}))),asset:{type:"BLOCK",id:"docs-api-graph-mousewheel-demo-api-graph-mousewheel",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(58779).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(17911).Z},"./settings.tsx":{type:"FILE",value:t(79741).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":p,"./settings.tsx":u,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/api/mousewheel/playground/index.less":p,"/home/runner/work/X6/X6/site/src/api/mousewheel/playground/settings.tsx":u,antd:s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},17895:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(52176),t(1706)),p=t(1011),u=t(34810),s=t(60759),v={"docs-api-graph-panning-demo-api-graph-panning":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,50785))}))),asset:{type:"BLOCK",id:"docs-api-graph-panning-demo-api-graph-panning",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(43323).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(92797).Z},"./settings.tsx":{type:"FILE",value:t(26098).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":p,"./settings.tsx":u,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/api/panning/playground/index.less":p,"/home/runner/work/X6/X6/site/src/api/panning/playground/settings.tsx":u,antd:s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},40414:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(23918);var n={}},96207:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(9230);var n={}},49287:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(89508);var n={}},65082:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(55444);var n={}},45597:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(75619);var n={}},24462:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return w}});var o,d,r,l,I,c,i=t(29008),p=t.n(i),u=t(70958),s=t.n(u),v=t(29186),x=(t(91242),t(1706)),h=t(28666),g=t(80935),m=t(79435),f=t(78880),b=t(84553),y=t(45550),w={"docs-api-model-labels-demo-append-label":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,12878))}))),asset:{type:"BLOCK",id:"docs-api-model-labels-demo-append-label",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(17347).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(26083).Z}},entry:"index.tsx"},context:{"./index.less":h,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/label/append-label/index.less":h},renderOpts:{compile:(c=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return c.apply(this,arguments)})}},"docs-api-model-labels-demo-label-position":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,34529))}))),asset:{type:"BLOCK",id:"docs-api-model-labels-demo-label-position",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(56202).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(57861).Z}},entry:"index.tsx"},context:{"./index.less":g,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/label/label-position/index.less":g},renderOpts:{compile:(I=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return I.apply(this,arguments)})}},"docs-api-model-labels-demo-label-offset":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,32520))}))),asset:{type:"BLOCK",id:"docs-api-model-labels-demo-label-offset",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(17371).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(34832).Z}},entry:"index.tsx"},context:{"./index.less":m,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/label/label-offset/index.less":m},renderOpts:{compile:(l=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-api-model-labels-demo-label-rotate":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,63388))}))),asset:{type:"BLOCK",id:"docs-api-model-labels-demo-label-rotate",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(89781).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(44544).Z}},entry:"index.tsx"},context:{"./index.less":f,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/label/label-rotate/index.less":f},renderOpts:{compile:(r=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-api-model-labels-demo-label-markup":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,60549))}))),asset:{type:"BLOCK",id:"docs-api-model-labels-demo-label-markup",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(18217).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(5680).Z}},entry:"index.tsx"},context:{"./index.less":b,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/label/label-markup/index.less":b},renderOpts:{compile:(d=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-api-model-labels-demo-label-attrs":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,73565))}))),asset:{type:"BLOCK",id:"docs-api-model-labels-demo-label-attrs",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(48450).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(71186).Z}},entry:"index.tsx"},context:{"./index.less":y,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/label/label-attrs/index.less":y},renderOpts:{compile:(o=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},43199:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return P}});var o,d,r,l,I,c,i=t(29008),p=t.n(i),u=t(70958),s=t.n(u),v=t(29186),x=(t(17053),t(1706)),h=t(14542),g=t(40408),m=t(60759),f=t(97483),b=t(83705),y=t(11497),w=t(32584),k=t(30964),P={"docs-api-model-marker-demo-marker-native":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,59637))}))),asset:{type:"BLOCK",id:"docs-api-model-marker-demo-marker-native",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(44551).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(32015).Z},"./settings.tsx":{type:"FILE",value:t(2678).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":h,"./settings.tsx":g,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/marker/native/index.less":h,"/home/runner/work/X6/X6/site/src/api/marker/native/settings.tsx":g,antd:m},renderOpts:{compile:(c=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return c.apply(this,arguments)})}},"docs-api-model-marker-demo-marker-path":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,94696))}))),asset:{type:"BLOCK",id:"docs-api-model-marker-demo-marker-path",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(59330).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(21036).Z}},entry:"index.tsx"},context:{"./index.less":f,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/marker/path/index.less":f},renderOpts:{compile:(I=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return I.apply(this,arguments)})}},"docs-api-model-marker-demo-marker-custom":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,35661))}))),asset:{type:"BLOCK",id:"docs-api-model-marker-demo-marker-custom",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(96028).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(39051).Z}},entry:"index.tsx"},context:{"./index.less":b,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/marker/custom/index.less":b},renderOpts:{compile:(l=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-api-model-marker-demo-marker-normalize-path":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,62535))}))),asset:{type:"BLOCK",id:"docs-api-model-marker-demo-marker-normalize-path",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(69913).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(19992).Z}},entry:"index.tsx"},context:{"./index.less":y,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/marker/normalize-path/index.less":y},renderOpts:{compile:(r=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-api-model-marker-demo-marker-image":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,90345))}))),asset:{type:"BLOCK",id:"docs-api-model-marker-demo-marker-image",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(88018).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(4394).Z}},entry:"index.tsx"},context:{"./index.less":w,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/marker/image/index.less":w},renderOpts:{compile:(d=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-api-model-marker-demo-marker-tagname":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,84709))}))),asset:{type:"BLOCK",id:"docs-api-model-marker-demo-marker-tagname",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(4618).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(98587).Z}},entry:"index.tsx"},context:{"./index.less":k,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/marker/tagname/index.less":k},renderOpts:{compile:(o=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},9947:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(93629);var n={}},6023:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(16687);var n={}},38277:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(98983);var n={}},40510:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return f}});var o,d,r,l=t(29008),I=t.n(l),c=t(70958),i=t.n(c),p=t(29186),u=(t(61851),t(1706)),s=t(8016),v=t(45811),x=t(60759),h=t(89167),g=t(3196),m=t(78754),f={"docs-api-registry-attr-demo-attrs-x-align":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,25174))}))),asset:{type:"BLOCK",id:"docs-api-registry-attr-demo-attrs-x-align",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(55988).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(82713).Z},"./settings.tsx":{type:"FILE",value:t(61258).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":s,"./settings.tsx":v,react:n||(n=t.t(p,2)),"@antv/x6":u,"/home/runner/work/X6/X6/site/src/api/attrs/x-align/index.less":s,"/home/runner/work/X6/X6/site/src/api/attrs/x-align/settings.tsx":v,antd:x},renderOpts:{compile:(r=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-api-registry-attr-demo-attrs-text-wrap":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,5207))}))),asset:{type:"BLOCK",id:"docs-api-registry-attr-demo-attrs-text-wrap",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(97724).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(87136).Z}},entry:"index.tsx"},context:{"./index.less":h,react:n||(n=t.t(p,2)),"@antv/x6":u,"/home/runner/work/X6/X6/site/src/api/attrs/text-wrap/index.less":h},renderOpts:{compile:(d=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-api-registry-attr-demo-attrs-text-anchor":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,24148))}))),asset:{type:"BLOCK",id:"docs-api-registry-attr-demo-attrs-text-anchor",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(4838).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(13).Z},"./settings.tsx":{type:"FILE",value:t(90021).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":g,"./settings.tsx":m,react:n||(n=t.t(p,2)),"@antv/x6":u,"/home/runner/work/X6/X6/site/src/api/attrs/text-anchor/index.less":g,"/home/runner/work/X6/X6/site/src/api/attrs/text-anchor/settings.tsx":m,antd:x},renderOpts:{compile:(o=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},9628:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(70367),t(1706)),p=t(27523),u=t(22466),s=t(60759),v={"docs-api-registry-connection-point-demo-connection-point":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,54030))}))),asset:{type:"BLOCK",id:"docs-api-registry-connection-point-demo-connection-point",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(78112).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(19907).Z},"./settings.tsx":{type:"FILE",value:t(10593).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":p,"./settings.tsx":u,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/api/connection-point/playground/index.less":p,"/home/runner/work/X6/X6/site/src/api/connection-point/playground/settings.tsx":u,antd:s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},39731:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return k}});var o,d,r,l,I,c=t(29008),i=t.n(c),p=t(70958),u=t.n(p),s=t(29186),v=(t(68075),t(1706)),x=t(6713),h=t(47283),g=t(30609),m=t(28089),f=t(60759),b=t(74894),y=t(75119),w=t(5427),k={"docs-api-registry-connector-demo-connector-normal":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,76566))}))),asset:{type:"BLOCK",id:"docs-api-registry-connector-demo-connector-normal",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(82514).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(68124).Z}},entry:"index.tsx"},context:{"./index.less":x,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/api/connector/normal/index.less":x},renderOpts:{compile:(I=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return I.apply(this,arguments)})}},"docs-api-registry-connector-demo-connector-smooth":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,50174))}))),asset:{type:"BLOCK",id:"docs-api-registry-connector-demo-connector-smooth",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(59094).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(1733).Z}},entry:"index.tsx"},context:{"./index.less":h,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/api/connector/smooth/index.less":h},renderOpts:{compile:(l=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-api-registry-connector-demo-connector-rounded":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,38330))}))),asset:{type:"BLOCK",id:"docs-api-registry-connector-demo-connector-rounded",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(89742).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(36751).Z},"./settings.tsx":{type:"FILE",value:t(2687).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":g,"./settings.tsx":m,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/api/connector/rounded/index.less":g,"/home/runner/work/X6/X6/site/src/api/connector/rounded/settings.tsx":m,antd:f},renderOpts:{compile:(r=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-api-registry-connector-demo-connector-jumpover":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,44843))}))),asset:{type:"BLOCK",id:"docs-api-registry-connector-demo-connector-jumpover",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(7426).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(52408).Z},"./settings.tsx":{type:"FILE",value:t(50046).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":b,"./settings.tsx":y,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/api/connector/jumpover/index.less":b,"/home/runner/work/X6/X6/site/src/api/connector/jumpover/settings.tsx":y,antd:f},renderOpts:{compile:(d=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-api-registry-connector-demo-connector-wobble":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,28356))}))),asset:{type:"BLOCK",id:"docs-api-registry-connector-demo-connector-wobble",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(43756).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(44020).Z}},entry:"index.tsx"},context:{"./index.less":w,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/api/connector/wobble/index.less":w},renderOpts:{compile:(o=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},15809:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(61039),t(1706)),p=t(45409),u=t(81482),s=t(60759),v={"docs-api-registry-edge-anchor-demo-edge-anchor-playground":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,36230))}))),asset:{type:"BLOCK",id:"docs-api-registry-edge-anchor-demo-edge-anchor-playground",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(83704).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(37547).Z},"./settings.tsx":{type:"FILE",value:t(55131).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":p,"./settings.tsx":u,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/api/edge-anchor/playground/index.less":p,"/home/runner/work/X6/X6/site/src/api/edge-anchor/playground/settings.tsx":u,antd:s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},90551:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return D}});var o,d,r,l,I,c,i,p,u,s=t(29008),v=t.n(s),x=t(70958),h=t.n(x),g=t(29186),m=(t(76953),t(1706)),f=t(61939),b=t(63357),y=t(38444),w=t(53461),k=t(83182),P=t(38606),N=t(88907),T=t(59609),C=t(1307),D={"docs-api-registry-edge-tool-demo-api-edge-tool-vertices":{component:g.memo(g.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,91738))}))),asset:{type:"BLOCK",id:"docs-api-registry-edge-tool-demo-api-edge-tool-vertices",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(87812).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(95617).Z}},entry:"index.tsx"},context:{"./index.less":f,react:n||(n=t.t(g,2)),"@antv/x6":m,"/home/runner/work/X6/X6/site/src/api/edge-tool/vertices/index.less":f},renderOpts:{compile:(u=h()(v()().mark((function e(){var a,n=arguments;return v()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return u.apply(this,arguments)})}},"docs-api-registry-edge-tool-demo-api-edge-tool-segments":{component:g.memo(g.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,84255))}))),asset:{type:"BLOCK",id:"docs-api-registry-edge-tool-demo-api-edge-tool-segments",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(33967).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(49785).Z}},entry:"index.tsx"},context:{"./index.less":b,react:n||(n=t.t(g,2)),"@antv/x6":m,"/home/runner/work/X6/X6/site/src/api/edge-tool/segments/index.less":b},renderOpts:{compile:(p=h()(v()().mark((function e(){var a,n=arguments;return v()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return p.apply(this,arguments)})}},"docs-api-registry-edge-tool-demo-api-edge-tool-boundary":{component:g.memo(g.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,96064))}))),asset:{type:"BLOCK",id:"docs-api-registry-edge-tool-demo-api-edge-tool-boundary",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(10057).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(44534).Z}},entry:"index.tsx"},context:{"./index.less":y,react:n||(n=t.t(g,2)),"@antv/x6":m,"/home/runner/work/X6/X6/site/src/api/edge-tool/boundary/index.less":y},renderOpts:{compile:(i=h()(v()().mark((function e(){var a,n=arguments;return v()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return i.apply(this,arguments)})}},"docs-api-registry-edge-tool-demo-api-edge-tool-button":{component:g.memo(g.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,59485))}))),asset:{type:"BLOCK",id:"docs-api-registry-edge-tool-demo-api-edge-tool-button",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(40727).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(18356).Z}},entry:"index.tsx"},context:{"./index.less":w,react:n||(n=t.t(g,2)),"@antv/x6":m,"/home/runner/work/X6/X6/site/src/api/edge-tool/button/index.less":w},renderOpts:{compile:(c=h()(v()().mark((function e(){var a,n=arguments;return v()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return c.apply(this,arguments)})}},"docs-api-registry-edge-tool-demo-api-edge-tool-button-remove":{component:g.memo(g.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,59981))}))),asset:{type:"BLOCK",id:"docs-api-registry-edge-tool-demo-api-edge-tool-button-remove",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(54603).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(22568).Z}},entry:"index.tsx"},context:{"./index.less":k,react:n||(n=t.t(g,2)),"@antv/x6":m,"/home/runner/work/X6/X6/site/src/api/edge-tool/button-remove/index.less":k},renderOpts:{compile:(I=h()(v()().mark((function e(){var a,n=arguments;return v()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return I.apply(this,arguments)})}},"docs-api-registry-edge-tool-demo-api-edge-tool-arrowhead":{component:g.memo(g.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,41719))}))),asset:{type:"BLOCK",id:"docs-api-registry-edge-tool-demo-api-edge-tool-arrowhead",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(602).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(79425).Z}},entry:"index.tsx"},context:{"./index.less":P,react:n||(n=t.t(g,2)),"@antv/x6":m,"/home/runner/work/X6/X6/site/src/api/edge-tool/arrowhead/index.less":P},renderOpts:{compile:(l=h()(v()().mark((function e(){var a,n=arguments;return v()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-api-registry-edge-tool-demo-api-edge-tool-editor":{component:g.memo(g.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,87837))}))),asset:{type:"BLOCK",id:"docs-api-registry-edge-tool-demo-api-edge-tool-editor",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(97579).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(79735).Z}},entry:"index.tsx"},context:{"./index.less":N,react:n||(n=t.t(g,2)),"@antv/x6":m,"/home/runner/work/X6/X6/site/src/api/node-tool/node-editor/index.less":N},renderOpts:{compile:(r=h()(v()().mark((function e(){var a,n=arguments;return v()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-api-registry-edge-tool-demo-api-edge-tool-custom-vertices":{component:g.memo(g.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,42419))}))),asset:{type:"BLOCK",id:"docs-api-registry-edge-tool-demo-api-edge-tool-custom-vertices",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(21869).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(243).Z}},entry:"index.tsx"},context:{"./index.less":T,react:n||(n=t.t(g,2)),"@antv/x6":m,"/home/runner/work/X6/X6/site/src/api/edge-tool/custom-vertices/index.less":T},renderOpts:{compile:(d=h()(v()().mark((function e(){var a,n=arguments;return v()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-api-registry-edge-tool-demo-api-edge-tool-custom-arrowhead":{component:g.memo(g.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,96279))}))),asset:{type:"BLOCK",id:"docs-api-registry-edge-tool-demo-api-edge-tool-custom-arrowhead",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(88127).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(91042).Z}},entry:"index.tsx"},context:{"./index.less":C,react:n||(n=t.t(g,2)),"@antv/x6":m,"/home/runner/work/X6/X6/site/src/api/edge-tool/custom-arrowhead/index.less":C},renderOpts:{compile:(o=h()(v()().mark((function e(){var a,n=arguments;return v()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},1638:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return q}});var o,d,r,l,I,c,i,p,u,s,v,x=t(29008),h=t.n(x),g=t(70958),m=t.n(g),f=t(29186),b=(t(99346),t(1706)),y=t(10025),w=t(27521),k=t(60759),P=t(67250),N=t(86025),T=t(50946),C=t(41e3),D=t(18897),E=t(45733),S=t(94422),M=t(13108),L=t(13938),O=t(71535),R=t(9623),A=t(96259),z=t(91367),W=t(24977),F=t(41727),G=t(2491),X=t(24338),V=t(60493),B=t(73354),Z=t(31741),q={"docs-api-registry-filter-demo-filter-drop-shadow":{component:f.memo(f.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,61027))}))),asset:{type:"BLOCK",id:"docs-api-registry-filter-demo-filter-drop-shadow",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(4521).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(59298).Z},"./settings.tsx":{type:"FILE",value:t(13894).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":y,"./settings.tsx":w,react:n||(n=t.t(f,2)),"@antv/x6":b,"/home/runner/work/X6/X6/site/src/api/filter/drop-shadow/index.less":y,"/home/runner/work/X6/X6/site/src/api/filter/drop-shadow/settings.tsx":w,antd:k},renderOpts:{compile:(v=m()(h()().mark((function e(){var a,n=arguments;return h()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return v.apply(this,arguments)})}},"docs-api-registry-filter-demo-filter-blur":{component:f.memo(f.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,49612))}))),asset:{type:"BLOCK",id:"docs-api-registry-filter-demo-filter-blur",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(26296).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(65557).Z},"./settings.tsx":{type:"FILE",value:t(78415).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":P,"./settings.tsx":N,react:n||(n=t.t(f,2)),"@antv/x6":b,"/home/runner/work/X6/X6/site/src/api/filter/blur/index.less":P,"/home/runner/work/X6/X6/site/src/api/filter/blur/settings.tsx":N,antd:k},renderOpts:{compile:(s=m()(h()().mark((function e(){var a,n=arguments;return h()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return s.apply(this,arguments)})}},"docs-api-registry-filter-demo-filter-gray-scale":{component:f.memo(f.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,99192))}))),asset:{type:"BLOCK",id:"docs-api-registry-filter-demo-filter-gray-scale",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(23869).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(44080).Z},"./settings.tsx":{type:"FILE",value:t(20261).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":T,"./settings.tsx":C,react:n||(n=t.t(f,2)),"@antv/x6":b,"/home/runner/work/X6/X6/site/src/api/filter/gray-scale/index.less":T,"/home/runner/work/X6/X6/site/src/api/filter/gray-scale/settings.tsx":C,antd:k},renderOpts:{compile:(u=m()(h()().mark((function e(){var a,n=arguments;return h()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return u.apply(this,arguments)})}},"docs-api-registry-filter-demo-filter-sepia":{component:f.memo(f.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,16902))}))),asset:{type:"BLOCK",id:"docs-api-registry-filter-demo-filter-sepia",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(94747).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(12614).Z},"./settings.tsx":{type:"FILE",value:t(23873).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":D,"./settings.tsx":E,react:n||(n=t.t(f,2)),"@antv/x6":b,"/home/runner/work/X6/X6/site/src/api/filter/sepia/index.less":D,"/home/runner/work/X6/X6/site/src/api/filter/sepia/settings.tsx":E,antd:k},renderOpts:{compile:(p=m()(h()().mark((function e(){var a,n=arguments;return h()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return p.apply(this,arguments)})}},"docs-api-registry-filter-demo-filter-saturate":{component:f.memo(f.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,69157))}))),asset:{type:"BLOCK",id:"docs-api-registry-filter-demo-filter-saturate",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(32350).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(12275).Z},"./settings.tsx":{type:"FILE",value:t(82343).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":S,"./settings.tsx":M,react:n||(n=t.t(f,2)),"@antv/x6":b,"/home/runner/work/X6/X6/site/src/api/filter/saturate/index.less":S,"/home/runner/work/X6/X6/site/src/api/filter/saturate/settings.tsx":M,antd:k},renderOpts:{compile:(i=m()(h()().mark((function e(){var a,n=arguments;return h()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return i.apply(this,arguments)})}},"docs-api-registry-filter-demo-filter-hue-rotate":{component:f.memo(f.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,5821))}))),asset:{type:"BLOCK",id:"docs-api-registry-filter-demo-filter-hue-rotate",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(22340).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(48649).Z},"./settings.tsx":{type:"FILE",value:t(46758).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":L,"./settings.tsx":O,react:n||(n=t.t(f,2)),"@antv/x6":b,"/home/runner/work/X6/X6/site/src/api/filter/hue-rotate/index.less":L,"/home/runner/work/X6/X6/site/src/api/filter/hue-rotate/settings.tsx":O,antd:k},renderOpts:{compile:(c=m()(h()().mark((function e(){var a,n=arguments;return h()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return c.apply(this,arguments)})}},"docs-api-registry-filter-demo-filter-invert":{component:f.memo(f.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,52968))}))),asset:{type:"BLOCK",id:"docs-api-registry-filter-demo-filter-invert",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(15696).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(57851).Z},"./settings.tsx":{type:"FILE",value:t(46498).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":R,"./settings.tsx":A,react:n||(n=t.t(f,2)),"@antv/x6":b,"/home/runner/work/X6/X6/site/src/api/filter/invert/index.less":R,"/home/runner/work/X6/X6/site/src/api/filter/invert/settings.tsx":A,antd:k},renderOpts:{compile:(I=m()(h()().mark((function e(){var a,n=arguments;return h()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return I.apply(this,arguments)})}},"docs-api-registry-filter-demo-filter-brightness":{component:f.memo(f.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,46833))}))),asset:{type:"BLOCK",id:"docs-api-registry-filter-demo-filter-brightness",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(23670).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(93734).Z},"./settings.tsx":{type:"FILE",value:t(37444).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":z,"./settings.tsx":W,react:n||(n=t.t(f,2)),"@antv/x6":b,"/home/runner/work/X6/X6/site/src/api/filter/brightness/index.less":z,"/home/runner/work/X6/X6/site/src/api/filter/brightness/settings.tsx":W,antd:k},renderOpts:{compile:(l=m()(h()().mark((function e(){var a,n=arguments;return h()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-api-registry-filter-demo-filter-contrast":{component:f.memo(f.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,96800))}))),asset:{type:"BLOCK",id:"docs-api-registry-filter-demo-filter-contrast",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(14924).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(28955).Z},"./settings.tsx":{type:"FILE",value:t(61290).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":F,"./settings.tsx":G,react:n||(n=t.t(f,2)),"@antv/x6":b,"/home/runner/work/X6/X6/site/src/api/filter/contrast/index.less":F,"/home/runner/work/X6/X6/site/src/api/filter/contrast/settings.tsx":G,antd:k},renderOpts:{compile:(r=m()(h()().mark((function e(){var a,n=arguments;return h()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-api-registry-filter-demo-filter-highlight":{component:f.memo(f.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,15184))}))),asset:{type:"BLOCK",id:"docs-api-registry-filter-demo-filter-highlight",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(6689).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(42295).Z},"./settings.tsx":{type:"FILE",value:t(4694).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":X,"./settings.tsx":V,react:n||(n=t.t(f,2)),"@antv/x6":b,"/home/runner/work/X6/X6/site/src/api/filter/highlight/index.less":X,"/home/runner/work/X6/X6/site/src/api/filter/highlight/settings.tsx":V,antd:k},renderOpts:{compile:(d=m()(h()().mark((function e(){var a,n=arguments;return h()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-api-registry-filter-demo-filter-outline":{component:f.memo(f.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,18089))}))),asset:{type:"BLOCK",id:"docs-api-registry-filter-demo-filter-outline",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(82069).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(46437).Z},"./settings.tsx":{type:"FILE",value:t(77434).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":B,"./settings.tsx":Z,react:n||(n=t.t(f,2)),"@antv/x6":b,"/home/runner/work/X6/X6/site/src/api/filter/outline/index.less":B,"/home/runner/work/X6/X6/site/src/api/filter/outline/settings.tsx":Z,antd:k},renderOpts:{compile:(o=m()(h()().mark((function e(){var a,n=arguments;return h()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},88970:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(53805);var n={}},10690:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(7505),t(1706)),p=t(17912),u=t(99527),s=t(60759),v={"docs-api-registry-node-anchor-demo-node-anchor-playground":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,27947))}))),asset:{type:"BLOCK",id:"docs-api-registry-node-anchor-demo-node-anchor-playground",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(90449).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(30772).Z},"./settings.tsx":{type:"FILE",value:t(77827).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":p,"./settings.tsx":u,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/api/node-anchor/playground/index.less":p,"/home/runner/work/X6/X6/site/src/api/node-anchor/playground/settings.tsx":u,antd:s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},3926:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return b}});var o,d,r,l,I,c=t(29008),i=t.n(c),p=t(70958),u=t.n(p),s=t(29186),v=(t(39587),t(1706)),x=t(63688),h=t(9652),g=t(32357),m=t(88907),f=t(55963),b={"docs-api-registry-node-tool-demo-api-node-tool-button":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,75741))}))),asset:{type:"BLOCK",id:"docs-api-registry-node-tool-demo-api-node-tool-button",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(31309).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(24643).Z}},entry:"index.tsx"},context:{"./index.less":x,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/api/node-tool/button/index.less":x},renderOpts:{compile:(I=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return I.apply(this,arguments)})}},"docs-api-registry-node-tool-demo-api-node-tool-button-remove":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,38307))}))),asset:{type:"BLOCK",id:"docs-api-registry-node-tool-demo-api-node-tool-button-remove",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(46609).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(15135).Z}},entry:"index.tsx"},context:{"./index.less":h,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/api/node-tool/button-remove/index.less":h},renderOpts:{compile:(l=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-api-registry-node-tool-demo-api-node-tool-boundary":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,49401))}))),asset:{type:"BLOCK",id:"docs-api-registry-node-tool-demo-api-node-tool-boundary",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(51756).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(6265).Z}},entry:"index.tsx"},context:{"./index.less":g,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/api/node-tool/boundary/index.less":g},renderOpts:{compile:(r=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-api-registry-node-tool-demo-api-node-tool-editor":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,87837))}))),asset:{type:"BLOCK",id:"docs-api-registry-node-tool-demo-api-node-tool-editor",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(97579).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(79735).Z}},entry:"index.tsx"},context:{"./index.less":m,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/api/node-tool/node-editor/index.less":m},renderOpts:{compile:(d=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-api-registry-node-tool-demo-api-node-tool-custom-button":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,21392))}))),asset:{type:"BLOCK",id:"docs-api-registry-node-tool-demo-api-node-tool-custom-button",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(90).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(50609).Z}},entry:"index.tsx"},context:{"./index.less":f,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/api/node-tool/custom-button/index.less":f},renderOpts:{compile:(o=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},44880:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return b}});var o,d,r,l=t(29008),I=t.n(l),c=t(70958),i=t.n(c),p=t(29186),u=(t(44417),t(1706)),s=t(2050),v=t(66198),x=t(60759),h=t(71460),g=t(78420),m=t(54299),f=t(61146),b={"docs-api-registry-port-label-layout-demo-port-label-layout-side":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,93220))}))),asset:{type:"BLOCK",id:"docs-api-registry-port-label-layout-demo-port-label-layout-side",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(45767).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(83986).Z},"./settings.tsx":{type:"FILE",value:t(42720).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":s,"./settings.tsx":v,react:n||(n=t.t(p,2)),"@antv/x6":u,"/home/runner/work/X6/X6/site/src/api/port-label-layout/side/index.less":s,"/home/runner/work/X6/X6/site/src/api/port-label-layout/side/settings.tsx":v,antd:x},renderOpts:{compile:(r=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-api-registry-port-label-layout-demo-port-label-layout-inside-outside":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,76945))}))),asset:{type:"BLOCK",id:"docs-api-registry-port-label-layout-demo-port-label-layout-inside-outside",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(45937).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(30361).Z},"./settings.tsx":{type:"FILE",value:t(36280).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":h,"./settings.tsx":g,react:n||(n=t.t(p,2)),"@antv/x6":u,"/home/runner/work/X6/X6/site/src/api/port-label-layout/inside-outside/index.less":h,"/home/runner/work/X6/X6/site/src/api/port-label-layout/inside-outside/settings.tsx":g,antd:x},renderOpts:{compile:(d=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-api-registry-port-label-layout-demo-port-label-layout-radial":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,49560))}))),asset:{type:"BLOCK",id:"docs-api-registry-port-label-layout-demo-port-label-layout-radial",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(4813).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(8524).Z},"./settings.tsx":{type:"FILE",value:t(94789).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":m,"./settings.tsx":f,react:n||(n=t.t(p,2)),"@antv/x6":u,"/home/runner/work/X6/X6/site/src/api/port-label-layout/radial/index.less":m,"/home/runner/work/X6/X6/site/src/api/port-label-layout/radial/settings.tsx":f,antd:x},renderOpts:{compile:(o=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},17182:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return D}});var o,d,r,l,I,c,i=t(29008),p=t.n(i),u=t(70958),s=t.n(u),v=t(29186),x=(t(65937),t(1706)),h=t(15983),g=t(22228),m=t(60759),f=t(85590),b=t(12293),y=t(7868),w=t(79194),k=t(58998),P=t(82650),N=t(83180),T=t(22133),C=t(58984),D={"docs-api-registry-port-layout-demo-port-layout-absolute":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,88371))}))),asset:{type:"BLOCK",id:"docs-api-registry-port-layout-demo-port-layout-absolute",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(99046).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(47091).Z},"./settings.tsx":{type:"FILE",value:t(13304).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":h,"./settings.tsx":g,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/port-layout/absolute/index.less":h,"/home/runner/work/X6/X6/site/src/api/port-layout/absolute/settings.tsx":g,antd:m},renderOpts:{compile:(c=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return c.apply(this,arguments)})}},"docs-api-registry-port-layout-demo-port-layout-side":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,83495))}))),asset:{type:"BLOCK",id:"docs-api-registry-port-layout-demo-port-layout-side",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(41669).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(2084).Z},"./settings.tsx":{type:"FILE",value:t(17652).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":f,"./settings.tsx":b,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/port-layout/side/index.less":f,"/home/runner/work/X6/X6/site/src/api/port-layout/side/settings.tsx":b,antd:m},renderOpts:{compile:(I=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return I.apply(this,arguments)})}},"docs-api-registry-port-layout-demo-port-layout-line":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,36834))}))),asset:{type:"BLOCK",id:"docs-api-registry-port-layout-demo-port-layout-line",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(12227).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(32752).Z},"./settings.tsx":{type:"FILE",value:t(58801).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":y,"./settings.tsx":w,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/port-layout/line/index.less":y,"/home/runner/work/X6/X6/site/src/api/port-layout/line/settings.tsx":w,antd:m},renderOpts:{compile:(l=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-api-registry-port-layout-demo-port-layout-ellipse":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,73916))}))),asset:{type:"BLOCK",id:"docs-api-registry-port-layout-demo-port-layout-ellipse",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(51452).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(68168).Z},"./settings.tsx":{type:"FILE",value:t(69451).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":k,"./settings.tsx":P,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/port-layout/ellipse/index.less":k,"/home/runner/work/X6/X6/site/src/api/port-layout/ellipse/settings.tsx":P,antd:m},renderOpts:{compile:(r=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-api-registry-port-layout-demo-port-layout-ellipse-spread":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,13357))}))),asset:{type:"BLOCK",id:"docs-api-registry-port-layout-demo-port-layout-ellipse-spread",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(14609).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(32639).Z},"./settings.tsx":{type:"FILE",value:t(42918).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":N,"./settings.tsx":T,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/port-layout/ellipse-spread/index.less":N,"/home/runner/work/X6/X6/site/src/api/port-layout/ellipse-spread/settings.tsx":T,antd:m},renderOpts:{compile:(d=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-api-registry-port-layout-demo-port-layout-sin":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,8087))}))),asset:{type:"BLOCK",id:"docs-api-registry-port-layout-demo-port-layout-sin",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(17264).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(27469).Z}},entry:"index.tsx"},context:{"./index.less":C,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/port-layout/sin/index.less":C},renderOpts:{compile:(o=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},86081:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return P}});var o,d,r,l,I,c,i=t(29008),p=t.n(i),u=t(70958),s=t.n(u),v=t(29186),x=(t(45617),t(1706)),h=t(33021),g=t(16661),m=t(18879),f=t(94709),b=t(96215),y=t(90198),w=t(60759),k=t(57244),P={"docs-api-registry-router-demo-api-orth-router":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,55479))}))),asset:{type:"BLOCK",id:"docs-api-registry-router-demo-api-orth-router",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(32885).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(51011).Z}},entry:"index.tsx"},context:{"./index.less":h,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/router/orth/index.less":h},renderOpts:{compile:(c=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return c.apply(this,arguments)})}},"docs-api-registry-router-demo-api-oneside-router":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,12584))}))),asset:{type:"BLOCK",id:"docs-api-registry-router-demo-api-oneside-router",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(73519).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(39269).Z}},entry:"index.tsx"},context:{"./index.less":g,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/router/oneside/index.less":g},renderOpts:{compile:(I=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return I.apply(this,arguments)})}},"docs-api-registry-router-demo-api-manhattan-router":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,35630))}))),asset:{type:"BLOCK",id:"docs-api-registry-router-demo-api-manhattan-router",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(30128).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(50973).Z}},entry:"index.tsx"},context:{"./index.less":m,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/router/manhattan/index.less":m},renderOpts:{compile:(l=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-api-registry-router-demo-api-metro-router":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,38075))}))),asset:{type:"BLOCK",id:"docs-api-registry-router-demo-api-metro-router",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(43481).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(46263).Z}},entry:"index.tsx"},context:{"./index.less":f,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/router/metro/index.less":f},renderOpts:{compile:(r=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-api-registry-router-demo-api-er-router":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,86479))}))),asset:{type:"BLOCK",id:"docs-api-registry-router-demo-api-er-router",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(93486).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(65962).Z},"./settings.tsx":{type:"FILE",value:t(27958).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":b,"./settings.tsx":y,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/router/er/index.less":b,"/home/runner/work/X6/X6/site/src/api/router/er/settings.tsx":y,antd:w},renderOpts:{compile:(d=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-api-registry-router-demo-api-random-router":{component:v.memo(v.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,42178))}))),asset:{type:"BLOCK",id:"docs-api-registry-router-demo-api-random-router",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(38822).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(74479).Z}},entry:"index.tsx"},context:{"./index.less":k,react:n||(n=t.t(v,2)),"@antv/x6":x,"/home/runner/work/X6/X6/site/src/api/router/random/index.less":k},renderOpts:{compile:(o=s()(p()().mark((function e(){var a,n=arguments;return p()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},57182:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(94164);var n={}},67629:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(85487);var n={}},80318:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return C}});var o,d,r,l,I,c,i,p,u=t(29008),s=t.n(u),v=t(70958),x=t.n(v),h=t(29186),g=(t(96001),t(1706)),m=t(87984),f=t(35582),b=t(93790),y=t(96692),w=t(76090),k=t(67565),P=t(37843),N=t(60759),T=t(40012),C={"docs-tutorial-basic-edge-demo-edge-vertices":{component:h.memo(h.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,77263))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-edge-demo-edge-vertices",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(99824).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(19478).Z}},entry:"index.tsx"},context:{"./index.less":m,react:n||(n=t.t(h,2)),"@antv/x6":g,"/home/runner/work/X6/X6/site/src/tutorial/basic/edge/vertices/index.less":m},renderOpts:{compile:(p=x()(s()().mark((function e(){var a,n=arguments;return s()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return p.apply(this,arguments)})}},"docs-tutorial-basic-edge-demo-edge-router":{component:h.memo(h.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,91060))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-edge-demo-edge-router",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(27439).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(61295).Z}},entry:"index.tsx"},context:{"./index.less":f,react:n||(n=t.t(h,2)),"@antv/x6":g,"/home/runner/work/X6/X6/site/src/tutorial/basic/edge/router/index.less":f},renderOpts:{compile:(i=x()(s()().mark((function e(){var a,n=arguments;return s()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return i.apply(this,arguments)})}},"docs-tutorial-basic-edge-demo-edge-connector":{component:h.memo(h.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,38695))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-edge-demo-edge-connector",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(77830).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(62155).Z}},entry:"index.tsx"},context:{"./index.less":b,react:n||(n=t.t(h,2)),"@antv/x6":g,"/home/runner/work/X6/X6/site/src/tutorial/basic/edge/connector/index.less":b},renderOpts:{compile:(c=x()(s()().mark((function e(){var a,n=arguments;return s()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return c.apply(this,arguments)})}},"docs-tutorial-basic-edge-demo-edge-labels":{component:h.memo(h.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,82880))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-edge-demo-edge-labels",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(33177).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(75325).Z}},entry:"index.tsx"},context:{"./index.less":y,react:n||(n=t.t(h,2)),"@antv/x6":g,"/home/runner/work/X6/X6/site/src/tutorial/basic/edge/labels/index.less":y},renderOpts:{compile:(I=x()(s()().mark((function e(){var a,n=arguments;return s()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return I.apply(this,arguments)})}},"docs-tutorial-basic-edge-demo-edge-native-marker":{component:h.memo(h.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,98545))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-edge-demo-edge-native-marker",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(40376).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(71104).Z}},entry:"index.tsx"},context:{"./index.less":w,react:n||(n=t.t(h,2)),"@antv/x6":g,"/home/runner/work/X6/X6/site/src/tutorial/basic/edge/native-marker/index.less":w},renderOpts:{compile:(l=x()(s()().mark((function e(){var a,n=arguments;return s()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-tutorial-basic-edge-demo-edge-custom-marker":{component:h.memo(h.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,41901))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-edge-demo-edge-custom-marker",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(89842).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(83818).Z}},entry:"index.tsx"},context:{"./index.less":k,react:n||(n=t.t(h,2)),"@antv/x6":g,"/home/runner/work/X6/X6/site/src/tutorial/basic/edge/custom-marker/index.less":k},renderOpts:{compile:(r=x()(s()().mark((function e(){var a,n=arguments;return s()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-tutorial-basic-edge-demo-edge-registry":{component:h.memo(h.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,44679))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-edge-demo-edge-registry",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(13294).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(86877).Z}},entry:"index.tsx"},context:{"./index.less":P,react:n||(n=t.t(h,2)),"@antv/x6":g,"/home/runner/work/X6/X6/site/src/tutorial/basic/edge/registry/index.less":P},renderOpts:{compile:(d=x()(s()().mark((function e(){var a,n=arguments;return s()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-tutorial-basic-edge-demo-edge-prop":{component:h.memo(h.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,43299))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-edge-demo-edge-prop",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(62451).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},antd:{type:"NPM",value:"5.29.3"},"./index.less":{type:"FILE",value:t(45432).Z}},entry:"index.tsx"},context:{"./index.less":T,react:n||(n=t.t(h,2)),"@antv/x6":g,antd:N,"/home/runner/work/X6/X6/site/src/tutorial/basic/edge/prop/index.less":T},renderOpts:{compile:(o=x()(s()().mark((function e(){var a,n=arguments;return s()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},4588:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return u}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(67719),t(1706)),p=t(6772),u={"docs-tutorial-basic-events-demo-event-custom-click":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,4451))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-events-demo-event-custom-click",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(31399).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(79063).Z}},entry:"index.tsx"},context:{"./index.less":p,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/tutorial/basic/event/custom-click/index.less":p},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},47802:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return y}});var o,d,r,l,I=t(29008),c=t.n(I),i=t(70958),p=t.n(i),u=t(29186),s=(t(43437),t(1706)),v=t(26500),x=t(66903),h=t(95882),g=t(83989),m=t(27477),f=t(60759),b=t(955),y={"docs-tutorial-basic-graph-demo-auto-resize":{component:u.memo(u.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,69449))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-graph-demo-auto-resize",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(66043).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"@antv/x6-react-components":{type:"NPM",value:"2.0.9"},"./index.less":{type:"FILE",value:t(43142).Z}},entry:"index.tsx"},context:{"./index.less":h,react:n||(n=t.t(u,2)),"@antv/x6":s,"@antv/x6-react-components":v,"@antv/x6-react-components/es/split-box/style/index.css":x,"/home/runner/work/X6/X6/site/src/tutorial/basic/graph/auto-resize/index.less":h},renderOpts:{compile:(l=p()(c()().mark((function e(){var a,n=arguments;return c()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-tutorial-basic-graph-demo-background-grid":{component:u.memo(u.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,57155))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-graph-demo-background-grid",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(95218).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(13519).Z}},entry:"index.tsx"},context:{"./index.less":g,react:n||(n=t.t(u,2)),"@antv/x6":s,"/home/runner/work/X6/X6/site/src/tutorial/basic/graph/background-grid/index.less":g},renderOpts:{compile:(r=p()(c()().mark((function e(){var a,n=arguments;return c()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-tutorial-basic-graph-demo-panning-mousewheel":{component:u.memo(u.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,93336))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-graph-demo-panning-mousewheel",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(205).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(64870).Z}},entry:"index.tsx"},context:{"./index.less":m,react:n||(n=t.t(u,2)),"@antv/x6":s,"/home/runner/work/X6/X6/site/src/tutorial/basic/graph/panning-mousewheel/index.less":m},renderOpts:{compile:(d=p()(c()().mark((function e(){var a,n=arguments;return c()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-tutorial-basic-graph-demo-transform":{component:u.memo(u.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,1301))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-graph-demo-transform",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(86219).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},antd:{type:"NPM",value:"5.29.3"},"./index.less":{type:"FILE",value:t(18450).Z}},entry:"index.tsx"},context:{"./index.less":b,react:n||(n=t.t(u,2)),"@antv/x6":s,antd:f,"/home/runner/work/X6/X6/site/src/tutorial/basic/graph/transform/index.less":b},renderOpts:{compile:(o=p()(c()().mark((function e(){var a,n=arguments;return c()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},17223:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return k}});var o,d,r,l,I,c=t(29008),i=t.n(c),p=t(70958),u=t.n(p),s=t(29186),v=(t(13669),t(1706)),x=t(22857),h=t(82194),g=t(60759),m=t(61889),f=t(42043),b=t(87710),y=t(31569),w=t(38462),k={"docs-tutorial-basic-interacting-demo-interacting-connection":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,50437))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-interacting-demo-interacting-connection",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(68238).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(30058).Z},"./settings.tsx":{type:"FILE",value:t(64860).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":x,"./settings.tsx":h,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/tutorial/basic/interacting/connecting/index.less":x,"/home/runner/work/X6/X6/site/src/tutorial/basic/interacting/connecting/settings.tsx":h,antd:g},renderOpts:{compile:(I=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return I.apply(this,arguments)})}},"docs-tutorial-basic-interacting-demo-interacting-validate":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,57104))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-interacting-demo-interacting-validate",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(48064).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(35805).Z}},entry:"index.tsx"},context:{"./index.less":m,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/tutorial/basic/interacting/validate/index.less":m},renderOpts:{compile:(l=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-tutorial-basic-interacting-demo-interacting-embedding":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,17034))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-interacting-demo-interacting-embedding",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(52954).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(90119).Z}},entry:"index.tsx"},context:{"./index.less":f,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/tutorial/basic/interacting/embedding/index.less":f},renderOpts:{compile:(r=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-tutorial-basic-interacting-demo-interacting-highlighting":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,65677))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-interacting-demo-interacting-highlighting",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(37078).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(86339).Z}},entry:"index.tsx"},context:{"./index.less":b,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/tutorial/basic/interacting/highlighting/index.less":b},renderOpts:{compile:(d=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-tutorial-basic-interacting-demo-interacting-interacting":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,64771))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-interacting-demo-interacting-interacting",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(77702).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(30864).Z},"./settings.tsx":{type:"FILE",value:t(24808).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":y,"./settings.tsx":w,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/tutorial/basic/interacting/interacting/index.less":y,"/home/runner/work/X6/X6/site/src/tutorial/basic/interacting/interacting/settings.tsx":w,antd:g},renderOpts:{compile:(o=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},2619:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return g}});var o,d,r,l=t(29008),I=t.n(l),c=t(70958),i=t.n(c),p=t(29186),u=(t(90576),t(1706)),s=t(2844),v=t(24561),x=t(60759),h=t(90117),g={"docs-tutorial-basic-node-demo-node-shapes":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,28615))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-node-demo-node-shapes",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(64449).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(48388).Z}},entry:"index.tsx"},context:{"./index.less":s,react:n||(n=t.t(p,2)),"@antv/x6":u,"/home/runner/work/X6/X6/site/src/tutorial/basic/node/shapes/index.less":s},renderOpts:{compile:(r=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-tutorial-basic-node-demo-node-registry":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,48202))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-node-demo-node-registry",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(64852).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(11459).Z}},entry:"index.tsx"},context:{"./index.less":v,react:n||(n=t.t(p,2)),"@antv/x6":u,"/home/runner/work/X6/X6/site/src/tutorial/basic/node/registry/index.less":v},renderOpts:{compile:(d=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-tutorial-basic-node-demo-node-prop":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,30331))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-node-demo-node-prop",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(93124).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},antd:{type:"NPM",value:"5.29.3"},"./index.less":{type:"FILE",value:t(58905).Z}},entry:"index.tsx"},context:{"./index.less":h,react:n||(n=t.t(p,2)),"@antv/x6":u,antd:x,"/home/runner/work/X6/X6/site/src/tutorial/basic/node/prop/index.less":h},renderOpts:{compile:(o=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},13909:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return x}});var o,d,r=t(29008),l=t.n(r),I=t(70958),c=t.n(I),i=t(29186),p=(t(27865),t(1706)),u=t(54518),s=t(60759),v=t(67482),x={"docs-tutorial-basic-port-demo-port-config":{component:i.memo(i.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,82053))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-port-demo-port-config",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(29547).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(94481).Z}},entry:"index.tsx"},context:{"./index.less":u,react:n||(n=t.t(i,2)),"@antv/x6":p,"/home/runner/work/X6/X6/site/src/tutorial/basic/ports/config/index.less":u},renderOpts:{compile:(d=c()(l()().mark((function e(){var a,n=arguments;return l()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-tutorial-basic-port-demo-port-prop":{component:i.memo(i.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,77347))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-port-demo-port-prop",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(24944).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},antd:{type:"NPM",value:"5.29.3"},"./index.less":{type:"FILE",value:t(5581).Z}},entry:"index.tsx"},context:{"./index.less":v,react:n||(n=t.t(i,2)),"@antv/x6":p,antd:s,"/home/runner/work/X6/X6/site/src/tutorial/basic/ports/dynamic/index.less":v},renderOpts:{compile:(o=c()(l()().mark((function e(){var a,n=arguments;return l()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},9221:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return x}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(2402),t(1706)),p=t(60169),u=t(73607),s=t(91770),v=t(95389),x={"docs-tutorial-basic-serialization-demo-serialization-tojson":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,98385))}))),asset:{type:"BLOCK",id:"docs-tutorial-basic-serialization-demo-serialization-tojson",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(70146).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"highlight.js":{type:"NPM",value:"10.7.3"},"./index.less":{type:"FILE",value:t(88491).Z}},entry:"index.tsx"},context:{"./index.less":v,react:n||(n=t.t(c,2)),"@antv/x6":i,"highlight.js/lib/core":p,"highlight.js/lib/languages/json":u,"highlight.js/styles/github.css":s,"/home/runner/work/X6/X6/site/src/tutorial/basic/serialization/to-json/index.less":v},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},12169:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(606);var n={}},67327:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return m}});var o,d,r,l=t(29008),I=t.n(l),c=t(70958),i=t.n(c),p=t(29186),u=(t(49457),t(1706)),s=t(89713),v=t(64125),x=t(60759),h=t(63888),g=t(68583),m={"docs-tutorial-getting-started-demo-helloworld":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,16783))}))),asset:{type:"BLOCK",id:"docs-tutorial-getting-started-demo-helloworld",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(48612).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(17023).Z}},entry:"index.tsx"},context:{"./index.less":s,react:n||(n=t.t(p,2)),"@antv/x6":u,"/home/runner/work/X6/X6/site/src/tutorial/getting-started/helloworld/index.less":s},renderOpts:{compile:(r=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-tutorial-getting-started-demo-react-shape":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,32399))}))),asset:{type:"BLOCK",id:"docs-tutorial-getting-started-demo-react-shape",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(10849).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"@antv/x6-react-shape":{type:"NPM",value:"3.0.1"},antd:{type:"NPM",value:"5.29.3"},"./index.less":{type:"FILE",value:t(21944).Z}},entry:"index.tsx"},context:{"./index.less":h,react:n||(n=t.t(p,2)),"@antv/x6":u,"@antv/x6-react-shape":v,antd:x,"/home/runner/work/X6/X6/site/src/tutorial/getting-started/react-shape/index.less":h},renderOpts:{compile:(d=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-tutorial-getting-started-demo-use-plugin":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,27635))}))),asset:{type:"BLOCK",id:"docs-tutorial-getting-started-demo-use-plugin",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(28880).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"@antv/x6-react-shape":{type:"NPM",value:"3.0.1"},antd:{type:"NPM",value:"5.29.3"},"./index.less":{type:"FILE",value:t(30177).Z}},entry:"index.tsx"},context:{"./index.less":g,react:n||(n=t.t(p,2)),"@antv/x6":u,"@antv/x6-react-shape":v,antd:x,"/home/runner/work/X6/X6/site/src/tutorial/getting-started/use-plugin/index.less":g},renderOpts:{compile:(o=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},33362:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(34739);var n={}},53920:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return u}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(36518),t(1706)),p=t(78501),u={"docs-tutorial-intermediate-connection-point-demo-connection-point-multi":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,79786))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-connection-point-demo-connection-point-multi",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(87697).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(69676).Z}},entry:"index.tsx"},context:{"./index.less":p,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/connection-point/multi/index.less":p},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},46049:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return k}});var o,d,r,l,I,c=t(29008),i=t.n(c),p=t(70958),u=t.n(p),s=t(29186),v=(t(80818),t(1706)),x=t(97560),h=t(42043),g=t(19902),m=t(52316),f=t(5837),b=t(60759),y=t(88698),w=t(16266),k={"docs-tutorial-intermediate-group-demo-group-embed-edge":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,48191))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-group-demo-group-embed-edge",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(20197).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(76944).Z}},entry:"index.tsx"},context:{"./index.less":x,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/group/embed-edge/index.less":x},renderOpts:{compile:(I=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return I.apply(this,arguments)})}},"docs-tutorial-intermediate-group-demo-group-embedding":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,17034))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-group-demo-group-embedding",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(52954).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(90119).Z}},entry:"index.tsx"},context:{"./index.less":h,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/tutorial/basic/interacting/embedding/index.less":h},renderOpts:{compile:(l=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return l.apply(this,arguments)})}},"docs-tutorial-intermediate-group-demo-group-restrict":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,9030))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-group-demo-group-restrict",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(44674).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(56321).Z}},entry:"index.tsx"},context:{"./index.less":g,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/group/restrict/index.less":g},renderOpts:{compile:(r=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-tutorial-intermediate-group-demo-group-expand-shrink":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,94399))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-group-demo-group-expand-shrink",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(14390).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(2137).Z},"./settings.tsx":{type:"FILE",value:t(422).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":m,"./settings.tsx":f,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/group/expand-shrink/index.less":m,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/group/expand-shrink/settings.tsx":f,antd:b},renderOpts:{compile:(d=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-tutorial-intermediate-group-demo-group-collapsable":{component:s.memo(s.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,53009))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-group-demo-group-collapsable",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(50678).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(3348).Z},"./shape.ts":{type:"FILE",value:t(60785).Z}},entry:"index.tsx"},context:{"./index.less":y,"./shape.ts":w,react:n||(n=t.t(s,2)),"@antv/x6":v,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/group/collapsable/index.less":y,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/group/collapsable/shape.ts":w},renderOpts:{compile:(o=u()(i()().mark((function e(){var a,n=arguments;return i()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},92861:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d,r=t(29008),l=t.n(r),I=t(70958),c=t.n(I),i=t(29186),p=(t(63126),t(1706)),u=t(40441),s=t(76763),v={"docs-tutorial-intermediate-html-demo-html-basic":{component:i.memo(i.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,29615))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-html-demo-html-basic",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(59599).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(10811).Z}},entry:"index.tsx"},context:{"./index.less":u,react:n||(n=t.t(i,2)),"@antv/x6":p,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/html/basic/index.less":u},renderOpts:{compile:(d=c()(l()().mark((function e(){var a,n=arguments;return l()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-tutorial-intermediate-html-demo-html-update":{component:i.memo(i.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,21285))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-html-demo-html-update",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(11740).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(90009).Z}},entry:"index.tsx"},context:{"./index.less":s,react:n||(n=t.t(i,2)),"@antv/x6":p,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/html/update/index.less":s},renderOpts:{compile:(o=c()(l()().mark((function e(){var a,n=arguments;return l()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},77178:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return m}});var o,d,r,l=t(29008),I=t.n(l),c=t(70958),i=t.n(c),p=t(29186),u=(t(86346),t(1706)),s=t(64125),v=t(60759),x=t(50162),h=t(63359),g=t(53091),m={"docs-tutorial-intermediate-react-demo-react-basic":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,87761))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-react-demo-react-basic",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(70941).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"@antv/x6-react-shape":{type:"NPM",value:"3.0.1"},antd:{type:"NPM",value:"5.29.3"},"./index.less":{type:"FILE",value:t(22335).Z}},entry:"index.tsx"},context:{"./index.less":x,react:n||(n=t.t(p,2)),"@antv/x6":u,"@antv/x6-react-shape":s,antd:v,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/react/basic/index.less":x},renderOpts:{compile:(r=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return r.apply(this,arguments)})}},"docs-tutorial-intermediate-react-demo-react-update":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,42733))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-react-demo-react-update",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(8306).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"@antv/x6-react-shape":{type:"NPM",value:"3.0.1"},antd:{type:"NPM",value:"5.29.3"},"./index.less":{type:"FILE",value:t(58935).Z}},entry:"index.tsx"},context:{"./index.less":h,react:n||(n=t.t(p,2)),"@antv/x6":u,"@antv/x6-react-shape":s,antd:v,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/react/update/index.less":h},renderOpts:{compile:(d=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-tutorial-intermediate-react-demo-react-portal":{component:p.memo(p.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,27341))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-react-demo-react-portal",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(72390).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"@antv/x6-react-shape":{type:"NPM",value:"3.0.1"},antd:{type:"NPM",value:"5.29.3"},"./index.less":{type:"FILE",value:t(47212).Z}},entry:"index.tsx"},context:{"./index.less":g,react:n||(n=t.t(p,2)),"@antv/x6":u,"@antv/x6-react-shape":s,antd:v,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/react/portal/index.less":g},renderOpts:{compile:(o=i()(I()().mark((function e(){var a,n=arguments;return I()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},29441:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d,r=t(29008),l=t.n(r),I=t(70958),c=t.n(I),i=t(29186),p=(t(86856),t(1706)),u=t(43843),s=t(30322),v={"docs-tutorial-intermediate-tools-demo-tools-basic":{component:i.memo(i.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,86974))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-tools-demo-tools-basic",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(88136).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(34015).Z}},entry:"index.tsx"},context:{"./index.less":u,react:n||(n=t.t(i,2)),"@antv/x6":p,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/tools/basic/index.less":u},renderOpts:{compile:(d=c()(l()().mark((function e(){var a,n=arguments;return l()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-tutorial-intermediate-tools-demo-tools-onhover":{component:i.memo(i.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,26879))}))),asset:{type:"BLOCK",id:"docs-tutorial-intermediate-tools-demo-tools-onhover",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(81841).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(45147).Z}},entry:"index.tsx"},context:{"./index.less":s,react:n||(n=t.t(i,2)),"@antv/x6":p,"/home/runner/work/X6/X6/site/src/tutorial/intermediate/tools/onhover/index.less":s},renderOpts:{compile:(o=c()(l()().mark((function e(){var a,n=arguments;return l()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},94124:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(41245);var n={}},58976:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(63874),t(60759)),p=t(1706),u=t(97761),s=t(86758),v={"docs-tutorial-plugins-clipboard-demo-plugin-clipboard-resizing":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,8139))}))),asset:{type:"BLOCK",id:"docs-tutorial-plugins-clipboard-demo-plugin-clipboard-resizing",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(99224).Z},react:{type:"NPM",value:"19.2.4"},antd:{type:"NPM",value:"5.29.3"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(9021).Z},"./settings.tsx":{type:"FILE",value:t(28849).Z}},entry:"index.tsx"},context:{"./index.less":u,"./settings.tsx":s,react:n||(n=t.t(c,2)),antd:i,"@antv/x6":p,"/home/runner/work/X6/X6/site/src/tutorial/plugins/clipboard/index.less":u,"/home/runner/work/X6/X6/site/src/tutorial/plugins/clipboard/settings.tsx":s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},18831:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return u}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(45514),t(1706)),p=t(4691),u={"docs-tutorial-plugins-dnd-demo-plugin-dnd":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,34569))}))),asset:{type:"BLOCK",id:"docs-tutorial-plugins-dnd-demo-plugin-dnd",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(45759).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(51019).Z}},entry:"index.tsx"},context:{"./index.less":p,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/tutorial/plugins/dnd/index.less":p},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},87834:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(99078);var n={}},16170:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return s}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(3609),t(60759)),p=t(1706),u=t(88571),s={"docs-tutorial-plugins-history-demo-plugin-history":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,21873))}))),asset:{type:"BLOCK",id:"docs-tutorial-plugins-history-demo-plugin-history",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(57128).Z},react:{type:"NPM",value:"19.2.4"},antd:{type:"NPM",value:"5.29.3"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(59239).Z}},entry:"index.tsx"},context:{"./index.less":u,react:n||(n=t.t(c,2)),antd:i,"@antv/x6":p,"/home/runner/work/X6/X6/site/src/tutorial/plugins/history/index.less":u},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},86965:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return u}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(86138),t(1706)),p=t(97666),u={"docs-tutorial-plugins-keyboard-demo-plugin-keyboard":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,98152))}))),asset:{type:"BLOCK",id:"docs-tutorial-plugins-keyboard-demo-plugin-keyboard",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(83941).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(61682).Z}},entry:"index.tsx"},context:{"./index.less":p,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/tutorial/plugins/keyboard/index.less":p},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},6673:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(39070),t(1706)),p=t(60759),u=t(18855),s=t(89296),v={"docs-tutorial-plugins-minimap-demo-plugin-minimap":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,75293))}))),asset:{type:"BLOCK",id:"docs-tutorial-plugins-minimap-demo-plugin-minimap",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(60891).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},antd:{type:"NPM",value:"5.29.3"},"./index.less":{type:"FILE",value:t(81700).Z},"./simple-view.tsx":{type:"FILE",value:t(99350).Z}},entry:"index.tsx"},context:{"./index.less":u,"./simple-view.tsx":s,react:n||(n=t.t(c,2)),"@antv/x6":i,antd:p,"/home/runner/work/X6/X6/site/src/tutorial/plugins/minimap/index.less":u,"/home/runner/work/X6/X6/site/src/tutorial/plugins/minimap/simple-view.tsx":s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},70053:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(59468),t(60759)),p=t(1706),u=t(68464),s=t(17846),v={"docs-tutorial-plugins-scroller-demo-plugin-scroller":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,25421))}))),asset:{type:"BLOCK",id:"docs-tutorial-plugins-scroller-demo-plugin-scroller",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(98240).Z},react:{type:"NPM",value:"19.2.4"},antd:{type:"NPM",value:"5.29.3"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(97820).Z},"./settings.tsx":{type:"FILE",value:t(51095).Z}},entry:"index.tsx"},context:{"./index.less":u,"./settings.tsx":s,react:n||(n=t.t(c,2)),antd:i,"@antv/x6":p,"/home/runner/work/X6/X6/site/src/tutorial/plugins/scroller/index.less":u,"/home/runner/work/X6/X6/site/src/tutorial/plugins/scroller/settings.tsx":s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},42649:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(85576),t(1706)),p=t(27618),u=t(30001),s=t(60759),v={"docs-tutorial-plugins-selection-demo-plugin-selection":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,92493))}))),asset:{type:"BLOCK",id:"docs-tutorial-plugins-selection-demo-plugin-selection",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(3962).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(75672).Z},"./settings.tsx":{type:"FILE",value:t(83484).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":p,"./settings.tsx":u,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/tutorial/plugins/selection/index.less":p,"/home/runner/work/X6/X6/site/src/tutorial/plugins/selection/settings.tsx":u,antd:s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},79358:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return v}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(6465),t(1706)),p=t(54789),u=t(89324),s=t(60759),v={"docs-tutorial-plugins-snapline-demo-plugin-snapline":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,69175))}))),asset:{type:"BLOCK",id:"docs-tutorial-plugins-snapline-demo-plugin-snapline",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(26525).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(89470).Z},"./settings.tsx":{type:"FILE",value:t(89902).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":p,"./settings.tsx":u,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/tutorial/plugins/snapline/index.less":p,"/home/runner/work/X6/X6/site/src/tutorial/plugins/snapline/settings.tsx":u,antd:s},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},69986:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return u}});var o,d=t(29008),r=t.n(d),l=t(70958),I=t.n(l),c=t(29186),i=(t(63487),t(1706)),p=t(74488),u={"docs-tutorial-plugins-stencil-demo-plugin-stencil":{component:c.memo(c.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,35253))}))),asset:{type:"BLOCK",id:"docs-tutorial-plugins-stencil-demo-plugin-stencil",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(93007).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(34828).Z}},entry:"index.tsx"},context:{"./index.less":p,react:n||(n=t.t(c,2)),"@antv/x6":i,"/home/runner/work/X6/X6/site/src/tutorial/plugins/stencil/index.less":p},renderOpts:{compile:(o=I()(r()().mark((function e(){var a,n=arguments;return r()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},17613:function(e,a,t){var n;t.r(a),t.d(a,{demos:function(){return g}});var o,d,r=t(29008),l=t.n(r),I=t(70958),c=t.n(I),i=t(29186),p=(t(29758),t(1706)),u=t(51591),s=t(46302),v=t(60759),x=t(63172),h=t(57774),g={"docs-tutorial-plugins-transform-demo-plugin-transform-resizing":{component:i.memo(i.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,67348))}))),asset:{type:"BLOCK",id:"docs-tutorial-plugins-transform-demo-plugin-transform-resizing",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(69335).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(64775).Z},"./settings.tsx":{type:"FILE",value:t(56771).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":u,"./settings.tsx":s,react:n||(n=t.t(i,2)),"@antv/x6":p,"/home/runner/work/X6/X6/site/src/tutorial/plugins/transform/resizing/index.less":u,"/home/runner/work/X6/X6/site/src/tutorial/plugins/transform/resizing/settings.tsx":s,antd:v},renderOpts:{compile:(d=c()(l()().mark((function e(){var a,n=arguments;return l()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return d.apply(this,arguments)})}},"docs-tutorial-plugins-transform-demo-plugin-transform-rotating":{component:i.memo(i.lazy((function(){return Promise.all([t.e(5770),t.e(2433)]).then(t.bind(t,24032))}))),asset:{type:"BLOCK",id:"docs-tutorial-plugins-transform-demo-plugin-transform-rotating",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:t(48643).Z},react:{type:"NPM",value:"19.2.4"},"@antv/x6":{type:"NPM",value:"3.1.5"},"./index.less":{type:"FILE",value:t(47332).Z},"./settings.tsx":{type:"FILE",value:t(90596).Z},antd:{type:"NPM",value:"5.29.3"}},entry:"index.tsx"},context:{"./index.less":x,"./settings.tsx":h,react:n||(n=t.t(i,2)),"@antv/x6":p,"/home/runner/work/X6/X6/site/src/tutorial/plugins/transform/rotating/index.less":x,"/home/runner/work/X6/X6/site/src/tutorial/plugins/transform/rotating/settings.tsx":h,antd:v},renderOpts:{compile:(o=c()(l()().mark((function e(){var a,n=arguments;return l()().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,Promise.all([t.e(5686),t.e(8857)]).then(t.bind(t,88857));case 2:return e.abrupt("return",(a=e.sent).default.apply(a,n));case 3:case"end":return e.stop()}}),e)}))),function(){return o.apply(this,arguments)})}}}},22243:function(e,a,t){t.r(a),t.d(a,{demos:function(){return n}});t(29186),t(63500);var n={}},95108:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(6267);const n=[{value:"The background is used to specify the background color or background image of the canvas, supporting ",paraId:0},{value:"watermark background",paraId:1},{value:". The background layer is at the bottom of the DOM layer.",paraId:0},{value:"The background color, supporting all ",paraId:2,tocIndex:2},{value:"CSS background-color",paraId:2,tocIndex:2},{value:" property values, such as:",paraId:2,tocIndex:2},{value:"red",paraId:3,tocIndex:2},{value:"#f5f5f5",paraId:3,tocIndex:2},{value:"rgba(255, 255, 128, 0.5)",paraId:3,tocIndex:2},{value:"hsla(50, 33%, 25%, 0.75)",paraId:3,tocIndex:2},{value:"radial-gradient(ellipse at center, red, green)",paraId:3,tocIndex:2},{value:"The URL address of the background image. The default value is ",paraId:4,tocIndex:3},{value:"undefined",paraId:4,tocIndex:3},{value:", indicating no background image.",paraId:4,tocIndex:3},{value:"The position of the background image, supporting all ",paraId:5,tocIndex:4},{value:"CSS background-position",paraId:5,tocIndex:4},{value:" property values, with a default value of ",paraId:5,tocIndex:4},{value:"'center'",paraId:5,tocIndex:4},{value:".",paraId:5,tocIndex:4},{value:"The size of the background image, supporting all ",paraId:6,tocIndex:5},{value:"CSS background-size",paraId:6,tocIndex:5},{value:" property values, with a default value of ",paraId:6,tocIndex:5},{value:"'auto auto'",paraId:6,tocIndex:5},{value:".",paraId:6,tocIndex:5},{value:"The repeat mode of the background image, supporting all ",paraId:7,tocIndex:6},{value:"CSS background-repeat",paraId:7,tocIndex:6},{value:" property values, with a default value of ",paraId:7,tocIndex:6},{value:"'no-repeat'",paraId:7,tocIndex:6},{value:".",paraId:7,tocIndex:6},{value:"Additionally, the following predefined values are supported:",paraId:8,tocIndex:6},{value:"watermark",paraId:9,tocIndex:6},{value:": Watermark effect.",paraId:9,tocIndex:6},{value:"flip-x",paraId:9,tocIndex:6},{value:": Flip the background image horizontally.",paraId:9,tocIndex:6},{value:"flip-y",paraId:9,tocIndex:6},{value:": Flip the background image vertically.",paraId:9,tocIndex:6},{value:"flip-xy",paraId:9,tocIndex:6},{value:": Flip the background image both horizontally and vertically.",paraId:9,tocIndex:6},{value:"The opacity of the background, with a value range of ",paraId:10,tocIndex:7},{value:"[0, 1]",paraId:10,tocIndex:7},{value:", and a default value of ",paraId:10,tocIndex:7},{value:"1",paraId:10,tocIndex:7},{value:".",paraId:10,tocIndex:7},{value:"The quality of the background image, with a value range of ",paraId:11,tocIndex:8},{value:"[0, 1]",paraId:11,tocIndex:8},{value:", and a default value of ",paraId:11,tocIndex:8},{value:"1",paraId:11,tocIndex:8},{value:".",paraId:11,tocIndex:8},{value:"The rotation angle of the watermark, only valid when ",paraId:12,tocIndex:9},{value:"repeat",paraId:13,tocIndex:9},{value:" is ",paraId:12,tocIndex:9},{value:"'watermark'",paraId:12,tocIndex:9},{value:", with a default value of ",paraId:12,tocIndex:9},{value:"20",paraId:12,tocIndex:9},{value:".",paraId:12,tocIndex:9},{value:"drawBackground(options?: Options): this\n",paraId:14,tocIndex:11},{value:"Redraw the background.",paraId:15,tocIndex:11},{value:"Name",paraId:16,tocIndex:11},{value:"Type",paraId:16,tocIndex:11},{value:"Required",paraId:16,tocIndex:11},{value:"Default Value",paraId:16,tocIndex:11},{value:"Description",paraId:16,tocIndex:11},{value:"options.color",paraId:16,tocIndex:11},{value:"string",paraId:16,tocIndex:11},{value:"-",paraId:16,tocIndex:11},{value:"Background color.",paraId:16,tocIndex:11},{value:"options.image",paraId:16,tocIndex:11},{value:"string",paraId:16,tocIndex:11},{value:"-",paraId:16,tocIndex:11},{value:"Background image address.",paraId:16,tocIndex:11},{value:"options.position",paraId:16,tocIndex:11},{value:"string",paraId:16,tocIndex:11},{value:"-",paraId:16,tocIndex:11},{value:"Background image position.",paraId:16,tocIndex:11},{value:"options.size",paraId:16,tocIndex:11},{value:"string",paraId:16,tocIndex:11},{value:"-",paraId:16,tocIndex:11},{value:"Background image size.",paraId:16,tocIndex:11},{value:"options.repeat",paraId:16,tocIndex:11},{value:"string",paraId:16,tocIndex:11},{value:"-",paraId:16,tocIndex:11},{value:"Background image repeat mode.",paraId:16,tocIndex:11},{value:"options.opacity",paraId:16,tocIndex:11},{value:"string",paraId:16,tocIndex:11},{value:"-",paraId:16,tocIndex:11},{value:"Background image opacity.",paraId:16,tocIndex:11},{value:"updateBackground(): this\n",paraId:17,tocIndex:12},{value:"Update the background.",paraId:18,tocIndex:12},{value:"clearBackground(): this\n",paraId:19,tocIndex:13},{value:"Clear the background.",paraId:20,tocIndex:13},{value:"In addition to the predefined values supported by ",paraId:21,tocIndex:14},{value:"repeat",paraId:22,tocIndex:14},{value:", you can also customize the image repeat mode.",paraId:21,tocIndex:14},{value:"function watermark(img, options) {\n  const width = img.width\n  const height = img.height\n  const canvas = document.createElement('canvas')\n\n  canvas.width = width * 3\n  canvas.height = height * 3\n\n  const ctx = canvas.getContext('2d')!\n  const angle = options.angle != null ? -options.angle : -20\n  const radians = Angle.toRad(angle)\n  const stepX = canvas.width / 4\n  const stepY = canvas.height / 4\n\n  for (let i = 0; i < 4; i += 1) {\n    for (let j = 0; j < 4; j += 1) {\n      if ((i + j) % 2 > 0) {\n        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY)\n        ctx.rotate(radians)\n        ctx.drawImage(img, -width / 2, -height / 2, width, height)\n      }\n    }\n  }\n\n  return canvas\n}\n\nGraph.registerBackground('watermark', watermark)\n",paraId:23,tocIndex:14}]},34763:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(82671);const n=[{value:"In position calculations, we often need to perform coordinate conversions. In X6, there are two coordinate systems: the local canvas coordinate system ",paraId:0},{value:"local",paraId:0},{value:" and the graph coordinate system ",paraId:0},{value:"graph",paraId:0},{value:". Sometimes, we also need to involve the browser coordinate system. Here's a unified explanation:",paraId:0},{value:"local",paraId:1},{value:": The local canvas coordinate system, which defaults to being consistent with the ",paraId:1},{value:"graph",paraId:1},{value:" coordinate system but will change with canvas scaling and translation. All node coordinates in the canvas are based on the ",paraId:1},{value:"local",paraId:1},{value:" coordinate system.",paraId:1},{value:"graph",paraId:1},{value:": The graph coordinate system, which is the canvas viewport we see and will not change with canvas scaling and translation.",paraId:1},{value:"client",paraId:1},{value:": The browser coordinate system, where ",paraId:1},{value:"e.clientX",paraId:1},{value:" and ",paraId:1},{value:"e.clientY",paraId:1},{value:" in mouse events are relative to the browser coordinate system.",paraId:1},{value:"page",paraId:1},{value:": The page coordinate system, which considers page horizontal and vertical scrolling compared to ",paraId:1},{value:"client",paraId:1},{value:". ",paraId:1},{value:"e.pageX",paraId:1},{value:" and ",paraId:1},{value:"e.pageY",paraId:1},{value:" in mouse events are relative to the page coordinate system.",paraId:1},{value:"pageToLocal(rect: Rectangle.RectangleLike): Rectangle\npageToLocal(x: number, y: number, width: number, height: number): Rectangle\npageToLocal(p: Point.PointLike): Point\npageToLocal(x: number, y: number): Point\n",paraId:2,tocIndex:2},{value:"Converts page coordinates to local canvas coordinates.",paraId:3,tocIndex:2},{value:"localToPage(rect: Rectangle.RectangleLike): Rectangle\nlocalToPage(x: number, y: number, width: number, height: number): Rectangle\nlocalToPage(p: Point.PointLike): Point\nlocalToPage(x: number, y: number): Point\n",paraId:4,tocIndex:3},{value:"Converts local canvas coordinates to page coordinates.",paraId:5,tocIndex:3},{value:"clientToLocal(rect: Rectangle.RectangleLike): Rectangle\nclientToLocal(x: number, y: number, width: number, height: number): Rectangle\nclientToLocal(p: Point.PointLike): Point\nclientToLocal(x: number, y: number): Point\n",paraId:6,tocIndex:4},{value:"Converts browser coordinates to local canvas coordinates.",paraId:7,tocIndex:4},{value:"localToClient(rect: Rectangle.RectangleLike): Rectangle\nlocalToClient(x: number, y: number, width: number, height: number): Rectangle\nlocalToClient(p: Point.PointLike): Point\nlocalToClient(x: number, y: number): Point\n",paraId:8,tocIndex:5},{value:"Converts local canvas coordinates to browser coordinates.",paraId:9,tocIndex:5},{value:"localToGraph(rect: Rectangle.RectangleLike): Rectangle\nlocalToGraph(x: number, y: number, width: number, height: number): Rectangle\nlocalToGraphPoint(p: Point.PointLike): Point\nlocalToGraphPoint(x: number, y: number): Point\n",paraId:10,tocIndex:6},{value:"Converts local canvas coordinates to graph coordinates.",paraId:11,tocIndex:6},{value:"graphToLocal(rect: Rectangle.RectangleLike): Rectangle\ngraphToLocal(x: number, y: number, width: number, height: number): Rectangle\ngraphToLocal(p: Point.PointLike): Point\ngraphToLocal(x: number, y: number): Point\n",paraId:12,tocIndex:7},{value:"Converts graph coordinates to local canvas coordinates.",paraId:13,tocIndex:7},{value:"snapToGrid(p: Point.PointLike): Point\nsnapToGrid(x: number, y: number): Point\n",paraId:14,tocIndex:8},{value:"Convert browser coordinates to canvas ",paraId:15,tocIndex:8},{value:"local coordinates",paraId:16,tocIndex:8},{value:" and align to the canvas grid.",paraId:15,tocIndex:8}]},37865:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(84421);const n=[{value:"new Graph(options: Options)\n",paraId:0,tocIndex:0},{value:"Option",paraId:1,tocIndex:0},{value:"Type",paraId:1,tocIndex:0},{value:"Required",paraId:1,tocIndex:0},{value:"Description",paraId:1,tocIndex:0},{value:"Default Value",paraId:1,tocIndex:0},{value:"container",paraId:1,tocIndex:0},{value:"HTMLElement",paraId:1,tocIndex:0},{value:"",paraId:1,tocIndex:0},{value:"The container of the canvas.",paraId:1,tocIndex:0},{value:"width",paraId:1,tocIndex:0},{value:"number",paraId:1,tocIndex:0},{value:"The width of the canvas, defaults to the container width.",paraId:1,tocIndex:0},{value:"-",paraId:1,tocIndex:0},{value:"height",paraId:1,tocIndex:0},{value:"number",paraId:1,tocIndex:0},{value:"The height of the canvas, defaults to the container height.",paraId:1,tocIndex:0},{value:"-",paraId:1,tocIndex:0},{value:"scaling",paraId:1,tocIndex:0},{value:"{ min?: number, max?: number }",paraId:1,tocIndex:0},{value:"The minimum and maximum zoom levels of the canvas.",paraId:1,tocIndex:0},{value:"{ min: 0.01, max: 16 }",paraId:1,tocIndex:0},{value:"autoResize",paraId:2,tocIndex:0},{value:"boolean | Element | Document",paraId:1,tocIndex:0},{value:"Whether to listen to container size changes and automatically update the canvas size.",paraId:1,tocIndex:0},{value:"false",paraId:1,tocIndex:0},{value:"panning",paraId:3,tocIndex:0},{value:"boolean | PanningManager.Options",paraId:1,tocIndex:0},{value:"Whether the canvas can be panned, defaults to disabled.",paraId:1,tocIndex:0},{value:"false",paraId:1,tocIndex:0},{value:"mousewheel",paraId:4,tocIndex:0},{value:"boolean | MouseWheel.Options",paraId:1,tocIndex:0},{value:"Whether the mouse wheel can zoom, defaults to disabled.",paraId:1,tocIndex:0},{value:"false",paraId:1,tocIndex:0},{value:"grid",paraId:5,tocIndex:0},{value:"boolean | number | GridManager.Options",paraId:1,tocIndex:0},{value:"The grid, defaults to a 10px grid but does not draw the grid background.",paraId:1,tocIndex:0},{value:"false",paraId:1,tocIndex:0},{value:"background",paraId:6,tocIndex:0},{value:"false | BackgroundManager.Options",paraId:1,tocIndex:0},{value:"The background, defaults to not drawing the background.",paraId:1,tocIndex:0},{value:"false",paraId:1,tocIndex:0},{value:"translating",paraId:7,tocIndex:0},{value:"Translating.Options",paraId:1,tocIndex:0},{value:"Restricts node movement. After a node is moved, automatically offset when it overlaps with other nodes.",paraId:1,tocIndex:0},{value:"{ restrict: false, autoOffset: true }",paraId:1,tocIndex:0},{value:"embedding",paraId:8,tocIndex:0},{value:"boolean | Embedding.Options",paraId:1,tocIndex:0},{value:"Whether to enable nested nodes, defaults to disabled.",paraId:1,tocIndex:0},{value:"false",paraId:1,tocIndex:0},{value:"connecting",paraId:9,tocIndex:0},{value:"Connecting.Options",paraId:1,tocIndex:0},{value:"The connection options.",paraId:1,tocIndex:0},{value:"{ snap: false, ... }",paraId:1,tocIndex:0},{value:"highlighting",paraId:10,tocIndex:0},{value:"Highlighting.Options",paraId:1,tocIndex:0},{value:"The highlighting options.",paraId:1,tocIndex:0},{value:"{...}",paraId:1,tocIndex:0},{value:"interacting",paraId:11,tocIndex:0},{value:"Interacting.Options",paraId:1,tocIndex:0},{value:"Customizes the interaction behavior of nodes and edges.",paraId:1,tocIndex:0},{value:"{ edgeLabelMovable: false }",paraId:1,tocIndex:0},{value:"magnetThreshold",paraId:12,tocIndex:0},{value:"number | onleave",paraId:1,tocIndex:0},{value:"The number of times the mouse can move before triggering a connection, or set to ",paraId:1,tocIndex:0},{value:"onleave",paraId:1,tocIndex:0},{value:" to trigger a connection when the mouse leaves an element.",paraId:1,tocIndex:0},{value:"0",paraId:1,tocIndex:0},{value:"moveThreshold",paraId:13,tocIndex:0},{value:"number",paraId:1,tocIndex:0},{value:"The number of times the mouse can move before triggering a ",paraId:1,tocIndex:0},{value:"mousemove",paraId:1,tocIndex:0},{value:" event.",paraId:1,tocIndex:0},{value:"0",paraId:1,tocIndex:0},{value:"clickThreshold",paraId:14,tocIndex:0},{value:"number",paraId:1,tocIndex:0},{value:"When the mouse moves more than the specified number of times, the mouse click event will not be triggered.",paraId:1,tocIndex:0},{value:"0",paraId:1,tocIndex:0},{value:"preventDefaultContextMenu",paraId:15,tocIndex:0},{value:"boolean",paraId:1,tocIndex:0},{value:"Whether to disable the browser's default right-click menu.",paraId:1,tocIndex:0},{value:"true",paraId:1,tocIndex:0},{value:"preventDefaultBlankAction",paraId:16,tocIndex:0},{value:"boolean",paraId:1,tocIndex:0},{value:"Whether to disable the default mouse behavior when clicking on a blank area of the canvas.",paraId:1,tocIndex:0},{value:"true",paraId:1,tocIndex:0},{value:"async",paraId:17,tocIndex:0},{value:"boolean",paraId:1,tocIndex:0},{value:"Whether to render asynchronously.",paraId:1,tocIndex:0},{value:"true",paraId:1,tocIndex:0},{value:"virtual",paraId:18,tocIndex:0},{value:"boolean | VirtualOptions",paraId:1,tocIndex:0},{value:"Whether to only render the visible area of the canvas; when an object is provided, you can configure the buffer margin ",paraId:1,tocIndex:0},{value:"margin",paraId:1,tocIndex:0},{value:" and the switch ",paraId:1,tocIndex:0},{value:"enabled",paraId:1,tocIndex:0},{value:".",paraId:1,tocIndex:0},{value:"false",paraId:1,tocIndex:0},{value:"onPortRendered",paraId:19,tocIndex:0},{value:"(args: OnPortRenderedArgs) => void",paraId:1,tocIndex:0},{value:"The callback triggered when a port is rendered.",paraId:1,tocIndex:0},{value:"-",paraId:1,tocIndex:0},{value:"onEdgeLabelRendered",paraId:20,tocIndex:0},{value:"(args: OnEdgeLabelRenderedArgs) => void | ((args: OnEdgeLabelRenderedArgs) => void)",paraId:1,tocIndex:0},{value:"The callback triggered when an edge label is rendered, And it can return a cleanup function, which will be executed when the label is destroyed.",paraId:1,tocIndex:0},{value:"-",paraId:1,tocIndex:0},{value:"createCellView",paraId:21,tocIndex:0},{value:"(cell: Cell) => CellView | null | undefined",paraId:1,tocIndex:0},{value:"Customizes the view of a cell.",paraId:1,tocIndex:0},{value:"-",paraId:1,tocIndex:0}]},4807:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(23799);const n=[{value:"The grid is the smallest unit of rendering/moving nodes. The default grid size is ",paraId:0},{value:"10px",paraId:0},{value:". When rendering nodes, it means aligning to the grid with ",paraId:0},{value:"10",paraId:0},{value:" as the minimum unit, such as a node with a position of ",paraId:0},{value:"{ x: 24, y: 38 }",paraId:0},{value:" will be rendered at ",paraId:0},{value:"{ x: 20, y: 40 }",paraId:0},{value:" on the canvas. When moving nodes, it means the minimum distance of each move is ",paraId:0},{value:"10px",paraId:0},{value:".",paraId:0},{value:"You can set the grid size when creating the canvas through the following configuration.",paraId:1,tocIndex:2},{value:"const graph = new Graph({\n  grid: 10,\n})\n\n// Equivalent to\nconst graph = new Graph({\n  grid: {\n    size: 10,\n  },\n})\n",paraId:2,tocIndex:2},{value:"The grid is invisible by default. You can enable grid drawing when creating the canvas through the following configuration.",paraId:3,tocIndex:3},{value:"const graph = new Graph({\n  grid: true, // Grid size is 10px and draw the grid\n})\n\n// Equivalent to\nconst graph = new Graph({\n  grid: {\n    size: 10, // Grid size is 10px\n    visible: true, // Draw the grid, default is dot type\n  },\n})\n",paraId:4,tocIndex:3},{value:"We have four built-in grid types, which can be specified through the ",paraId:5,tocIndex:3},{value:"type",paraId:5,tocIndex:3},{value:" option, with a default value of ",paraId:5,tocIndex:3},{value:"dot",paraId:5,tocIndex:3},{value:". You can also configure the grid style through the ",paraId:5,tocIndex:3},{value:"args",paraId:5,tocIndex:3},{value:" option.",paraId:5,tocIndex:3},{value:"Dot grid.",paraId:6,tocIndex:4},{value:"new Graph({\n  container: this.container,\n  grid: {\n    visible: true,\n    type: 'dot',\n    args: {\n      color: '#a0a0a0', // Grid point color\n      thickness: 1, // Grid point size\n    },\n  },\n})\n",paraId:7,tocIndex:4},{value:"Fixed dot grid with a fixed point size. When the canvas zoom ratio is less than ",paraId:8,tocIndex:5},{value:"1",paraId:8,tocIndex:5},{value:", the grid point size scales with the canvas zoom ratio. When the canvas zoom ratio is greater than ",paraId:8,tocIndex:5},{value:"1",paraId:8,tocIndex:5},{value:", the grid point size is the given ",paraId:8,tocIndex:5},{value:"thickness",paraId:8,tocIndex:5},{value:" value.",paraId:8,tocIndex:5},{value:"new Graph({\n  container: this.container,\n  grid: {\n    visible: true,\n    size: 10,\n    type: 'fixedDot',\n    args: {\n      color: '#a0a0a0', // Grid point color\n      thickness: 2, // Grid point size\n    },\n  },\n})\n\ngraph.scale(10, 10)\n",paraId:9,tocIndex:5},{value:"Mesh grid.",paraId:10,tocIndex:6},{value:"new Graph({\n  container: this.container,\n  grid: {\n    visible: true,\n    type: 'mesh',\n    args: {\n      color: '#ddd', // Grid line color\n      thickness: 1, // Grid line width\n    },\n  },\n})\n",paraId:11,tocIndex:6},{value:"Double mesh grid.",paraId:12,tocIndex:7},{value:"const graph = new Graph({\n  grid: {\n    size: 10,\n    visible: true,\n    type: 'doubleMesh',\n    args: [\n      {\n        color: '#eee', // Main grid line color\n        thickness: 1, // Main grid line width\n      },\n      {\n        color: '#ddd', // Secondary grid line color\n        thickness: 1, // Secondary grid line width\n        factor: 4, // Main and secondary grid line interval\n      },\n    ],\n  },\n})\n",paraId:13,tocIndex:7},{value:"getGridSize(): number\n",paraId:14,tocIndex:9},{value:"Get the grid size.",paraId:15,tocIndex:9},{value:"setGridSize(gridSize: number): this\n",paraId:16,tocIndex:10},{value:"Set the grid size.",paraId:17,tocIndex:10},{value:"showGrid(): this\n",paraId:18,tocIndex:11},{value:"Show the grid.",paraId:19,tocIndex:11},{value:"hideGrid(): this\n",paraId:20,tocIndex:12},{value:"Hide the grid.",paraId:21,tocIndex:12},{value:"clearGrid(): this\n",paraId:22,tocIndex:13},{value:"Clear the grid.",paraId:23,tocIndex:13},{value:"drawGrid(options?: DrawGridOptions): this\n",paraId:24,tocIndex:14},{value:"Redraw the grid.",paraId:25,tocIndex:14},{value:"Name",paraId:26,tocIndex:14},{value:"Type",paraId:26,tocIndex:14},{value:"Required",paraId:26,tocIndex:14},{value:"Default",paraId:26,tocIndex:14},{value:"Description",paraId:26,tocIndex:14},{value:"type",paraId:26,tocIndex:14},{value:"string",paraId:26,tocIndex:14},{value:"dot",paraId:26,tocIndex:14},{value:"Grid type. For details, please refer to ",paraId:26,tocIndex:14},{value:"here",paraId:27,tocIndex:14},{value:".",paraId:26,tocIndex:14},{value:"args",paraId:26,tocIndex:14},{value:"object",paraId:26,tocIndex:14},{value:"-",paraId:26,tocIndex:14},{value:"Grid parameters corresponding to the grid type.",paraId:26,tocIndex:14},{value:"Here's an example of registering a red dot grid:",paraId:28,tocIndex:15},{value:"Graph.registerGrid('red-dot', {\n  color: 'red',\n  thickness: 1,\n  markup: 'rect',\n  update(elem, options) {\n    const width = options.thickness * options.sx\n    const height = options.thickness * options.sy\n    Dom.attr(elem, {\n      width,\n      height,\n      rx: width,\n      ry: height,\n      fill: options.color,\n    })\n  },\n})\n\nconst graph = new Graph({\n  grid: {\n    type: 'red-dot',\n  },\n})\n",paraId:29,tocIndex:15}]},71004:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(61579);const n=[{value:"Hold down the ",paraId:0,tocIndex:0},{value:"Command",paraId:0,tocIndex:0},{value:" key and use the mouse wheel to zoom in/out of the canvas.",paraId:0,tocIndex:0},{value:"You can use the ",paraId:1,tocIndex:1},{value:"mousewheel",paraId:1,tocIndex:1},{value:" configuration to zoom in/out of the canvas, often used in combination with modifier keys. The usage is as follows:",paraId:1,tocIndex:1},{value:"const graph = new Graph({\n  mousewheel: {\n    enabled: true,\n    modifiers: ['ctrl', 'meta'],\n  },\n})\n",paraId:2,tocIndex:1},{value:"Supported options are as follows:",paraId:3,tocIndex:1},{value:"interface MouseWheelOptions {\n  enabled?: boolean\n  global?: boolean\n  factor?: number\n  zoomAtMousePosition?: boolean\n  modifiers?: string | ('alt' | 'ctrl' | 'meta' | 'shift')[] | null\n  guard?: (this: Graph, e: WheelEvent) => boolean\n}\n",paraId:4,tocIndex:1},{value:"Whether to enable mouse wheel zooming interaction.",paraId:5,tocIndex:2},{value:"The zoom factor. Defaults to ",paraId:6,tocIndex:3},{value:"1.2",paraId:6,tocIndex:3},{value:".",paraId:6,tocIndex:3},{value:"Whether to zoom in/out at the mouse position. Defaults to ",paraId:7,tocIndex:4},{value:"true",paraId:7,tocIndex:4},{value:".",paraId:7,tocIndex:4},{value:"Whether to bind the wheel event globally. If set to ",paraId:8,tocIndex:5},{value:"true",paraId:8,tocIndex:5},{value:", the wheel event is bound to the ",paraId:8,tocIndex:5},{value:"Document",paraId:8,tocIndex:5},{value:", otherwise it is bound to the canvas container. Defaults to ",paraId:8,tocIndex:5},{value:"false",paraId:8,tocIndex:5},{value:".",paraId:8,tocIndex:5},{value:"Modifier keys (",paraId:9,tocIndex:6},{value:"alt",paraId:9,tocIndex:6},{value:", ",paraId:9,tocIndex:6},{value:"ctrl",paraId:9,tocIndex:6},{value:", ",paraId:9,tocIndex:6},{value:"meta",paraId:9,tocIndex:6},{value:", ",paraId:9,tocIndex:6},{value:"shift",paraId:9,tocIndex:6},{value:"), which can be set to resolve conflicts between default wheel behavior and canvas zooming. Modifier keys support the following formats:",paraId:9,tocIndex:6},{value:"alt",paraId:10,tocIndex:6},{value:" represents pressing the ",paraId:10,tocIndex:6},{value:"alt",paraId:10,tocIndex:6},{value:" key.",paraId:10,tocIndex:6},{value:"[alt, ctrl]",paraId:10,tocIndex:6},{value:" represents pressing either ",paraId:10,tocIndex:6},{value:"alt",paraId:10,tocIndex:6},{value:" or ",paraId:10,tocIndex:6},{value:"ctrl",paraId:10,tocIndex:6},{value:".",paraId:10,tocIndex:6},{value:"alt|ctrl",paraId:10,tocIndex:6},{value:" represents pressing either ",paraId:10,tocIndex:6},{value:"alt",paraId:10,tocIndex:6},{value:" or ",paraId:10,tocIndex:6},{value:"ctrl",paraId:10,tocIndex:6},{value:".",paraId:10,tocIndex:6},{value:"alt&ctrl",paraId:10,tocIndex:6},{value:" represents pressing both ",paraId:10,tocIndex:6},{value:"alt",paraId:10,tocIndex:6},{value:" and ",paraId:10,tocIndex:6},{value:"ctrl",paraId:10,tocIndex:6},{value:" simultaneously.",paraId:10,tocIndex:6},{value:"alt|ctrl&shift",paraId:10,tocIndex:6},{value:" represents pressing both ",paraId:10,tocIndex:6},{value:"alt",paraId:10,tocIndex:6},{value:" and ",paraId:10,tocIndex:6},{value:"shift",paraId:10,tocIndex:6},{value:" simultaneously or both ",paraId:10,tocIndex:6},{value:"ctrl",paraId:10,tocIndex:6},{value:" and ",paraId:10,tocIndex:6},{value:"shift",paraId:10,tocIndex:6},{value:" simultaneously.",paraId:10,tocIndex:6},{value:"Determines whether a wheel event should be handled, returning ",paraId:11,tocIndex:7},{value:"false",paraId:11,tocIndex:7},{value:" to ignore the event.",paraId:11,tocIndex:7},{value:"new Graph({\n  mousewheel: {\n    enabled: true,\n    guard(e: WheelEvent) {\n      if (e.altKey) {\n        // Ignore all wheel events when the alt key is pressed\n        return false\n      }\n      return true\n    },\n  },\n})\n",paraId:12,tocIndex:7},{value:"isMouseWheelEnabled(): boolean\n",paraId:13,tocIndex:9},{value:"Returns whether mouse wheel zooming is enabled.",paraId:14,tocIndex:9},{value:"enableMouseWheel(): this\n",paraId:15,tocIndex:10},{value:"Enables mouse wheel zooming.",paraId:16,tocIndex:10},{value:"disableMouseWheel(): this\n",paraId:17,tocIndex:11},{value:"Disables mouse wheel zooming.",paraId:18,tocIndex:11},{value:"toggleMouseWheel(enabled?: boolean): this\n",paraId:19,tocIndex:12},{value:"Toggles the enabled state of mouse wheel zooming.",paraId:20,tocIndex:12},{value:"Name",paraId:21,tocIndex:12},{value:"Type",paraId:21,tocIndex:12},{value:"Required",paraId:21,tocIndex:12},{value:"Default",paraId:21,tocIndex:12},{value:"Description",paraId:21,tocIndex:12},{value:"enabled",paraId:21,tocIndex:12},{value:"boolean",paraId:21,tocIndex:12},{value:"-",paraId:21,tocIndex:12},{value:"Whether to enable mouse wheel zooming, toggles the state if not provided.",paraId:21,tocIndex:12}]},23208:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(52176);const n=[{value:"A regular canvas (without the ",paraId:0,tocIndex:1},{value:"Scroller",paraId:0,tocIndex:1},{value:" plugin) can support panning by the ",paraId:0,tocIndex:1},{value:"panning",paraId:0,tocIndex:1},{value:" option.",paraId:0,tocIndex:1},{value:"const graph = new Graph({\n  panning: true, // If not provided, default is also true\n})\n\n// Equivalent to\nconst graph = new Graph({\n  panning: {\n    enabled: true,\n  },\n})\n",paraId:1,tocIndex:1},{value:"The supported options are as follows:",paraId:2,tocIndex:1},{value:"interface Options {\n  enabled?: boolean\n  modifiers?: ModifierKey\n  eventTypes?: ('leftMouseDown' | 'rightMouseDown' | 'mouseWheel' | 'mouseWheelDown')[]\n}\n",paraId:3,tocIndex:1},{value:"Whether to enable canvas panning interaction.",paraId:4,tocIndex:2},{value:"Dragging may conflict with other operations, so you can set the ",paraId:5,tocIndex:3},{value:"modifiers",paraId:5,tocIndex:3},{value:" parameter to specify a modifier key that needs to be pressed along with the mouse click to trigger canvas panning.",paraId:5,tocIndex:3},{value:"The type definition of ",paraId:6,tocIndex:3},{value:"ModifierKey",paraId:6,tocIndex:3},{value:" is as follows:",paraId:6,tocIndex:3},{value:"type ModifierKey = string | ('alt' | 'ctrl' | 'meta' | 'shift' | 'space')[] | null\n",paraId:7,tocIndex:3},{value:"It supports the following forms:",paraId:8,tocIndex:3},{value:"alt",paraId:9,tocIndex:3},{value:" represents pressing the ",paraId:9,tocIndex:3},{value:"alt",paraId:9,tocIndex:3},{value:" key.",paraId:9,tocIndex:3},{value:"[alt, ctrl]",paraId:9,tocIndex:3},{value:" represents pressing either the ",paraId:9,tocIndex:3},{value:"alt",paraId:9,tocIndex:3},{value:" or ",paraId:9,tocIndex:3},{value:"ctrl",paraId:9,tocIndex:3},{value:" key.",paraId:9,tocIndex:3},{value:"alt|ctrl",paraId:9,tocIndex:3},{value:" represents pressing either the ",paraId:9,tocIndex:3},{value:"alt",paraId:9,tocIndex:3},{value:" or ",paraId:9,tocIndex:3},{value:"ctrl",paraId:9,tocIndex:3},{value:" key.",paraId:9,tocIndex:3},{value:"alt&ctrl",paraId:9,tocIndex:3},{value:" represents pressing both the ",paraId:9,tocIndex:3},{value:"alt",paraId:9,tocIndex:3},{value:" and ",paraId:9,tocIndex:3},{value:"ctrl",paraId:9,tocIndex:3},{value:" keys simultaneously.",paraId:9,tocIndex:3},{value:"alt|ctrl&shift",paraId:9,tocIndex:3},{value:" represents pressing both the ",paraId:9,tocIndex:3},{value:"alt",paraId:9,tocIndex:3},{value:" and ",paraId:9,tocIndex:3},{value:"shift",paraId:9,tocIndex:3},{value:" keys simultaneously or pressing both the ",paraId:9,tocIndex:3},{value:"ctrl",paraId:9,tocIndex:3},{value:" and ",paraId:9,tocIndex:3},{value:"shift",paraId:9,tocIndex:3},{value:" keys simultaneously.",paraId:9,tocIndex:3},{value:"The interaction types that trigger canvas panning. It supports four forms or their combinations:",paraId:10,tocIndex:4},{value:"leftMouseDown",paraId:11,tocIndex:4},{value:": Dragging by pressing the left mouse button",paraId:11,tocIndex:4},{value:"rightMouseDown",paraId:11,tocIndex:4},{value:": Dragging by pressing the right mouse button",paraId:11,tocIndex:4},{value:"mouseWheel",paraId:11,tocIndex:4},{value:": Dragging by scrolling the mouse wheel",paraId:11,tocIndex:4},{value:"mouseWheelDown",paraId:11,tocIndex:4},{value:": Dragging by pressing the mouse wheel",paraId:11,tocIndex:4},{value:"isPannable(): boolean\n",paraId:12,tocIndex:6},{value:"Returns whether canvas panning interaction is enabled.",paraId:13,tocIndex:6},{value:"enablePanning(): this\n",paraId:14,tocIndex:7},{value:"Enables canvas panning.",paraId:15,tocIndex:7},{value:"disablePanning(): this\n",paraId:16,tocIndex:8},{value:"Disables canvas panning.",paraId:17,tocIndex:8},{value:"togglePanning(enabled?: boolean): this\n",paraId:18,tocIndex:9},{value:"Toggles the enabled state of canvas panning. The parameter is as follows:",paraId:19,tocIndex:9},{value:"Name",paraId:20,tocIndex:9},{value:"Type",paraId:20,tocIndex:9},{value:"Required",paraId:20,tocIndex:9},{value:"Default Value",paraId:20,tocIndex:9},{value:"Description",paraId:20,tocIndex:9},{value:"enabled",paraId:20,tocIndex:9},{value:"boolean",paraId:20,tocIndex:9},{value:"-",paraId:20,tocIndex:9},{value:"Whether to enable canvas panning, defaults to toggling the enabled state.",paraId:20,tocIndex:9}]},34047:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(23918);const n=[{value:"Configure the minimum or maximum zoom level of the canvas through the scaling configuration.",paraId:0,tocIndex:1},{value:"new Graph({\n  scaling: {\n    min: 0.05, // default value is 0.01\n    max: 12, // default value is 16\n  },\n})\n",paraId:1,tocIndex:1},{value:"resize(width?: number, height?: number): this\n",paraId:2,tocIndex:3},{value:"Set the canvas size.",paraId:3,tocIndex:3},{value:"Name",paraId:4,tocIndex:3},{value:"Type",paraId:4,tocIndex:3},{value:"Required",paraId:4,tocIndex:3},{value:"Default Value",paraId:4,tocIndex:3},{value:"Description",paraId:4,tocIndex:3},{value:"width",paraId:4,tocIndex:3},{value:"number",paraId:4,tocIndex:3},{value:"Canvas width, remains unchanged if not provided.",paraId:4,tocIndex:3},{value:"height",paraId:4,tocIndex:3},{value:"number",paraId:4,tocIndex:3},{value:"Canvas height, remains unchanged if not provided.",paraId:4,tocIndex:3},{value:"zoom(): number\n",paraId:5,tocIndex:4},{value:"Get the canvas zoom ratio.",paraId:6,tocIndex:4},{value:"zoom(factor: number, options?: ZoomOptions): this\n",paraId:7,tocIndex:4},{value:"Zoom the canvas.",paraId:8,tocIndex:4},{value:"Name",paraId:9,tocIndex:4},{value:"Type",paraId:9,tocIndex:4},{value:"Required",paraId:9,tocIndex:4},{value:"Default Value",paraId:9,tocIndex:4},{value:"Description",paraId:9,tocIndex:4},{value:"factor",paraId:9,tocIndex:4},{value:"number",paraId:9,tocIndex:4},{value:"",paraId:9,tocIndex:4},{value:"Zoom ratio.",paraId:9,tocIndex:4},{value:"options.absolute",paraId:9,tocIndex:4},{value:"boolean",paraId:9,tocIndex:4},{value:"false",paraId:9,tocIndex:4},{value:"Whether to zoom absolutely.",paraId:9,tocIndex:4},{value:"options.minScale",paraId:9,tocIndex:4},{value:"number",paraId:9,tocIndex:4},{value:"-",paraId:9,tocIndex:4},{value:"Minimum zoom ratio.",paraId:9,tocIndex:4},{value:"options.maxScale",paraId:9,tocIndex:4},{value:"number",paraId:9,tocIndex:4},{value:"-",paraId:9,tocIndex:4},{value:"Maximum zoom ratio.",paraId:9,tocIndex:4},{value:"options.scaleGrid",paraId:9,tocIndex:4},{value:"number",paraId:9,tocIndex:4},{value:"-",paraId:9,tocIndex:4},{value:"Correct the zoom ratio to be an integer multiple of ",paraId:9,tocIndex:4},{value:"scaleGrid",paraId:9,tocIndex:4},{value:".",paraId:9,tocIndex:4},{value:"options.center",paraId:9,tocIndex:4},{value:"Point.PointLike",paraId:9,tocIndex:4},{value:"-",paraId:9,tocIndex:4},{value:"Zoom center.",paraId:9,tocIndex:4},{value:"When ",paraId:10,tocIndex:4},{value:"options.absolute",paraId:10,tocIndex:4},{value:" is ",paraId:10,tocIndex:4},{value:"true",paraId:10,tocIndex:4},{value:", it means zooming the canvas to the value represented by ",paraId:10,tocIndex:4},{value:"factor",paraId:10,tocIndex:4},{value:". Otherwise, ",paraId:10,tocIndex:4},{value:"factor",paraId:10,tocIndex:4},{value:" represents the zoom-in or zoom-out factor. When ",paraId:10,tocIndex:4},{value:"factor",paraId:10,tocIndex:4},{value:" is a positive number, it means zooming in, and when it's a negative number, it means zooming out.",paraId:10,tocIndex:4},{value:"zoomTo(factor: number, options?: ZoomOptions): this\n",paraId:11,tocIndex:5},{value:"Zoom the canvas to a specified ratio.",paraId:12,tocIndex:5},{value:"Name",paraId:13,tocIndex:5},{value:"Type",paraId:13,tocIndex:5},{value:"Required",paraId:13,tocIndex:5},{value:"Default Value",paraId:13,tocIndex:5},{value:"Description",paraId:13,tocIndex:5},{value:"factor",paraId:13,tocIndex:5},{value:"number",paraId:13,tocIndex:5},{value:"",paraId:13,tocIndex:5},{value:"Zoom ratio.",paraId:13,tocIndex:5},{value:"options.minScale",paraId:13,tocIndex:5},{value:"number",paraId:13,tocIndex:5},{value:"-",paraId:13,tocIndex:5},{value:"Minimum zoom ratio.",paraId:13,tocIndex:5},{value:"options.maxScale",paraId:13,tocIndex:5},{value:"number",paraId:13,tocIndex:5},{value:"-",paraId:13,tocIndex:5},{value:"Maximum zoom ratio.",paraId:13,tocIndex:5},{value:"options.scaleGrid",paraId:13,tocIndex:5},{value:"number",paraId:13,tocIndex:5},{value:"-",paraId:13,tocIndex:5},{value:"Correct the zoom ratio to be an integer multiple of ",paraId:13,tocIndex:5},{value:"scaleGrid",paraId:13,tocIndex:5},{value:".",paraId:13,tocIndex:5},{value:"options.center",paraId:13,tocIndex:5},{value:"Point.PointLike",paraId:13,tocIndex:5},{value:"-",paraId:13,tocIndex:5},{value:"Zoom center.",paraId:13,tocIndex:5},{value:"zoomToFit(options?: Options): this\n",paraId:14,tocIndex:6},{value:"Zoom the canvas content to fit the viewport.",paraId:15,tocIndex:6},{value:"Name",paraId:16,tocIndex:6},{value:"Type",paraId:16,tocIndex:6},{value:"Required",paraId:16,tocIndex:6},{value:"Default Value",paraId:16,tocIndex:6},{value:"Description",paraId:16,tocIndex:6},{value:"rect",paraId:16,tocIndex:6},{value:"Rectangle.RectangleLike",paraId:16,tocIndex:6},{value:"",paraId:16,tocIndex:6},{value:"Rectangle area.",paraId:16,tocIndex:6},{value:"options.padding",paraId:16,tocIndex:6},{value:"number | ",paraId:16,tocIndex:6},{value:"{ left: number, top: number, right: number, bottom: number }",paraId:16,tocIndex:6},{value:"-",paraId:16,tocIndex:6},{value:"Margin.",paraId:16,tocIndex:6},{value:"options.contentArea",paraId:16,tocIndex:6},{value:"Rectangle.RectangleLike",paraId:16,tocIndex:6},{value:"-",paraId:16,tocIndex:6},{value:"Content area, defaults to getting the canvas content area.",paraId:16,tocIndex:6},{value:"options.viewportArea",paraId:16,tocIndex:6},{value:"Rectangle.RectangleLike",paraId:16,tocIndex:6},{value:"-",paraId:16,tocIndex:6},{value:"Viewport area, defaults to getting the canvas viewport.",paraId:16,tocIndex:6},{value:"options.scaleGrid",paraId:16,tocIndex:6},{value:"number",paraId:16,tocIndex:6},{value:"-",paraId:16,tocIndex:6},{value:"Correct the zoom ratio to be an integer multiple of ",paraId:16,tocIndex:6},{value:"scaleGrid",paraId:16,tocIndex:6},{value:".",paraId:16,tocIndex:6},{value:"options.minScale",paraId:16,tocIndex:6},{value:"number",paraId:16,tocIndex:6},{value:"-",paraId:16,tocIndex:6},{value:"Minimum zoom ratio.",paraId:16,tocIndex:6},{value:"options.maxScale",paraId:16,tocIndex:6},{value:"number",paraId:16,tocIndex:6},{value:"-",paraId:16,tocIndex:6},{value:"Maximum zoom ratio.",paraId:16,tocIndex:6},{value:"options.minScaleX",paraId:16,tocIndex:6},{value:"number",paraId:16,tocIndex:6},{value:"-",paraId:16,tocIndex:6},{value:"Minimum zoom ratio in the X-axis direction.",paraId:16,tocIndex:6},{value:"options.maxScaleX",paraId:16,tocIndex:6},{value:"number",paraId:16,tocIndex:6},{value:"-",paraId:16,tocIndex:6},{value:"Maximum zoom ratio in the X-axis direction.",paraId:16,tocIndex:6},{value:"options.minScaleY",paraId:16,tocIndex:6},{value:"number",paraId:16,tocIndex:6},{value:"-",paraId:16,tocIndex:6},{value:"Minimum zoom ratio in the Y-axis direction.",paraId:16,tocIndex:6},{value:"options.maxScaleY",paraId:16,tocIndex:6},{value:"number",paraId:16,tocIndex:6},{value:"-",paraId:16,tocIndex:6},{value:"Maximum zoom ratio in the Y-axis direction.",paraId:16,tocIndex:6},{value:"options.preserveAspectRatio",paraId:16,tocIndex:6},{value:"boolean",paraId:16,tocIndex:6},{value:"false",paraId:16,tocIndex:6},{value:"Whether to preserve the aspect ratio.",paraId:16,tocIndex:6},{value:"options.useCellGeometry",paraId:16,tocIndex:6},{value:"boolean",paraId:16,tocIndex:6},{value:"true",paraId:16,tocIndex:6},{value:"Whether to use node/edge geometry information (Model) to calculate the bounding box.",paraId:16,tocIndex:6},{value:"rotate(): {\n  angle: number\n  cx?: number\n  cy?: number\n}\n",paraId:17,tocIndex:7},{value:"Get the canvas rotation angle and center.",paraId:18,tocIndex:7},{value:"rotate(angle: number, cx?: number, cy?: number): this\n",paraId:19,tocIndex:7},{value:"Rotate the canvas.",paraId:20,tocIndex:7},{value:"Name",paraId:21,tocIndex:7},{value:"Type",paraId:21,tocIndex:7},{value:"Required",paraId:21,tocIndex:7},{value:"Default Value",paraId:21,tocIndex:7},{value:"Description",paraId:21,tocIndex:7},{value:"angle",paraId:21,tocIndex:7},{value:"number",paraId:21,tocIndex:7},{value:"",paraId:21,tocIndex:7},{value:"Rotation angle.",paraId:21,tocIndex:7},{value:"cx",paraId:21,tocIndex:7},{value:"number",paraId:21,tocIndex:7},{value:"-",paraId:21,tocIndex:7},{value:"Rotation center x-coordinate, defaults to the canvas center.",paraId:21,tocIndex:7},{value:"cy",paraId:21,tocIndex:7},{value:"number",paraId:21,tocIndex:7},{value:"-",paraId:21,tocIndex:7},{value:"Rotation center y-coordinate, defaults to the canvas center.",paraId:21,tocIndex:7},{value:"translate(): {\n  tx: number\n  ty: number\n}\n",paraId:22,tocIndex:8},{value:"Get the canvas translation.",paraId:23,tocIndex:8},{value:"translate(tx: number, ty: number): this\n",paraId:24,tocIndex:8},{value:"Translate the canvas.",paraId:25,tocIndex:8},{value:"Name",paraId:26,tocIndex:8},{value:"Type",paraId:26,tocIndex:8},{value:"Required",paraId:26,tocIndex:8},{value:"Default Value",paraId:26,tocIndex:8},{value:"Description",paraId:26,tocIndex:8},{value:"tx",paraId:26,tocIndex:8},{value:"number",paraId:26,tocIndex:8},{value:"",paraId:26,tocIndex:8},{value:"X-axis translation.",paraId:26,tocIndex:8},{value:"ty",paraId:26,tocIndex:8},{value:"number",paraId:26,tocIndex:8},{value:"",paraId:26,tocIndex:8},{value:"Y-axis translation.",paraId:26,tocIndex:8},{value:"getContentArea(options?: Transform.GetContentAreaOptions): Rectangle\n",paraId:27,tocIndex:9},{value:"Get the bounding box of the canvas content, represented in local coordinates.",paraId:28,tocIndex:9},{value:"Name",paraId:29,tocIndex:9},{value:"Type",paraId:29,tocIndex:9},{value:"Required",paraId:29,tocIndex:9},{value:"Default Value",paraId:29,tocIndex:9},{value:"Description",paraId:29,tocIndex:9},{value:"options.useCellGeometry",paraId:29,tocIndex:9},{value:"boolean",paraId:29,tocIndex:9},{value:"true",paraId:29,tocIndex:9},{value:"Whether to use node/edge geometry information (Model) to calculate the content size.",paraId:29,tocIndex:9},{value:"getContentBBox(options?: Transform.GetContentAreaOptions): Rectangle\n",paraId:30,tocIndex:10},{value:"Get the bounding box of the canvas content, represented in graph coordinates.",paraId:31,tocIndex:10},{value:"Name",paraId:32,tocIndex:10},{value:"Type",paraId:32,tocIndex:10},{value:"Required",paraId:32,tocIndex:10},{value:"Default Value",paraId:32,tocIndex:10},{value:"Description",paraId:32,tocIndex:10},{value:"options.useCellGeometry",paraId:32,tocIndex:10},{value:"boolean",paraId:32,tocIndex:10},{value:"true",paraId:32,tocIndex:10},{value:"Whether to use node/edge geometry information (Model) to calculate the content size.",paraId:32,tocIndex:10},{value:"center(options?: CenterOptions): this\n",paraId:33,tocIndex:11},{value:"Align the canvas center with the viewport center.",paraId:34,tocIndex:11},{value:"Name",paraId:35,tocIndex:11},{value:"Type",paraId:35,tocIndex:11},{value:"Required",paraId:35,tocIndex:11},{value:"Default Value",paraId:35,tocIndex:11},{value:"Description",paraId:35,tocIndex:11},{value:"options.padding",paraId:35,tocIndex:11},{value:"number | Padding",paraId:35,tocIndex:11},{value:"-",paraId:35,tocIndex:11},{value:"Margin, only effective in scroller canvas.",paraId:35,tocIndex:11},{value:"centerPoint(x?: number | null, y?: number | null, options?: CenterOptions): this\n",paraId:36,tocIndex:12},{value:"Align the point ",paraId:37,tocIndex:12},{value:"(x, y)",paraId:37,tocIndex:12},{value:" (relative to the canvas) with the viewport center.",paraId:37,tocIndex:12},{value:"Name",paraId:38,tocIndex:12},{value:"Type",paraId:38,tocIndex:12},{value:"Required",paraId:38,tocIndex:12},{value:"Default Value",paraId:38,tocIndex:12},{value:"Description",paraId:38,tocIndex:12},{value:"x",paraId:38,tocIndex:12},{value:"number",paraId:38,tocIndex:12},{value:"-",paraId:38,tocIndex:12},{value:"X-coordinate relative to the canvas.",paraId:38,tocIndex:12},{value:"y",paraId:38,tocIndex:12},{value:"number",paraId:38,tocIndex:12},{value:"-",paraId:38,tocIndex:12},{value:"Y-coordinate relative to the canvas.",paraId:38,tocIndex:12},{value:"options.padding",paraId:38,tocIndex:12},{value:"number | Padding",paraId:38,tocIndex:12},{value:"-",paraId:38,tocIndex:12},{value:"Margin, only effective in scroller canvas.",paraId:38,tocIndex:12},{value:"graph.centerPoint(100, 200)\ngraph.centerPoint(100, null, { padding: { left: 100 } })\ngraph.centerPoint(null, 200, { padding: { left: 100 } })\n",paraId:39,tocIndex:12},{value:"centerContent(options?: PositionContentOptions): this\n",paraId:40,tocIndex:13},{value:"Align the canvas content center with the viewport center.",paraId:41,tocIndex:13},{value:"Name",paraId:42,tocIndex:13},{value:"Type",paraId:42,tocIndex:13},{value:"Required",paraId:42,tocIndex:13},{value:"Default Value",paraId:42,tocIndex:13},{value:"Description",paraId:42,tocIndex:13},{value:"options.padding",paraId:42,tocIndex:13},{value:"number | Padding",paraId:42,tocIndex:13},{value:"-",paraId:42,tocIndex:13},{value:"Margin, only effective in scroller canvas.",paraId:42,tocIndex:13},{value:"options.useCellGeometry",paraId:42,tocIndex:13},{value:"boolean",paraId:42,tocIndex:13},{value:"true",paraId:42,tocIndex:13},{value:"Whether to use node/edge geometry information (Model) to calculate the content area.",paraId:42,tocIndex:13},{value:"graph.centerContent()\ngraph.centerContent({ padding: { left: 100 } })\n",paraId:43,tocIndex:13},{value:"centerCell(options?: CenterOptions): this\n",paraId:44,tocIndex:14},{value:"Align the node/edge center with the viewport center.",paraId:45,tocIndex:14},{value:"Name",paraId:46,tocIndex:14},{value:"Type",paraId:46,tocIndex:14},{value:"Required",paraId:46,tocIndex:14},{value:"Default Value",paraId:46,tocIndex:14},{value:"Description",paraId:46,tocIndex:14},{value:"cell",paraId:46,tocIndex:14},{value:"Cell",paraId:46,tocIndex:14},{value:"",paraId:46,tocIndex:14},{value:"Node/edge.",paraId:46,tocIndex:14},{value:"options.padding",paraId:46,tocIndex:14},{value:"number | Padding",paraId:46,tocIndex:14},{value:"-",paraId:46,tocIndex:14},{value:"Margin, only effective in scroller canvas.",paraId:46,tocIndex:14},{value:"graph.centerCell(cell)\ngraph.centerCell(cell, { padding: { left: 100 } })\n",paraId:47,tocIndex:14},{value:"positionContent(pos: Position, options?: PositionContentOptions): this\n",paraId:48,tocIndex:15},{value:"Align the canvas content bounding box position with the corresponding viewport position. For example, if ",paraId:49,tocIndex:15},{value:"pos",paraId:49,tocIndex:15},{value:" is ",paraId:49,tocIndex:15},{value:"'bottom-left'",paraId:49,tocIndex:15},{value:", it means aligning the bottom-left corner of the content bounding box with the bottom-left corner of the viewport.",paraId:49,tocIndex:15},{value:"Name",paraId:50,tocIndex:15},{value:"Type",paraId:50,tocIndex:15},{value:"Required",paraId:50,tocIndex:15},{value:"Default Value",paraId:50,tocIndex:15},{value:"Description",paraId:50,tocIndex:15},{value:"pos",paraId:50,tocIndex:15},{value:"Position",paraId:50,tocIndex:15},{value:"",paraId:50,tocIndex:15},{value:"Alignment position.",paraId:50,tocIndex:15},{value:"options.padding",paraId:50,tocIndex:15},{value:"number | Padding",paraId:50,tocIndex:15},{value:"-",paraId:50,tocIndex:15},{value:"Margin, only effective in scroller canvas.",paraId:50,tocIndex:15},{value:"options.useCellGeometry",paraId:50,tocIndex:15},{value:"boolean",paraId:50,tocIndex:15},{value:"true",paraId:50,tocIndex:15},{value:"Whether to use node/edge geometry information (Model) to calculate the content area.",paraId:50,tocIndex:15},{value:"Supported alignment positions:",paraId:51,tocIndex:15},{value:"type Position =\n  | 'center'\n  | 'top'\n  | 'top-right'\n  | 'top-left'\n  | 'right'\n  | 'bottom-right'\n  | 'bottom'\n  | 'bottom-left'\n  | 'left'\n",paraId:52,tocIndex:15},{value:"positionCell(cell: Cell, pos: Direction, options?: CenterOptions): this\n",paraId:53,tocIndex:16},{value:"Align the node/edge bounding box position with the corresponding viewport position. For example, if ",paraId:54,tocIndex:16},{value:"pos",paraId:54,tocIndex:16},{value:" is ",paraId:54,tocIndex:16},{value:"'bottom-left'",paraId:54,tocIndex:16},{value:", it means aligning the bottom-left corner of the node/edge bounding box with the bottom-left corner of the viewport.",paraId:54,tocIndex:16},{value:"Name",paraId:55,tocIndex:16},{value:"Type",paraId:55,tocIndex:16},{value:"Required",paraId:55,tocIndex:16},{value:"Default Value",paraId:55,tocIndex:16},{value:"Description",paraId:55,tocIndex:16},{value:"cell",paraId:55,tocIndex:16},{value:"Cell",paraId:55,tocIndex:16},{value:"",paraId:55,tocIndex:16},{value:"Node/edge.",paraId:55,tocIndex:16},{value:"pos",paraId:55,tocIndex:16},{value:"Position",paraId:55,tocIndex:16},{value:"",paraId:55,tocIndex:16},{value:"Alignment position.",paraId:55,tocIndex:16},{value:"options.padding",paraId:55,tocIndex:16},{value:"number | Padding",paraId:55,tocIndex:16},{value:"-",paraId:55,tocIndex:16},{value:"Margin, only effective in scroller canvas.",paraId:55,tocIndex:16},{value:"type Position =\n  | 'center'\n  | 'top'\n  | 'top-right'\n  | 'top-left'\n  | 'right'\n  | 'bottom-right'\n  | 'bottom'\n  | 'bottom-left'\n  | 'left'\n",paraId:56,tocIndex:16},{value:"positionRect(rect: Rectangle.RectangleLike, pos: Direction, options?: CenterOptions): this\n",paraId:57,tocIndex:17},{value:"Align the rectangle position with the corresponding viewport position. For example, if ",paraId:58,tocIndex:17},{value:"pos",paraId:58,tocIndex:17},{value:" is ",paraId:58,tocIndex:17},{value:"'bottom-left'",paraId:58,tocIndex:17},{value:", it means aligning the bottom-left corner of the rectangle with the bottom-left corner of the viewport.",paraId:58,tocIndex:17},{value:"Name",paraId:59,tocIndex:17},{value:"Type",paraId:59,tocIndex:17},{value:"Required",paraId:59,tocIndex:17},{value:"Default Value",paraId:59,tocIndex:17},{value:"Description",paraId:59,tocIndex:17},{value:"rect",paraId:59,tocIndex:17},{value:"Rectangle.RectangleLike",paraId:59,tocIndex:17},{value:"",paraId:59,tocIndex:17},{value:"Rectangle area.",paraId:59,tocIndex:17},{value:"pos",paraId:59,tocIndex:17},{value:"Position",paraId:59,tocIndex:17},{value:"",paraId:59,tocIndex:17},{value:"Alignment position.",paraId:59,tocIndex:17},{value:"options.padding",paraId:59,tocIndex:17},{value:"number | Padding",paraId:59,tocIndex:17},{value:"-",paraId:59,tocIndex:17},{value:"Margin, only effective in scroller canvas.",paraId:59,tocIndex:17},{value:"type Position =\n  | 'center'\n  | 'top'\n  | 'top-right'\n  | 'top-left'\n  | 'right'\n  | 'bottom-right'\n  | 'bottom'\n  | 'bottom-left'\n  | 'left'\n",paraId:60,tocIndex:17},{value:"positionPoint(point: Point.PointLike, x: number | string, y: number | string, options?: CenterOptions): this\n",paraId:61,tocIndex:18},{value:"Align the point ",paraId:62,tocIndex:18},{value:"(x, y)",paraId:62,tocIndex:18},{value:" (relative to the canvas) with the corresponding viewport position.",paraId:62,tocIndex:18},{value:"Name",paraId:63,tocIndex:18},{value:"Type",paraId:63,tocIndex:18},{value:"Required",paraId:63,tocIndex:18},{value:"Default Value",paraId:63,tocIndex:18},{value:"Description",paraId:63,tocIndex:18},{value:"point",paraId:63,tocIndex:18},{value:"Point.PointLike",paraId:63,tocIndex:18},{value:"",paraId:63,tocIndex:18},{value:"Point to be aligned.",paraId:63,tocIndex:18},{value:"x",paraId:63,tocIndex:18},{value:"number | string",paraId:63,tocIndex:18},{value:"",paraId:63,tocIndex:18},{value:"Viewport x-coordinate, supports percentage and negative values.",paraId:63,tocIndex:18},{value:"y",paraId:63,tocIndex:18},{value:"number | string",paraId:63,tocIndex:18},{value:"",paraId:63,tocIndex:18},{value:"Viewport y-coordinate, supports percentage and negative values.",paraId:63,tocIndex:18},{value:"options.padding",paraId:63,tocIndex:18},{value:"number | Padding",paraId:63,tocIndex:18},{value:"-",paraId:63,tocIndex:18},{value:"Margin, only effective in scroller canvas.",paraId:63,tocIndex:18},{value:"// Align the top-left corner of the canvas with the point [100, 50] in the viewport\ngraph.positionPoint({ x: 0, y: 0 }, 100, 50)\n\n// Align the point { x: 30, y: 80 } on the canvas with the point 25% from the left and 40px from the bottom of the viewport\ngraph.positionPoint({ x: 30, y: 80 }, '25%', -40)\n\n// Align the point { x: 30, y: 80 } on the canvas with the point 25% from the right and 40px from the top of the viewport\ngraph.positionPoint({ x: 30, y: 80 }, '-25%', 40)\n",paraId:64,tocIndex:18}]},46828:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(9230);const n=[{value:"For native SVG attributes, there are many tutorials available online, such as the ",paraId:0},{value:"SVG Attribute Reference",paraId:0},{value:" provided by MDN. Here, we will focus more on how to define and use special attributes. Special attributes provide more flexible and powerful functionality than native SVG attributes. When applying attributes, native attributes are directly passed to the corresponding element, while special attributes are further processed and converted into native attributes recognized by the browser before being passed to the corresponding element.",paraId:0},{value:"When customizing nodes or edges, setting the relative size of elements is a very common requirement. We provide a series of special attributes prefixed with ",paraId:1,tocIndex:0},{value:"ref",paraId:1,tocIndex:0},{value:" in X6, which can be used to set the relative size of elements. These attributes are calculated based on the data size of nodes/edges, which means that all calculations do not rely on the browser's bbox calculation, so there are no performance issues.",paraId:1,tocIndex:0},{value:"refWidth",paraId:2,tocIndex:0},{value:" and ",paraId:3,tocIndex:0},{value:"refHeight",paraId:4,tocIndex:0},{value:" set the element size.",paraId:3,tocIndex:0},{value:"refX",paraId:5,tocIndex:0},{value:" and ",paraId:3,tocIndex:0},{value:"refY",paraId:6,tocIndex:0},{value:" set the element position.",paraId:3,tocIndex:0},{value:"refCx",paraId:7,tocIndex:0},{value:" and ",paraId:3,tocIndex:0},{value:"refCy",paraId:8,tocIndex:0},{value:" set the center position of ",paraId:3,tocIndex:0},{value:"<ellipse>",paraId:3,tocIndex:0},{value:" and ",paraId:3,tocIndex:0},{value:"<circle>",paraId:3,tocIndex:0},{value:".",paraId:3,tocIndex:0},{value:"refRx",paraId:9,tocIndex:0},{value:" and ",paraId:3,tocIndex:0},{value:"refRy",paraId:10,tocIndex:0},{value:" set the radius of ",paraId:3,tocIndex:0},{value:"<ellipse>",paraId:3,tocIndex:0},{value:".",paraId:3,tocIndex:0},{value:"refR",paraId:11,tocIndex:0},{value:" sets the radius of ",paraId:3,tocIndex:0},{value:"<circle>",paraId:3,tocIndex:0},{value:".",paraId:3,tocIndex:0},{value:"Let's take a look at how to use these relative attributes. In the following example, we define a red ellipse ",paraId:12,tocIndex:0},{value:"e",paraId:12,tocIndex:0},{value:", a green rectangle ",paraId:12,tocIndex:0},{value:"r",paraId:12,tocIndex:0},{value:", a blue circle ",paraId:12,tocIndex:0},{value:"c",paraId:12,tocIndex:0},{value:", and a rectangle ",paraId:12,tocIndex:0},{value:"outline",paraId:12,tocIndex:0},{value:" that represents the node size.",paraId:12,tocIndex:0},{value:"graph.addNode({\n  shape: 'custom-rect',\n  x: 160,\n  y: 100,\n  width: 280,\n  height: 120,\n  attrs: {\n    e: {\n      refRx: '50%', // ellipse x-axis radius is half of the width\n      refRy: '25%', // ellipse y-axis radius is a quarter of the height\n      refCx: '50%', // ellipse center x-coordinate is half of the width\n      refCy: 0, // ellipse center y-coordinate is 0\n      refX: '-50%', // offset to the left by half of the width\n      refY: '25%', // offset down by a quarter of the height\n    },\n    r: {\n      refX: '100%', // rectangle x-coordinate is at the right bottom corner of the node\n      refY: '100%', // rectangle y-coordinate is at the right bottom corner of the node\n      refWidth: '50%', // rectangle width is half of the node width\n      refHeight: '50%', // rectangle height is half of the node height\n      x: -10, // offset to the left by 10px\n      y: -10, // offset up by 10px\n    },\n    c: {\n      refRCircumscribed: '50%', // circle radius is half of the larger value of node width and height\n      refCx: '50%', // circle center x-coordinate is at the node center\n      refCy: '50%', // circle center y-coordinate is at the node center\n    },\n  },\n})\n",paraId:13,tocIndex:0},{value:"The above attributes are calculated relative to the node size by default. We can also use the ",paraId:14,tocIndex:1},{value:"ref",paraId:14,tocIndex:1},{value:" attribute to provide a sub-element selector, so that all calculations are relative to the element referred to by ",paraId:14,tocIndex:1},{value:"ref",paraId:14,tocIndex:1},{value:", achieving relative size and position to sub-elements.",paraId:14,tocIndex:1},{value:"::: warning\nNote that setting ",paraId:15,tocIndex:1},{value:"ref",paraId:15,tocIndex:1},{value:" will make all calculations dependent on the sub-element's bbox measurement in the browser, which may affect performance.\n:::",paraId:15,tocIndex:1},{value:"graph.addNode({\n  shape: 'custom-text',\n  x: 320,\n  y: 160,\n  width: 280,\n  height: 120,\n  attrs: {\n    label: {\n      text: 'H',\n    },\n    e: {\n      ref: 'label',\n      refRx: '50%',\n      refRy: '25%',\n      refCx: '50%',\n      refCy: 0,\n      refX: '-50%',\n      refY: '25%',\n    },\n    r: {\n      ref: 'label',\n      refX: '100%',\n      refY: '100%',\n      x: -10,\n      y: -10,\n      refWidth: '50%',\n      refHeight: '50%',\n    },\n    c: {\n      ref: 'label',\n      refRCircumscribed: '50%',\n    },\n  },\n})\n",paraId:16,tocIndex:1},{value:"We provide the following attributes to set the position of edges and sub-elements relative to the edge.",paraId:17,tocIndex:2},{value:"connection",paraId:18,tocIndex:2},{value:" is only applicable to ",paraId:19,tocIndex:2},{value:"<path>",paraId:19,tocIndex:2},{value:" elements of edges, indicating that the edge will be rendered on this element when set to ",paraId:19,tocIndex:2},{value:"true",paraId:19,tocIndex:2},{value:".",paraId:19,tocIndex:2},{value:"atConnectionLength",paraId:20,tocIndex:2},{value:" is an abbreviation of ",paraId:19,tocIndex:2},{value:"atConnectionLengthKeepGradient",paraId:19,tocIndex:2},{value:", indicating that the element will be moved to the specified offset position and automatically rotated to match the slope of the edge at that position.",paraId:19,tocIndex:2},{value:"atConnectionRatio",paraId:21,tocIndex:2},{value:" is an abbreviation of ",paraId:19,tocIndex:2},{value:"atConnectionRatioKeepGradient",paraId:19,tocIndex:2},{value:", indicating that the element will be moved to the specified ratio ",paraId:19,tocIndex:2},{value:"[0, 1]",paraId:19,tocIndex:2},{value:" position and automatically rotated to match the slope of the edge at that position.",paraId:19,tocIndex:2},{value:"atConnectionLengthIgnoreGradient",paraId:22,tocIndex:2},{value:" will move the element to the specified offset position, ignoring the edge's slope, without automatic rotation.",paraId:19,tocIndex:2},{value:"atConnectionRatioIgnoreGradient",paraId:23,tocIndex:2},{value:" will move the element to the specified ratio ",paraId:19,tocIndex:2},{value:"[0, 1]",paraId:19,tocIndex:2},{value:" position, ignoring the edge's slope, without automatic rotation.",paraId:19,tocIndex:2},{value:"graph.addEdge({\n  shape: 'custom-edge',\n  source: { x: 100, y: 60 },\n  target: { x: 500, y: 60 },\n  vertices: [{ x: 300, y: 160 }],\n  attrs: {\n    symbol: {\n      atConnectionRatio: 0.75, // along the edge, 75% from the start point\n    },\n    arrowhead: {\n      atConnectionLength: 100, // along the edge, 100px from the start point\n    },\n  },\n})\n",paraId:24,tocIndex:2},{value:"graph.addEdge({\n  shape: 'custom-edge',\n  source: { x: 100, y: 60 },\n  target: { x: 500, y: 60 },\n  vertices: [{ x: 300, y: 160 }],\n  attrs: {\n    relativeLabel: {\n      text: '0.25',\n      atConnectionRatio: 0.25,\n    },\n    relativeLabelBody: {\n      atConnectionRatio: 0.25,\n    },\n\n    absoluteLabel: {\n      text: '150',\n      atConnectionLength: 150,\n    },\n    absoluteLabelBody: {\n      atConnectionLength: 150,\n    },\n\n    absoluteReverseLabel: {\n      text: '-100',\n      atConnectionLength: -100,\n    },\n    absoluteReverseLabelBody: {\n      atConnectionLength: -100,\n    },\n\n    offsetLabelPositive: {\n      y: 40,\n      text: 'keepGradient: 0,40',\n      atConnectionRatio: 0.66,\n    },\n    offsetLabelPositiveBody: {\n      x: -60, // 0 + -60\n      y: 30, // 40 + -10\n      atConnectionRatio: 0.66,\n    },\n\n    offsetLabelNegative: {\n      y: -40,\n      text: 'keepGradient: 0,-40',\n      atConnectionRatio: 0.66,\n    },\n    offsetLabelNegativeBody: {\n      x: -60, // 0 + -60\n      y: -50, // -40 + -10\n      atConnectionRatio: 0.66,\n    },\n\n    offsetLabelAbsolute: {\n      x: -40,\n      y: 80,\n      text: 'ignoreGradient: -40,80',\n      atConnectionRatioIgnoreGradient: 0.66,\n    },\n    offsetLabelAbsoluteBody: {\n      x: -110, // -40 + -70\n      y: 70, // 80 + -10\n      atConnectionRatioIgnoreGradient: 0.66,\n    },\n  },\n})\n",paraId:25,tocIndex:2},{value:"We can use the ",paraId:26,tocIndex:3},{value:"sourceMarker",paraId:26,tocIndex:3},{value:" and ",paraId:26,tocIndex:3},{value:"targetMarker",paraId:26,tocIndex:3},{value:" special attributes to specify the start and end arrowheads of edges, respectively. For more information, please refer to ",paraId:26,tocIndex:3},{value:"this tutorial",paraId:27,tocIndex:3},{value:".",paraId:26,tocIndex:3}]},39799:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(89508);const n=[{value:"Cell is the base class for ",paraId:0},{value:"Node",paraId:1},{value:" and ",paraId:0},{value:"Edge",paraId:2},{value:", containing common property and method definitions for nodes and edges, such as attribute styles, visibility, business data, etc. It also exhibits the same behavior in terms of instantiation, style customization, default options, and custom options.",paraId:0},{value:"Option",paraId:3,tocIndex:0},{value:"Type",paraId:3,tocIndex:0},{value:"Default",paraId:3,tocIndex:0},{value:"Required",paraId:3,tocIndex:0},{value:"Description",paraId:3,tocIndex:0},{value:"id",paraId:3,tocIndex:0},{value:"string",paraId:3,tocIndex:0},{value:"Unique identifier for the node/edge. It's recommended to use an ID with business meaning. By default, a UUID is automatically generated.",paraId:3,tocIndex:0},{value:"markup",paraId:3,tocIndex:0},{value:"Markup",paraId:3,tocIndex:0},{value:"SVG/HTML fragment for the node/edge.",paraId:3,tocIndex:0},{value:"attrs",paraId:3,tocIndex:0},{value:"Attr.CellAttrs",paraId:3,tocIndex:0},{value:"Attribute styles for the node/edge.",paraId:3,tocIndex:0},{value:"shape",paraId:3,tocIndex:0},{value:"string",paraId:3,tocIndex:0},{value:"Shape used to render the node/edge. Default value for nodes is ",paraId:3,tocIndex:0},{value:"rect",paraId:3,tocIndex:0},{value:", for edges is ",paraId:3,tocIndex:0},{value:"edge",paraId:3,tocIndex:0},{value:".",paraId:3,tocIndex:0},{value:"view",paraId:3,tocIndex:0},{value:"string",paraId:3,tocIndex:0},{value:"View used to render the node/edge.",paraId:3,tocIndex:0},{value:"zIndex",paraId:3,tocIndex:0},{value:"number",paraId:3,tocIndex:0},{value:"Layer level of the node/edge in the canvas. By default, it's automatically determined based on the order of node/edge addition.",paraId:3,tocIndex:0},{value:"visible",paraId:3,tocIndex:0},{value:"boolean",paraId:3,tocIndex:0},{value:"true",paraId:3,tocIndex:0},{value:"Whether the node/edge is visible.",paraId:3,tocIndex:0},{value:"parent",paraId:3,tocIndex:0},{value:"string",paraId:3,tocIndex:0},{value:"Parent node.",paraId:3,tocIndex:0},{value:"children",paraId:3,tocIndex:0},{value:"string[]",paraId:3,tocIndex:0},{value:"Child nodes/edges.",paraId:3,tocIndex:0},{value:"tools",paraId:3,tocIndex:0},{value:"ToolItem | ToolItem[] | Tools",paraId:3,tocIndex:0},{value:"Tool options.",paraId:3,tocIndex:0},{value:"data",paraId:3,tocIndex:0},{value:"any",paraId:3,tocIndex:0},{value:"Business data associated with the node/edge.",paraId:3,tocIndex:0},{value:"id",paraId:4,tocIndex:1},{value:" is the unique identifier for the node/edge. It's recommended to use an ID with business meaning. By default, a UUID is automatically generated.",paraId:4,tocIndex:1},{value:"markup",paraId:5,tocIndex:2},{value:" specifies the SVG/HTML fragment used to render the node/edge, described in JSON format. For example, the ",paraId:5,tocIndex:2},{value:"markup",paraId:5,tocIndex:2},{value:" definition for the built-in node ",paraId:5,tocIndex:2},{value:"Shape.Rect",paraId:5,tocIndex:2},{value:" is as follows:",paraId:5,tocIndex:2},{value:"{\n  markup: [\n    {\n      tagName: 'rect',\n      selector: 'body',\n    },\n    {\n      tagName: 'text',\n      selector: 'label',\n    },\n  ],\n}\n",paraId:6,tocIndex:2},{value:"This indicates that the node internally contains two SVG elements: ",paraId:7,tocIndex:2},{value:"<rect>",paraId:7,tocIndex:2},{value:" and ",paraId:7,tocIndex:2},{value:"<text>",paraId:7,tocIndex:2},{value:". After rendering to the page, the SVG element corresponding to the node looks like this:",paraId:7,tocIndex:2},{value:'<g\n  data-cell-id="c2e1dd06-15c6-43a4-987a-712a664b8f85"\n  class="x6-cell x6-node"\n  transform="translate(40,40)"\n>\n  <rect\n    fill="#fff"\n    stroke="#000"\n    stroke-width="2"\n    fill-opacity="0.5"\n    width="100"\n    height="40"\n  ></rect>\n  <text\n    font-size="14"\n    xml:space="preserve"\n    fill="#333"\n    text-anchor="middle"\n    font-family="Arial, helvetica, sans-serif"\n    transform="matrix(1,0,0,1,50,20)"\n  >\n    <tspan dy="0.3em" class="v-line">rect</tspan>\n  </text>\n</g>\n',paraId:8,tocIndex:2},{value:"From the above introduction, we have a general understanding of the ",paraId:9,tocIndex:2},{value:"Markup",paraId:9,tocIndex:2},{value:" structure. Now, let's detail the ",paraId:9,tocIndex:2},{value:"Markup",paraId:9,tocIndex:2},{value:" definition.",paraId:9,tocIndex:2},{value:"interface Markup {\n  tagName: string\n  ns?: string\n  selector?: string\n  groupSelector?: string | string[]\n  attrs?: { [key: string]: string | number }\n  style?: { [key: string]: string | number }\n  className?: string | string[]\n  textContent?: string\n  children?: Markup[]\n}\n",paraId:10,tocIndex:2},{value:"Option",paraId:11,tocIndex:2},{value:"Type",paraId:11,tocIndex:2},{value:"Default",paraId:11,tocIndex:2},{value:"Required",paraId:11,tocIndex:2},{value:"Description",paraId:11,tocIndex:2},{value:"tagName",paraId:11,tocIndex:2},{value:"string",paraId:11,tocIndex:2},{value:"",paraId:11,tocIndex:2},{value:"SVG/HTML element tag name.",paraId:11,tocIndex:2},{value:"ns",paraId:11,tocIndex:2},{value:"string",paraId:11,tocIndex:2},{value:'"http://www.w3.org/2000/svg"',paraId:11,tocIndex:2},{value:"SVG/HTML element namespace.",paraId:11,tocIndex:2},{value:"selector",paraId:11,tocIndex:2},{value:"string",paraId:11,tocIndex:2},{value:"-",paraId:11,tocIndex:2},{value:"Unique selector for the element, used to locate the element or specify attribute styles for it.",paraId:11,tocIndex:2},{value:"groupSelector",paraId:11,tocIndex:2},{value:"string",paraId:11,tocIndex:2},{value:"-",paraId:11,tocIndex:2},{value:"Group selector for the element, can be used to specify styles for multiple elements in the group simultaneously.",paraId:11,tocIndex:2},{value:"attrs",paraId:11,tocIndex:2},{value:"Attr.SimpleAttrs",paraId:11,tocIndex:2},{value:"-",paraId:11,tocIndex:2},{value:"Default attribute key-value pairs for the element.",paraId:11,tocIndex:2},{value:"style",paraId:11,tocIndex:2},{value:"KeyValue",paraId:11,tocIndex:2},{value:"-",paraId:11,tocIndex:2},{value:"Inline style key-value pairs for the element.",paraId:11,tocIndex:2},{value:"className",paraId:11,tocIndex:2},{value:"string",paraId:11,tocIndex:2},{value:"-",paraId:11,tocIndex:2},{value:"CSS class name for the element.",paraId:11,tocIndex:2},{value:"textContent",paraId:11,tocIndex:2},{value:"string",paraId:11,tocIndex:2},{value:"-",paraId:11,tocIndex:2},{value:"Text content of the element.",paraId:11,tocIndex:2},{value:"children",paraId:11,tocIndex:2},{value:"Markup[]",paraId:11,tocIndex:2},{value:"-",paraId:11,tocIndex:2},{value:"Nested child elements.",paraId:11,tocIndex:2},{value:"Specifies which type of SVG/HTML element to create through ",paraId:12,tocIndex:3},{value:"tagName",paraId:12,tocIndex:3},{value:".",paraId:12,tocIndex:3},{value:"The namespace of the element. It should correspond to the element type specified by ",paraId:13,tocIndex:4},{value:"tagName",paraId:13,tocIndex:4},{value:". By default, it uses the SVG element namespace ",paraId:13,tocIndex:4},{value:'"http://www.w3.org/2000/svg"',paraId:13,tocIndex:4},{value:".",paraId:13,tocIndex:4},{value:"SVG element namespace is ",paraId:14,tocIndex:4},{value:'"http://www.w3.org/2000/svg"',paraId:14,tocIndex:4},{value:"HTML element namespace is ",paraId:14,tocIndex:4},{value:'"http://www.w3.org/1999/xhtml"',paraId:14,tocIndex:4},{value:"The unique selector for the element, used to specify ",paraId:15,tocIndex:5},{value:"attribute styles",paraId:15,tocIndex:5},{value:" for the element. For example, to specify attribute styles for ",paraId:15,tocIndex:5},{value:"<rect>",paraId:15,tocIndex:5},{value:" and ",paraId:15,tocIndex:5},{value:"<text>",paraId:15,tocIndex:5},{value:" elements of the built-in node ",paraId:15,tocIndex:5},{value:"Shape.Rect",paraId:15,tocIndex:5},{value:":",paraId:15,tocIndex:5},{value:"const rect = new Shape.Rect({\n  x: 40,\n  y: 40,\n  width: 100,\n  height: 40,\n  attrs: {\n    // Specify styles for the rect element\n    body: {\n      stroke: '#000', // Border color\n      fill: '#fff', // Fill color\n    },\n    // Specify styles for the text element\n    label: {\n      text: 'rect', // Text content\n      fill: '#333', // Text color\n    },\n  },\n})\n",paraId:16,tocIndex:5},{value:"The group selector for the element. Through the group selector, styles can be specified for multiple elements associated with the group. For example, in the following Markup, two ",paraId:17,tocIndex:6},{value:"<rect>",paraId:17,tocIndex:6},{value:" elements have the same ",paraId:17,tocIndex:6},{value:"groupSelector",paraId:17,tocIndex:6},{value:" value ",paraId:17,tocIndex:6},{value:"group1",paraId:17,tocIndex:6},{value:":",paraId:17,tocIndex:6},{value:"{\n  markup: [\n    {\n      tagName: 'rect',\n      selector: 'body',\n      groupSelector: 'group1',\n    },\n    {\n      tagName: 'rect',\n      selector: 'wrap',\n      groupSelector: 'group1',\n    },\n    {\n      tagName: 'text',\n      selector: 'label',\n    },\n  ],\n}\n",paraId:18,tocIndex:6},{value:"When creating a node, we can specify group styles like this:",paraId:19,tocIndex:6},{value:"new SomeNode({\n  attrs: {\n    group1: {\n      fill: '#2ECC71',\n    },\n  },\n})\n",paraId:20,tocIndex:6},{value:"Default attribute key-value pairs for the element, typically used to define unchanging common attributes. These default attributes can also be overridden when instantiating the node. Note that the ",paraId:21,tocIndex:7},{value:"attrs",paraId:21,tocIndex:7},{value:" property in ",paraId:21,tocIndex:7},{value:"markup",paraId:21,tocIndex:7},{value:" only supports native SVG attributes, meaning X6's ",paraId:21,tocIndex:7},{value:"custom attributes",paraId:22,tocIndex:7},{value:" are not available here.",paraId:21,tocIndex:7},{value:"For example, we specified the following default attributes for the ",paraId:23,tocIndex:7},{value:"<rect>",paraId:23,tocIndex:7},{value:" and ",paraId:23,tocIndex:7},{value:"<text>",paraId:23,tocIndex:7},{value:" elements of the built-in node ",paraId:23,tocIndex:7},{value:"Shape.Rect",paraId:23,tocIndex:7},{value:":",paraId:23,tocIndex:7},{value:"{\n  markup: [\n    {\n      tagName: 'rect',\n      selector: 'body',\n      attrs: {\n        fill: '#fff',\n        stroke: '#000',\n        strokeWidth: 2,\n      }\n    },\n    {\n      tagName: 'text',\n      selector: 'label',\n      attrs: {\n        fill: '#333',\n        textAnchor: 'middle',\n        textVerticalAnchor: 'middle',\n      }\n    },\n  ],\n}\n",paraId:24,tocIndex:7},{value:"Inline style key-value pairs for the element.",paraId:25,tocIndex:8},{value:"CSS class name for the element.",paraId:26,tocIndex:9},{value:"Text content of the element.",paraId:27,tocIndex:10},{value:"Nested child elements.",paraId:28,tocIndex:11},{value:"The attribute option ",paraId:29,tocIndex:12},{value:"attrs",paraId:29,tocIndex:12},{value:" is a complex object. The keys of this object are the selectors (",paraId:29,tocIndex:12},{value:"selector",paraId:30,tocIndex:12},{value:") of elements defined in the node's Markup, and the corresponding values are ",paraId:29,tocIndex:12},{value:"SVG attribute values",paraId:29,tocIndex:12},{value:" (such as ",paraId:29,tocIndex:12},{value:"fill",paraId:29,tocIndex:12},{value:" and ",paraId:29,tocIndex:12},{value:"stroke",paraId:29,tocIndex:12},{value:") applied to that SVG element. If you're not familiar with SVG attributes yet, you can refer to the beginner's tutorial on ",paraId:29,tocIndex:12},{value:"Fills and Strokes",paraId:29,tocIndex:12},{value:" provided by MDN.",paraId:29,tocIndex:12},{value:"For example, the Markup of the built-in node ",paraId:31,tocIndex:12},{value:"Shape.Rect",paraId:31,tocIndex:12},{value:" defines two selectors: ",paraId:31,tocIndex:12},{value:"body",paraId:31,tocIndex:12},{value:" (representing the ",paraId:31,tocIndex:12},{value:"<rect>",paraId:31,tocIndex:12},{value:" element) and ",paraId:31,tocIndex:12},{value:"label",paraId:31,tocIndex:12},{value:" (representing the ",paraId:31,tocIndex:12},{value:"<text>",paraId:31,tocIndex:12},{value:" element). We can specify attribute styles for elements in this node like this:",paraId:31,tocIndex:12},{value:"const rect = new Shape.Rect({\n  x: 40,\n  y: 40,\n  width: 100,\n  height: 40,\n  attrs: {\n    body: {\n      fill: '#2ECC71',\n      stroke: '#000',\n    },\n    label: {\n      text: 'rect',\n      fill: '#333',\n      fontSize: 13,\n    },\n  },\n})\n",paraId:32,tocIndex:12},{value:"After the node is rendered to the canvas, the DOM structure looks like this:",paraId:33,tocIndex:12},{value:'<g\n  data-cell-id="3ee1452c-6d75-478d-af22-88e03c6d513b"\n  class="x6-cell x6-node"\n  transform="translate(40,40)"\n>\n  <rect\n      fill="#2ECC71"\n      stroke="#000"\n      stroke-width="2"\n      width="100"\n      height="40"\n  ></rect>\n  <text\n      font-size="13"\n      xml:space="preserve"\n      fill="#333"\n      text-anchor="middle"\n      font-family="Arial, helvetica, sans-serif"\n      transform="matrix(1,0,0,1,50,20)"\n  >\n    <tspan dy="0.3em" class="v-line"> rect </tspan>\n  </text>\n</g>\n',paraId:34,tocIndex:12},{value:"Additionally, we can use CSS selectors to specify node styles, so we don't have to remember predefined selector names. We can simply define styles based on the rendered DOM structure. When using CSS selectors, it's important to note that the specified CSS selector may match multiple elements, in which case the corresponding attribute styles will be applied to multiple elements simultaneously.",paraId:35,tocIndex:12},{value:"const rect = new Shape.Rect({\n  x: 40,\n  y: 40,\n  width: 100,\n  height: 40,\n  attrs: {\n    rect: {\n      // Use the 'rect' CSS selector instead of the predefined 'body' selector\n      fill: '#2ECC71',\n      stroke: '#000',\n    },\n    text: {\n      // Use the 'text' CSS selector instead of the predefined 'label' selector\n      text: 'rect',\n      fill: '#333',\n      fontSize: 13,\n    },\n  },\n})\n",paraId:36,tocIndex:12},{value:"It's worth mentioning that camelCase format for property names is supported, such as ",paraId:37,tocIndex:12},{value:"fontSize",paraId:37,tocIndex:12},{value:". This avoids the hassle of having to add quotes to property names like ",paraId:37,tocIndex:12},{value:"font-size",paraId:37,tocIndex:12},{value:" when used as object keys.",paraId:37,tocIndex:12},{value:"In addition to standard SVG attributes, we have defined a series of special attributes in X6. For details, please refer to ",paraId:38,tocIndex:12},{value:"Special Attributes",paraId:39,tocIndex:12},{value:" and ",paraId:38,tocIndex:12},{value:"Custom Attributes",paraId:40,tocIndex:12},{value:". Furthermore, we can use CSS to customize styles. Nodes and edges rendered on the canvas have the class names ",paraId:38,tocIndex:12},{value:"x6-node",paraId:38,tocIndex:12},{value:" and ",paraId:38,tocIndex:12},{value:"x6-edge",paraId:38,tocIndex:12},{value:" respectively. The default style definitions can be ",paraId:38,tocIndex:12},{value:"referenced here",paraId:38,tocIndex:12},{value:". For example, we can specify the style of the ",paraId:38,tocIndex:12},{value:"<rect>",paraId:38,tocIndex:12},{value:" element in nodes like this:",paraId:38,tocIndex:12},{value:".x6-node rect {\n  fill: #2ecc71;\n  stroke: #000;\n}\n",paraId:41,tocIndex:12},{value:"After creating nodes/edges, we can call the ",paraId:42,tocIndex:12},{value:"attr()",paraId:42,tocIndex:12},{value:" method on the instance to modify node attribute styles. In the code below, the path separated by ",paraId:42,tocIndex:12},{value:"/",paraId:42,tocIndex:12},{value:" modifies the style. The ",paraId:42,tocIndex:12},{value:"label",paraId:42,tocIndex:12},{value:" selector corresponds to the ",paraId:42,tocIndex:12},{value:"<text>",paraId:42,tocIndex:12},{value:" element, ",paraId:42,tocIndex:12},{value:"text",paraId:42,tocIndex:12},{value:" is the attribute name of that element, and ",paraId:42,tocIndex:12},{value:"hello",paraId:42,tocIndex:12},{value:" is the new attribute value.",paraId:42,tocIndex:12},{value:"rect.attr('label/text', 'hello')\n\n// Equivalent to\nrect.attr('label', {\n  text: 'hello',\n})\n\n// Equivalent to\nrect.attr({\n  label: {\n    text: 'hello',\n  },\n})\n",paraId:43,tocIndex:12},{value:"When the attribute value passed in is ",paraId:44,tocIndex:12},{value:"null",paraId:44,tocIndex:12},{value:", that attribute can be removed.",paraId:44,tocIndex:12},{value:"rect.attr('label/text', null)\n",paraId:45,tocIndex:12},{value:"The shape of the node/edge, similar to the Model in the MVC pattern, determines the structured data of the node/edge. This option is typically used when adding nodes and edges with the ",paraId:46,tocIndex:13},{value:"graph.addNode",paraId:46,tocIndex:13},{value:" and ",paraId:46,tocIndex:13},{value:"graph.addEdge",paraId:46,tocIndex:13},{value:" methods.",paraId:46,tocIndex:13},{value:"const rect = graph.addNode({\n  shape: 'rect',\n  x: 100,\n  y: 200,\n  width: 80,\n  height: 40,\n  label: 'rect',\n})\n\nconst circle = graph.addNode({\n  shape: 'circle',\n  x: 280,\n  y: 200,\n  width: 60,\n  height: 60,\n  label: 'circle',\n})\n\nconst edge = graph.addEdge({\n  shape: 'edge',\n  source: rect,\n  target: circle,\n})\n",paraId:47,tocIndex:13},{value:"In X6's internal implementation, we use the shape specified by ",paraId:48,tocIndex:13},{value:"shape",paraId:48,tocIndex:13},{value:" to find the corresponding constructor to initialize the node/edge and add it to the canvas.",paraId:48,tocIndex:13},{value:"The default values for this option are:",paraId:49,tocIndex:13},{value:"The default value of ",paraId:50,tocIndex:13},{value:"shape",paraId:50,tocIndex:13},{value:" in the ",paraId:50,tocIndex:13},{value:"graph.addNode",paraId:50,tocIndex:13},{value:" method is ",paraId:50,tocIndex:13},{value:"rect",paraId:50,tocIndex:13},{value:"The default value of ",paraId:50,tocIndex:13},{value:"shape",paraId:50,tocIndex:13},{value:" in the ",paraId:50,tocIndex:13},{value:"graph.addEdge",paraId:50,tocIndex:13},{value:" method is ",paraId:50,tocIndex:13},{value:"edge",paraId:50,tocIndex:13},{value:"At the same time, we have built-in a series of nodes and edges in X6.",paraId:51,tocIndex:13},{value:"Constructor",paraId:52,tocIndex:13},{value:"shape name",paraId:52,tocIndex:13},{value:"Description",paraId:52,tocIndex:13},{value:"Shape.Rect",paraId:52,tocIndex:13},{value:"rect",paraId:52,tocIndex:13},{value:"Rectangle.",paraId:52,tocIndex:13},{value:"Shape.Circle",paraId:52,tocIndex:13},{value:"circle",paraId:52,tocIndex:13},{value:"Circle.",paraId:52,tocIndex:13},{value:"Shape.Ellipse",paraId:52,tocIndex:13},{value:"ellipse",paraId:52,tocIndex:13},{value:"Ellipse.",paraId:52,tocIndex:13},{value:"Shape.Polygon",paraId:52,tocIndex:13},{value:"polygon",paraId:52,tocIndex:13},{value:"Polygon.",paraId:52,tocIndex:13},{value:"Shape.Polyline",paraId:52,tocIndex:13},{value:"polyline",paraId:52,tocIndex:13},{value:"Polyline.",paraId:52,tocIndex:13},{value:"Shape.Path",paraId:52,tocIndex:13},{value:"path",paraId:52,tocIndex:13},{value:"Path.",paraId:52,tocIndex:13},{value:"Shape.Image",paraId:52,tocIndex:13},{value:"image",paraId:52,tocIndex:13},{value:"Image.",paraId:52,tocIndex:13},{value:"Shape.HTML",paraId:52,tocIndex:13},{value:"html",paraId:52,tocIndex:13},{value:"HTML node, renders HTML fragment using ",paraId:52,tocIndex:13},{value:"foreignObject",paraId:52,tocIndex:13},{value:".",paraId:52,tocIndex:13},{value:"Specifies the view used to render the node/edge. The concept of view is consistent with the View in the MVC pattern. Generally, there's no need to set the view field, as X6's built-in view is used by default.",paraId:53,tocIndex:14},{value:"The layer level of the node/edge in the canvas, automatically determined by the order of node/edge addition by default. After the node/edge is rendered to the canvas, you can use ",paraId:54,tocIndex:15},{value:"cell.getZIndex()",paraId:54,tocIndex:15},{value:" and ",paraId:54,tocIndex:15},{value:"cell.setZIndex(z: number)",paraId:54,tocIndex:15},{value:" to get or set the ",paraId:54,tocIndex:15},{value:"zIndex",paraId:54,tocIndex:15},{value:" value, or call ",paraId:54,tocIndex:15},{value:"cell.toFront()",paraId:54,tocIndex:15},{value:" and ",paraId:54,tocIndex:15},{value:"cell.toBack()",paraId:54,tocIndex:15},{value:" to move it to the top or bottom layer.",paraId:54,tocIndex:15},{value:"Whether the node/edge is visible, visible by default.",paraId:55,tocIndex:16},{value:"Parent node ID.",paraId:56,tocIndex:17},{value:"Array of child node/edge IDs.",paraId:57,tocIndex:18},{value:"Tools for nodes/edges. Tools can enhance the interaction capabilities of nodes/edges. We provide the following built-in tools for nodes and edges respectively:",paraId:58,tocIndex:19},{value:"Nodes",paraId:59,tocIndex:19},{value:"button",paraId:60,tocIndex:19},{value:" Renders a button at the specified position, supports customizing button click interactions.",paraId:61,tocIndex:19},{value:"button-remove",paraId:62,tocIndex:19},{value:" Renders a delete button at the specified position, deletes the corresponding node when clicked.",paraId:61,tocIndex:19},{value:"boundary",paraId:63,tocIndex:19},{value:" Renders a rectangle surrounding the node based on the node's bounding box. Note that this tool only renders a rectangle without any interaction.",paraId:61,tocIndex:19},{value:"node-editor",paraId:64,tocIndex:19},{value:" Provides text editing functionality on the node.",paraId:61,tocIndex:19},{value:"Edges",paraId:65,tocIndex:19},{value:"vertices",paraId:66,tocIndex:19},{value:" Path point tool, renders a small dot at the path point position, drag the dot to modify the path point position, double-click the dot to delete the path point, click on the edge to add a path point.",paraId:67,tocIndex:19},{value:"segments",paraId:68,tocIndex:19},{value:" Segment tool. Renders a toolbar at the center of each edge segment, which can be dragged to adjust the positions of the path points at both ends of the segment.",paraId:67,tocIndex:19},{value:"boundary",paraId:69,tocIndex:19},{value:" Renders a rectangle surrounding the edge based on the edge's bounding box. Note that this tool only renders a rectangle without any interaction.",paraId:67,tocIndex:19},{value:"button",paraId:70,tocIndex:19},{value:" Renders a button at the specified position, supports customizing button click interactions.",paraId:67,tocIndex:19},{value:"button-remove",paraId:71,tocIndex:19},{value:" Renders a delete button at the specified position, deletes the corresponding edge when clicked.",paraId:67,tocIndex:19},{value:"source-arrowhead-and-target-arrowhead",paraId:72,tocIndex:19},{value:" Renders a shape (arrow by default) at the start or end point of the edge, drag the shape to modify the start or end point of the edge.",paraId:67,tocIndex:19},{value:"edge-editor",paraId:73,tocIndex:19},{value:" Provides text editing functionality on the edge.",paraId:67,tocIndex:19},{value:"You can specify a single tool:",paraId:74,tocIndex:19},{value:"graph.addNode({\n  x: 40,\n  y: 40,\n  width: 100,\n  height: 40,\n  tools: 'button-remove', // or { name: 'button-remove' }\n})\n",paraId:75,tocIndex:19},{value:"Also, you can specify the parameter options for the tool like this:",paraId:76,tocIndex:19},{value:"graph.addNode({\n  x: 40,\n  y: 40,\n  width: 100,\n  height: 40,\n  tools: {\n    name: 'button-remove',\n    args: {\n      x: 10, // x coordinate of the button, relative to the top-left corner of the node\n      y: 10, // y coordinate of the button, relative to the top-left corner of the node\n    },\n  },\n})\n",paraId:77,tocIndex:19},{value:"You can also specify multiple tools at the same time:",paraId:78,tocIndex:19},{value:"graph.addNode({\n  x: 40,\n  y: 40,\n  width: 100,\n  height: 40,\n  tools: [\n    'button-remove',\n    {\n      name: 'boundary',\n      args: {\n        padding: 5,\n      },\n    },\n  ],\n})\n",paraId:79,tocIndex:19},{value:"Business data associated with the node/edge. For example, in actual use, we usually store certain business data on the ",paraId:80,tocIndex:20},{value:"data",paraId:80,tocIndex:20},{value:" of the node/edge.",paraId:80,tocIndex:20},{value:"const rect = new Shape.Rect({\n  x: 40,\n  y: 40,\n  width: 100,\n  height: 40,\n  data: {\n    bizID: 125,\n    date: '20200630',\n    price: 89.0,\n  },\n})\n",paraId:81,tocIndex:20},{value:"Get the shape of the node/edge, returns the name of the shape registered to X6.",paraId:82,tocIndex:23},{value:"if (node.shape === 'rect') {\n  // do something if the node is a 'rect' node.\n}\n",paraId:83,tocIndex:23},{value:"Get the view of the node/edge, returns the name of the view registered to X6.",paraId:84,tocIndex:24},{value:"if (node.view === 'rect') {\n  // do something if the node is a 'rect' view.\n}\n",paraId:85,tocIndex:24},{value:"isNode(): boolean\n",paraId:86,tocIndex:25},{value:"Checks if the instance is a ",paraId:87,tocIndex:25},{value:"Node",paraId:88,tocIndex:25},{value:" instance. Returns ",paraId:87,tocIndex:25},{value:"true",paraId:87,tocIndex:25},{value:" if it's a ",paraId:87,tocIndex:25},{value:"Node",paraId:89,tocIndex:25},{value:" instance, otherwise returns ",paraId:87,tocIndex:25},{value:"false",paraId:87,tocIndex:25},{value:". All nodes inheriting from ",paraId:87,tocIndex:25},{value:"Node",paraId:90,tocIndex:25},{value:" return ",paraId:87,tocIndex:25},{value:"true",paraId:87,tocIndex:25},{value:".",paraId:87,tocIndex:25},{value:"if (cell.isNode()) {\n  // do something if the cell is a node.\n}\n",paraId:91,tocIndex:25},{value:"isEdge(): boolean\n",paraId:92,tocIndex:26},{value:"Checks if the instance is an ",paraId:93,tocIndex:26},{value:"Edge",paraId:94,tocIndex:26},{value:" instance. Returns ",paraId:93,tocIndex:26},{value:"true",paraId:93,tocIndex:26},{value:" if it's an ",paraId:93,tocIndex:26},{value:"Edge",paraId:95,tocIndex:26},{value:" instance, otherwise returns ",paraId:93,tocIndex:26},{value:"false",paraId:93,tocIndex:26},{value:". All edges inheriting from ",paraId:93,tocIndex:26},{value:"Edge",paraId:96,tocIndex:26},{value:" return ",paraId:93,tocIndex:26},{value:"true",paraId:93,tocIndex:26},{value:".",paraId:93,tocIndex:26},{value:"if (cell.isEdge()) {\n  // do something if the cell is an edge.\n}\n",paraId:97,tocIndex:26},{value:"toJSON(options?: Cell.ToJSONOptions): Object\n",paraId:98,tocIndex:27},{value:"Converts the structured data of the node/edge to JSON data for persistent storage (usually we call ",paraId:99,tocIndex:27},{value:"graph.toJSON",paraId:99,tocIndex:27},{value:" to export the data of the entire canvas).",paraId:99,tocIndex:27},{value:"Option",paraId:100,tocIndex:27},{value:"Type",paraId:100,tocIndex:27},{value:"Default",paraId:100,tocIndex:27},{value:"Required",paraId:100,tocIndex:27},{value:"Description",paraId:100,tocIndex:27},{value:"options.diff",paraId:100,tocIndex:27},{value:"boolean",paraId:100,tocIndex:27},{value:"false",paraId:100,tocIndex:27},{value:"Whether to return data that differs from the default values (still exports data for the entire canvas).",paraId:100,tocIndex:27},{value:"When ",paraId:101,tocIndex:27},{value:"options.diff",paraId:101,tocIndex:27},{value:" is ",paraId:101,tocIndex:27},{value:"false",paraId:101,tocIndex:27},{value:", returns complete data.",paraId:101,tocIndex:27},{value:"When ",paraId:101,tocIndex:27},{value:"options.diff",paraId:101,tocIndex:27},{value:" is ",paraId:101,tocIndex:27},{value:"true",paraId:101,tocIndex:27},{value:", returns differential data (removes default values of properties).",paraId:101,tocIndex:27},{value:"clone(options?: Cell.CloneOptions): Cell | Node | Edge | { [id:string]: Node | Edge }\n",paraId:102,tocIndex:28},{value:"Clone the node/edge.",paraId:103,tocIndex:28},{value:"Option",paraId:104,tocIndex:28},{value:"Type",paraId:104,tocIndex:28},{value:"Default",paraId:104,tocIndex:28},{value:"Required",paraId:104,tocIndex:28},{value:"Description",paraId:104,tocIndex:28},{value:"options.deep",paraId:104,tocIndex:28},{value:"boolean",paraId:104,tocIndex:28},{value:"false",paraId:104,tocIndex:28},{value:"Whether to clone descendant nodes and edges, default is ",paraId:104,tocIndex:28},{value:"false",paraId:104,tocIndex:28},{value:" which means only cloning itself.",paraId:104,tocIndex:28},{value:"When ",paraId:105,tocIndex:28},{value:"options.deep",paraId:105,tocIndex:28},{value:" is ",paraId:105,tocIndex:28},{value:"false",paraId:105,tocIndex:28},{value:", returns the newly created node/edge by cloning.",paraId:105,tocIndex:28},{value:"When ",paraId:105,tocIndex:28},{value:"options.deep",paraId:105,tocIndex:28},{value:" is ",paraId:105,tocIndex:28},{value:"true",paraId:105,tocIndex:28},{value:", returns an object where the Key is the ID of the cloned node/edge, and the Value is the cloned node/edge.",paraId:105,tocIndex:28},{value:"on(name: string, handler: Events.Handler, context?: any): this\n",paraId:106,tocIndex:29},{value:"Listen to events.",paraId:107,tocIndex:29},{value:"Option",paraId:108,tocIndex:29},{value:"Type",paraId:108,tocIndex:29},{value:"Default",paraId:108,tocIndex:29},{value:"Required",paraId:108,tocIndex:29},{value:"Description",paraId:108,tocIndex:29},{value:"name",paraId:108,tocIndex:29},{value:"string",paraId:108,tocIndex:29},{value:"",paraId:108,tocIndex:29},{value:"Event name.",paraId:108,tocIndex:29},{value:"handler",paraId:108,tocIndex:29},{value:"Events.Handler",paraId:108,tocIndex:29},{value:"",paraId:108,tocIndex:29},{value:"Callback function.",paraId:108,tocIndex:29},{value:"context",paraId:108,tocIndex:29},{value:"any",paraId:108,tocIndex:29},{value:"Calling context of the callback.",paraId:108,tocIndex:29},{value:"once(name: string, handler: Events.Handler, context?: any): this\n",paraId:109,tocIndex:30},{value:"Listen to an event once, automatically remove the listener after the event is triggered.",paraId:110,tocIndex:30},{value:"Option",paraId:111,tocIndex:30},{value:"Type",paraId:111,tocIndex:30},{value:"Default",paraId:111,tocIndex:30},{value:"Required",paraId:111,tocIndex:30},{value:"Description",paraId:111,tocIndex:30},{value:"name",paraId:111,tocIndex:30},{value:"string",paraId:111,tocIndex:30},{value:"",paraId:111,tocIndex:30},{value:"Event name.",paraId:111,tocIndex:30},{value:"handler",paraId:111,tocIndex:30},{value:"Events.Handler",paraId:111,tocIndex:30},{value:"",paraId:111,tocIndex:30},{value:"Callback function.",paraId:111,tocIndex:30},{value:"context",paraId:111,tocIndex:30},{value:"any",paraId:111,tocIndex:30},{value:"Calling context of callback function.",paraId:111,tocIndex:30},{value:"/**\n * Remove all event listeners.\n */\noff(): this\n\n/**\n * Remove all event listeners for the specified name.\n */\noff(name: string): this\n\n/**\n * Remove the event listener corresponding to the specified handler.\n */\noff(name: null, handler: Events.Handler): this\n\n/**\n * Remove the event listener for the specified name and handler.\n */\noff(name: string, handler: Events.Handler, context?: any): this\n",paraId:112,tocIndex:31},{value:"Remove event listeners.",paraId:113,tocIndex:31},{value:"trigger(name: string, ...args?: any[]): boolean | Promise<boolean>\n",paraId:114,tocIndex:32},{value:"Trigger an event.",paraId:115,tocIndex:32},{value:"Option",paraId:116,tocIndex:32},{value:"Type",paraId:116,tocIndex:32},{value:"Default",paraId:116,tocIndex:32},{value:"Required",paraId:116,tocIndex:32},{value:"Description",paraId:116,tocIndex:32},{value:"name",paraId:116,tocIndex:32},{value:"string",paraId:116,tocIndex:32},{value:"",paraId:116,tocIndex:32},{value:"Event name.",paraId:116,tocIndex:32},{value:"...args",paraId:116,tocIndex:32},{value:"any[]",paraId:116,tocIndex:32},{value:"Parameters passed to callback functions.",paraId:116,tocIndex:32},{value:"When all callback functions are synchronous, it returns ",paraId:117,tocIndex:32},{value:"false",paraId:117,tocIndex:32},{value:" if any callback function returns ",paraId:117,tocIndex:32},{value:"false",paraId:117,tocIndex:32},{value:", otherwise returns ",paraId:117,tocIndex:32},{value:"true",paraId:117,tocIndex:32},{value:".",paraId:117,tocIndex:32},{value:"When there are asynchronous functions among the callbacks, it returns ",paraId:117,tocIndex:32},{value:"Promise<boolean>",paraId:117,tocIndex:32},{value:" based on the same logic as synchronous callbacks.",paraId:117,tocIndex:32},{value:"dispose(): void\n",paraId:118,tocIndex:33},{value:"Destroy and remove the node/edge from its parent.",paraId:119,tocIndex:33},{value:"Specifies the SVG/HTML structure used to render nodes/edges, described in ",paraId:120,tocIndex:34},{value:"JSON format",paraId:121,tocIndex:34},{value:", usually set through the ",paraId:120,tocIndex:34},{value:"config",paraId:122,tocIndex:34},{value:" method when defining nodes/edges to be shared by all instances. When modifying ",paraId:120,tocIndex:34},{value:"markup",paraId:120,tocIndex:34},{value:", it will trigger the ",paraId:120,tocIndex:34},{value:"change:markup",paraId:120,tocIndex:34},{value:" event and canvas redraw.",paraId:120,tocIndex:34},{value:"Get ",paraId:123,tocIndex:35},{value:"markup",paraId:123,tocIndex:35},{value:".",paraId:123,tocIndex:35},{value:"const markup = cell.markup\n",paraId:124,tocIndex:35},{value:"Set ",paraId:125,tocIndex:36},{value:"markup",paraId:125,tocIndex:36},{value:", and trigger the ",paraId:125,tocIndex:36},{value:"change:markup",paraId:125,tocIndex:36},{value:" event and canvas redraw.",paraId:125,tocIndex:36},{value:"cell.markup = markup\n",paraId:126,tocIndex:36},{value:"getMarkup(): Markup\n",paraId:127,tocIndex:37},{value:"Get ",paraId:128,tocIndex:37},{value:"markup",paraId:128,tocIndex:37},{value:".",paraId:128,tocIndex:37},{value:"const markup = cell.getMarkup()\n",paraId:129,tocIndex:37},{value:"setMarkup(markup: Markup, options?: Cell.SetOptions): this\n",paraId:130,tocIndex:38},{value:"Set ",paraId:131,tocIndex:38},{value:"markup",paraId:131,tocIndex:38},{value:". By default, it triggers the ",paraId:131,tocIndex:38},{value:"change:markup",paraId:131,tocIndex:38},{value:" event and canvas redraw. When ",paraId:131,tocIndex:38},{value:"options.silent",paraId:131,tocIndex:38},{value:" is ",paraId:131,tocIndex:38},{value:"true",paraId:131,tocIndex:38},{value:", it does not trigger the ",paraId:131,tocIndex:38},{value:"change:markup",paraId:131,tocIndex:38},{value:" event and canvas redraw.",paraId:131,tocIndex:38},{value:"Name",paraId:132,tocIndex:38},{value:"Type",paraId:132,tocIndex:38},{value:"Required",paraId:132,tocIndex:38},{value:"Default",paraId:132,tocIndex:38},{value:"Description",paraId:132,tocIndex:38},{value:"markup",paraId:132,tocIndex:38},{value:"Markup",paraId:133,tocIndex:38},{value:"",paraId:132,tocIndex:38},{value:"options.silent",paraId:132,tocIndex:38},{value:"boolean",paraId:132,tocIndex:38},{value:"false",paraId:132,tocIndex:38},{value:"When ",paraId:132,tocIndex:38},{value:"true",paraId:132,tocIndex:38},{value:", do not trigger ",paraId:132,tocIndex:38},{value:"change:markup",paraId:132,tocIndex:38},{value:" event and canvas redraw.",paraId:132,tocIndex:38},{value:"options...others",paraId:132,tocIndex:38},{value:"object",paraId:132,tocIndex:38},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:132,tocIndex:38},{value:"removeMarkup(options?: Cell.SetOptions): this\n",paraId:134,tocIndex:39},{value:"Remove ",paraId:135,tocIndex:39},{value:"markup",paraId:135,tocIndex:39},{value:". By default, it triggers the ",paraId:135,tocIndex:39},{value:"change:markup",paraId:135,tocIndex:39},{value:" event and canvas redraw. When ",paraId:135,tocIndex:39},{value:"options.silent",paraId:135,tocIndex:39},{value:" is ",paraId:135,tocIndex:39},{value:"true",paraId:135,tocIndex:39},{value:", it does not trigger the ",paraId:135,tocIndex:39},{value:"change:markup",paraId:135,tocIndex:39},{value:" event and canvas redraw.",paraId:135,tocIndex:39},{value:"Name",paraId:136,tocIndex:39},{value:"Type",paraId:136,tocIndex:39},{value:"Required",paraId:136,tocIndex:39},{value:"Default",paraId:136,tocIndex:39},{value:"Description",paraId:136,tocIndex:39},{value:"options.silent",paraId:136,tocIndex:39},{value:"boolean",paraId:136,tocIndex:39},{value:"false",paraId:136,tocIndex:39},{value:"When ",paraId:136,tocIndex:39},{value:"true",paraId:136,tocIndex:39},{value:", do not trigger ",paraId:136,tocIndex:39},{value:"change:markup",paraId:136,tocIndex:39},{value:" event and canvas redraw.",paraId:136,tocIndex:39},{value:"options...others",paraId:136,tocIndex:39},{value:"object",paraId:136,tocIndex:39},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:136,tocIndex:39},{value:"The ",paraId:137,tocIndex:40},{value:"attrs",paraId:137,tocIndex:40},{value:" property is a ",paraId:137,tocIndex:40},{value:"complex object",paraId:138,tocIndex:40},{value:". When modifying ",paraId:137,tocIndex:40},{value:"attrs",paraId:137,tocIndex:40},{value:", it will trigger the ",paraId:137,tocIndex:40},{value:"change:attrs",paraId:137,tocIndex:40},{value:" event and canvas redraw.",paraId:137,tocIndex:40},{value:"Get attributes.",paraId:139,tocIndex:41},{value:"const atts = cell.attrs\n",paraId:140,tocIndex:41},{value:"Set attributes, and trigger the ",paraId:141,tocIndex:42},{value:"change:attrs",paraId:141,tocIndex:42},{value:" event and canvas redraw.",paraId:141,tocIndex:42},{value:"cell.atts = attrs\n",paraId:142,tocIndex:42},{value:"getAttrs(): Attr.CellAttrs\n",paraId:143,tocIndex:43},{value:"Get attributes.",paraId:144,tocIndex:43},{value:"const atts = cell.getAttrs()\n",paraId:145,tocIndex:43},{value:"setAttrs(attrs: Attr.CellAttrs, options?: Cell.SetAttrOptions): this\n",paraId:146,tocIndex:44},{value:"Set attributes. By default, it triggers the ",paraId:147,tocIndex:44},{value:"change:attrs",paraId:147,tocIndex:44},{value:" event and canvas redraw.",paraId:147,tocIndex:44},{value:"Name",paraId:148,tocIndex:44},{value:"Type",paraId:148,tocIndex:44},{value:"Required",paraId:148,tocIndex:44},{value:"Default",paraId:148,tocIndex:44},{value:"Description",paraId:148,tocIndex:44},{value:"attrs",paraId:148,tocIndex:44},{value:"Attr.CellAttrs | null | undefined",paraId:148,tocIndex:44},{value:"",paraId:148,tocIndex:44},{value:"options.overwrite",paraId:148,tocIndex:44},{value:"boolean",paraId:148,tocIndex:44},{value:"false",paraId:148,tocIndex:44},{value:"When ",paraId:148,tocIndex:44},{value:"true",paraId:148,tocIndex:44},{value:", replace existing attributes; otherwise, perform deep or shallow merge based on the ",paraId:148,tocIndex:44},{value:"options.deep",paraId:148,tocIndex:44},{value:" option.",paraId:148,tocIndex:44},{value:"options.deep",paraId:148,tocIndex:44},{value:"boolean",paraId:148,tocIndex:44},{value:"true",paraId:148,tocIndex:44},{value:"Effective when ",paraId:148,tocIndex:44},{value:"options.overwrite",paraId:148,tocIndex:44},{value:" is ",paraId:148,tocIndex:44},{value:"false",paraId:148,tocIndex:44},{value:". When ",paraId:148,tocIndex:44},{value:"true",paraId:148,tocIndex:44},{value:", perform deep merge; otherwise, perform shallow merge.",paraId:148,tocIndex:44},{value:"options.silent",paraId:148,tocIndex:44},{value:"boolean",paraId:148,tocIndex:44},{value:"false",paraId:148,tocIndex:44},{value:"When ",paraId:148,tocIndex:44},{value:"true",paraId:148,tocIndex:44},{value:", do not trigger ",paraId:148,tocIndex:44},{value:"change:attrs",paraId:148,tocIndex:44},{value:" event and canvas redraw.",paraId:148,tocIndex:44},{value:"options...others",paraId:148,tocIndex:44},{value:"object",paraId:148,tocIndex:44},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:148,tocIndex:44},{value:"By default, the specified attributes will be ",paraId:149,tocIndex:44},{value:"deeply merged",paraId:149,tocIndex:44},{value:" with the old attributes:",paraId:149,tocIndex:44},{value:"console.log(cell.getAttrs())\n// {\n//   body: { fill: '#ffffff' },\n//   label: { fill: '#333333' },\n// }\n\ncell.setAttrs({\n  body: { fill: '#f5f5f5' },\n  label: { text: 'My Label' },\n})\n\nconsole.log(cell.getAttrs())\n// {\n//   body: { fill: '#f5f5f5' },\n//   label: { fill: '#333333', text: 'My Label' },\n// }\n",paraId:150,tocIndex:44},{value:"When ",paraId:151,tocIndex:44},{value:"options.deep",paraId:151,tocIndex:44},{value:" is ",paraId:151,tocIndex:44},{value:"false",paraId:151,tocIndex:44},{value:", perform shallow merge:",paraId:151,tocIndex:44},{value:"console.log(cell.getAttrs())\n// {\n//   body: { fill: '#ffffff' },\n//   label: { fill: '#333333' },\n// }\n\ncell.setAttrs({ label: { text: 'My Label' } }, { deep: false })\n\nconsole.log(cell.getAttrs())\n// {\n//   body: { fill: '#ffffff' },\n//   label: { text: 'My Label' },\n// }\n",paraId:152,tocIndex:44},{value:"When ",paraId:153,tocIndex:44},{value:"options.overwrite",paraId:153,tocIndex:44},{value:" is ",paraId:153,tocIndex:44},{value:"true",paraId:153,tocIndex:44},{value:", directly replace old attributes:",paraId:153,tocIndex:44},{value:"console.log(cell.getAttrs())\n// {\n//   body: { fill: '#ffffff' },\n//   label: { fill: '#333333' },\n// }\n\ncell.setAttrs({ label: { text: 'My Label' } }, { overwrite: true })\n\nconsole.log(cell.getAttrs())\n// {\n//   label: { text: 'My Label' },\n// }\n",paraId:154,tocIndex:44},{value:"replaceAttrs(attrs: Attr.CellAttrs, options: Cell.SetOptions = {}): this\n",paraId:155,tocIndex:45},{value:"Replace original attributes with given attributes, equivalent to calling ",paraId:156,tocIndex:45},{value:"setAttrs(attrs, { ...options, overwrite: true })",paraId:156,tocIndex:45},{value:".",paraId:156,tocIndex:45},{value:"Name",paraId:157,tocIndex:45},{value:"Type",paraId:157,tocIndex:45},{value:"Required",paraId:157,tocIndex:45},{value:"Default",paraId:157,tocIndex:45},{value:"Description",paraId:157,tocIndex:45},{value:"attrs",paraId:157,tocIndex:45},{value:"Attr.CellAttrs | null | undefined",paraId:157,tocIndex:45},{value:"",paraId:157,tocIndex:45},{value:"options.silent",paraId:157,tocIndex:45},{value:"boolean",paraId:157,tocIndex:45},{value:"false",paraId:157,tocIndex:45},{value:"When ",paraId:157,tocIndex:45},{value:"true",paraId:157,tocIndex:45},{value:", do not trigger ",paraId:157,tocIndex:45},{value:"change:attrs",paraId:157,tocIndex:45},{value:" event and canvas redraw.",paraId:157,tocIndex:45},{value:"options...others",paraId:157,tocIndex:45},{value:"object",paraId:157,tocIndex:45},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:157,tocIndex:45},{value:"updateAttrs(attrs: Attr.CellAttrs, options: Cell.SetOptions = {}): this\n",paraId:158,tocIndex:46},{value:"Update attributes using shallow merge, equivalent to calling ",paraId:159,tocIndex:46},{value:"setAttrs(attrs, { ...options, deep: false })",paraId:159,tocIndex:46},{value:".",paraId:159,tocIndex:46},{value:"Name",paraId:160,tocIndex:46},{value:"Type",paraId:160,tocIndex:46},{value:"Required",paraId:160,tocIndex:46},{value:"Default",paraId:160,tocIndex:46},{value:"Description",paraId:160,tocIndex:46},{value:"attrs",paraId:160,tocIndex:46},{value:"Attr.CellAttrs | null | undefined",paraId:160,tocIndex:46},{value:"",paraId:160,tocIndex:46},{value:"options.silent",paraId:160,tocIndex:46},{value:"boolean",paraId:160,tocIndex:46},{value:"false",paraId:160,tocIndex:46},{value:"When ",paraId:160,tocIndex:46},{value:"true",paraId:160,tocIndex:46},{value:", it doesn't trigger the ",paraId:160,tocIndex:46},{value:"change:attrs",paraId:160,tocIndex:46},{value:" event and canvas redraw.",paraId:160,tocIndex:46},{value:"options...others",paraId:160,tocIndex:46},{value:"object",paraId:160,tocIndex:46},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:160,tocIndex:46},{value:"removeAttrs(options?: Cell.SetOptions): this\n",paraId:161,tocIndex:47},{value:"Remove attributes.",paraId:162,tocIndex:47},{value:"Name",paraId:163,tocIndex:47},{value:"Type",paraId:163,tocIndex:47},{value:"Required",paraId:163,tocIndex:47},{value:"Default",paraId:163,tocIndex:47},{value:"Description",paraId:163,tocIndex:47},{value:"options.silent",paraId:163,tocIndex:47},{value:"boolean",paraId:163,tocIndex:47},{value:"false",paraId:163,tocIndex:47},{value:"When ",paraId:163,tocIndex:47},{value:"true",paraId:163,tocIndex:47},{value:", it won't trigger the ",paraId:163,tocIndex:47},{value:"change:attrs",paraId:163,tocIndex:47},{value:" event and canvas redraw.",paraId:163,tocIndex:47},{value:"options...others",paraId:163,tocIndex:47},{value:"object",paraId:163,tocIndex:47},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:163,tocIndex:47},{value:"getAttrByPath<T>(path?: string | string[]): T\n",paraId:164,tocIndex:48},{value:"Get attribute value by attribute path.",paraId:165,tocIndex:48},{value:"Name",paraId:166,tocIndex:48},{value:"Type",paraId:166,tocIndex:48},{value:"Required",paraId:166,tocIndex:48},{value:"Default",paraId:166,tocIndex:48},{value:"Description",paraId:166,tocIndex:48},{value:"path",paraId:166,tocIndex:48},{value:"string | string[]",paraId:166,tocIndex:48},{value:"Attribute path. When ",paraId:166,tocIndex:48},{value:"path",paraId:166,tocIndex:48},{value:" is of type ",paraId:166,tocIndex:48},{value:"string",paraId:166,tocIndex:48},{value:", the path is a string separated by ",paraId:166,tocIndex:48},{value:"\\",paraId:166,tocIndex:48},{value:". When ",paraId:166,tocIndex:48},{value:"path",paraId:166,tocIndex:48},{value:" is of type ",paraId:166,tocIndex:48},{value:"string[]",paraId:166,tocIndex:48},{value:", the path is an array of keys on the attribute object path.",paraId:166,tocIndex:48},{value:"The attribute value of a certain node is as follows:",paraId:167,tocIndex:48},{value:"console.log(cell.getAttrs())\n// {\n//   body: { fill: '#ffffff' },\n//   label: { fill: '#333333' },\n// }\n",paraId:168,tocIndex:48},{value:"When the path is empty, it returns all attributes:",paraId:169,tocIndex:48},{value:"console.log(cell.getAttrByPath())\n// {\n//   body: { fill: '#ffffff' },\n//   label: { fill: '#333333' },\n// }\n",paraId:170,tocIndex:48},{value:"Get attribute value through string path:",paraId:171,tocIndex:48},{value:"console.log(cell.getAttrByPath('body'))\n// { fill: '#ffffff' }\n\nconsole.log(cell.getAttrByPath('body/fill'))\n// '#ffffff'\n\nconsole.log(cell.getAttrByPath('unknown'))\n// undefined\n\nconsole.log(cell.getAttrByPath('body/unknown'))\n// undefined\n",paraId:172,tocIndex:48},{value:"Get attribute value through a path composed of an array of keys of the attribute object:",paraId:173,tocIndex:48},{value:"console.log(cell.getAttrByPath(['body']))\n// { fill: '#ffffff' }\n\nconsole.log(cell.getAttrByPath(['body', 'fill']))\n// '#ffffff'\n\nconsole.log(cell.getAttrByPath(['unknown']))\n// undefined\n\nconsole.log(cell.getAttrByPath(['body', 'unknown']))\n// undefined\n",paraId:174,tocIndex:48},{value:"setAttrByPath(path: string | string[], value: Attr.ComplexAttrValue, options?: Cell.SetOptions): this\n",paraId:175,tocIndex:49},{value:"Set attribute value by attribute path.",paraId:176,tocIndex:49},{value:"Name",paraId:177,tocIndex:49},{value:"Type",paraId:177,tocIndex:49},{value:"Required",paraId:177,tocIndex:49},{value:"Default",paraId:177,tocIndex:49},{value:"Description",paraId:177,tocIndex:49},{value:"path",paraId:177,tocIndex:49},{value:"string | string[]",paraId:177,tocIndex:49},{value:"",paraId:177,tocIndex:49},{value:"Attribute path. When ",paraId:177,tocIndex:49},{value:"path",paraId:177,tocIndex:49},{value:" is of type ",paraId:177,tocIndex:49},{value:"string",paraId:177,tocIndex:49},{value:", the path is a string separated by ",paraId:177,tocIndex:49},{value:"\\",paraId:177,tocIndex:49},{value:". When ",paraId:177,tocIndex:49},{value:"path",paraId:177,tocIndex:49},{value:" is of type ",paraId:177,tocIndex:49},{value:"string[]",paraId:177,tocIndex:49},{value:", the path is an array of keys on the attribute object path.",paraId:177,tocIndex:49},{value:"value",paraId:177,tocIndex:49},{value:"Attr.ComplexAttrValue",paraId:177,tocIndex:49},{value:"",paraId:177,tocIndex:49},{value:"New attribute value.",paraId:177,tocIndex:49},{value:"options.silent",paraId:177,tocIndex:49},{value:"boolean",paraId:177,tocIndex:49},{value:"false",paraId:177,tocIndex:49},{value:"When ",paraId:177,tocIndex:49},{value:"true",paraId:177,tocIndex:49},{value:", it won't trigger the ",paraId:177,tocIndex:49},{value:"change:attrs",paraId:177,tocIndex:49},{value:" event and canvas redraw.",paraId:177,tocIndex:49},{value:"options...others",paraId:177,tocIndex:49},{value:"object",paraId:177,tocIndex:49},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:177,tocIndex:49},{value:"The initial attribute value of a certain node is as follows:",paraId:178,tocIndex:49},{value:"console.log(cell.getAttrs())\n// {\n//   body: { fill: '#ffffff' },\n//   label: { fill: '#333333' },\n// }\n",paraId:179,tocIndex:49},{value:"Set attribute value through string path:",paraId:180,tocIndex:49},{value:"cell.setAttrByPath('body', { stroke: '#000000' }) // Replace body attribute value\nconsole.log(cell.getAttrs())\n// {\n//   body: { stroke: '#000000' },\n//   label: { fill: '#333333' },\n// }\n\ncell.setAttrByPath('body/fill', '#f5f5f5') // Set body.fill attribute value\nconsole.log(cell.getAttrs())\n// {\n//   body: { stroke: '#000000', fill: '#f5f5f5' },\n//   label: { fill: '#333333' },\n// }\n",paraId:181,tocIndex:49},{value:"Or set attribute value through a path composed of an array of keys of the attribute object:",paraId:182,tocIndex:49},{value:"cell.setAttrByPath(['body'], { stroke: '#000000' }) // Replace body attribute value\nconsole.log(cell.getAttrs())\n// {\n//   body: { stroke: '#000000' },\n//   label: { fill: '#333333' },\n// }\n\ncell.setAttrByPath(['body', 'fill'], '#f5f5f5') // Set body.fill attribute value\nconsole.log(cell.getAttrs())\n// {\n//   body: { stroke: '#000000', fill: '#f5f5f5' },\n//   label: { fill: '#333333' },\n// }\n",paraId:183,tocIndex:49},{value:"removeAttrByPath(path: string | string[], options?: Cell.SetOption ): this\n",paraId:184,tocIndex:50},{value:"Remove attribute value at the specified path.",paraId:185,tocIndex:50},{value:"Name",paraId:186,tocIndex:50},{value:"Type",paraId:186,tocIndex:50},{value:"Required",paraId:186,tocIndex:50},{value:"Default",paraId:186,tocIndex:50},{value:"Description",paraId:186,tocIndex:50},{value:"path",paraId:186,tocIndex:50},{value:"string | string[]",paraId:186,tocIndex:50},{value:"",paraId:186,tocIndex:50},{value:"Attribute path. When ",paraId:186,tocIndex:50},{value:"path",paraId:186,tocIndex:50},{value:" is of type ",paraId:186,tocIndex:50},{value:"string",paraId:186,tocIndex:50},{value:", the path is a string separated by ",paraId:186,tocIndex:50},{value:"\\",paraId:186,tocIndex:50},{value:". When ",paraId:186,tocIndex:50},{value:"path",paraId:186,tocIndex:50},{value:" is of type ",paraId:186,tocIndex:50},{value:"string[]",paraId:186,tocIndex:50},{value:", the path is an array of keys on the attribute object path.",paraId:186,tocIndex:50},{value:"options.silent",paraId:186,tocIndex:50},{value:"boolean",paraId:186,tocIndex:50},{value:"false",paraId:186,tocIndex:50},{value:"When ",paraId:186,tocIndex:50},{value:"true",paraId:186,tocIndex:50},{value:", it won't trigger the ",paraId:186,tocIndex:50},{value:"change:attrs",paraId:186,tocIndex:50},{value:" event and canvas redraw.",paraId:186,tocIndex:50},{value:"options...others",paraId:186,tocIndex:50},{value:"object",paraId:186,tocIndex:50},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:186,tocIndex:50},{value:"The initial attribute value of a certain node is as follows:",paraId:187,tocIndex:50},{value:"console.log(cell.getAttrs())\n// {\n//   body: { fill: '#ffffff' },\n//   label: { fill: '#333333' },\n// }\n",paraId:188,tocIndex:50},{value:"Remove attribute value through string path:",paraId:189,tocIndex:50},{value:"cell.removeAttrByPath('body/fill')\nconsole.log(cell.getAttrs())\n// {\n//   body: { },\n//   label: { fill: '#333333' },\n// }\n\ncell.removeAttrByPath('body')\nconsole.log(cell.getAttrs())\n// {\n//   label: { fill: '#333333' },\n// }\n",paraId:190,tocIndex:50},{value:"Or remove attribute value through a path composed of an array of keys of the attribute object:",paraId:191,tocIndex:50},{value:"cell.removeAttrByPath(['body', 'fill'])\nconsole.log(cell.getAttrs())\n// {\n//   body: { },\n//   label: { fill: '#333333' },\n// }\n\ncell.removeAttrByPath(['body'])\nconsole.log(cell.getAttrs())\n// {\n//   label: { fill: '#333333' },\n// }\n",paraId:192,tocIndex:50},{value:"/**\n * Get attributes.\n */\nattr(): Cell.CellAttrs\n\n/**\n * Get attribute value at the specified path.\n */\nattr<T>(path: string | string[]): T\n\n/**\n * Set attribute value at the specified path.\n */\nattr(path: string | string[], value: Attr.ComplexAttrValue | null, options?: Cell.SetOptions): this\n\n/**\n * Set attribute values, the passed attributes are deeply merged with the old attributes.\n */\nattr(attrs: Attr.CellAttrs, options?: Cell.SetOptions): this\n",paraId:193,tocIndex:51},{value:"This method is an integration of ",paraId:194,tocIndex:51},{value:"getAttrByPath",paraId:195,tocIndex:51},{value:", ",paraId:194,tocIndex:51},{value:"setAttrByPath",paraId:196,tocIndex:51},{value:", and ",paraId:194,tocIndex:51},{value:"setAttrs",paraId:197,tocIndex:51},{value:" methods, providing the above four function signatures, making it a very practical method.",paraId:194,tocIndex:51},{value:"Get all attribute values:",paraId:198,tocIndex:51},{value:"console.log(cell.attr())\n// {\n//   body: { fill: '#ffffff' },\n//   label: { fill: '#333333' },\n// }\n",paraId:199,tocIndex:51},{value:"Get attribute value at the specified path:",paraId:200,tocIndex:51},{value:"console.log(cell.attr('body/fill'))\n// '#ffffff'\n",paraId:201,tocIndex:51},{value:"Set attribute value at the specified path:",paraId:202,tocIndex:51},{value:"cell.attr('body/fill', '#f5f5f5')\nconsole.log(cell.attr())\n// {\n//   body: { fill: '#f5f5f5' },\n//   label: { fill: '#333333' },\n// }\n",paraId:203,tocIndex:51},{value:"Set attribute values through the attribute object, and perform a ",paraId:204,tocIndex:51},{value:"deep merge",paraId:204,tocIndex:51},{value:" with the existing attribute object.",paraId:204,tocIndex:51},{value:"cell.attr({\n  body: { stroke: '#000000' },\n  label: { fill: 'blue', text: 'my label' },\n})\nconsole.log(cell.attr())\n// {\n//   body: { fill: '#f5f5f5', stroke: '#000000' },\n//   label: { fill: 'blue', text: 'my label' },\n// }\n",paraId:205,tocIndex:51},{value:"zIndex",paraId:206,tocIndex:52},{value:" is the layer level of a node/edge in the canvas, which is automatically determined based on the order of node/edge addition by default. When modifying ",paraId:206,tocIndex:52},{value:"zIndex",paraId:206,tocIndex:52},{value:", it will trigger the ",paraId:206,tocIndex:52},{value:"change:zIndex",paraId:206,tocIndex:52},{value:" event and canvas redraw.",paraId:206,tocIndex:52},{value:"Get the ",paraId:207,tocIndex:53},{value:"zIndex",paraId:207,tocIndex:53},{value:".",paraId:207,tocIndex:53},{value:"const z = cell.zIndex\n",paraId:208,tocIndex:53},{value:"Set the ",paraId:209,tocIndex:54},{value:"zIndex",paraId:209,tocIndex:54},{value:", triggering the ",paraId:209,tocIndex:54},{value:"change:zIndex",paraId:209,tocIndex:54},{value:" event and canvas redraw.",paraId:209,tocIndex:54},{value:"cell.zIndex = 2\n",paraId:210,tocIndex:54},{value:"getZIndex(): number\n",paraId:211,tocIndex:55},{value:"Get the ",paraId:212,tocIndex:55},{value:"zIndex",paraId:212,tocIndex:55},{value:".",paraId:212,tocIndex:55},{value:"const z = cell.getZIndex()\n",paraId:213,tocIndex:55},{value:"setZIndex(zIndex: number, options?: Cell.SetOptions): this\n",paraId:214,tocIndex:56},{value:"Set the ",paraId:215,tocIndex:56},{value:"zIndex",paraId:215,tocIndex:56},{value:". By default, it triggers the ",paraId:215,tocIndex:56},{value:"change:zIndex",paraId:215,tocIndex:56},{value:" event and canvas redraw. When ",paraId:215,tocIndex:56},{value:"options.silent",paraId:215,tocIndex:56},{value:" is ",paraId:215,tocIndex:56},{value:"true",paraId:215,tocIndex:56},{value:", it doesn't trigger the ",paraId:215,tocIndex:56},{value:"change:zIndex",paraId:215,tocIndex:56},{value:" event and canvas redraw.",paraId:215,tocIndex:56},{value:"Name",paraId:216,tocIndex:56},{value:"Type",paraId:216,tocIndex:56},{value:"Required",paraId:216,tocIndex:56},{value:"Default",paraId:216,tocIndex:56},{value:"Description",paraId:216,tocIndex:56},{value:"zIndex",paraId:216,tocIndex:56},{value:"number",paraId:216,tocIndex:56},{value:"",paraId:216,tocIndex:56},{value:"options.silent",paraId:216,tocIndex:56},{value:"boolean",paraId:216,tocIndex:56},{value:"false",paraId:216,tocIndex:56},{value:"When ",paraId:216,tocIndex:56},{value:"true",paraId:216,tocIndex:56},{value:", doesn't trigger ",paraId:216,tocIndex:56},{value:"change:zIndex",paraId:216,tocIndex:56},{value:" event and redraw.",paraId:216,tocIndex:56},{value:"options...others",paraId:216,tocIndex:56},{value:"object",paraId:216,tocIndex:56},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:216,tocIndex:56},{value:"removeZIndex(options?: Cell.SetOptions): this\n",paraId:217,tocIndex:57},{value:"Remove the ",paraId:218,tocIndex:57},{value:"zIndex",paraId:218,tocIndex:57},{value:". By default, it triggers the ",paraId:218,tocIndex:57},{value:"change:zIndex",paraId:218,tocIndex:57},{value:" event and canvas redraw. When ",paraId:218,tocIndex:57},{value:"options.silent",paraId:218,tocIndex:57},{value:" is ",paraId:218,tocIndex:57},{value:"true",paraId:218,tocIndex:57},{value:", it doesn't trigger the ",paraId:218,tocIndex:57},{value:"change:zIndex",paraId:218,tocIndex:57},{value:" event and canvas redraw.",paraId:218,tocIndex:57},{value:"Name",paraId:219,tocIndex:57},{value:"Type",paraId:219,tocIndex:57},{value:"Required",paraId:219,tocIndex:57},{value:"Default",paraId:219,tocIndex:57},{value:"Description",paraId:219,tocIndex:57},{value:"options.silent",paraId:219,tocIndex:57},{value:"boolean",paraId:219,tocIndex:57},{value:"false",paraId:219,tocIndex:57},{value:"When ",paraId:219,tocIndex:57},{value:"true",paraId:219,tocIndex:57},{value:", doesn't trigger ",paraId:219,tocIndex:57},{value:"change:zIndex",paraId:219,tocIndex:57},{value:" event and redraw.",paraId:219,tocIndex:57},{value:"options...others",paraId:219,tocIndex:57},{value:"object",paraId:219,tocIndex:57},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:219,tocIndex:57},{value:"toFront(options?: Cell.ToFrontOptions): this\n",paraId:220,tocIndex:58},{value:"Move the node/edge to the topmost layer.",paraId:221,tocIndex:58},{value:"Name",paraId:222,tocIndex:58},{value:"Type",paraId:222,tocIndex:58},{value:"Required",paraId:222,tocIndex:58},{value:"Default",paraId:222,tocIndex:58},{value:"Description",paraId:222,tocIndex:58},{value:"options.deep",paraId:222,tocIndex:58},{value:"boolean",paraId:222,tocIndex:58},{value:"false",paraId:222,tocIndex:58},{value:"When ",paraId:222,tocIndex:58},{value:"true",paraId:222,tocIndex:58},{value:", also updates the hierarchy of all child nodes/edges.",paraId:222,tocIndex:58},{value:"options.silent",paraId:222,tocIndex:58},{value:"boolean",paraId:222,tocIndex:58},{value:"false",paraId:222,tocIndex:58},{value:"When ",paraId:222,tocIndex:58},{value:"true",paraId:222,tocIndex:58},{value:", doesn't trigger ",paraId:222,tocIndex:58},{value:"change:zIndex",paraId:222,tocIndex:58},{value:" event and redraw.",paraId:222,tocIndex:58},{value:"options...others",paraId:222,tocIndex:58},{value:"object",paraId:222,tocIndex:58},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:222,tocIndex:58},{value:"toBack(options?: Cell.ToBackOptions): this\n",paraId:223,tocIndex:59},{value:"Move the node/edge to the bottommost layer.",paraId:224,tocIndex:59},{value:"Name",paraId:225,tocIndex:59},{value:"Type",paraId:225,tocIndex:59},{value:"Required",paraId:225,tocIndex:59},{value:"Default",paraId:225,tocIndex:59},{value:"Description",paraId:225,tocIndex:59},{value:"options.deep",paraId:225,tocIndex:59},{value:"boolean",paraId:225,tocIndex:59},{value:"false",paraId:225,tocIndex:59},{value:"When ",paraId:225,tocIndex:59},{value:"true",paraId:225,tocIndex:59},{value:", also updates the hierarchy of all child nodes/edges.",paraId:225,tocIndex:59},{value:"options.silent",paraId:225,tocIndex:59},{value:"boolean",paraId:225,tocIndex:59},{value:"false",paraId:225,tocIndex:59},{value:"When ",paraId:225,tocIndex:59},{value:"true",paraId:225,tocIndex:59},{value:", doesn't trigger ",paraId:225,tocIndex:59},{value:"change:zIndex",paraId:225,tocIndex:59},{value:" event and redraw.",paraId:225,tocIndex:59},{value:"options...others",paraId:225,tocIndex:59},{value:"object",paraId:225,tocIndex:59},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:225,tocIndex:59},{value:"By default, updating ",paraId:226,tocIndex:59},{value:"zIndex",paraId:226,tocIndex:59},{value:" triggers the ",paraId:226,tocIndex:59},{value:"change:zIndex",paraId:226,tocIndex:59},{value:" event and canvas redraw:",paraId:226,tocIndex:59},{value:"cell.toBack()\n",paraId:227,tocIndex:59},{value:"When ",paraId:228,tocIndex:59},{value:"options.deep",paraId:228,tocIndex:59},{value:" is ",paraId:228,tocIndex:59},{value:"true",paraId:228,tocIndex:59},{value:", it also updates the hierarchy of all child nodes/edges:",paraId:228,tocIndex:59},{value:"cell.toBack({ deep: true })\n",paraId:229,tocIndex:59},{value:"Returns whether the node/edge is visible.",paraId:230,tocIndex:61},{value:"if (cell.visible) {\n  // do something\n}\n",paraId:231,tocIndex:61},{value:"Sets whether the node/edge is visible and triggers the ",paraId:232,tocIndex:62},{value:"change:visible",paraId:232,tocIndex:62},{value:" event and canvas redraw.",paraId:232,tocIndex:62},{value:"show(options?: Cell.SetOptions): this\n",paraId:233,tocIndex:63},{value:"Show the node/edge.",paraId:234,tocIndex:63},{value:"Name",paraId:235,tocIndex:63},{value:"Type",paraId:235,tocIndex:63},{value:"Required",paraId:235,tocIndex:63},{value:"Default",paraId:235,tocIndex:63},{value:"Description",paraId:235,tocIndex:63},{value:"options.silent",paraId:235,tocIndex:63},{value:"boolean",paraId:235,tocIndex:63},{value:"false",paraId:235,tocIndex:63},{value:"When ",paraId:235,tocIndex:63},{value:"true",paraId:235,tocIndex:63},{value:", doesn't trigger ",paraId:235,tocIndex:63},{value:"change:visible",paraId:235,tocIndex:63},{value:" event and redraw.",paraId:235,tocIndex:63},{value:"options...others",paraId:235,tocIndex:63},{value:"object",paraId:235,tocIndex:63},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:235,tocIndex:63},{value:"hide(options?: Cell.SetOptions): this\n",paraId:236,tocIndex:64},{value:"Hide the node/edge.",paraId:237,tocIndex:64},{value:"Name",paraId:238,tocIndex:64},{value:"Type",paraId:238,tocIndex:64},{value:"Required",paraId:238,tocIndex:64},{value:"Default",paraId:238,tocIndex:64},{value:"Description",paraId:238,tocIndex:64},{value:"options.silent",paraId:238,tocIndex:64},{value:"boolean",paraId:238,tocIndex:64},{value:"false",paraId:238,tocIndex:64},{value:"When ",paraId:238,tocIndex:64},{value:"true",paraId:238,tocIndex:64},{value:", doesn't trigger ",paraId:238,tocIndex:64},{value:"change:visible",paraId:238,tocIndex:64},{value:" event and redraw.",paraId:238,tocIndex:64},{value:"options...others",paraId:238,tocIndex:64},{value:"object",paraId:238,tocIndex:64},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:238,tocIndex:64},{value:"X6 2.x implements element hiding by adding ",paraId:239},{value:"display: none",paraId:239},{value:" to the node label.",paraId:239},{value:"isVisible(): boolean\n",paraId:240,tocIndex:65},{value:"Returns whether the node/edge is visible.",paraId:241,tocIndex:65},{value:"setVisible(visible: boolean, options?: Cell.SetOptions): this\n",paraId:242,tocIndex:66},{value:"Set the visibility of the node/edge. By default, it triggers the ",paraId:243,tocIndex:66},{value:"change:visible",paraId:243,tocIndex:66},{value:" event and canvas redraw. When ",paraId:243,tocIndex:66},{value:"options.silent",paraId:243,tocIndex:66},{value:" is ",paraId:243,tocIndex:66},{value:"true",paraId:243,tocIndex:66},{value:", it doesn't trigger the ",paraId:243,tocIndex:66},{value:"change:visible",paraId:243,tocIndex:66},{value:" event and canvas redraw.",paraId:243,tocIndex:66},{value:"Name",paraId:244,tocIndex:66},{value:"Type",paraId:244,tocIndex:66},{value:"Required",paraId:244,tocIndex:66},{value:"Default",paraId:244,tocIndex:66},{value:"Description",paraId:244,tocIndex:66},{value:"visible",paraId:244,tocIndex:66},{value:"boolean",paraId:244,tocIndex:66},{value:"",paraId:244,tocIndex:66},{value:"options.silent",paraId:244,tocIndex:66},{value:"boolean",paraId:244,tocIndex:66},{value:"false",paraId:244,tocIndex:66},{value:"When ",paraId:244,tocIndex:66},{value:"true",paraId:244,tocIndex:66},{value:", doesn't trigger ",paraId:244,tocIndex:66},{value:"change:visible",paraId:244,tocIndex:66},{value:" event and redraw.",paraId:244,tocIndex:66},{value:"options...others",paraId:244,tocIndex:66},{value:"object",paraId:244,tocIndex:66},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:244,tocIndex:66},{value:"toggleVisible(options?: Cell.SetOptions): this\n",paraId:245,tocIndex:67},{value:"Toggle the visibility of the node/edge. By default, it triggers the ",paraId:246,tocIndex:67},{value:"change:visible",paraId:246,tocIndex:67},{value:" event and canvas redraw. When ",paraId:246,tocIndex:67},{value:"options.silent",paraId:246,tocIndex:67},{value:" is ",paraId:246,tocIndex:67},{value:"true",paraId:246,tocIndex:67},{value:", it doesn't trigger the ",paraId:246,tocIndex:67},{value:"change:visible",paraId:246,tocIndex:67},{value:" event and canvas redraw.",paraId:246,tocIndex:67},{value:"Name",paraId:247,tocIndex:67},{value:"Type",paraId:247,tocIndex:67},{value:"Required",paraId:247,tocIndex:67},{value:"Default",paraId:247,tocIndex:67},{value:"Description",paraId:247,tocIndex:67},{value:"options.silent",paraId:247,tocIndex:67},{value:"boolean",paraId:247,tocIndex:67},{value:"false",paraId:247,tocIndex:67},{value:"When ",paraId:247,tocIndex:67},{value:"true",paraId:247,tocIndex:67},{value:", doesn't trigger ",paraId:247,tocIndex:67},{value:"change:visible",paraId:247,tocIndex:67},{value:" event and redraw.",paraId:247,tocIndex:67},{value:"options...others",paraId:247,tocIndex:67},{value:"object",paraId:247,tocIndex:67},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:247,tocIndex:67},{value:"Business data associated with nodes/edges. For example, in practical use, we often store certain business data on the data property of nodes/edges.",paraId:248,tocIndex:68},{value:"const rect = new Shape.Rect({\n  x: 40,\n  y: 40,\n  width: 100,\n  height: 40,\n  data: {\n    bizID: 125,\n    date: '20200630',\n    price: 89.0,\n  },\n})\n",paraId:249,tocIndex:68},{value:"Get the associated data.",paraId:250,tocIndex:69},{value:"Set the associated data and trigger the ",paraId:251,tocIndex:70},{value:"change:data",paraId:251,tocIndex:70},{value:" event and canvas redraw.",paraId:251,tocIndex:70},{value:"getData(): any\n",paraId:252,tocIndex:71},{value:"Get the associated data.",paraId:253,tocIndex:71},{value:"setData(data: any, options?: Cell.SetDataOptions): this\n",paraId:254,tocIndex:72},{value:"Set the associated business data. By default, it triggers the ",paraId:255,tocIndex:72},{value:"change:data",paraId:255,tocIndex:72},{value:" event and canvas redraw. When ",paraId:255,tocIndex:72},{value:"options.silent",paraId:255,tocIndex:72},{value:" is ",paraId:255,tocIndex:72},{value:"true",paraId:255,tocIndex:72},{value:", it doesn't trigger the ",paraId:255,tocIndex:72},{value:"change:data",paraId:255,tocIndex:72},{value:" event and canvas redraw.",paraId:255,tocIndex:72},{value:"Name",paraId:256,tocIndex:72},{value:"Type",paraId:256,tocIndex:72},{value:"Required",paraId:256,tocIndex:72},{value:"Default",paraId:256,tocIndex:72},{value:"Description",paraId:256,tocIndex:72},{value:"data",paraId:256,tocIndex:72},{value:"any",paraId:256,tocIndex:72},{value:"",paraId:256,tocIndex:72},{value:"options.overwrite",paraId:256,tocIndex:72},{value:"boolean",paraId:256,tocIndex:72},{value:"false",paraId:256,tocIndex:72},{value:"When ",paraId:256,tocIndex:72},{value:"true",paraId:256,tocIndex:72},{value:", replaces existing values; otherwise, performs deep or shallow merge based on ",paraId:256,tocIndex:72},{value:"options.deep",paraId:256,tocIndex:72},{value:".",paraId:256,tocIndex:72},{value:"options.deep",paraId:256,tocIndex:72},{value:"boolean",paraId:256,tocIndex:72},{value:"true",paraId:256,tocIndex:72},{value:"Effective when ",paraId:256,tocIndex:72},{value:"options.overwrite",paraId:256,tocIndex:72},{value:" is ",paraId:256,tocIndex:72},{value:"false",paraId:256,tocIndex:72},{value:". When ",paraId:256,tocIndex:72},{value:"true",paraId:256,tocIndex:72},{value:", performs deep merge; otherwise, shallow merge.",paraId:256,tocIndex:72},{value:"options.silent",paraId:256,tocIndex:72},{value:"boolean",paraId:256,tocIndex:72},{value:"false",paraId:256,tocIndex:72},{value:"When ",paraId:256,tocIndex:72},{value:"true",paraId:256,tocIndex:72},{value:", doesn't trigger ",paraId:256,tocIndex:72},{value:"change:data",paraId:256,tocIndex:72},{value:" event and redraw.",paraId:256,tocIndex:72},{value:"options...others",paraId:256,tocIndex:72},{value:"object",paraId:256,tocIndex:72},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:256,tocIndex:72},{value:"By default, it performs a ",paraId:257,tocIndex:72},{value:"deep merge",paraId:257,tocIndex:72},{value:" with the original data and triggers the ",paraId:257,tocIndex:72},{value:"change:data",paraId:257,tocIndex:72},{value:" event and canvas redraw:",paraId:257,tocIndex:72},{value:"cell.setData(data)\n",paraId:258,tocIndex:72},{value:"When ",paraId:259,tocIndex:72},{value:"options.overwrite",paraId:259,tocIndex:72},{value:" is ",paraId:259,tocIndex:72},{value:"true",paraId:259,tocIndex:72},{value:", it replaces the old data:",paraId:259,tocIndex:72},{value:"cell.setData(data, { overwrite: true })\n",paraId:260,tocIndex:72},{value:"When ",paraId:261,tocIndex:72},{value:"options.deep",paraId:261,tocIndex:72},{value:" is ",paraId:261,tocIndex:72},{value:"false",paraId:261,tocIndex:72},{value:", it performs a shallow merge with the original data:",paraId:261,tocIndex:72},{value:"cell.setData(data, { deep: false })\n",paraId:262,tocIndex:72},{value:"The ",paraId:263},{value:"setData",paraId:263},{value:" method uses shallow comparison to determine if the data has been updated, thus deciding whether to trigger node redraw.",paraId:263},{value:"const obj = { name: 'x6', star: true }\nnode.setData(obj) // This will trigger a node redraw\n\nobj.star = false\nnode.setData(obj) // Note: At this point, no deep comparison is performed. The object is considered unchanged, so it won't trigger a node redraw\n\nnode.setData({\n  ...obj,\n  star: false,\n}) // This will trigger a node redraw\n",paraId:264},{value:"replaceData(data: any, options: Cell.SetOptions = {}): this\n",paraId:265,tocIndex:73},{value:"Replace the original data with the specified data, equivalent to calling ",paraId:266,tocIndex:73},{value:"setData(data, { ...options, overwrite: true })",paraId:266,tocIndex:73},{value:".",paraId:266,tocIndex:73},{value:"Name",paraId:267,tocIndex:73},{value:"Type",paraId:267,tocIndex:73},{value:"Required",paraId:267,tocIndex:73},{value:"Default",paraId:267,tocIndex:73},{value:"Description",paraId:267,tocIndex:73},{value:"data",paraId:267,tocIndex:73},{value:"any",paraId:267,tocIndex:73},{value:"",paraId:267,tocIndex:73},{value:"options.silent",paraId:267,tocIndex:73},{value:"boolean",paraId:267,tocIndex:73},{value:"false",paraId:267,tocIndex:73},{value:"When ",paraId:267,tocIndex:73},{value:"true",paraId:267,tocIndex:73},{value:", does not trigger the ",paraId:267,tocIndex:73},{value:"change:data",paraId:267,tocIndex:73},{value:" event and canvas redrawing.",paraId:267,tocIndex:73},{value:"options...others",paraId:267,tocIndex:73},{value:"object",paraId:267,tocIndex:73},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:267,tocIndex:73},{value:"updateData(data: any, options: Cell.SetOptions = {}): this\n",paraId:268,tocIndex:74},{value:"Update data using shallow merge, equivalent to calling ",paraId:269,tocIndex:74},{value:"setData(data, { ...options, deep: false })",paraId:269,tocIndex:74},{value:".",paraId:269,tocIndex:74},{value:"Name",paraId:270,tocIndex:74},{value:"Type",paraId:270,tocIndex:74},{value:"Required",paraId:270,tocIndex:74},{value:"Default",paraId:270,tocIndex:74},{value:"Description",paraId:270,tocIndex:74},{value:"data",paraId:270,tocIndex:74},{value:"any",paraId:270,tocIndex:74},{value:"",paraId:270,tocIndex:74},{value:"options.silent",paraId:270,tocIndex:74},{value:"boolean",paraId:270,tocIndex:74},{value:"false",paraId:270,tocIndex:74},{value:"When ",paraId:270,tocIndex:74},{value:"true",paraId:270,tocIndex:74},{value:", does not trigger the ",paraId:270,tocIndex:74},{value:"change:data",paraId:270,tocIndex:74},{value:" event and canvas redrawing.",paraId:270,tocIndex:74},{value:"options...others",paraId:270,tocIndex:74},{value:"object",paraId:270,tocIndex:74},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:270,tocIndex:74},{value:"removeData(options: Cell.SetOptions): this\n",paraId:271,tocIndex:75},{value:"Remove data. By default, it triggers the ",paraId:272,tocIndex:75},{value:"change:data",paraId:272,tocIndex:75},{value:" event and canvas redrawing. When ",paraId:272,tocIndex:75},{value:"options.silent",paraId:272,tocIndex:75},{value:" is ",paraId:272,tocIndex:75},{value:"true",paraId:272,tocIndex:75},{value:", it does not trigger the ",paraId:272,tocIndex:75},{value:"change:data",paraId:272,tocIndex:75},{value:" event and canvas redrawing.",paraId:272,tocIndex:75},{value:"Name",paraId:273,tocIndex:75},{value:"Type",paraId:273,tocIndex:75},{value:"Required",paraId:273,tocIndex:75},{value:"Default",paraId:273,tocIndex:75},{value:"Description",paraId:273,tocIndex:75},{value:"options.silent",paraId:273,tocIndex:75},{value:"boolean",paraId:273,tocIndex:75},{value:"false",paraId:273,tocIndex:75},{value:"When ",paraId:273,tocIndex:75},{value:"true",paraId:273,tocIndex:75},{value:", does not trigger the ",paraId:273,tocIndex:75},{value:"change:data",paraId:273,tocIndex:75},{value:" event and canvas redrawing.",paraId:273,tocIndex:75},{value:"options...others",paraId:273,tocIndex:75},{value:"object",paraId:273,tocIndex:75},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:273,tocIndex:75},{value:"Get the parent node.",paraId:274,tocIndex:77},{value:"getParent(): Cell | null\n",paraId:275,tocIndex:78},{value:"Get the parent node. Returns the parent node if it exists, otherwise returns ",paraId:276,tocIndex:78},{value:"null",paraId:276,tocIndex:78},{value:".",paraId:276,tocIndex:78},{value:"setParent(parent: Cell | null, options?: Cell.SetOptions): this\n",paraId:277,tocIndex:79},{value:"Set the parent node.",paraId:278,tocIndex:79},{value:"Name",paraId:279,tocIndex:79},{value:"Type",paraId:279,tocIndex:79},{value:"Required",paraId:279,tocIndex:79},{value:"Default",paraId:279,tocIndex:79},{value:"Description",paraId:279,tocIndex:79},{value:"parent",paraId:279,tocIndex:79},{value:"Cell | null",paraId:279,tocIndex:79},{value:"",paraId:279,tocIndex:79},{value:"Parent node or ",paraId:279,tocIndex:79},{value:"null",paraId:279,tocIndex:79},{value:". When ",paraId:279,tocIndex:79},{value:"parent",paraId:279,tocIndex:79},{value:" is ",paraId:279,tocIndex:79},{value:"null",paraId:279,tocIndex:79},{value:", it removes the parent node.",paraId:279,tocIndex:79},{value:"options.silent",paraId:279,tocIndex:79},{value:"boolean",paraId:279,tocIndex:79},{value:"false",paraId:279,tocIndex:79},{value:"When ",paraId:279,tocIndex:79},{value:"true",paraId:279,tocIndex:79},{value:", does not trigger the ",paraId:279,tocIndex:79},{value:"change:parent",paraId:279,tocIndex:79},{value:" event and canvas redrawing.",paraId:279,tocIndex:79},{value:"options...others",paraId:279,tocIndex:79},{value:"object",paraId:279,tocIndex:79},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:279,tocIndex:79},{value:"getParentId(): string | undefined\n",paraId:280,tocIndex:80},{value:"Get the ID of the parent node. Returns the parent node's ID if it exists, otherwise returns ",paraId:281,tocIndex:80},{value:"undefined",paraId:281,tocIndex:80},{value:".",paraId:281,tocIndex:80},{value:"hasParent(): boolean\n",paraId:282,tocIndex:81},{value:"Check if the node/edge has a parent node.",paraId:283,tocIndex:81},{value:"Get all child nodes/edges.",paraId:284,tocIndex:82},{value:"getChildren(): Cell[] | null\n",paraId:285,tocIndex:83},{value:"Get all child nodes/edges.",paraId:286,tocIndex:83},{value:"setChildren(children: Cell[] | null, options?: Cell.SetOptions)\n",paraId:287,tocIndex:84},{value:"Set child nodes/edges.",paraId:288,tocIndex:84},{value:"Name",paraId:289,tocIndex:84},{value:"Type",paraId:289,tocIndex:84},{value:"Required",paraId:289,tocIndex:84},{value:"Default",paraId:289,tocIndex:84},{value:"Description",paraId:289,tocIndex:84},{value:"children",paraId:289,tocIndex:84},{value:"Cell[] | null",paraId:289,tocIndex:84},{value:"",paraId:289,tocIndex:84},{value:"Array of child nodes/edges or ",paraId:289,tocIndex:84},{value:"null",paraId:289,tocIndex:84},{value:". When ",paraId:289,tocIndex:84},{value:"children",paraId:289,tocIndex:84},{value:" is ",paraId:289,tocIndex:84},{value:"null",paraId:289,tocIndex:84},{value:", it clears all children.",paraId:289,tocIndex:84},{value:"options.silent",paraId:289,tocIndex:84},{value:"boolean",paraId:289,tocIndex:84},{value:"false",paraId:289,tocIndex:84},{value:"When ",paraId:289,tocIndex:84},{value:"true",paraId:289,tocIndex:84},{value:", does not trigger the ",paraId:289,tocIndex:84},{value:"change:children",paraId:289,tocIndex:84},{value:" event and canvas redrawing.",paraId:289,tocIndex:84},{value:"options...others",paraId:289,tocIndex:84},{value:"object",paraId:289,tocIndex:84},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:289,tocIndex:84},{value:"isParentOf(child: Cell | null): boolean\n",paraId:290,tocIndex:85},{value:"Returns whether the current node is the parent of the specified Cell.",paraId:291,tocIndex:85},{value:"Name",paraId:292,tocIndex:85},{value:"Type",paraId:292,tocIndex:85},{value:"Required",paraId:292,tocIndex:85},{value:"Default",paraId:292,tocIndex:85},{value:"Description",paraId:292,tocIndex:85},{value:"child",paraId:292,tocIndex:85},{value:"Cell | null",paraId:292,tocIndex:85},{value:"",paraId:292,tocIndex:85},{value:"isChildOf(parent: Cell | null): boolean\n",paraId:293,tocIndex:86},{value:"Returns whether the current node/edge is a child of the specified node.",paraId:294,tocIndex:86},{value:"Name",paraId:295,tocIndex:86},{value:"Type",paraId:295,tocIndex:86},{value:"Required",paraId:295,tocIndex:86},{value:"Default",paraId:295,tocIndex:86},{value:"Description",paraId:295,tocIndex:86},{value:"parent",paraId:295,tocIndex:86},{value:"Cell | null",paraId:295,tocIndex:86},{value:"",paraId:295,tocIndex:86},{value:"eachChild(iterator: (child: Cell, index: number, children: Cell[]) => void, context?: any): this\n",paraId:296,tocIndex:87},{value:"Iterate through child nodes.",paraId:297,tocIndex:87},{value:"Name",paraId:298,tocIndex:87},{value:"Type",paraId:298,tocIndex:87},{value:"Required",paraId:298,tocIndex:87},{value:"Default",paraId:298,tocIndex:87},{value:"Description",paraId:298,tocIndex:87},{value:"iterator",paraId:298,tocIndex:87},{value:"(child: Cell, index: number, children: Cell[]) => void",paraId:298,tocIndex:87},{value:"",paraId:298,tocIndex:87},{value:"Iterator function.",paraId:298,tocIndex:87},{value:"context",paraId:298,tocIndex:87},{value:"any",paraId:298,tocIndex:87},{value:"Execution context of iterator function.",paraId:298,tocIndex:87},{value:"filterChild(iterator: (child: Cell, index: number, children: Cell[]) => boolean, context?: any): Cell[]\n",paraId:299,tocIndex:88},{value:"Filter child nodes.",paraId:300,tocIndex:88},{value:"Name",paraId:301,tocIndex:88},{value:"Type",paraId:301,tocIndex:88},{value:"Required",paraId:301,tocIndex:88},{value:"Default",paraId:301,tocIndex:88},{value:"Description",paraId:301,tocIndex:88},{value:"iterator",paraId:301,tocIndex:88},{value:"(child: Cell, index: number, children: Cell[]) => boolean",paraId:301,tocIndex:88},{value:"",paraId:301,tocIndex:88},{value:"Filter function.",paraId:301,tocIndex:88},{value:"context",paraId:301,tocIndex:88},{value:"any",paraId:301,tocIndex:88},{value:"Execution context of filter function.",paraId:301,tocIndex:88},{value:"getChildCount(): number\n",paraId:302,tocIndex:89},{value:"Get the number of child nodes/edges.",paraId:303,tocIndex:89},{value:"getChildIndex(child: Cell): number\n",paraId:304,tocIndex:90},{value:"Get the index of a child node/edge.",paraId:305,tocIndex:90},{value:"Name",paraId:306,tocIndex:90},{value:"Type",paraId:306,tocIndex:90},{value:"Required",paraId:306,tocIndex:90},{value:"Default",paraId:306,tocIndex:90},{value:"Description",paraId:306,tocIndex:90},{value:"child",paraId:306,tocIndex:90},{value:"Cell",paraId:306,tocIndex:90},{value:"",paraId:306,tocIndex:90},{value:"getChildAt(index: number): Cell | null\n",paraId:307,tocIndex:91},{value:"Get the child node/edge at the specified index.",paraId:308,tocIndex:91},{value:"Name",paraId:309,tocIndex:91},{value:"Type",paraId:309,tocIndex:91},{value:"Required",paraId:309,tocIndex:91},{value:"Default",paraId:309,tocIndex:91},{value:"Description",paraId:309,tocIndex:91},{value:"index",paraId:309,tocIndex:91},{value:"number",paraId:309,tocIndex:91},{value:"",paraId:309,tocIndex:91},{value:"Index position.",paraId:309,tocIndex:91},{value:"getAncestors(options?: { deep?: boolean }): Cell[]\n",paraId:310,tocIndex:92},{value:"Get all ancestor nodes.",paraId:311,tocIndex:92},{value:"Name",paraId:312,tocIndex:92},{value:"Type",paraId:312,tocIndex:92},{value:"Required",paraId:312,tocIndex:92},{value:"Default",paraId:312,tocIndex:92},{value:"Description",paraId:312,tocIndex:92},{value:"options.deep",paraId:312,tocIndex:92},{value:"boolean",paraId:312,tocIndex:92},{value:"true",paraId:312,tocIndex:92},{value:"By default, recursively gets all ancestor nodes. Set to ",paraId:312,tocIndex:92},{value:"false",paraId:312,tocIndex:92},{value:" to only return the parent node.",paraId:312,tocIndex:92},{value:"getDescendants(options?: Cell.GetDescendantsOptions): Cell[]\n",paraId:313,tocIndex:93},{value:"Get all descendant nodes.",paraId:314,tocIndex:93},{value:"Name",paraId:315,tocIndex:93},{value:"Type",paraId:315,tocIndex:93},{value:"Required",paraId:315,tocIndex:93},{value:"Default",paraId:315,tocIndex:93},{value:"Description",paraId:315,tocIndex:93},{value:"options.deep",paraId:315,tocIndex:93},{value:"boolean",paraId:315,tocIndex:93},{value:"true",paraId:315,tocIndex:93},{value:"By default, recursively gets all descendant nodes. Set to ",paraId:315,tocIndex:93},{value:"false",paraId:315,tocIndex:93},{value:" to only return child nodes/edges.",paraId:315,tocIndex:93},{value:"options.breadthFirst",paraId:315,tocIndex:93},{value:"boolean",paraId:315,tocIndex:93},{value:"false",paraId:315,tocIndex:93},{value:"By default, uses depth-first algorithm. Set to ",paraId:315,tocIndex:93},{value:"true",paraId:315,tocIndex:93},{value:" to use breadth-first search algorithm.",paraId:315,tocIndex:93},{value:"Returns an array of descendant nodes/edges.",paraId:316,tocIndex:93},{value:"isDescendantOf(ancestor: Cell | null, options?: { deep?: boolean }): boolean\n",paraId:317,tocIndex:94},{value:"Returns whether the current node/edge is a descendant of the specified node.",paraId:318,tocIndex:94},{value:"Name",paraId:319,tocIndex:94},{value:"Type",paraId:319,tocIndex:94},{value:"Required",paraId:319,tocIndex:94},{value:"Default",paraId:319,tocIndex:94},{value:"Description",paraId:319,tocIndex:94},{value:"ancestor",paraId:319,tocIndex:94},{value:"Cell | null",paraId:319,tocIndex:94},{value:"",paraId:319,tocIndex:94},{value:"Specified node.",paraId:319,tocIndex:94},{value:"options.deep",paraId:319,tocIndex:94},{value:"boolean",paraId:319,tocIndex:94},{value:"true",paraId:319,tocIndex:94},{value:"By default, recursively checks all descendants of the specified node. Set to ",paraId:319,tocIndex:94},{value:"false",paraId:319,tocIndex:94},{value:" to only check children.",paraId:319,tocIndex:94},{value:"isAncestorOf(descendant: Cell | null, options?: { deep?: boolean }): boolean\n",paraId:320,tocIndex:95},{value:"Returns whether the current node is an ancestor of the specified node/edge.",paraId:321,tocIndex:95},{value:"Name",paraId:322,tocIndex:95},{value:"Type",paraId:322,tocIndex:95},{value:"Required",paraId:322,tocIndex:95},{value:"Default",paraId:322,tocIndex:95},{value:"Description",paraId:322,tocIndex:95},{value:"descendant",paraId:322,tocIndex:95},{value:"Cell | null",paraId:322,tocIndex:95},{value:"",paraId:322,tocIndex:95},{value:"Specified node/edge.",paraId:322,tocIndex:95},{value:"options.deep",paraId:322,tocIndex:95},{value:"boolean",paraId:322,tocIndex:95},{value:"true",paraId:322,tocIndex:95},{value:"By default, recursively checks all descendants of the specified node. Set to ",paraId:322,tocIndex:95},{value:"false",paraId:322,tocIndex:95},{value:" to only check children.",paraId:322,tocIndex:95},{value:"getCommonAncestor(...cells: (Cell | null | undefined)[]): Cell | null\n",paraId:323,tocIndex:96},{value:"Get the common ancestor nodes of the given nodes/edges.",paraId:324,tocIndex:96},{value:"Name",paraId:325,tocIndex:96},{value:"Type",paraId:325,tocIndex:96},{value:"Required",paraId:325,tocIndex:96},{value:"Default",paraId:325,tocIndex:96},{value:"Description",paraId:325,tocIndex:96},{value:"...cells",paraId:325,tocIndex:96},{value:"(Cell | null | undefined)[]",paraId:325,tocIndex:96},{value:"",paraId:325,tocIndex:96},{value:"Specified nodes/edges.",paraId:325,tocIndex:96},{value:"addChild(child: Cell, options?: Cell.SetOptions): this\n",paraId:326,tocIndex:97},{value:"Adds the specified node/edge to the end of the current node's children.",paraId:327,tocIndex:97},{value:"Name",paraId:328,tocIndex:97},{value:"Type",paraId:328,tocIndex:97},{value:"Required",paraId:328,tocIndex:97},{value:"Default",paraId:328,tocIndex:97},{value:"Description",paraId:328,tocIndex:97},{value:"child",paraId:328,tocIndex:97},{value:"Cell",paraId:328,tocIndex:97},{value:"",paraId:328,tocIndex:97},{value:"The specified node/edge.",paraId:328,tocIndex:97},{value:"options.silent",paraId:328,tocIndex:97},{value:"boolean",paraId:328,tocIndex:97},{value:"false",paraId:328,tocIndex:97},{value:"When ",paraId:328,tocIndex:97},{value:"true",paraId:328,tocIndex:97},{value:", does not trigger the ",paraId:328,tocIndex:97},{value:"change:children",paraId:328,tocIndex:97},{value:" event and canvas redraw.",paraId:328,tocIndex:97},{value:"options...others",paraId:328,tocIndex:97},{value:"object",paraId:328,tocIndex:97},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:328,tocIndex:97},{value:"removeChild(child: Cell, options?: Cell.RemoveOptions): Cell | null\n",paraId:329,tocIndex:98},{value:"Removes the specified child node/edge.",paraId:330,tocIndex:98},{value:"Name",paraId:331,tocIndex:98},{value:"Type",paraId:331,tocIndex:98},{value:"Required",paraId:331,tocIndex:98},{value:"Default",paraId:331,tocIndex:98},{value:"Description",paraId:331,tocIndex:98},{value:"child",paraId:331,tocIndex:98},{value:"Cell",paraId:331,tocIndex:98},{value:"",paraId:331,tocIndex:98},{value:"The specified node/edge.",paraId:331,tocIndex:98},{value:"options.deep",paraId:331,tocIndex:98},{value:"boolean",paraId:331,tocIndex:98},{value:"true",paraId:331,tocIndex:98},{value:"By default, recursively removes all child nodes/edges. Set to ",paraId:331,tocIndex:98},{value:"false",paraId:331,tocIndex:98},{value:" to only remove the current node/edge.",paraId:331,tocIndex:98},{value:"options.silent",paraId:331,tocIndex:98},{value:"boolean",paraId:331,tocIndex:98},{value:"false",paraId:331,tocIndex:98},{value:"When ",paraId:331,tocIndex:98},{value:"true",paraId:331,tocIndex:98},{value:", does not trigger the ",paraId:331,tocIndex:98},{value:"change:children",paraId:331,tocIndex:98},{value:" event and canvas redraw.",paraId:331,tocIndex:98},{value:"options...others",paraId:331,tocIndex:98},{value:"object",paraId:331,tocIndex:98},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:331,tocIndex:98},{value:"remove(options?: Cell.RemoveOptions): this\n",paraId:332,tocIndex:99},{value:"First removes the current node/edge from its parent node, then removes it from the canvas.",paraId:333,tocIndex:99},{value:"The basic options introduced above such as ",paraId:334,tocIndex:100},{value:"markup",paraId:334,tocIndex:100},{value:", ",paraId:334,tocIndex:100},{value:"attrs",paraId:334,tocIndex:100},{value:", ",paraId:334,tocIndex:100},{value:"zIndex",paraId:334,tocIndex:100},{value:", ",paraId:334,tocIndex:100},{value:"data",paraId:334,tocIndex:100},{value:", as well as node options like ",paraId:334,tocIndex:100},{value:"size",paraId:334,tocIndex:100},{value:", ",paraId:334,tocIndex:100},{value:"position",paraId:334,tocIndex:100},{value:", ",paraId:334,tocIndex:100},{value:"angle",paraId:334,tocIndex:100},{value:", ",paraId:334,tocIndex:100},{value:"ports",paraId:334,tocIndex:100},{value:", and edge options like ",paraId:334,tocIndex:100},{value:"source",paraId:334,tocIndex:100},{value:", ",paraId:334,tocIndex:100},{value:"target",paraId:334,tocIndex:100},{value:", ",paraId:334,tocIndex:100},{value:"labels",paraId:334,tocIndex:100},{value:", along with any additional key-value pairs provided when creating nodes/edges, are all called properties.",paraId:334,tocIndex:100},{value:"const rect = new Shape.Rect({\n  x: 30,\n  y: 30,\n  width: 100,\n  height: 40,\n  attrs: {...},\n  data: {...},\n  zIndex: 10,\n  sale: {...},\n  product: {\n    id: '1234',\n    name: 'apple',\n    price: 3.99,\n  },\n})\n",paraId:335,tocIndex:100},{value:"For example, in the code above, ",paraId:336,tocIndex:100},{value:"attrs",paraId:336,tocIndex:100},{value:", ",paraId:336,tocIndex:100},{value:"data",paraId:336,tocIndex:100},{value:", ",paraId:336,tocIndex:100},{value:"zIndex",paraId:336,tocIndex:100},{value:" are standard properties, while ",paraId:336,tocIndex:100},{value:"x",paraId:336,tocIndex:100},{value:" and ",paraId:336,tocIndex:100},{value:"y",paraId:336,tocIndex:100},{value:" are a pair of ",paraId:336,tocIndex:100},{value:"custom options",paraId:337,tocIndex:100},{value:" that are converted to the ",paraId:336,tocIndex:100},{value:"position",paraId:336,tocIndex:100},{value:" property during node initialization. Similarly, ",paraId:336,tocIndex:100},{value:"width",paraId:336,tocIndex:100},{value:" and ",paraId:336,tocIndex:100},{value:"height",paraId:336,tocIndex:100},{value:" are another pair of ",paraId:336,tocIndex:100},{value:"custom options",paraId:338,tocIndex:100},{value:" converted to the ",paraId:336,tocIndex:100},{value:"size",paraId:336,tocIndex:100},{value:" property during node initialization. The remaining ",paraId:336,tocIndex:100},{value:"sale",paraId:336,tocIndex:100},{value:" and ",paraId:336,tocIndex:100},{value:"product",paraId:336,tocIndex:100},{value:" objects are non-standard properties.",paraId:336,tocIndex:100},{value:"We've introduced some standard properties and methods to operate (get/set) these standard properties above. Now let's introduce a few more general methods that apply to both standard and non-standard properties.",paraId:339,tocIndex:100},{value:"Gets the value of the specified property.",paraId:340,tocIndex:101},{value:"getProp<T>(key: string, defaultValue?: T): T\n",paraId:341,tocIndex:101},{value:"Name",paraId:342,tocIndex:101},{value:"Type",paraId:342,tocIndex:101},{value:"Required",paraId:342,tocIndex:101},{value:"Default",paraId:342,tocIndex:101},{value:"Description",paraId:342,tocIndex:101},{value:"key",paraId:342,tocIndex:101},{value:"string",paraId:342,tocIndex:101},{value:"",paraId:342,tocIndex:101},{value:"Property name.",paraId:342,tocIndex:101},{value:"defaultValue",paraId:342,tocIndex:101},{value:"T",paraId:342,tocIndex:101},{value:"-",paraId:342,tocIndex:101},{value:"Default value, returned when the specified property doesn't exist.",paraId:342,tocIndex:101},{value:"// Get standard properties\nconst zIndex = rect.getProp<number>('zIndex')\nconst position = rect.getProp<{ x: number; y: number }>('position')\n\n// Get non-standard properties\nconst product = rect.getProp('product')\n",paraId:343,tocIndex:101},{value:"Sets the specified property. By default, it triggers the corresponding ",paraId:344,tocIndex:102},{value:"change:xxx",paraId:344,tocIndex:102},{value:" event and canvas redraw. When ",paraId:344,tocIndex:102},{value:"options.silent",paraId:344,tocIndex:102},{value:" is ",paraId:344,tocIndex:102},{value:"true",paraId:344,tocIndex:102},{value:", it doesn't trigger.",paraId:344,tocIndex:102},{value:"// Set a specific property\nsetProp(key: string, value: any, options?: Cell.SetOptions): this\n// Batch set properties, deeply merging the provided properties with the original properties. Note that using this method will trigger propHooks calls\nsetProp(props: Partial<Properties>, options?: Cell.SetOptions): this\n",paraId:345,tocIndex:102},{value:"Name",paraId:346,tocIndex:102},{value:"Type",paraId:346,tocIndex:102},{value:"Required",paraId:346,tocIndex:102},{value:"Default",paraId:346,tocIndex:102},{value:"Description",paraId:346,tocIndex:102},{value:"key",paraId:346,tocIndex:102},{value:"string",paraId:346,tocIndex:102},{value:"",paraId:346,tocIndex:102},{value:"Property name.",paraId:346,tocIndex:102},{value:"value",paraId:346,tocIndex:102},{value:"any",paraId:346,tocIndex:102},{value:"",paraId:346,tocIndex:102},{value:"Property value.",paraId:346,tocIndex:102},{value:"props",paraId:346,tocIndex:102},{value:"Partial<Properties>",paraId:346,tocIndex:102},{value:"",paraId:346,tocIndex:102},{value:"Property key-value pairs, which will be ",paraId:346,tocIndex:102},{value:"deeply merged",paraId:346,tocIndex:102},{value:" with existing properties.",paraId:346,tocIndex:102},{value:"options.silent",paraId:346,tocIndex:102},{value:"boolean",paraId:346,tocIndex:102},{value:"false",paraId:346,tocIndex:102},{value:"When ",paraId:346,tocIndex:102},{value:"true",paraId:346,tocIndex:102},{value:", does not trigger the ",paraId:346,tocIndex:102},{value:"change:markup",paraId:346,tocIndex:102},{value:" event and canvas redraw.",paraId:346,tocIndex:102},{value:"options...others",paraId:346,tocIndex:102},{value:"object",paraId:346,tocIndex:102},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:346,tocIndex:102},{value:"// Set a single property:\nrect.setProp('size', { width: 100, height: 30 })\nrect.setProp('zIndex', 10)\n\n// Set multiple properties simultaneously\nrect.setProp({\n  size: {\n    width: 100,\n    height: 30,\n  },\n  zIndex: 10,\n})\n",paraId:347,tocIndex:102},{value:"Removes the property at the specified path. By default, it triggers the corresponding ",paraId:348,tocIndex:103},{value:"change:xxx",paraId:348,tocIndex:103},{value:" event and canvas redraw. When ",paraId:348,tocIndex:103},{value:"options.silent",paraId:348,tocIndex:103},{value:" is ",paraId:348,tocIndex:103},{value:"true",paraId:348,tocIndex:103},{value:", it doesn't trigger.",paraId:348,tocIndex:103},{value:"removeProp(path: string | string[], options?: Cell.SetOptions): this\n",paraId:349,tocIndex:103},{value:"Name",paraId:350,tocIndex:103},{value:"Type",paraId:350,tocIndex:103},{value:"Required",paraId:350,tocIndex:103},{value:"Default",paraId:350,tocIndex:103},{value:"Description",paraId:350,tocIndex:103},{value:"path",paraId:350,tocIndex:103},{value:"string | string[]",paraId:350,tocIndex:103},{value:"",paraId:350,tocIndex:103},{value:"Property path.",paraId:350,tocIndex:103},{value:"options.silent",paraId:350,tocIndex:103},{value:"boolean",paraId:350,tocIndex:103},{value:"false",paraId:350,tocIndex:103},{value:"When ",paraId:350,tocIndex:103},{value:"true",paraId:350,tocIndex:103},{value:", does not trigger the ",paraId:350,tocIndex:103},{value:"change:markup",paraId:350,tocIndex:103},{value:" event and canvas redraw.",paraId:350,tocIndex:103},{value:"options...others",paraId:350,tocIndex:103},{value:"object",paraId:350,tocIndex:103},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:350,tocIndex:103},{value:"rect.removeProp('zIndex')\nrect.removeProp('product/id')\n",paraId:351,tocIndex:103},{value:"This method integrates the above methods and provides four function signatures, making it a very practical method.",paraId:352,tocIndex:104},{value:"prop(): Properties // Get all properties.\nprop<T>(path: string | string[]): T // Get the property value at the specified path.\nprop(path: string | string[], value: any, options?: Cell.SetOptions): this // Set the property value at the specified path, deeply merging with existing properties on the path.\nprop(props: Partial<Properties>, options?: Cell.SetOptions): this // Set properties, deeply merging with existing properties.\n",paraId:353,tocIndex:104},{value:"// Get properties:\nrect.prop()\nrect.prop('zIndex')\nrect.prop('product/price')\n\n// Set properties:\nrect.prop('zIndex', 10)\nrect.prop('product/price', 5.99)\nrect.prop({\n  product: {\n    id: '234',\n    name: 'banana',\n    price: 3.99,\n  },\n})\n",paraId:354,tocIndex:104},{value:"hasChanged(key: string | undefined | null): boolean\n",paraId:355,tocIndex:105},{value:"Returns whether the specified property or all properties have changed.",paraId:356,tocIndex:105},{value:"Name",paraId:357,tocIndex:105},{value:"Type",paraId:357,tocIndex:105},{value:"Required",paraId:357,tocIndex:105},{value:"Default",paraId:357,tocIndex:105},{value:"Description",paraId:357,tocIndex:105},{value:"key",paraId:357,tocIndex:105},{value:"string | undefined | null",paraId:357,tocIndex:105},{value:"Property name. When omitted, it checks all properties.",paraId:357,tocIndex:105},{value:"previous<T>(name: string): T | undefined\n",paraId:358,tocIndex:106},{value:"After a specified property has changed, get the property value before the change.",paraId:359,tocIndex:106},{value:"Name",paraId:360,tocIndex:106},{value:"Type",paraId:360,tocIndex:106},{value:"Required",paraId:360,tocIndex:106},{value:"Default",paraId:360,tocIndex:106},{value:"Description",paraId:360,tocIndex:106},{value:"key",paraId:360,tocIndex:106},{value:"string",paraId:360,tocIndex:106},{value:"",paraId:360,tocIndex:106},{value:"Property name.",paraId:360,tocIndex:106},{value:"addTools(\n  items: Cell.ToolItem | Cell.ToolItem[],\n  options?: Cell.AddToolOptions,\n): this\naddTools(\n  items: Cell.ToolItem | Cell.ToolItem[],\n  name: string,\n  options?: Cell.AddToolOptions,\n): this\n",paraId:361,tocIndex:108},{value:"Add tools.",paraId:362,tocIndex:108},{value:"Name",paraId:363,tocIndex:108},{value:"Type",paraId:363,tocIndex:108},{value:"Required",paraId:363,tocIndex:108},{value:"Default",paraId:363,tocIndex:108},{value:"Description",paraId:363,tocIndex:108},{value:"items",paraId:363,tocIndex:108},{value:"Cell.ToolItem | Cell.ToolItem[]",paraId:363,tocIndex:108},{value:"Tools defined in ",paraId:363,tocIndex:108},{value:"NodeTool",paraId:364,tocIndex:108},{value:" or ",paraId:363,tocIndex:108},{value:"EdgeTool",paraId:365,tocIndex:108},{value:".",paraId:363,tocIndex:108},{value:"name",paraId:363,tocIndex:108},{value:"string",paraId:363,tocIndex:108},{value:"null",paraId:363,tocIndex:108},{value:"Define an alias for this group of tools, which can be used as a parameter for ",paraId:363,tocIndex:108},{value:"hasTools(name)",paraId:363,tocIndex:108},{value:"options.reset",paraId:363,tocIndex:108},{value:"boolean",paraId:363,tocIndex:108},{value:"false",paraId:363,tocIndex:108},{value:"Whether to clear the tool set. By default, tools are appended to the tool set.",paraId:363,tocIndex:108},{value:"options.local",paraId:363,tocIndex:108},{value:"boolean",paraId:363,tocIndex:108},{value:"false",paraId:363,tocIndex:108},{value:"Whether the tool is rendered in the node/edge container. By default, it's ",paraId:363,tocIndex:108},{value:"false",paraId:363,tocIndex:108},{value:", and all tools are rendered under ",paraId:363,tocIndex:108},{value:"x6-graph-svg-decorator",paraId:363,tocIndex:108},{value:". Only takes effect when ",paraId:363,tocIndex:108},{value:"options.reset",paraId:363,tocIndex:108},{value:" is ",paraId:363,tocIndex:108},{value:"true",paraId:363,tocIndex:108},{value:"options.silent",paraId:363,tocIndex:108},{value:"boolean",paraId:363,tocIndex:108},{value:"false",paraId:363,tocIndex:108},{value:"When ",paraId:363,tocIndex:108},{value:"true",paraId:363,tocIndex:108},{value:", does not trigger the ",paraId:363,tocIndex:108},{value:"change:tools",paraId:363,tocIndex:108},{value:" event and tool redraw.",paraId:363,tocIndex:108},{value:"options...others",paraId:363,tocIndex:108},{value:"object",paraId:363,tocIndex:108},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:363,tocIndex:108},{value:"getTools(): Cell.Tools | null\n",paraId:366,tocIndex:109},{value:"Get the tool set.",paraId:367,tocIndex:109},{value:"removeTools(options?: Cell.SetOptions): this\n",paraId:368,tocIndex:110},{value:"Remove all tools.",paraId:369,tocIndex:110},{value:"Name",paraId:370,tocIndex:110},{value:"Type",paraId:370,tocIndex:110},{value:"Required",paraId:370,tocIndex:110},{value:"Default",paraId:370,tocIndex:110},{value:"Description",paraId:370,tocIndex:110},{value:"options.silent",paraId:370,tocIndex:110},{value:"boolean",paraId:370,tocIndex:110},{value:"false",paraId:370,tocIndex:110},{value:"When ",paraId:370,tocIndex:110},{value:"true",paraId:370,tocIndex:110},{value:", does not trigger the ",paraId:370,tocIndex:110},{value:"change:tools",paraId:370,tocIndex:110},{value:" event and tool redraw.",paraId:370,tocIndex:110},{value:"options...others",paraId:370,tocIndex:110},{value:"object",paraId:370,tocIndex:110},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:370,tocIndex:110},{value:"hasTool(name: string): boolean\n",paraId:371,tocIndex:111},{value:"Check if a tool with the specified name exists.",paraId:372,tocIndex:111},{value:"removeTool(name: string, options?: Cell.SetOptions): this\nremoveTool(index: number, options?: Cell.SetOptions): this\n",paraId:373,tocIndex:112},{value:"Removes a tool with the specified name.",paraId:374,tocIndex:112},{value:"Name",paraId:375,tocIndex:112},{value:"Type",paraId:375,tocIndex:112},{value:"Required",paraId:375,tocIndex:112},{value:"Default",paraId:375,tocIndex:112},{value:"Description",paraId:375,tocIndex:112},{value:"nameOrIndex",paraId:375,tocIndex:112},{value:"string | number",paraId:375,tocIndex:112},{value:"",paraId:375,tocIndex:112},{value:"The name or index of the tool.",paraId:375,tocIndex:112},{value:"options.silent",paraId:375,tocIndex:112},{value:"boolean",paraId:375,tocIndex:112},{value:"false",paraId:375,tocIndex:112},{value:"If ",paraId:375,tocIndex:112},{value:"true",paraId:375,tocIndex:112},{value:", doesn't trigger the ",paraId:375,tocIndex:112},{value:"change:tools",paraId:375,tocIndex:112},{value:" event and tool redraw.",paraId:375,tocIndex:112},{value:"options...others",paraId:375,tocIndex:112},{value:"object",paraId:375,tocIndex:112},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:375,tocIndex:112},{value:"config<C extends Cell.Config = Cell.Config>(presets: C): void\n",paraId:376,tocIndex:113},{value:"Sets the default values for node/edge options.",paraId:377,tocIndex:113},{value:"Name",paraId:378,tocIndex:113},{value:"Type",paraId:378,tocIndex:113},{value:"Required",paraId:378,tocIndex:113},{value:"Default",paraId:378,tocIndex:113},{value:"Description",paraId:378,tocIndex:113},{value:"options.propHooks",paraId:378,tocIndex:113},{value:"Cell.PropHooks<M, C>",paraId:378,tocIndex:113},{value:"Custom options.",paraId:378,tocIndex:113},{value:"options.attrHooks",paraId:378,tocIndex:113},{value:"Attr.Definitions",paraId:378,tocIndex:113},{value:"Custom attribute key-value pairs. Key is the name of the custom attribute, Value is the custom attribute object (including methods for attribute checking, applying attributes, etc.).",paraId:378,tocIndex:113},{value:"options...others",paraId:378,tocIndex:113},{value:"object",paraId:378,tocIndex:113},{value:"Other options, properties of nodes/edges.",paraId:378,tocIndex:113},{value:"This method is very friendly for custom nodes/edges, making it convenient for us to set some preset options for our nodes/edges. For example, when defining a rectangle node, we specified the default Markup, default size, and default style for it.",paraId:379,tocIndex:114},{value:"Shape.Rect.config({\n  width: 80,\n  height: 40,\n  markup: ...,\n  attrs: ...,\n})\n",paraId:380,tocIndex:114},{value:"Our code for creating rectangles can be very simple:",paraId:381,tocIndex:114},{value:"const rect = graph.addNode({\n  x: 100,\n  y: 100,\n  attrs: {\n    label: {\n      text: 'rect',\n    },\n  },\n})\n",paraId:382,tocIndex:114},{value:"Each call to ",paraId:383,tocIndex:114},{value:"config(presets)",paraId:383,tocIndex:114},{value:" performs a ",paraId:383,tocIndex:114},{value:"deep merge",paraId:383,tocIndex:114},{value:" with the current preset values. For example, the following code modifies the default border color of the rectangle to red and the default text color to blue, respectively. The final effect is the combination of both:",paraId:383,tocIndex:114},{value:"// Only modify the default border color\nShape.Rect.config({\n  attrs: {\n    body: {\n      stroke: 'red',\n    },\n  },\n})\n\n// Only modify the default text color\nShape.Rect.config({\n  attrs: {\n    label: {\n      fill: 'blue',\n      // Override the 'red' defined above\n      stroke: '#000',\n    },\n  },\n})\n",paraId:384,tocIndex:114},{value:"When creating a rectangle, we can use ",paraId:385,tocIndex:115},{value:"label",paraId:385,tocIndex:115},{value:" to set the label text of the rectangle:",paraId:385,tocIndex:115},{value:"const rect = graph.addNode({\n  x: 100,\n  y: 100,\n  label: 'rect',\n})\n",paraId:386,tocIndex:115},{value:"We didn't define the ",paraId:387,tocIndex:115},{value:"label",paraId:387,tocIndex:115},{value:" option for the rectangle, so how is this ",paraId:387,tocIndex:115},{value:"label",paraId:387,tocIndex:115},{value:" applied to ",paraId:387,tocIndex:115},{value:"attrs/label/text",paraId:387,tocIndex:115},{value:"? This is where the ",paraId:387,tocIndex:115},{value:"propHooks",paraId:387,tocIndex:115},{value:" hook comes in. We can define ",paraId:387,tocIndex:115},{value:"propHooks",paraId:387,tocIndex:115},{value:" hooks to consume these non-standard options.",paraId:387,tocIndex:115},{value:"Let's look at the implementation details of the ",paraId:388,tocIndex:115},{value:"label",paraId:388,tocIndex:115},{value:" option hook:",paraId:388,tocIndex:115},{value:"Shape.Rect.config({\n  // Apply 'label' to the 'attrs/text/text' property through the hook\n  propHooks(metadata) {\n    const { label, ...others } = metadata\n    if (label) {\n      ObjectExt.setByPath(others, 'attrs/text/text', label)\n    }\n    return others\n  },\n})\n",paraId:389,tocIndex:115},{value:"Through the ",paraId:390,tocIndex:115},{value:"propHooks",paraId:390,tocIndex:115},{value:" hook, we can easily extend some custom options. For example, we can define certain styles as options for the node, which not only reduces nesting but also makes the code for creating nodes more semantic.",paraId:390,tocIndex:115},{value:"Look at the following code, which defines custom ",paraId:391,tocIndex:115},{value:"rx",paraId:391,tocIndex:115},{value:" and ",paraId:391,tocIndex:115},{value:"ry",paraId:391,tocIndex:115},{value:" options for rectangles:",paraId:391,tocIndex:115},{value:"Shape.Rect.config({\n  propHooks: {\n    rx(metadata) {\n      const { rx, ...others } = metadata\n      if (rx != null) {\n        ObjectExt.setByPath(others, 'attrs/body/rx', rx)\n      }\n      return others\n    },\n    ry(metadata) {\n      const { ry, ...others } = metadata\n      if (ry != null) {\n        ObjectExt.setByPath(others, 'attrs/body/ry', ry)\n      }\n      return others\n    },\n  },\n})\n",paraId:392,tocIndex:115},{value:"This way, we can easily add rounded rectangles:",paraId:393,tocIndex:115},{value:"const rect = graph.addNode({\n  x: 100,\n  y: 100,\n  rx: 5,\n  ry: 10,\n  label: 'rect',\n})\n",paraId:394,tocIndex:115},{value:"Custom attributes refer to non-standard SVG/HTML attributes, such as built-in system attributes like ",paraId:395,tocIndex:116},{value:"refWidth",paraId:395,tocIndex:116},{value:", ",paraId:395,tocIndex:116},{value:"refHeight",paraId:395,tocIndex:116},{value:", ",paraId:395,tocIndex:116},{value:"sourceMarker",paraId:395,tocIndex:116},{value:", ",paraId:395,tocIndex:116},{value:"targetMarker",paraId:395,tocIndex:116},{value:", etc. These attributes are globally shared, and we can use the ",paraId:395,tocIndex:116},{value:"attrHooks",paraId:395,tocIndex:116},{value:" hook to define ",paraId:395,tocIndex:116},{value:"exclusive",paraId:395,tocIndex:116},{value:" custom attributes for nodes/edges.",paraId:395,tocIndex:116},{value:"For example:",paraId:396,tocIndex:116},{value:"import { Shape, Color } from '@antv/x6'\n\nShape.Rect.config({\n  attrHooks: {\n    fill: {\n      set(val) {\n        return Color.invert(val) // Automatically invert the fill color\n      },\n    },\n    theme: {\n      set(val) {\n        // Set both fill color and border color simultaneously\n        return {\n          fill: val,\n          stroke: Color.invert(val),\n        }\n      },\n    },\n  },\n})\n",paraId:397,tocIndex:116},{value:"We can use the ",paraId:398,tocIndex:116},{value:"fill",paraId:398,tocIndex:116},{value:" and ",paraId:398,tocIndex:116},{value:"theme",paraId:398,tocIndex:116},{value:" attributes defined above like this:",paraId:398,tocIndex:116},{value:"const rect = graph.addNode({\n  x: 100,\n  y: 100,\n  rx: 5,\n  ry: 10,\n  label: 'rect',\n  attrs: {\n    body: {\n      theme: '#f5f5f5',\n    },\n    label: {\n      fill: '#fff',\n    },\n  },\n})\n",paraId:399,tocIndex:116},{value:"We provide a static method ",paraId:400,tocIndex:118},{value:"generateId",paraId:400,tocIndex:118},{value:" on the Cell base class to quickly implement custom node/edge IDs.",paraId:400,tocIndex:118},{value:"generateId(metadata: Cell.Metadata): string\n",paraId:401,tocIndex:118},{value:"For example:",paraId:402,tocIndex:118},{value:"import { Cell } from '@antv/x6'\n\nlet sid = 0\nCell.generateId = ({ shape }) => {\n  return `${shape}_${sid++}`\n}\n",paraId:403,tocIndex:118}]},16789:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(55444);const n=[{value:"Edge is the base class for edges, inheriting from ",paraId:0},{value:"Cell",paraId:1},{value:", and defines the common properties and methods for edges.",paraId:0},{value:"In addition to inheriting from Cell ",paraId:2,tocIndex:0},{value:"attributes",paraId:3,tocIndex:0},{value:", the following attributes are also supported.",paraId:2,tocIndex:0},{value:"Option",paraId:4,tocIndex:0},{value:"Type",paraId:4,tocIndex:0},{value:"Default Value",paraId:4,tocIndex:0},{value:"Required",paraId:4,tocIndex:0},{value:"Description",paraId:4,tocIndex:0},{value:"source",paraId:4,tocIndex:0},{value:"TerminalData",paraId:4,tocIndex:0},{value:"Starting point or source node, connection point information.",paraId:4,tocIndex:0},{value:"target",paraId:4,tocIndex:0},{value:"TerminalData",paraId:4,tocIndex:0},{value:"End point or target node, connection point information.",paraId:4,tocIndex:0},{value:"vertices",paraId:4,tocIndex:0},{value:"Point.PointLike[]",paraId:4,tocIndex:0},{value:"Path points.",paraId:4,tocIndex:0},{value:"router",paraId:4,tocIndex:0},{value:"RouterData",paraId:4,tocIndex:0},{value:"Routing.",paraId:4,tocIndex:0},{value:"connector",paraId:4,tocIndex:0},{value:"ConnectorData",paraId:4,tocIndex:0},{value:"Connector.",paraId:4,tocIndex:0},{value:"labels",paraId:4,tocIndex:0},{value:"Label[] | string[]",paraId:4,tocIndex:0},{value:"Labels.",paraId:4,tocIndex:0},{value:"defaultLabel",paraId:4,tocIndex:0},{value:"Label",paraId:4,tocIndex:0},{value:"Default label.",paraId:4,tocIndex:0},{value:"Setting the starting/ending point or source/target node of an edge can be categorized into the following situations:",paraId:5,tocIndex:1},{value:"Connecting to a point on the canvas",paraId:6,tocIndex:1},{value:"const edge = graph.addEdge({\n  source: { x: 40, y: 40 },\n  target: { x: 180, y: 80 },\n})\n",paraId:7,tocIndex:1},{value:"Connecting to nodes/edges",paraId:6,tocIndex:1},{value:"const edge = graph.addEdge({\n  source: { cell: 'source-cell-id' },\n  target: { cell: 'target-cell-id' },\n})\n",paraId:8,tocIndex:1},{value:"Connecting to connection points on nodes",paraId:6,tocIndex:1},{value:"const edge = graph.addEdge({\n  source: { cell: 'source-cell-id', port: 'port-id' },\n  target: { cell: 'target-cell-id', port: 'port-id' },\n})\n",paraId:9,tocIndex:1},{value:"Connecting to specific elements on nodes",paraId:6,tocIndex:1},{value:"const edge = graph.addEdge({\n  source: { cell: 'source-cell-id', selector: 'some-selector' },\n  target: { cell: 'target-cell-id', selector: 'some-selector' },\n})\n",paraId:10,tocIndex:1},{value:"Additionally, the edge's ",paraId:11,tocIndex:1},{value:"anchor points",paraId:12,tocIndex:1},{value:" and ",paraId:11,tocIndex:1},{value:"connection points",paraId:13,tocIndex:1},{value:" options together determine the starting and ending points of the edge.",paraId:11,tocIndex:1},{value:"Starting Point: A reference line is drawn from the first path point or the center of the target node (if there are no path points) to the anchor point of the source node. Then, based on the intersection calculation method specified by the connectionPoint, the intersection of the reference line and the shape is calculated, which becomes the starting point of the edge.",paraId:14,tocIndex:1},{value:"Ending Point: A reference line is drawn from the last path point or the center of the source node (if there are no path points) to the anchor point of the target node. Then, based on the intersection calculation method specified by the connectionPoint, the intersection of the reference line and the shape is calculated, which becomes the ending point of the edge.",paraId:14,tocIndex:1},{value:"When creating an edge, you can specify anchor points and connection points for ",paraId:15,tocIndex:1},{value:"source",paraId:15,tocIndex:1},{value:" and ",paraId:15,tocIndex:1},{value:"target",paraId:15,tocIndex:1},{value:" separately.",paraId:15,tocIndex:1},{value:"Specifying Anchor Points",paraId:16,tocIndex:1},{value:"const edge = graph.addEdge({\n  source: {\n    cell: 'source-id',\n    anchor: {\n      name: 'midSide',\n      args: {\n        dx: 10,\n      },\n    },\n  },\n  target: {\n    cell: 'target-id',\n    anchor: 'orth', // Can be simplified when there are no parameters\n  },\n})\n",paraId:17,tocIndex:1},{value:"Specifying Connection Points",paraId:16,tocIndex:1},{value:"const edge = graph.addEdge({\n  source: {\n    cell: 'source-id',\n    connectionPoint: {\n      name: 'boundary',\n      args: {\n        sticky: true,\n      },\n    },\n  },\n  target: {\n    cell: 'target-id',\n    connectionPoint: 'boundary', // Can be simplified when there are no parameters\n  },\n})\n",paraId:18,tocIndex:1},{value:"The path points ",paraId:19,tocIndex:2},{value:"vertices",paraId:19,tocIndex:2},{value:" is an array of points. The edge starts from the starting point, passes through the path points in order, and finally reaches the end point.",paraId:19,tocIndex:2},{value:"const edge = graph.addEdge({\n  source,\n  target,\n  vertices: [\n    { x: 100, y: 200 },\n    { x: 300, y: 120 },\n  ],\n})\n",paraId:20,tocIndex:2},{value:"The router ",paraId:21,tocIndex:3},{value:"router",paraId:21,tocIndex:3},{value:" will further process the ",paraId:21,tocIndex:3},{value:"vertices",paraId:21,tocIndex:3},{value:", adding additional points if necessary, and return the processed points (excluding the starting and ending points of the edge). For example, after processing with the ",paraId:21,tocIndex:3},{value:"orth",paraId:22,tocIndex:3},{value:" router, each link segment of the edge is either horizontal or vertical.",paraId:21,tocIndex:3},{value:"We provide the following default routers.",paraId:23,tocIndex:3},{value:"Router Name",paraId:24,tocIndex:3},{value:"Description",paraId:24,tocIndex:3},{value:"normal",paraId:24,tocIndex:3},{value:"Default router",paraId:25,tocIndex:3},{value:", returns the path points as is.",paraId:24,tocIndex:3},{value:"orth",paraId:24,tocIndex:3},{value:"Orthogonal router",paraId:26,tocIndex:3},{value:", consists of horizontal or vertical orthogonal segments.",paraId:24,tocIndex:3},{value:"oneSide",paraId:24,tocIndex:3},{value:"Restricted orthogonal router",paraId:27,tocIndex:3},{value:", consists of three restricted horizontal or vertical orthogonal segments.",paraId:24,tocIndex:3},{value:"manhattan",paraId:24,tocIndex:3},{value:"Smart orthogonal router",paraId:28,tocIndex:3},{value:", consists of horizontal or vertical orthogonal segments and automatically avoids other nodes (obstacles) along the path.",paraId:24,tocIndex:3},{value:"metro",paraId:24,tocIndex:3},{value:"Smart subway line router",paraId:29,tocIndex:3},{value:", consists of horizontal or vertical orthogonal segments and diagonal segments, similar to a subway map, and automatically avoids other nodes (obstacles) along the path.",paraId:24,tocIndex:3},{value:"er",paraId:24,tocIndex:3},{value:"Entity-relationship router",paraId:30,tocIndex:3},{value:", consists of ",paraId:24,tocIndex:3},{value:"Z",paraId:24,tocIndex:3},{value:" shaped diagonal segments.",paraId:24,tocIndex:3},{value:"You can specify the router name ",paraId:31,tocIndex:3},{value:"name",paraId:31,tocIndex:3},{value:" and router parameters ",paraId:31,tocIndex:3},{value:"args",paraId:31,tocIndex:3},{value:" like this:",paraId:31,tocIndex:3},{value:"const edge = graph.addEdge({\n  source,\n  target,\n  vertices: [\n    { x: 100, y: 200 },\n    { x: 300, y: 120 },\n  ],\n  router: {\n    name: 'orth',\n    args: {\n      padding: 10,\n    },\n  },\n})\n",paraId:32,tocIndex:3},{value:"When there are no router parameters ",paraId:33,tocIndex:3},{value:"args",paraId:33,tocIndex:3},{value:", it can also be simplified to:",paraId:33,tocIndex:3},{value:"const edge = graph.addEdge({\n  source,\n  target,\n  vertices: [\n    { x: 100, y: 200 },\n    { x: 300, y: 120 },\n  ],\n  router: 'orth',\n})\n",paraId:34,tocIndex:3},{value:"In addition to the built-in routers mentioned above, we can also create custom routers and register them for use. For more details, please refer to the ",paraId:35,tocIndex:3},{value:"Custom Router",paraId:36,tocIndex:3},{value:" tutorial.",paraId:35,tocIndex:3},{value:"The connector processes the starting point, the points returned by the router, and the ending point into the ",paraId:37,tocIndex:4},{value:"d",paraId:37,tocIndex:4},{value:" attribute of the ",paraId:37,tocIndex:4},{value:"<path>",paraId:37,tocIndex:4},{value:" element, which determines the style of the edge rendered on the canvas.",paraId:37,tocIndex:4},{value:"We provide the following default connectors.",paraId:38,tocIndex:4},{value:"Connector Name",paraId:39,tocIndex:4},{value:"Description",paraId:39,tocIndex:4},{value:"normal",paraId:39,tocIndex:4},{value:"Simple connector",paraId:40,tocIndex:4},{value:", connects the starting point, routing points, and ending point with straight lines.",paraId:39,tocIndex:4},{value:"smooth",paraId:39,tocIndex:4},{value:"Smooth connector",paraId:41,tocIndex:4},{value:", connects the starting point, routing points, and ending point with cubic Bezier curves.",paraId:39,tocIndex:4},{value:"rounded",paraId:39,tocIndex:4},{value:"Rounded connector",paraId:42,tocIndex:4},{value:", connects the starting point, routing points, and ending point with straight lines and uses arcs to link at the segment connections (rounded corners).",paraId:39,tocIndex:4},{value:"jumpover",paraId:39,tocIndex:4},{value:"Jump line connector",paraId:43,tocIndex:4},{value:", connects the starting point, routing points, and ending point with straight lines and uses jump line symbols at the intersections of edges.",paraId:39,tocIndex:4},{value:"You can specify the connector name ",paraId:44,tocIndex:4},{value:"name",paraId:44,tocIndex:4},{value:" and connector parameters ",paraId:44,tocIndex:4},{value:"args",paraId:44,tocIndex:4},{value:" like this:",paraId:44,tocIndex:4},{value:"const edge = graph.addEdge({\n  source,\n  target,\n  vertices: [\n    { x: 100, y: 200 },\n    { x: 300, y: 120 },\n  ],\n  connector: {\n    name: 'rounded',\n    args: {\n      radius: 20,\n    },\n  },\n})\n",paraId:45,tocIndex:4},{value:"When there are no connector parameters ",paraId:46,tocIndex:4},{value:"args",paraId:46,tocIndex:4},{value:", it can also be simplified to:",paraId:46,tocIndex:4},{value:"const edge = graph.addEdge({\n  source,\n  target,\n  vertices: [\n    { x: 100, y: 200 },\n    { x: 300, y: 120 },\n  ],\n  connector: 'rounded',\n})\n",paraId:47,tocIndex:4},{value:"In addition to the built-in connectors mentioned above, we can also create custom connectors and register them for use. For more details, please refer to the ",paraId:48,tocIndex:4},{value:"Custom Connector",paraId:49,tocIndex:4},{value:" tutorial.",paraId:48,tocIndex:4},{value:"Due to the flexibility of label configuration, we provide a separate tutorial to explain how to use labels. For details, please refer to the ",paraId:50,tocIndex:5},{value:"Using Labels",paraId:51,tocIndex:5},{value:" tutorial.",paraId:50,tocIndex:5},{value:"isEdge(): true\n",paraId:52,tocIndex:8},{value:"Determines if it is an edge; this method always returns ",paraId:53,tocIndex:8},{value:"true",paraId:53,tocIndex:8},{value:".",paraId:53,tocIndex:8},{value:"getBBox(): Rectangle\n",paraId:54,tocIndex:9},{value:"Returns the bounding box of the edge.",paraId:55,tocIndex:9},{value:"getPolyline(): Polyline\n",paraId:56,tocIndex:10},{value:"Returns the line segments composed of endpoints and path points.",paraId:57,tocIndex:10},{value:"hasLoop(options: { deep?: boolean }): boolean\n",paraId:58,tocIndex:11},{value:"Checks if it contains a loop link.",paraId:59,tocIndex:11},{value:"Name",paraId:60,tocIndex:11},{value:"Type",paraId:60,tocIndex:11},{value:"Required",paraId:60,tocIndex:11},{value:"Default Value",paraId:60,tocIndex:11},{value:"Description",paraId:60,tocIndex:11},{value:"options.deep",paraId:60,tocIndex:11},{value:"boolean",paraId:60,tocIndex:11},{value:"false",paraId:60,tocIndex:11},{value:"Whether to perform nested checks.",paraId:60,tocIndex:11},{value:"When ",paraId:61,tocIndex:11},{value:"options.deep",paraId:61,tocIndex:11},{value:" is ",paraId:61,tocIndex:11},{value:"false",paraId:61,tocIndex:11},{value:", it indicates that it is a loop connection only if the starting node and the ending node are the same node.",paraId:61,tocIndex:11},{value:"When ",paraId:61,tocIndex:11},{value:"options.deep",paraId:61,tocIndex:11},{value:" is ",paraId:61,tocIndex:11},{value:"true",paraId:61,tocIndex:11},{value:", it indicates that it is a loop connection if the starting node and the ending node are the same node or if there is a parent-child nesting relationship between the starting node and the ending node.",paraId:61,tocIndex:11},{value:"getSource(): Edge.TerminalData\n",paraId:62,tocIndex:13},{value:"Gets the starting node/start point information of the edge.",paraId:63,tocIndex:13},{value:"getSourceCell(): Cell | null\n",paraId:64,tocIndex:14},{value:"Gets the starting node/edge of the edge; returns ",paraId:65,tocIndex:14},{value:"null",paraId:65,tocIndex:14},{value:" if not connected to a node/edge.",paraId:65,tocIndex:14},{value:"getSourceNode(): Node | null\n",paraId:66,tocIndex:15},{value:"Gets the starting node of the edge; returns ",paraId:67,tocIndex:15},{value:"null",paraId:67,tocIndex:15},{value:" if not connected to a node.",paraId:67,tocIndex:15},{value:"getSourceCellId(): string | null\n",paraId:68,tocIndex:16},{value:"Gets the ID of the starting node/edge of the edge; returns ",paraId:69,tocIndex:16},{value:"null",paraId:69,tocIndex:16},{value:" if not connected to a node/edge.",paraId:69,tocIndex:16},{value:"getSourcePortId(): string | null\n",paraId:70,tocIndex:17},{value:"Gets the ID of the starting connection point; returns ",paraId:71,tocIndex:17},{value:"null",paraId:71,tocIndex:17},{value:" if not connected to a connection point.",paraId:71,tocIndex:17},{value:"getSourcePoint(): Point.PointLike | null\n",paraId:72,tocIndex:18},{value:"Gets the starting point linked to the canvas; returns ",paraId:73,tocIndex:18},{value:"null",paraId:73,tocIndex:18},{value:" when the edge is connected to a node/edge.",paraId:73,tocIndex:18},{value:"/**\n * Link to a node.\n */\nsetSource(\n  node: Node,\n  args?: Edge.SetCellTerminalArgs,\n  options?: Edge.SetOptions,\n): this\n\n/**\n * Link to an edge.\n */\nsetSource(\n  edge: Edge,\n  args?: Edge.SetEdgeTerminalArgs,\n  options?: Edge.SetOptions,\n): this\n\n/**\n * Link to a point on the canvas.\n */\nsetSource(\n  point: Point | Point.PointLike,\n  args?: Edge.SetTerminalCommonArgs,\n  options?: Edge.SetOptions,\n): this\n\n/**\n * Set the starting point or starting node/edge of the edge.\n */\nsetSource(args: Edge.TerminalData, options?: Edge.SetOptions): this\n",paraId:74,tocIndex:19},{value:"getTarget(): Edge.TerminalData\n",paraId:75,tocIndex:20},{value:"Gets the ending node/end point information of the edge.",paraId:76,tocIndex:20},{value:"getTargetCell(): Cell | null\n",paraId:77,tocIndex:21},{value:"Gets the ending node/edge of the edge; returns ",paraId:78,tocIndex:21},{value:"null",paraId:78,tocIndex:21},{value:" if not connected to a node/edge.",paraId:78,tocIndex:21},{value:"getTargetNode(): Node | null\n",paraId:79,tocIndex:22},{value:"Gets the ending node of the edge; returns ",paraId:80,tocIndex:22},{value:"null",paraId:80,tocIndex:22},{value:" if not connected to a node.",paraId:80,tocIndex:22},{value:"getTargetCellId(): string | null\n",paraId:81,tocIndex:23},{value:"Gets the ID of the ending node/edge of the edge; returns ",paraId:82,tocIndex:23},{value:"null",paraId:82,tocIndex:23},{value:" if not connected to a node/edge.",paraId:82,tocIndex:23},{value:"getTargetPortId(): string | null\n",paraId:83,tocIndex:24},{value:"Gets the ID of the ending connection point; returns ",paraId:84,tocIndex:24},{value:"null",paraId:84,tocIndex:24},{value:" if not connected to a connection point.",paraId:84,tocIndex:24},{value:"getTargetPoint(): Point.PointLike | null\n",paraId:85,tocIndex:25},{value:"Gets the ending point linked to the canvas; returns ",paraId:86,tocIndex:25},{value:"null",paraId:86,tocIndex:25},{value:" when the edge is connected to a node/edge.",paraId:86,tocIndex:25},{value:"/**\n * Link to a node.\n */\nsetTarget(\n  edge: Node,\n  args?: Edge.SetCellTerminalArgs,\n  options?: Edge.SetOptions,\n): this\n\n/**\n * Link to an edge.\n */\nsetTarget(\n  edge: Edge,\n  args?: Edge.SetEdgeTerminalArgs,\n  options?: Edge.SetOptions,\n): this\n\n/**\n * Link to a point on the canvas.\n */\nsetTarget(\n  point: Point | Point.PointLike,\n  args?: Edge.SetTerminalCommonArgs,\n  options?: Edge.SetOptions,\n): this\n\n/**\n * Set the ending point or ending node/edge of the edge.\n */\nsetTarget(args: Edge.TerminalData, options?: Edge.SetOptions): this\n",paraId:87,tocIndex:26},{value:"disconnect(options?: Edge.SetOptions)\n",paraId:88,tocIndex:27},{value:"Removes the link information of the edge, setting both the starting and ending points to the origin of the canvas ",paraId:89,tocIndex:27},{value:"{ x:0, y:0 }",paraId:89,tocIndex:27},{value:".",paraId:89,tocIndex:27},{value:"Name",paraId:90,tocIndex:27},{value:"Type",paraId:90,tocIndex:27},{value:"Required",paraId:90,tocIndex:27},{value:"Default Value",paraId:90,tocIndex:27},{value:"Description",paraId:90,tocIndex:27},{value:"options.silent",paraId:90,tocIndex:27},{value:"boolean",paraId:90,tocIndex:27},{value:"false",paraId:90,tocIndex:27},{value:"If ",paraId:90,tocIndex:27},{value:"true",paraId:90,tocIndex:27},{value:", does not trigger ",paraId:90,tocIndex:27},{value:"'change:source'",paraId:90,tocIndex:27},{value:" and ",paraId:90,tocIndex:27},{value:"'change:target'",paraId:90,tocIndex:27},{value:" events and canvas redraw.",paraId:90,tocIndex:27},{value:"options...others",paraId:90,tocIndex:27},{value:"object",paraId:90,tocIndex:27},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:90,tocIndex:27},{value:"getVertices(): Point.PointLike[]\n",paraId:91,tocIndex:29},{value:"Gets the path points; returns an empty array if there are no path points.",paraId:92,tocIndex:29},{value:"setVertices(\n  vertices: Point.PointLike | Point.PointLike[],\n  options?: Edge.SetOptions,\n): this\n",paraId:93,tocIndex:30},{value:"Sets the path points.",paraId:94,tocIndex:30},{value:"Name",paraId:95,tocIndex:30},{value:"Type",paraId:95,tocIndex:30},{value:"Required",paraId:95,tocIndex:30},{value:"Default Value",paraId:95,tocIndex:30},{value:"Description",paraId:95,tocIndex:30},{value:"vertices",paraId:95,tocIndex:30},{value:"Point.PointLike | Point.PointLike[]",paraId:95,tocIndex:30},{value:"",paraId:95,tocIndex:30},{value:"Path points.",paraId:95,tocIndex:30},{value:"options.silent",paraId:95,tocIndex:30},{value:"boolean",paraId:95,tocIndex:30},{value:"false",paraId:95,tocIndex:30},{value:"If ",paraId:95,tocIndex:30},{value:"true",paraId:95,tocIndex:30},{value:", does not trigger ",paraId:95,tocIndex:30},{value:"'change:vertices'",paraId:95,tocIndex:30},{value:" events and canvas redraw.",paraId:95,tocIndex:30},{value:"options...others",paraId:95,tocIndex:30},{value:"object",paraId:95,tocIndex:30},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:95,tocIndex:30},{value:"insertVertex(\n  vertice: Point.PointLike,\n  index?: number,\n  options?: Edge.SetOptions,\n): this\n",paraId:96,tocIndex:31},{value:"Inserts a path point at the specified position.",paraId:97,tocIndex:31},{value:"Name",paraId:98,tocIndex:31},{value:"Type",paraId:98,tocIndex:31},{value:"Required",paraId:98,tocIndex:31},{value:"Default Value",paraId:98,tocIndex:31},{value:"Description",paraId:98,tocIndex:31},{value:"vertice",paraId:98,tocIndex:31},{value:"Point.PointLike",paraId:98,tocIndex:31},{value:"",paraId:98,tocIndex:31},{value:"Path point.",paraId:98,tocIndex:31},{value:"index",paraId:98,tocIndex:31},{value:"number",paraId:98,tocIndex:31},{value:"Insertion position, defaults to the end of the path point array.",paraId:98,tocIndex:31},{value:"options.silent",paraId:98,tocIndex:31},{value:"boolean",paraId:98,tocIndex:31},{value:"false",paraId:98,tocIndex:31},{value:"If ",paraId:98,tocIndex:31},{value:"true",paraId:98,tocIndex:31},{value:", does not trigger ",paraId:98,tocIndex:31},{value:"'change:vertices'",paraId:98,tocIndex:31},{value:" events and canvas redraw.",paraId:98,tocIndex:31},{value:"options...others",paraId:98,tocIndex:31},{value:"object",paraId:98,tocIndex:31},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:98,tocIndex:31},{value:"appendVertex(vertex: Point.PointLike, options?: Edge.SetOptions): this\n",paraId:99,tocIndex:32},{value:"Inserts a path point at the end of the path point array.",paraId:100,tocIndex:32},{value:"Name",paraId:101,tocIndex:32},{value:"Type",paraId:101,tocIndex:32},{value:"Required",paraId:101,tocIndex:32},{value:"Default Value",paraId:101,tocIndex:32},{value:"Description",paraId:101,tocIndex:32},{value:"vertex",paraId:101,tocIndex:32},{value:"Point.PointLike",paraId:101,tocIndex:32},{value:"",paraId:101,tocIndex:32},{value:"Path point.",paraId:101,tocIndex:32},{value:"options.silent",paraId:101,tocIndex:32},{value:"boolean",paraId:101,tocIndex:32},{value:"false",paraId:101,tocIndex:32},{value:"If ",paraId:101,tocIndex:32},{value:"true",paraId:101,tocIndex:32},{value:", does not trigger ",paraId:101,tocIndex:32},{value:"'change:vertices'",paraId:101,tocIndex:32},{value:" events and canvas redraw.",paraId:101,tocIndex:32},{value:"options...others",paraId:101,tocIndex:32},{value:"object",paraId:101,tocIndex:32},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:101,tocIndex:32},{value:"getVertexAt(index: number): Point.PointLike | null\n",paraId:102,tocIndex:33},{value:"Gets the path point at the specified index.",paraId:103,tocIndex:33},{value:"Name",paraId:104,tocIndex:33},{value:"Type",paraId:104,tocIndex:33},{value:"Required",paraId:104,tocIndex:33},{value:"Default Value",paraId:104,tocIndex:33},{value:"Description",paraId:104,tocIndex:33},{value:"index",paraId:104,tocIndex:33},{value:"number",paraId:104,tocIndex:33},{value:"",paraId:104,tocIndex:33},{value:"Index position.",paraId:104,tocIndex:33},{value:"setVertexAt(\n  index: number,\n  vertice: Point.PointLike,\n  options?: Edge.SetOptions,\n): this\n",paraId:105,tocIndex:34},{value:"Sets the path point at the specified index.",paraId:106,tocIndex:34},{value:"Name",paraId:107,tocIndex:34},{value:"Type",paraId:107,tocIndex:34},{value:"Required",paraId:107,tocIndex:34},{value:"Default Value",paraId:107,tocIndex:34},{value:"Description",paraId:107,tocIndex:34},{value:"index",paraId:107,tocIndex:34},{value:"number",paraId:107,tocIndex:34},{value:"",paraId:107,tocIndex:34},{value:"Index position.",paraId:107,tocIndex:34},{value:"vertice",paraId:107,tocIndex:34},{value:"Point.PointLike",paraId:107,tocIndex:34},{value:"",paraId:107,tocIndex:34},{value:"Path point.",paraId:107,tocIndex:34},{value:"options.silent",paraId:107,tocIndex:34},{value:"boolean",paraId:107,tocIndex:34},{value:"false",paraId:107,tocIndex:34},{value:"If ",paraId:107,tocIndex:34},{value:"true",paraId:107,tocIndex:34},{value:", does not trigger ",paraId:107,tocIndex:34},{value:"'change:vertices'",paraId:107,tocIndex:34},{value:" events and canvas redraw.",paraId:107,tocIndex:34},{value:"options...others",paraId:107,tocIndex:34},{value:"object",paraId:107,tocIndex:34},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:107,tocIndex:34},{value:"removeVertexAt(index: number, options?: Edge.SetOptions): this\n",paraId:108,tocIndex:35},{value:"Removes the path point at the specified index.",paraId:109,tocIndex:35},{value:"Name",paraId:110,tocIndex:35},{value:"Type",paraId:110,tocIndex:35},{value:"Required",paraId:110,tocIndex:35},{value:"Default Value",paraId:110,tocIndex:35},{value:"Description",paraId:110,tocIndex:35},{value:"index",paraId:110,tocIndex:35},{value:"number",paraId:110,tocIndex:35},{value:"",paraId:110,tocIndex:35},{value:"Index position.",paraId:110,tocIndex:35},{value:"options.silent",paraId:110,tocIndex:35},{value:"boolean",paraId:110,tocIndex:35},{value:"false",paraId:110,tocIndex:35},{value:"If ",paraId:110,tocIndex:35},{value:"true",paraId:110,tocIndex:35},{value:", does not trigger ",paraId:110,tocIndex:35},{value:"'change:vertices'",paraId:110,tocIndex:35},{value:" events and canvas redraw.",paraId:110,tocIndex:35},{value:"options...others",paraId:110,tocIndex:35},{value:"object",paraId:110,tocIndex:35},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:110,tocIndex:35},{value:"getRouter(): Edge.RouterData\n",paraId:111,tocIndex:37},{value:"Gets the router.",paraId:112,tocIndex:37},{value:"setRouter(name: string, args?: KeyValue, options?: Edge.SetOptions): this\nsetRouter(router: Edge.RouterData, options?: Edge.SetOptions): this\n",paraId:113,tocIndex:38},{value:"Sets the router.",paraId:114,tocIndex:38},{value:"Name",paraId:115,tocIndex:38},{value:"Type",paraId:115,tocIndex:38},{value:"Required",paraId:115,tocIndex:38},{value:"Default Value",paraId:115,tocIndex:38},{value:"Description",paraId:115,tocIndex:38},{value:"name",paraId:115,tocIndex:38},{value:"string",paraId:115,tocIndex:38},{value:"",paraId:115,tocIndex:38},{value:"Router name.",paraId:115,tocIndex:38},{value:"args",paraId:115,tocIndex:38},{value:"KeyValue",paraId:115,tocIndex:38},{value:"Router parameters.",paraId:115,tocIndex:38},{value:"router",paraId:115,tocIndex:38},{value:"Edge.RouterData",paraId:115,tocIndex:38},{value:"",paraId:115,tocIndex:38},{value:"Router.",paraId:115,tocIndex:38},{value:"options.silent",paraId:115,tocIndex:38},{value:"boolean",paraId:115,tocIndex:38},{value:"false",paraId:115,tocIndex:38},{value:"If ",paraId:115,tocIndex:38},{value:"true",paraId:115,tocIndex:38},{value:", does not trigger ",paraId:115,tocIndex:38},{value:"'change:router'",paraId:115,tocIndex:38},{value:" events and canvas redraw.",paraId:115,tocIndex:38},{value:"options...others",paraId:115,tocIndex:38},{value:"object",paraId:115,tocIndex:38},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:115,tocIndex:38},{value:"removeRouter(options?: Edge.SetOptions): this\n",paraId:116,tocIndex:39},{value:"Removes the router.",paraId:117,tocIndex:39},{value:"Name",paraId:118,tocIndex:39},{value:"Type",paraId:118,tocIndex:39},{value:"Required",paraId:118,tocIndex:39},{value:"Default Value",paraId:118,tocIndex:39},{value:"Description",paraId:118,tocIndex:39},{value:"options.silent",paraId:118,tocIndex:39},{value:"boolean",paraId:118,tocIndex:39},{value:"false",paraId:118,tocIndex:39},{value:"If ",paraId:118,tocIndex:39},{value:"true",paraId:118,tocIndex:39},{value:", does not trigger ",paraId:118,tocIndex:39},{value:"'change:router'",paraId:118,tocIndex:39},{value:" events and canvas redraw.",paraId:118,tocIndex:39},{value:"options...others",paraId:118,tocIndex:39},{value:"object",paraId:118,tocIndex:39},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:118,tocIndex:39},{value:"getConnector(): Edge.ConnectorData\n",paraId:119,tocIndex:41},{value:"Gets the connector.",paraId:120,tocIndex:41},{value:"setConnector(name: string, args?: KeyValue, options?: Edge.SetOptions): this\nsetConnector(connector: Edge.ConnectorData, options?: Edge.SetOptions): this\n",paraId:121,tocIndex:42},{value:"Sets the connector.",paraId:122,tocIndex:42},{value:"Name",paraId:123,tocIndex:42},{value:"Type",paraId:123,tocIndex:42},{value:"Required",paraId:123,tocIndex:42},{value:"Default Value",paraId:123,tocIndex:42},{value:"Description",paraId:123,tocIndex:42},{value:"name",paraId:123,tocIndex:42},{value:"string",paraId:123,tocIndex:42},{value:"",paraId:123,tocIndex:42},{value:"Connector name.",paraId:123,tocIndex:42},{value:"args",paraId:123,tocIndex:42},{value:"KeyValue",paraId:123,tocIndex:42},{value:"Connector parameters.",paraId:123,tocIndex:42},{value:"connector",paraId:123,tocIndex:42},{value:"Edge.ConnectorData",paraId:123,tocIndex:42},{value:"",paraId:123,tocIndex:42},{value:"Connector.",paraId:123,tocIndex:42},{value:"options.silent",paraId:123,tocIndex:42},{value:"boolean",paraId:123,tocIndex:42},{value:"false",paraId:123,tocIndex:42},{value:"If ",paraId:123,tocIndex:42},{value:"true",paraId:123,tocIndex:42},{value:", does not trigger ",paraId:123,tocIndex:42},{value:"'change:connector'",paraId:123,tocIndex:42},{value:" events and canvas redraw.",paraId:123,tocIndex:42},{value:"options...others",paraId:123,tocIndex:42},{value:"object",paraId:123,tocIndex:42},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:123,tocIndex:42},{value:"removeConnector(options?: Edge.SetOptions): this\n",paraId:124,tocIndex:43},{value:"Removes the connector.",paraId:125,tocIndex:43},{value:"Name",paraId:126,tocIndex:43},{value:"Type",paraId:126,tocIndex:43},{value:"Required",paraId:126,tocIndex:43},{value:"Default Value",paraId:126,tocIndex:43},{value:"Description",paraId:126,tocIndex:43},{value:"options.silent",paraId:126,tocIndex:43},{value:"boolean",paraId:126,tocIndex:43},{value:"false",paraId:126,tocIndex:43},{value:"If ",paraId:126,tocIndex:43},{value:"true",paraId:126,tocIndex:43},{value:", does not trigger ",paraId:126,tocIndex:43},{value:"'change:connector'",paraId:126,tocIndex:43},{value:" events and canvas redraw.",paraId:126,tocIndex:43},{value:"options...others",paraId:126,tocIndex:43},{value:"object",paraId:126,tocIndex:43},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:126,tocIndex:43},{value:"getDefaultLabel(): Edge.Label\n",paraId:127,tocIndex:45},{value:"Gets the default label.",paraId:128,tocIndex:45},{value:"getLabels(): Edge.Label[]\n",paraId:129,tocIndex:46},{value:"Gets all labels.",paraId:130,tocIndex:46},{value:"setLabels(\n  labels: Edge.Label | Edge.Label[] | string | string[],\n  options?: Edge.SetOptions,\n): this\n",paraId:131,tocIndex:47},{value:"Sets the labels.",paraId:132,tocIndex:47},{value:"Name",paraId:133,tocIndex:47},{value:"Type",paraId:133,tocIndex:47},{value:"Required",paraId:133,tocIndex:47},{value:"Default Value",paraId:133,tocIndex:47},{value:"Description",paraId:133,tocIndex:47},{value:"labels",paraId:133,tocIndex:47},{value:"Edge.Label | Edge.Label[] | string | string[]",paraId:133,tocIndex:47},{value:"",paraId:133,tocIndex:47},{value:"Labels or array of labels.",paraId:133,tocIndex:47},{value:"options.silent",paraId:133,tocIndex:47},{value:"boolean",paraId:133,tocIndex:47},{value:"false",paraId:133,tocIndex:47},{value:"If ",paraId:133,tocIndex:47},{value:"true",paraId:133,tocIndex:47},{value:", does not trigger ",paraId:133,tocIndex:47},{value:"'change:labels'",paraId:133,tocIndex:47},{value:" events and canvas redraw.",paraId:133,tocIndex:47},{value:"options...others",paraId:133,tocIndex:47},{value:"object",paraId:133,tocIndex:47},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:133,tocIndex:47},{value:"insertLabel(\n  label: Edge.Label | string,\n  index?: number,\n  options?: Edge.SetOptions,\n): this\n",paraId:134,tocIndex:48},{value:"Inserts a label at the specified position.",paraId:135,tocIndex:48},{value:"Name",paraId:136,tocIndex:48},{value:"Type",paraId:136,tocIndex:48},{value:"Required",paraId:136,tocIndex:48},{value:"Default Value",paraId:136,tocIndex:48},{value:"Description",paraId:136,tocIndex:48},{value:"label",paraId:136,tocIndex:48},{value:"Edge.Label | string",paraId:136,tocIndex:48},{value:"",paraId:136,tocIndex:48},{value:"Label.",paraId:136,tocIndex:48},{value:"index",paraId:136,tocIndex:48},{value:"number",paraId:136,tocIndex:48},{value:"Insertion position, defaults to the end of the label array.",paraId:136,tocIndex:48},{value:"options.silent",paraId:136,tocIndex:48},{value:"boolean",paraId:136,tocIndex:48},{value:"false",paraId:136,tocIndex:48},{value:"If ",paraId:136,tocIndex:48},{value:"true",paraId:136,tocIndex:48},{value:", does not trigger ",paraId:136,tocIndex:48},{value:"'change:labels'",paraId:136,tocIndex:48},{value:" events and canvas redraw.",paraId:136,tocIndex:48},{value:"options...others",paraId:136,tocIndex:48},{value:"object",paraId:136,tocIndex:48},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:136,tocIndex:48},{value:"appendLabel(label: Edge.Label | string, options?: Edge.SetOptions): this\n",paraId:137,tocIndex:49},{value:"Inserts a label at the end of the label array.",paraId:138,tocIndex:49},{value:"Name",paraId:139,tocIndex:49},{value:"Type",paraId:139,tocIndex:49},{value:"Required",paraId:139,tocIndex:49},{value:"Default Value",paraId:139,tocIndex:49},{value:"Description",paraId:139,tocIndex:49},{value:"label",paraId:139,tocIndex:49},{value:"Edge.Label | string",paraId:139,tocIndex:49},{value:"",paraId:139,tocIndex:49},{value:"Label.",paraId:139,tocIndex:49},{value:"options.silent",paraId:139,tocIndex:49},{value:"boolean",paraId:139,tocIndex:49},{value:"false",paraId:139,tocIndex:49},{value:"If ",paraId:139,tocIndex:49},{value:"true",paraId:139,tocIndex:49},{value:", does not trigger ",paraId:139,tocIndex:49},{value:"'change:labels'",paraId:139,tocIndex:49},{value:" events and canvas redraw.",paraId:139,tocIndex:49},{value:"options...others",paraId:139,tocIndex:49},{value:"object",paraId:139,tocIndex:49},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:139,tocIndex:49},{value:"getLabelAt(index: number): Edge.Label | null\n",paraId:140,tocIndex:50},{value:"Gets the label at the specified position.",paraId:141,tocIndex:50},{value:"Name",paraId:142,tocIndex:50},{value:"Type",paraId:142,tocIndex:50},{value:"Required",paraId:142,tocIndex:50},{value:"Default Value",paraId:142,tocIndex:50},{value:"Description",paraId:142,tocIndex:50},{value:"index",paraId:142,tocIndex:50},{value:"number",paraId:142,tocIndex:50},{value:"",paraId:142,tocIndex:50},{value:"Index position.",paraId:142,tocIndex:50},{value:"setLabelAt(\n  index: number,\n  label: Edge.Label | string,\n  options?: Edge.SetOptions,\n): this\n",paraId:143,tocIndex:51},{value:"Sets the label at the specified position.",paraId:144,tocIndex:51},{value:"Name",paraId:145,tocIndex:51},{value:"Type",paraId:145,tocIndex:51},{value:"Required",paraId:145,tocIndex:51},{value:"Default Value",paraId:145,tocIndex:51},{value:"Description",paraId:145,tocIndex:51},{value:"index",paraId:145,tocIndex:51},{value:"number",paraId:145,tocIndex:51},{value:"",paraId:145,tocIndex:51},{value:"Index position.",paraId:145,tocIndex:51},{value:"label",paraId:145,tocIndex:51},{value:"Edge.Label | string",paraId:145,tocIndex:51},{value:"",paraId:145,tocIndex:51},{value:"Label.",paraId:145,tocIndex:51},{value:"options.silent",paraId:145,tocIndex:51},{value:"boolean",paraId:145,tocIndex:51},{value:"false",paraId:145,tocIndex:51},{value:"If ",paraId:145,tocIndex:51},{value:"true",paraId:145,tocIndex:51},{value:", does not trigger ",paraId:145,tocIndex:51},{value:"'change:labels'",paraId:145,tocIndex:51},{value:" events and canvas redraw.",paraId:145,tocIndex:51},{value:"options...others",paraId:145,tocIndex:51},{value:"object",paraId:145,tocIndex:51},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:145,tocIndex:51},{value:"removeLabelAt(index: number, options?: Edge.SetOptions): this\n",paraId:146,tocIndex:52},{value:"Removes the label at the specified position.",paraId:147,tocIndex:52},{value:"Name",paraId:148,tocIndex:52},{value:"Type",paraId:148,tocIndex:52},{value:"Required",paraId:148,tocIndex:52},{value:"Default Value",paraId:148,tocIndex:52},{value:"Description",paraId:148,tocIndex:52},{value:"index",paraId:148,tocIndex:52},{value:"number",paraId:148,tocIndex:52},{value:"",paraId:148,tocIndex:52},{value:"Index position.",paraId:148,tocIndex:52},{value:"options.silent",paraId:148,tocIndex:52},{value:"boolean",paraId:148,tocIndex:52},{value:"false",paraId:148,tocIndex:52},{value:"If ",paraId:148,tocIndex:52},{value:"true",paraId:148,tocIndex:52},{value:", does not trigger ",paraId:148,tocIndex:52},{value:"'change:labels'",paraId:148,tocIndex:52},{value:" events and canvas redraw.",paraId:148,tocIndex:52},{value:"options...others",paraId:148,tocIndex:52},{value:"object",paraId:148,tocIndex:52},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:148,tocIndex:52}]},81195:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(75619);const n=[{value:"One of the most appealing aspects of X6 for developers is its comprehensive interaction customization capabilities, which allow us to achieve a wide range of complex effects. Below are some common interactive behaviors.",paraId:0},{value:"By configuring ",paraId:1,tocIndex:0},{value:"connecting",paraId:1,tocIndex:0},{value:", you can achieve rich connection interactions. The usage is as follows:",paraId:1,tocIndex:0},{value:"const graph = new Graph({\n  ...,\n  connecting: {\n    snap: true,\n  }\n})\n",paraId:2,tocIndex:0},{value:"Below are the configurations supported by ",paraId:3,tocIndex:0},{value:"connecting",paraId:3,tocIndex:0},{value:".",paraId:3,tocIndex:0},{value:"snap: boolean | { radius: number, anchor: 'center' | 'bbox' }\n",paraId:4,tocIndex:1},{value:"When ",paraId:5,tocIndex:1},{value:"snap",paraId:5,tocIndex:1},{value:" is set to ",paraId:5,tocIndex:1},{value:"true",paraId:5,tocIndex:1},{value:" or ",paraId:5,tocIndex:1},{value:"false",paraId:5,tocIndex:1},{value:", it represents enabling or disabling automatic snapping during the connection process. When enabled, a distance of ",paraId:5,tocIndex:1},{value:"50px",paraId:5,tocIndex:1},{value:" from the target will trigger the snap. You can customize the snap radius by configuring the ",paraId:5,tocIndex:1},{value:"radius",paraId:5,tocIndex:1},{value:" property.",paraId:5,tocIndex:1},{value:"const graph = new Graph({\n  connecting: {\n    snap: true,\n  },\n})\n// Equivalent to\nconst graph = new Graph({\n  connecting: {\n    snap: {\n      radius: 50,\n    },\n  },\n})\n",paraId:6,tocIndex:1},{value:"When calculating the distance to determine if it snaps to a node, it defaults to the center of the node. You can change this to calculate the distance based on the bounding box of the node by configuring ",paraId:7,tocIndex:1},{value:"anchor",paraId:7,tocIndex:1},{value:" to ",paraId:7,tocIndex:1},{value:"bbox",paraId:7,tocIndex:1},{value:".",paraId:7,tocIndex:1},{value:"allowBlank: boolean | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n",paraId:8,tocIndex:2},{value:"Whether to allow connections to blank areas of the canvas. The default is ",paraId:9,tocIndex:2},{value:"true",paraId:9,tocIndex:2},{value:", and it also supports dynamic adjustment through a function.",paraId:9,tocIndex:2},{value:"const graph = new Graph({\n  connecting: {\n    allowBlank() {\n      // Return true or false based on conditions\n      return true\n    },\n  },\n})\n",paraId:10,tocIndex:2},{value:"allowLoop: boolean | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n",paraId:11,tocIndex:3},{value:"Whether to allow the creation of loop connections, where the starting and ending nodes are the same. The default is ",paraId:12,tocIndex:3},{value:"true",paraId:12,tocIndex:3},{value:".",paraId:12,tocIndex:3},{value:"allowNode: boolean | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n",paraId:13,tocIndex:4},{value:"Whether to allow edges to connect to nodes (not connection ports on nodes). The default is ",paraId:14,tocIndex:4},{value:"true",paraId:14,tocIndex:4},{value:".",paraId:14,tocIndex:4},{value:"allowEdge: boolean | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n",paraId:15,tocIndex:5},{value:"Whether to allow edges to connect to other edges. The default is ",paraId:16,tocIndex:5},{value:"true",paraId:16,tocIndex:5},{value:".",paraId:16,tocIndex:5},{value:"allowPort: boolean | ((this: Graph, args: ValidateConnectionArgs) => boolean)\n",paraId:17,tocIndex:6},{value:"Whether to allow edges to connect to connection ports. The default is ",paraId:18,tocIndex:6},{value:"true",paraId:18,tocIndex:6},{value:".",paraId:18,tocIndex:6},{value:"allowMulti: boolean |\n  'withPort' |\n  ((this: Graph, args: ValidateConnectionArgs) => boolean)\n",paraId:19,tocIndex:7},{value:"Whether to allow multiple edges to be created between the same starting and ending nodes. The default is ",paraId:20,tocIndex:7},{value:"true",paraId:20,tocIndex:7},{value:". When set to ",paraId:20,tocIndex:7},{value:"false",paraId:20,tocIndex:7},{value:", only one edge is allowed between the starting and ending nodes. When set to ",paraId:20,tocIndex:7},{value:"'withPort'",paraId:20,tocIndex:7},{value:", only one edge is allowed between the same connection ports of the starting and ending nodes (i.e., multiple edges can be created between the starting and ending nodes, but they must connect at different ports).",paraId:20,tocIndex:7},{value:"highlight: boolean\n",paraId:21,tocIndex:8},{value:"Whether to highlight all available connection ports or nodes while dragging an edge. The default value is ",paraId:22,tocIndex:8},{value:"false",paraId:22,tocIndex:8},{value:". This is generally used in conjunction with ",paraId:22,tocIndex:8},{value:"highlighting",paraId:23,tocIndex:8},{value:"highlighting",paraId:22,tocIndex:8},{value:"anchor: NodeAnchorOptions\n",paraId:24,tocIndex:9},{value:"When connecting to a node, the anchor point of the connected node is specified through ",paraId:25,tocIndex:9},{value:" ",paraId:26,tocIndex:9},{value:"anchor",paraId:26,tocIndex:9},{value:" ",paraId:26,tocIndex:9},{value:", with the default value being ",paraId:25,tocIndex:9},{value:"center",paraId:25,tocIndex:9},{value:".",paraId:25,tocIndex:9},{value:"sourceAnchor?: NodeAnchorOptions\n",paraId:27,tocIndex:10},{value:"When connecting to a node, the anchor point of the source node is specified through ",paraId:28,tocIndex:10},{value:"sourceAnchor",paraId:28,tocIndex:10},{value:".",paraId:28,tocIndex:10},{value:"targetAnchor?: NodeAnchorOptions\n",paraId:29,tocIndex:11},{value:"When connecting to a node, the anchor point of the target node is specified through ",paraId:30,tocIndex:11},{value:"targetAnchor",paraId:30,tocIndex:11},{value:".",paraId:30,tocIndex:11},{value:"edgeAnchor: EdgeAnchorOptions\n",paraId:31,tocIndex:12},{value:"When connecting to an edge, the anchor point of the connected edge is specified through ",paraId:32,tocIndex:12},{value:" ",paraId:33,tocIndex:12},{value:"edgeAnchor",paraId:33,tocIndex:12},{value:" ",paraId:33,tocIndex:12},{value:", with the default value being ",paraId:32,tocIndex:12},{value:"ratio",paraId:32,tocIndex:12},{value:".",paraId:32,tocIndex:12},{value:"sourceEdgeAnchor?: EdgeAnchorOptions\n",paraId:34,tocIndex:13},{value:"When connecting to an edge, the anchor point of the source edge is specified through ",paraId:35,tocIndex:13},{value:"sourceEdgeAnchor",paraId:35,tocIndex:13},{value:".",paraId:35,tocIndex:13},{value:"targetEdgeAnchor?: EdgeAnchorOptions\n",paraId:36,tocIndex:14},{value:"When connecting to an edge, the anchor point of the target edge is specified through ",paraId:37,tocIndex:14},{value:"targetEdgeAnchor",paraId:37,tocIndex:14},{value:".",paraId:37,tocIndex:14},{value:"connectionPoint: ConnectionPointOptions\n",paraId:38,tocIndex:15},{value:"Specifies the ",paraId:39,tocIndex:15},{value:"connection point",paraId:40,tocIndex:15},{value:", with the default value being ",paraId:39,tocIndex:15},{value:"boundary",paraId:39,tocIndex:15},{value:".",paraId:39,tocIndex:15},{value:"sourceConnectionPoint?: ConnectionPointOptions\n",paraId:41,tocIndex:16},{value:"The connection point of the source.",paraId:42,tocIndex:16},{value:"targetConnectionPoint?: ConnectionPointOptions\n",paraId:43,tocIndex:17},{value:"The connection point of the target.",paraId:44,tocIndex:17},{value:"router: string | Router.NativeItem | Router.ManaualItem\n",paraId:45,tocIndex:18},{value:"The ",paraId:46,tocIndex:18},{value:"router",paraId:47,tocIndex:18},{value:" further processes the edge's path points ",paraId:46,tocIndex:18},{value:"vertices",paraId:46,tocIndex:18},{value:", adding extra points if necessary, and returns the processed points. The default value is ",paraId:46,tocIndex:18},{value:"normal",paraId:46,tocIndex:18},{value:".",paraId:46,tocIndex:18},{value:"connector: string | Connector.NativeItem | Connector.ManaualItem\n",paraId:48,tocIndex:19},{value:"The ",paraId:49,tocIndex:19},{value:"connector",paraId:50,tocIndex:19},{value:" processes the starting point, the points returned by the router, and the endpoint into the ",paraId:49,tocIndex:19},{value:"d",paraId:49,tocIndex:19},{value:" attribute of the ",paraId:49,tocIndex:19},{value:"path",paraId:49,tocIndex:19},{value:" element, determining the style of the edge after rendering on the canvas. The default value is ",paraId:49,tocIndex:19},{value:"normal",paraId:49,tocIndex:19},{value:".",paraId:49,tocIndex:19},{value:"createEdge?: (\n  this: Graph,\n  args: {\n    sourceCell: Cell\n    sourceView: CellView\n    sourceMagnet: Element\n  },\n) => Nilable<Edge> | void\n",paraId:51,tocIndex:20},{value:"This method allows you to customize the style of the newly created edge.",paraId:52,tocIndex:20},{value:"validateMagnet?: (\n  this: Graph,\n  args: {\n    cell: Cell\n    view: CellView\n    magnet: Element\n    e: Dom.MouseDownEvent | Dom.MouseEnterEvent\n  },\n) => boolean\n",paraId:53,tocIndex:21},{value:"When clicking on a ",paraId:54,tocIndex:21},{value:"magnet",paraId:54,tocIndex:21},{value:", the return value of ",paraId:54,tocIndex:21},{value:"validateMagnet",paraId:54,tocIndex:21},{value:" determines whether to add a new edge. The trigger occurs when the ",paraId:54,tocIndex:21},{value:"magnet",paraId:54,tocIndex:21},{value:" is pressed. If it returns ",paraId:54,tocIndex:21},{value:"false",paraId:54,tocIndex:21},{value:", there is no response; if it returns ",paraId:54,tocIndex:21},{value:"true",paraId:54,tocIndex:21},{value:", a new edge will be created at the current ",paraId:54,tocIndex:21},{value:"magnet",paraId:54,tocIndex:21},{value:".",paraId:54,tocIndex:21},{value:"validateConnection: (this: Graph, args: ValidateConnectionArgs) => boolean\n",paraId:55,tocIndex:22},{value:"When moving an edge, this checks if the connection is valid. If it returns ",paraId:56,tocIndex:22},{value:"false",paraId:56,tocIndex:22},{value:", the edge will not connect to the current element when the mouse is released; otherwise, it will connect.",paraId:56,tocIndex:22},{value:"validateEdge?: (\n  this: Graph,\n  args: {\n    edge: Edge\n    type: Edge.TerminalType\n    previous: Edge.TerminalData\n  },\n) => boolean\n",paraId:57,tocIndex:23},{value:"When stopping the drag of an edge, this checks if the edge is valid based on the return value of ",paraId:58,tocIndex:23},{value:"validateEdge",paraId:58,tocIndex:23},{value:". If it returns ",paraId:58,tocIndex:23},{value:"false",paraId:58,tocIndex:23},{value:", the edge will be removed.",paraId:58,tocIndex:23},{value:"By using ",paraId:59,tocIndex:24},{value:"embedding",paraId:59,tocIndex:24},{value:", you can drag a node into another node, making it a child of the other node. This feature is disabled by default. The supported configurations are as follows:",paraId:59,tocIndex:24},{value:"enabled?: boolean\n",paraId:60,tocIndex:25},{value:"Whether to allow nesting between nodes. The default value is ",paraId:61,tocIndex:25},{value:"false",paraId:61,tocIndex:25},{value:".",paraId:61,tocIndex:25},{value:"findParent?:\n  | 'bbox'\n  | 'center'\n  | 'topLeft'\n  | 'topRight'\n  | 'bottomLeft'\n  | 'bottomRight'\n  | ((this: Graph, args: { node: Node; view: NodeView }) => Cell[])\n",paraId:62,tocIndex:26},{value:"When a node is moved, the method specified by ",paraId:63,tocIndex:26},{value:"findParent",paraId:63,tocIndex:26},{value:" returns the parent node. The default value is ",paraId:63,tocIndex:26},{value:"bbox",paraId:63,tocIndex:26},{value:".",paraId:63,tocIndex:26},{value:"frontOnly?: boolean\n",paraId:64,tocIndex:27},{value:"If ",paraId:65,tocIndex:27},{value:"frontOnly",paraId:65,tocIndex:27},{value:" is ",paraId:65,tocIndex:27},{value:"true",paraId:65,tocIndex:27},{value:", only nodes displayed in the front can be embedded. The default value is ",paraId:65,tocIndex:27},{value:"true",paraId:65,tocIndex:27},{value:".",paraId:65,tocIndex:27},{value:"validate: (\n  this: Graph,\n  args: {\n    child: Node\n    parent: Node\n    childView: CellView\n    parentView: CellView\n  },\n) => boolean\n",paraId:66,tocIndex:28},{value:"validate",paraId:67,tocIndex:28},{value:" is a function that determines whether a node can be embedded in a parent node. The default return value is ",paraId:67,tocIndex:28},{value:"true",paraId:67,tocIndex:28},{value:".",paraId:67,tocIndex:28},{value:"Limit the interaction behavior of nodes and edges. The ",paraId:68,tocIndex:29},{value:"interacting",paraId:68,tocIndex:29},{value:" configuration supports the following:",paraId:68,tocIndex:29},{value:"export type Interacting =\n  | boolean\n  | InteractionMap\n  | ((this: Graph, cellView: CellView) => InteractionMap | boolean)\n",paraId:69,tocIndex:29},{value:"boolean",paraId:70,tocIndex:29},{value:": Whether the node or edge is interactive.",paraId:70,tocIndex:29},{value:"InteractionMap",paraId:70,tocIndex:29},{value:": Interaction details for the node or edge, supporting the following properties:\n",paraId:70,tocIndex:29},{value:"'nodeMovable'",paraId:71,tocIndex:29},{value:": Whether the node can be moved.",paraId:71,tocIndex:29},{value:"'magnetConnectable'",paraId:71,tocIndex:29},{value:": Whether to trigger connection interactions when dragging starts on elements with the ",paraId:71,tocIndex:29},{value:"'magnet'",paraId:71,tocIndex:29},{value:" attribute.",paraId:71,tocIndex:29},{value:"'edgeMovable'",paraId:71,tocIndex:29},{value:": Whether the edge can be moved.",paraId:71,tocIndex:29},{value:"'edgeLabelMovable'",paraId:71,tocIndex:29},{value:": Whether the edge's label can be moved.",paraId:71,tocIndex:29},{value:"'arrowheadMovable'",paraId:71,tocIndex:29},{value:": Whether the starting/ending arrow of the edge can be moved.",paraId:71,tocIndex:29},{value:"'vertexMovable'",paraId:71,tocIndex:29},{value:": Whether the path points of the edge can be moved.",paraId:71,tocIndex:29},{value:"'vertexAddable'",paraId:71,tocIndex:29},{value:": Whether path points can be added to the edge.",paraId:71,tocIndex:29},{value:"'vertexDeletable'",paraId:71,tocIndex:29},{value:": Whether path points can be deleted from the edge.",paraId:71,tocIndex:29},{value:"(this: Graph, cellView: CellView) => InteractionMap | boolean",paraId:70,tocIndex:29},{value:"const graph = new Graph({\n  container: this.container,\n  width: 800,\n  height: 1400,\n  grid: 10,\n  interacting: function (cellView: CellView) {\n    if (cellView.cell.getProp('customLinkInteractions')) {\n      return { vertexAdd: false }\n    }\n    return true\n  },\n})\n",paraId:72,tocIndex:29},{value:"You can specify the highlighting style triggered by certain interactions through the ",paraId:73,tocIndex:30},{value:"highlighting",paraId:73,tocIndex:30},{value:" option, such as:",paraId:73,tocIndex:30},{value:"new Graph({\n  highlighting: {\n    // When connection ports are available for linking, render a 2px wide red rectangle around the port\n    magnetAvailable: {\n      name: 'stroke',\n      args: {\n        padding: 4,\n        attrs: {\n          'stroke-width': 2,\n          stroke: 'red',\n        },\n      },\n    },\n  },\n})\n",paraId:74,tocIndex:30},{value:"The supported ",paraId:75,tocIndex:30},{value:"highlighting",paraId:75,tocIndex:30},{value:" configuration options include:",paraId:75,tocIndex:30},{value:"'default'",paraId:76,tocIndex:30},{value:": Default highlighting options used when the following highlighting configurations are absent.",paraId:76,tocIndex:30},{value:"'embedding'",paraId:76,tocIndex:30},{value:": Used when a node can be embedded during the drag operation.",paraId:76,tocIndex:30},{value:"'nodeAvailable'",paraId:76,tocIndex:30},{value:": Used when a node can be linked during the connection process.",paraId:76,tocIndex:30},{value:"'magnetAvailable'",paraId:76,tocIndex:30},{value:": Used when connection ports can be linked during the connection process.",paraId:76,tocIndex:30},{value:"'magnetAdsorbed'",paraId:76,tocIndex:30},{value:": Used when automatically snapping to connection ports during the connection process.",paraId:76,tocIndex:30},{value:"The ",paraId:77,tocIndex:30},{value:"magnetAvailable.name",paraId:77,tocIndex:30},{value:" above is actually the name of the highlighter. X6 has built-in highlighters ",paraId:77,tocIndex:30},{value:"stroke",paraId:77,tocIndex:30},{value:" and ",paraId:77,tocIndex:30},{value:"className",paraId:77,tocIndex:30},{value:". For more details, refer to ",paraId:77,tocIndex:30},{value:"Highlighter",paraId:78,tocIndex:30},{value:".",paraId:77,tocIndex:30},{value:"You can globally configure ",paraId:79,tocIndex:31},{value:"translating",paraId:79,tocIndex:31},{value:" to limit the movement range of nodes.",paraId:79,tocIndex:31},{value:"const graph = new Graph({\n  translating: {\n    restrict: true,\n  },\n})\n",paraId:80,tocIndex:31},{value:"The movable range of nodes. Supports the following two methods:",paraId:81,tocIndex:32},{value:"boolean",paraId:82,tocIndex:32},{value:": If set to ",paraId:82,tocIndex:32},{value:"true",paraId:82,tocIndex:32},{value:", nodes cannot move outside the canvas area.",paraId:82,tocIndex:32},{value:"Rectangle.RectangleLike | (arg: CellView) => Rectangle.RectangleLike",paraId:82,tocIndex:32},{value:": Specify a node's movement range.",paraId:82,tocIndex:32},{value:"const graph = new Graph({\n  translating: {\n    restrict: {\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 100,\n    },\n  },\n})\n",paraId:83,tocIndex:32}]},77582:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(91242);const n=[{value:"The label configuration for edges in X6 is very flexible, so we dedicate a separate section to detail how to use edge labels.",paraId:0},{value:"Before we begin, let's briefly understand a few methods for manipulating labels on an Edge instance.",paraId:1},{value:"Method Signature",paraId:2},{value:"Description",paraId:2},{value:"edge.getLabels()",paraId:3},{value:"Get all labels.",paraId:2},{value:"edge.setLabels(...)",paraId:4},{value:"Set labels.",paraId:2},{value:"edge.insertLabel(...)",paraId:5},{value:"Insert a label at a specified position.",paraId:2},{value:"edge.appendLabel(...)",paraId:6},{value:"Append a label at the end.",paraId:2},{value:"edge.setLabelAt(...)",paraId:7},{value:"Set a label at a specified position.",paraId:2},{value:"edge.getLabelAt(...)",paraId:8},{value:"Get a label at a specified position.",paraId:2},{value:"edge.removeLabelAt(...)",paraId:9},{value:"Remove a label at a specified position.",paraId:2},{value:"A label includes label markup, label position, label style, etc. The complete definition is as follows.",paraId:10,tocIndex:0},{value:"interface Label {\n  markup?: Markup\n  attrs?: Attr.CellAttrs\n  position?:\n    | number\n    | {\n        distance: number\n        offset?:\n          | number\n          | {\n              x?: number\n              y?: number\n            }\n        angle?: number\n        options?: {\n          absoluteDistance?: boolean\n          reverseDistance?: boolean\n          absoluteOffset?: boolean\n          keepGradient?: boolean\n          ensureLegibility?: boolean\n        }\n      }\n}\n",paraId:11,tocIndex:0},{value:"markup",paraId:12,tocIndex:0},{value:": Label markup.",paraId:12,tocIndex:0},{value:"attrs",paraId:12,tocIndex:0},{value:": Label style.",paraId:12,tocIndex:0},{value:"position",paraId:12,tocIndex:0},{value:": Label position. When its value is a ",paraId:12,tocIndex:0},{value:"number",paraId:12,tocIndex:0},{value:", it is equivalent to setting the value of ",paraId:12,tocIndex:0},{value:"position.distance",paraId:12,tocIndex:0},{value:".\n",paraId:12,tocIndex:0},{value:"distance",paraId:13,tocIndex:0},{value:": ",paraId:13,tocIndex:0},{value:"Label position",paraId:14,tocIndex:0},{value:".",paraId:13,tocIndex:0},{value:"offset",paraId:13,tocIndex:0},{value:": ",paraId:13,tocIndex:0},{value:"Label offset",paraId:15,tocIndex:0},{value:".",paraId:13,tocIndex:0},{value:"angle",paraId:13,tocIndex:0},{value:": ",paraId:13,tocIndex:0},{value:"Label rotation",paraId:16,tocIndex:0},{value:".",paraId:13,tocIndex:0},{value:"When creating an Edge, you can set the default label using the ",paraId:17,tocIndex:1},{value:"defaultLabel option",paraId:18,tocIndex:1},{value:", with the default value as follows:",paraId:17,tocIndex:1},{value:"{\n  markup: [\n    {\n      tagName: 'rect',\n      selector: 'body',\n    },\n    {\n      tagName: 'text',\n      selector: 'label',\n    },\n  ],\n  attrs: {\n    text: {\n      fill: '#000',\n      fontSize: 14,\n      textAnchor: 'middle',\n      textVerticalAnchor: 'middle',\n      pointerEvents: 'none',\n    },\n    rect: {\n      ref: 'label',\n      fill: '#fff',\n      rx: 3,\n      ry: 3,\n      refWidth: 1,\n      refHeight: 1,\n      refX: 0,\n      refY: 0,\n    },\n  },\n  position: {\n    distance: 0.5,\n  },\n}\n",paraId:19,tocIndex:1},{value:"This default label includes a ",paraId:20,tocIndex:1},{value:"<text>",paraId:20,tocIndex:1},{value:" element (representing the label text) and a ",paraId:20,tocIndex:1},{value:"<rect>",paraId:20,tocIndex:1},{value:" element (representing the label background), which is centered by default and has a white rounded background. Since all custom labels will be ",paraId:20,tocIndex:1},{value:"merged",paraId:20,tocIndex:1},{value:" with this default label, we can simply provide a text attribute for a label as shown below.",paraId:20,tocIndex:1},{value:"edge.appendLabel({\n  attrs: {\n    text: {\n      text: 'Hello Label',\n    },\n  },\n})\n",paraId:21,tocIndex:1},{value:"We can specify the label's position using the ",paraId:22,tocIndex:3},{value:"position.distance",paraId:22,tocIndex:3},{value:" option of the Label, with a default value of ",paraId:22,tocIndex:3},{value:"0.5",paraId:22,tocIndex:3},{value:", indicating that the label is positioned at the center of the edge's length. Depending on the value, the calculation of the label's position can be categorized into three cases.",paraId:22,tocIndex:3},{value:"When it is between ",paraId:23,tocIndex:3},{value:"[0, 1]",paraId:23,tocIndex:3},{value:", it indicates that the label is positioned at a relative length (proportion) from the starting point along the length direction.",paraId:23,tocIndex:3},{value:"A positive number indicates that the label is positioned at a distance from the starting point along the edge's length.",paraId:23,tocIndex:3},{value:"A negative number indicates that the label is positioned at a distance from the endpoint along the length direction.",paraId:23,tocIndex:3},{value:"edge.appendLabel({\n  attrs: {\n    text: {\n      text: '0.25',\n    },\n  },\n  position: {\n    distance: 0.25,\n  },\n})\n\nedge.appendLabel({\n  attrs: {\n    text: {\n      text: '150',\n    },\n  },\n  position: {\n    distance: 150,\n  },\n})\n\nedge.appendLabel({\n  attrs: {\n    text: {\n      text: '-100',\n    },\n  },\n  position: {\n    distance: -100,\n  },\n})\n",paraId:24,tocIndex:3},{value:"We can set the label's offset using the ",paraId:25,tocIndex:4},{value:"position.offset",paraId:25,tocIndex:4},{value:" option of the Label, with a default value of ",paraId:25,tocIndex:4},{value:"0",paraId:25,tocIndex:4},{value:", indicating no offset. Depending on the value, the calculation of the label's offset can be categorized into three cases.",paraId:25,tocIndex:4},{value:"A positive number indicates an ",paraId:26,tocIndex:4},{value:"absolute offset downwards perpendicular to the edge",paraId:26,tocIndex:4},{value:".",paraId:26,tocIndex:4},{value:"A negative number indicates an ",paraId:26,tocIndex:4},{value:"absolute offset upwards perpendicular to the edge",paraId:26,tocIndex:4},{value:".",paraId:26,tocIndex:4},{value:"A coordinate object ",paraId:26,tocIndex:4},{value:"{x: number; y: number }",paraId:26,tocIndex:4},{value:" indicates an ",paraId:26,tocIndex:4},{value:"absolute offset in both ",paraId:26,tocIndex:4},{value:"x",paraId:26,tocIndex:4},{value:" and ",paraId:26,tocIndex:4},{value:"y",paraId:26,tocIndex:4},{value:" directions",paraId:26,tocIndex:4},{value:".",paraId:26,tocIndex:4},{value:"edge.appendLabel({\n  attrs: {\n    text: {\n      text: 'offset: 40',\n    },\n  },\n  position: {\n    distance: 0.66,\n    offset: 40,\n  },\n})\n\nedge.appendLabel({\n  attrs: {\n    text: {\n      text: 'offset: -40',\n    },\n  },\n  position: {\n    distance: 0.66,\n    offset: -40,\n  },\n})\n\nedge.appendLabel({\n  attrs: {\n    text: {\n      text: 'offset: { x: -40, y: 80 }',\n    },\n  },\n  position: {\n    distance: 0.66,\n    offset: {\n      x: -40,\n      y: 80,\n    },\n  },\n})\n",paraId:27,tocIndex:4},{value:"We can set the label's rotation angle in the ",paraId:28,tocIndex:5},{value:"clockwise direction",paraId:28,tocIndex:5},{value:" using the ",paraId:28,tocIndex:5},{value:"position.angle",paraId:28,tocIndex:5},{value:" option of the Label, with a default value of ",paraId:28,tocIndex:5},{value:"0",paraId:28,tocIndex:5},{value:", indicating no rotation.",paraId:28,tocIndex:5},{value:"Options",paraId:29,tocIndex:5},{value:"When ",paraId:30,tocIndex:5},{value:"position.options.keepGradient",paraId:30,tocIndex:5},{value:" is ",paraId:30,tocIndex:5},{value:"true",paraId:30,tocIndex:5},{value:", the initial rotation angle of the label is the angle of the edge at the label's position, and subsequent ",paraId:30,tocIndex:5},{value:"position.angle",paraId:30,tocIndex:5},{value:" settings are relative to that initial angle.",paraId:30,tocIndex:5},{value:"When ",paraId:30,tocIndex:5},{value:"position.options.ensureLegibility",paraId:30,tocIndex:5},{value:" is ",paraId:30,tocIndex:5},{value:"true",paraId:30,tocIndex:5},{value:", an additional 180 rotation will be applied to the label if necessary to ensure the label text is more readable.",paraId:30,tocIndex:5},{value:"edge.appendLabel({\n  attrs: {\n    text: {\n      text: '70\\nkeepGradient',\n    },\n  },\n  position: {\n    distance: 0.05,\n    angle: 70,\n    options: {\n      keepGradient: true,\n    },\n  },\n})\n\nedge.appendLabel({\n  attrs: {\n    text: {\n      text: '0\\nkeepGradient',\n    },\n  },\n  position: {\n    distance: 0.3,\n    options: {\n      keepGradient: true,\n    },\n  },\n})\n\nedge.appendLabel({\n  attrs: {\n    text: {\n      text: '45',\n    },\n  },\n  position: {\n    distance: 0.8,\n    angle: 45,\n  },\n})\n\nedge.appendLabel({\n  attrs: {\n    text: {\n      text: '135',\n    },\n  },\n  position: {\n    distance: 0.9,\n    angle: 135,\n  },\n})\n\nedge.appendLabel({\n  attrs: {\n    text: {\n      text: '270\\nkeepGradient',\n    },\n  },\n  position: {\n    distance: 0.66,\n    offset: 80,\n    angle: 270,\n    options: {\n      keepGradient: true,\n    },\n  },\n})\n\nedge.appendLabel({\n  attrs: {\n    text: {\n      text: '270\\nkeepGradient\\nensureLegibility',\n    },\n  },\n  position: {\n    distance: 0.66,\n    offset: -80,\n    angle: 270,\n    options: {\n      keepGradient: true,\n      ensureLegibility: true,\n    },\n  },\n})\n",paraId:31,tocIndex:5},{value:"We can customize the label style using the ",paraId:32,tocIndex:6},{value:"markup",paraId:32,tocIndex:6},{value:" and ",paraId:32,tocIndex:6},{value:"attrs",paraId:32,tocIndex:6},{value:" options, supporting customization in two dimensions.",paraId:32,tocIndex:6},{value:"Method 1",paraId:33,tocIndex:6},{value:": Globally override the default label definition when creating an Edge, affecting all labels.",paraId:33,tocIndex:6},{value:"const edge = graph.addEdge({\n  source: { x: 100, y: 40 },\n  target: { x: 400, y: 40 },\n  defaultLabel: {\n    markup: [\n      {\n        tagName: 'ellipse',\n        selector: 'bg',\n      },\n      {\n        tagName: 'text',\n        selector: 'txt',\n      },\n    ],\n    attrs: {\n      txt: {\n        fill: '#7c68fc',\n        textAnchor: 'middle',\n        textVerticalAnchor: 'middle',\n      },\n      bg: {\n        ref: 'txt',\n        refRx: '70%',\n        refRy: '80%',\n        stroke: '#7c68fc',\n        fill: 'white',\n        strokeWidth: 2,\n      },\n    },\n  },\n})\n\nedge.appendLabel({\n  attrs: {\n    txt: {\n      text: 'First',\n    },\n  },\n  position: {\n    distance: 0.3,\n  },\n})\n\nedge.appendLabel({\n  attrs: {\n    txt: {\n      text: 'Second',\n    },\n  },\n  position: {\n    distance: 0.7,\n  },\n})\n",paraId:34,tocIndex:6},{value:"Method 2",paraId:35},{value:": Override the default label definition when creating a single label, affecting only that label.",paraId:35},{value:"edge.appendLabel({\n  markup: [\n    {\n      tagName: 'circle',\n      selector: 'body',\n    },\n    {\n      tagName: 'text',\n      selector: 'label',\n    },\n    {\n      tagName: 'circle',\n      selector: 'asteriskBody',\n    },\n    {\n      tagName: 'text',\n      selector: 'asterisk',\n    },\n  ],\n  attrs: {\n    label: {\n      text: '',\n      fill: '#000',\n      fontSize: 12,\n      textAnchor: 'middle',\n      textVerticalAnchor: 'middle',\n      pointerEvents: 'none',\n    },\n    body: {\n      ref: 'label',\n      fill: '#fff',\n      stroke: '#000',\n      strokeWidth: 1,\n      refR: 1,\n      refCx: 0,\n      refCy: 0,\n    },\n    asterisk: {\n      ref: 'label',\n      text: '',\n      fill: '#ff0000',\n      fontSize: 8,\n      textAnchor: 'middle',\n      textVerticalAnchor: 'middle',\n      pointerEvents: 'none',\n      refX: 16.5,\n      refY: -2,\n    },\n    asteriskBody: {\n      ref: 'asterisk',\n      fill: '#fff',\n      stroke: '#000',\n      strokeWidth: 1,\n      refR: 1,\n      refCx: '50%',\n      refCy: '50%',\n      refX: 0,\n      refY: 0,\n    },\n  },\n})\n",paraId:36},{value:"When setting the ",paraId:37,tocIndex:7},{value:"default label",paraId:38,tocIndex:7},{value:" using the ",paraId:37,tocIndex:7},{value:"updateLabels",paraId:39,tocIndex:7},{value:" option, adding labels becomes very simple, as shown in the following code.",paraId:37,tocIndex:7},{value:"// Specify label when creating a node\nconst edge = graph.addEdge({\n  source,\n  target,\n  labels: [\n    {\n      attrs: { label: { text: 'edge label' } },\n    },\n  ],\n})\n\n// Reset labels\nedge.setLabels([\n  {\n    attrs: { label: { text: 'edge label' } },\n  },\n])\n\n// Append label\nedge.appendLabel({\n  attrs: { label: { text: 'edge label' } },\n})\n",paraId:40,tocIndex:7},{value:"The above code only sets the label text, but it looks complicated as we have to provide a deeply nested object ",paraId:41,tocIndex:7},{value:"{ attrs: { label: { text: 'edge' } } }",paraId:41,tocIndex:7},{value:". To simplify this, we provide a syntax sugar that allows direct input of string labels, making the above code even simpler.",paraId:41,tocIndex:7},{value:"const edge = graph.addEdge({\n  source,\n  target,\n  labels: ['edge label'],\n})\n\nedge.setLabels(['edge label'])\n\nedge.appendLabel('edge label')\n",paraId:42,tocIndex:7},{value:"This syntax sugar defines a static method ",paraId:43,tocIndex:7},{value:"parseStringLabel",paraId:43,tocIndex:7},{value:" on ",paraId:43,tocIndex:7},{value:"Edge",paraId:43,tocIndex:7},{value:", which converts string labels into Label objects. The default implementation is as follows.",paraId:43,tocIndex:7},{value:"function parseStringLabel(label: string): Label {\n  return {\n    attrs: { label: { text: label } },\n  }\n}\n",paraId:44,tocIndex:7},{value:"It is important to note that this syntax sugar only applies to the system's default labels. This means that if you redefine the default label's ",paraId:45,tocIndex:7},{value:"markup",paraId:45,tocIndex:7},{value:" using the ",paraId:45,tocIndex:7},{value:"defaultLabel",paraId:45,tocIndex:7},{value:" option, you will also need to rewrite the ",paraId:45,tocIndex:7},{value:"parseStringLabel",paraId:45,tocIndex:7},{value:" method to ensure the usability of string labels.",paraId:45,tocIndex:7},{value:"Edge.config({\n  defaultLabel: {\n    markup: [\n      {\n        tagName: 'rect',\n        selector: 'body',\n      },\n      {\n        tagName: 'text',\n        selector: 'my-label', // Here the default selector is modified.\n      },\n    ],\n  },\n})\n\n// You also need to redefine parseStringLabel to ensure the usability of string labels.\nEdge.parseStringLabel = (label: string) => {\n  return {\n    attrs: { 'my-label': { text: label } },\n  }\n}\n",paraId:46,tocIndex:7},{value:"Most edges only have at most one label, so we define a ",paraId:47,tocIndex:8},{value:"custom option",paraId:48,tocIndex:8},{value:" ",paraId:47,tocIndex:8},{value:"label",paraId:47,tocIndex:8},{value:" for ",paraId:47,tocIndex:8},{value:"Edge",paraId:47,tocIndex:8},{value:" to support passing a single label.",paraId:47,tocIndex:8},{value:"graph.addEdge({\n  source,\n  target,\n  label: {\n    attrs: { label: { text: 'edge label' } },\n  },\n})\n",paraId:49,tocIndex:8},{value:"When only setting the label text, you can also use the string form of a single label.",paraId:50,tocIndex:8},{value:"graph.addEdge({\n  source,\n  target,\n  label: 'edge label',\n})\n",paraId:51,tocIndex:8}]},35821:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(17053);const n=[{value:"In the previous ",paraId:0},{value:"tutorial",paraId:1},{value:", we briefly introduced how to use the two special attributes ",paraId:0},{value:"sourceMarker",paraId:2},{value:" and ",paraId:0},{value:"targetMarker",paraId:3},{value:" to specify the starting and ending arrows for edges. We demonstrated how to use built-in arrows and custom arrows. Next, we will first list the parameters for each built-in arrow, then provide a detailed explanation of how to use various SVG elements to customize arrows, and finally explain how to register custom arrows as built-in arrows.",paraId:0},{value:"Built-in arrows allow for the parameterization of commonly used arrow types. When using built-in arrows, you only need to specify the arrow name ",paraId:4,tocIndex:0},{value:"name",paraId:4,tocIndex:0},{value:" and the corresponding parameters. The fill color ",paraId:4,tocIndex:0},{value:"fill",paraId:4,tocIndex:0},{value:" and stroke color ",paraId:4,tocIndex:0},{value:"stroke",paraId:4,tocIndex:0},{value:" default to inheriting from the edge, but can be overridden by specifying the ",paraId:4,tocIndex:0},{value:"fill",paraId:4,tocIndex:0},{value:" and ",paraId:4,tocIndex:0},{value:"stroke",paraId:4,tocIndex:0},{value:" properties.",paraId:4,tocIndex:0},{value:"edge.attr({\n  line: {\n    sourceMarker: 'block',\n    targetMarker: {\n      name: 'ellipse',\n      rx: 10, // x radius of the ellipse arrow\n      ry: 6,  // y radius of the ellipse arrow\n    },\n  },\n})\n",paraId:5,tocIndex:0},{value:"Each built-in arrow has corresponding parameters, which will be introduced below.",paraId:6},{value:"Solid arrow.",paraId:7,tocIndex:1},{value:"Parameter Name",paraId:8,tocIndex:1},{value:"Type",paraId:8,tocIndex:1},{value:"Default Value",paraId:8,tocIndex:1},{value:"Description",paraId:8,tocIndex:1},{value:"size",paraId:8,tocIndex:1},{value:"Number",paraId:8,tocIndex:1},{value:"10",paraId:8,tocIndex:1},{value:"Size of the arrow.",paraId:8,tocIndex:1},{value:"width",paraId:8,tocIndex:1},{value:"Number",paraId:8,tocIndex:1},{value:"size",paraId:8,tocIndex:1},{value:"Width of the arrow; can use ",paraId:8,tocIndex:1},{value:"size",paraId:8,tocIndex:1},{value:" directly when width and height are the same.",paraId:8,tocIndex:1},{value:"height",paraId:8,tocIndex:1},{value:"Number",paraId:8,tocIndex:1},{value:"size",paraId:8,tocIndex:1},{value:"Height of the arrow; can use ",paraId:8,tocIndex:1},{value:"size",paraId:8,tocIndex:1},{value:" directly when width and height are the same.",paraId:8,tocIndex:1},{value:"offset",paraId:8,tocIndex:1},{value:"Number",paraId:8,tocIndex:1},{value:"0",paraId:8,tocIndex:1},{value:"Absolute offset along the edge direction.",paraId:8,tocIndex:1},{value:"open",paraId:8,tocIndex:1},{value:"Boolean",paraId:8,tocIndex:1},{value:"false",paraId:8,tocIndex:1},{value:"Non-closed arrow.",paraId:8,tocIndex:1},{value:"...attrs",paraId:8,tocIndex:1},{value:"Object",paraId:8,tocIndex:1},{value:"{ }",paraId:8,tocIndex:1},{value:"Other parameters will be treated as attributes of the arrow ",paraId:8,tocIndex:1},{value:"<path>",paraId:8,tocIndex:1},{value:" element, such as ",paraId:8,tocIndex:1},{value:"fill",paraId:8,tocIndex:1},{value:" and ",paraId:8,tocIndex:1},{value:"'stroke'",paraId:8,tocIndex:1},{value:".",paraId:8,tocIndex:1},{value:"Classic arrow.",paraId:9,tocIndex:2},{value:"Parameter Name",paraId:10,tocIndex:2},{value:"Type",paraId:10,tocIndex:2},{value:"Default Value",paraId:10,tocIndex:2},{value:"Description",paraId:10,tocIndex:2},{value:"size",paraId:10,tocIndex:2},{value:"Number",paraId:10,tocIndex:2},{value:"10",paraId:10,tocIndex:2},{value:"Size of the arrow.",paraId:10,tocIndex:2},{value:"width",paraId:10,tocIndex:2},{value:"Number",paraId:10,tocIndex:2},{value:"size",paraId:10,tocIndex:2},{value:"Width of the arrow; can use ",paraId:10,tocIndex:2},{value:"size",paraId:10,tocIndex:2},{value:" directly when width and height are the same.",paraId:10,tocIndex:2},{value:"height",paraId:10,tocIndex:2},{value:"Number",paraId:10,tocIndex:2},{value:"size",paraId:10,tocIndex:2},{value:"Height of the arrow; can use ",paraId:10,tocIndex:2},{value:"size",paraId:10,tocIndex:2},{value:" directly when width and height are the same.",paraId:10,tocIndex:2},{value:"offset",paraId:10,tocIndex:2},{value:"Number",paraId:10,tocIndex:2},{value:"0",paraId:10,tocIndex:2},{value:"Absolute offset along the edge direction.",paraId:10,tocIndex:2},{value:"...attrs",paraId:10,tocIndex:2},{value:"Object",paraId:10,tocIndex:2},{value:"{ }",paraId:10,tocIndex:2},{value:"Other parameters will be treated as attributes of the arrow ",paraId:10,tocIndex:2},{value:"<path>",paraId:10,tocIndex:2},{value:" element, such as ",paraId:10,tocIndex:2},{value:"fill",paraId:10,tocIndex:2},{value:" and ",paraId:10,tocIndex:2},{value:"'stroke'",paraId:10,tocIndex:2},{value:".",paraId:10,tocIndex:2},{value:"Diamond arrow.",paraId:11,tocIndex:3},{value:"Parameter Name",paraId:12,tocIndex:3},{value:"Type",paraId:12,tocIndex:3},{value:"Default Value",paraId:12,tocIndex:3},{value:"Description",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:"Number",paraId:12,tocIndex:3},{value:"10",paraId:12,tocIndex:3},{value:"Size of the arrow.",paraId:12,tocIndex:3},{value:"width",paraId:12,tocIndex:3},{value:"Number",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:"Width of the arrow; can use ",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:" directly when width and height are the same.",paraId:12,tocIndex:3},{value:"height",paraId:12,tocIndex:3},{value:"Number",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:"Height of the arrow; can use ",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:" directly when width and height are the same.",paraId:12,tocIndex:3},{value:"offset",paraId:12,tocIndex:3},{value:"Number",paraId:12,tocIndex:3},{value:"0",paraId:12,tocIndex:3},{value:"Absolute offset along the edge direction.",paraId:12,tocIndex:3},{value:"...attrs",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"{ }",paraId:12,tocIndex:3},{value:"Other parameters will be treated as attributes of the arrow ",paraId:12,tocIndex:3},{value:"<path>",paraId:12,tocIndex:3},{value:" element, such as ",paraId:12,tocIndex:3},{value:"fill",paraId:12,tocIndex:3},{value:" and ",paraId:12,tocIndex:3},{value:"'stroke'",paraId:12,tocIndex:3},{value:".",paraId:12,tocIndex:3},{value:"Cross arrow.",paraId:13,tocIndex:4},{value:"Parameter Name",paraId:14,tocIndex:4},{value:"Type",paraId:14,tocIndex:4},{value:"Default Value",paraId:14,tocIndex:4},{value:"Description",paraId:14,tocIndex:4},{value:"size",paraId:14,tocIndex:4},{value:"Number",paraId:14,tocIndex:4},{value:"10",paraId:14,tocIndex:4},{value:"Size of the arrow.",paraId:14,tocIndex:4},{value:"width",paraId:14,tocIndex:4},{value:"Number",paraId:14,tocIndex:4},{value:"size",paraId:14,tocIndex:4},{value:"Width of the arrow; can use ",paraId:14,tocIndex:4},{value:"size",paraId:14,tocIndex:4},{value:" directly when width and height are the same.",paraId:14,tocIndex:4},{value:"height",paraId:14,tocIndex:4},{value:"Number",paraId:14,tocIndex:4},{value:"size",paraId:14,tocIndex:4},{value:"Height of the arrow; can use ",paraId:14,tocIndex:4},{value:"size",paraId:14,tocIndex:4},{value:" directly when width and height are the same.",paraId:14,tocIndex:4},{value:"offset",paraId:14,tocIndex:4},{value:"Number",paraId:14,tocIndex:4},{value:"0",paraId:14,tocIndex:4},{value:"Absolute offset along the edge direction.",paraId:14,tocIndex:4},{value:"...attrs",paraId:14,tocIndex:4},{value:"Object",paraId:14,tocIndex:4},{value:"{ }",paraId:14,tocIndex:4},{value:"Other parameters will be treated as attributes of the arrow ",paraId:14,tocIndex:4},{value:"<path>",paraId:14,tocIndex:4},{value:" element, such as ",paraId:14,tocIndex:4},{value:"fill",paraId:14,tocIndex:4},{value:" and ",paraId:14,tocIndex:4},{value:"'stroke'",paraId:14,tocIndex:4},{value:".",paraId:14,tocIndex:4},{value:"Parameter Name",paraId:15,tocIndex:5},{value:"Type",paraId:15,tocIndex:5},{value:"Default Value",paraId:15,tocIndex:5},{value:"Description",paraId:15,tocIndex:5},{value:"width",paraId:15,tocIndex:5},{value:"Number",paraId:15,tocIndex:5},{value:"10",paraId:15,tocIndex:5},{value:"Width of the arrow.",paraId:15,tocIndex:5},{value:"height",paraId:15,tocIndex:5},{value:"Number",paraId:15,tocIndex:5},{value:"6",paraId:15,tocIndex:5},{value:"Height of the arrow.",paraId:15,tocIndex:5},{value:"offset",paraId:15,tocIndex:5},{value:"Number",paraId:15,tocIndex:5},{value:"0",paraId:15,tocIndex:5},{value:"Absolute offset along the edge direction.",paraId:15,tocIndex:5},{value:"open",paraId:15,tocIndex:5},{value:"Boolean",paraId:15,tocIndex:5},{value:"false",paraId:15,tocIndex:5},{value:"Non-closed arrow.",paraId:15,tocIndex:5},{value:"flip",paraId:15,tocIndex:5},{value:"Boolean",paraId:15,tocIndex:5},{value:"false",paraId:15,tocIndex:5},{value:"Whether to flip the arrow.",paraId:15,tocIndex:5},{value:"...attrs",paraId:15,tocIndex:5},{value:"Object",paraId:15,tocIndex:5},{value:"{ }",paraId:15,tocIndex:5},{value:"Other parameters will be treated as attributes of the arrow ",paraId:15,tocIndex:5},{value:"<path>",paraId:15,tocIndex:5},{value:" element, such as ",paraId:15,tocIndex:5},{value:"fill",paraId:15,tocIndex:5},{value:" and ",paraId:15,tocIndex:5},{value:"'stroke'",paraId:15,tocIndex:5},{value:".",paraId:15,tocIndex:5},{value:"Custom arrow with ",paraId:16,tocIndex:6},{value:"pathData",paraId:16,tocIndex:6},{value:".",paraId:16,tocIndex:6},{value:"Parameter Name",paraId:17,tocIndex:6},{value:"Type",paraId:17,tocIndex:6},{value:"Default Value",paraId:17,tocIndex:6},{value:"Description",paraId:17,tocIndex:6},{value:"d",paraId:17,tocIndex:6},{value:"string",paraId:17,tocIndex:6},{value:"undefined",paraId:17,tocIndex:6},{value:"The ",paraId:17,tocIndex:6},{value:"d attribute value",paraId:17,tocIndex:6},{value:" of the ",paraId:17,tocIndex:6},{value:"<path>",paraId:17,tocIndex:6},{value:" element, applied to the ",paraId:17,tocIndex:6},{value:"<path>",paraId:17,tocIndex:6},{value:" element after being standardized by ",paraId:17,tocIndex:6},{value:"Util.normalizeMarker",paraId:17,tocIndex:6},{value:".",paraId:17,tocIndex:6},{value:"offsetX",paraId:17,tocIndex:6},{value:"Number",paraId:17,tocIndex:6},{value:"0",paraId:17,tocIndex:6},{value:"x-direction offset.",paraId:17,tocIndex:6},{value:"offsetY",paraId:17,tocIndex:6},{value:"Number",paraId:17,tocIndex:6},{value:"0",paraId:17,tocIndex:6},{value:"y-direction offset.",paraId:17,tocIndex:6},{value:"...attrs",paraId:17,tocIndex:6},{value:"Object",paraId:17,tocIndex:6},{value:"{ }",paraId:17,tocIndex:6},{value:"Other parameters will be treated as attributes of the arrow ",paraId:17,tocIndex:6},{value:"<path>",paraId:17,tocIndex:6},{value:" element, such as ",paraId:17,tocIndex:6},{value:"fill",paraId:17,tocIndex:6},{value:" and ",paraId:17,tocIndex:6},{value:"'stroke'",paraId:17,tocIndex:6},{value:".",paraId:17,tocIndex:6},{value:"graph.addEdge({\n  source: { x: 100, y: 40 },\n  target: { x: 400, y: 40 },\n  attrs: {\n    line: {\n      stroke: '#31d0c6',\n      sourceMarker: {\n        name: 'path',\n        d: 'M5.5,15.499,15.8,21.447,15.8,15.846,25.5,21.447,25.5,9.552,15.8,15.152,15.8,9.552z',\n      },\n      targetMarker: {\n        name: 'path',\n        offsetX: 10,\n        d: 'M4.834,4.834L4.833,4.833c-5.889,5.892-5.89,15.443,0.001,21.334s15.44,5.888,21.33-0.002c5.891-5.891,5.893-15.44,0.002-21.33C20.275-1.056,10.725-1.056,4.834,4.834zM25.459,5.542c0.833,0.836,1.523,1.757,2.104,2.726l-4.08,4.08c-0.418-1.062-1.053-2.06-1.912-2.918c-0.859-0.859-1.857-1.494-2.92-1.913l4.08-4.08C23.7,4.018,24.622,4.709,25.459,5.542zM10.139,20.862c-2.958-2.968-2.959-7.758-0.001-10.725c2.966-2.957,7.756-2.957,10.725,0c2.954,2.965,2.955,7.757-0.001,10.724C17.896,23.819,13.104,23.817,10.139,20.862zM5.542,25.459c-0.833-0.837-1.524-1.759-2.105-2.728l4.081-4.081c0.418,1.063,1.055,2.06,1.914,2.919c0.858,0.859,1.855,1.494,2.917,1.913l-4.081,4.081C7.299,26.982,6.379,26.292,5.542,25.459zM8.268,3.435l4.082,4.082C11.288,7.935,10.29,8.571,9.43,9.43c-0.858,0.859-1.494,1.855-1.912,2.918L3.436,8.267c0.58-0.969,1.271-1.89,2.105-2.727C6.377,4.707,7.299,4.016,8.268,3.435zM22.732,27.563l-4.082-4.082c1.062-0.418,2.061-1.053,2.919-1.912c0.859-0.859,1.495-1.857,1.913-2.92l4.082,4.082c-0.58,0.969-1.271,1.891-2.105,2.728C24.623,26.292,23.701,26.983,22.732,27.563z',\n      },\n    },\n  },\n})\n",paraId:18,tocIndex:6},{value:"Circular arrow.",paraId:19,tocIndex:7},{value:"Parameter Name",paraId:20,tocIndex:7},{value:"Type",paraId:20,tocIndex:7},{value:"Default Value",paraId:20,tocIndex:7},{value:"Description",paraId:20,tocIndex:7},{value:"r",paraId:20,tocIndex:7},{value:"Number",paraId:20,tocIndex:7},{value:"5",paraId:20,tocIndex:7},{value:"Circle radius.",paraId:20,tocIndex:7},{value:"...attrs",paraId:20,tocIndex:7},{value:"Object",paraId:20,tocIndex:7},{value:"{ }",paraId:20,tocIndex:7},{value:"Other parameters will be treated as attributes of the arrow ",paraId:20,tocIndex:7},{value:"<circle>",paraId:20,tocIndex:7},{value:" element, such as ",paraId:20,tocIndex:7},{value:"fill",paraId:20,tocIndex:7},{value:" and ",paraId:20,tocIndex:7},{value:"'stroke'",paraId:20,tocIndex:7},{value:".",paraId:20,tocIndex:7},{value:"Circular plus arrow.",paraId:21,tocIndex:8},{value:"Parameter Name",paraId:22,tocIndex:8},{value:"Type",paraId:22,tocIndex:8},{value:"Default Value",paraId:22,tocIndex:8},{value:"Description",paraId:22,tocIndex:8},{value:"r",paraId:22,tocIndex:8},{value:"Number",paraId:22,tocIndex:8},{value:"5",paraId:22,tocIndex:8},{value:"Circle radius.",paraId:22,tocIndex:8},{value:"...attrs",paraId:22,tocIndex:8},{value:"Object",paraId:22,tocIndex:8},{value:"{ }",paraId:22,tocIndex:8},{value:"Other parameters will be treated as attributes of the arrow ",paraId:22,tocIndex:8},{value:"<path>",paraId:22,tocIndex:8},{value:" element (plus), such as ",paraId:22,tocIndex:8},{value:"fill",paraId:22,tocIndex:8},{value:" and ",paraId:22,tocIndex:8},{value:"'stroke'",paraId:22,tocIndex:8},{value:".",paraId:22,tocIndex:8},{value:"Elliptical arrow.",paraId:23,tocIndex:9},{value:"Parameter Name",paraId:24,tocIndex:9},{value:"Type",paraId:24,tocIndex:9},{value:"Default Value",paraId:24,tocIndex:9},{value:"Description",paraId:24,tocIndex:9},{value:"rx",paraId:24,tocIndex:9},{value:"Number",paraId:24,tocIndex:9},{value:"5",paraId:24,tocIndex:9},{value:"x-axis radius of the ellipse.",paraId:24,tocIndex:9},{value:"ry",paraId:24,tocIndex:9},{value:"Number",paraId:24,tocIndex:9},{value:"5",paraId:24,tocIndex:9},{value:"y-axis radius of the ellipse.",paraId:24,tocIndex:9},{value:"...attrs",paraId:24,tocIndex:9},{value:"Object",paraId:24,tocIndex:9},{value:"{ }",paraId:24,tocIndex:9},{value:"Other parameters will be treated as attributes of the arrow ",paraId:24,tocIndex:9},{value:"<ellipse>",paraId:24,tocIndex:9},{value:" element, such as ",paraId:24,tocIndex:9},{value:"fill",paraId:24,tocIndex:9},{value:" and ",paraId:24,tocIndex:9},{value:"'stroke'",paraId:24,tocIndex:9},{value:".",paraId:24,tocIndex:9},{value:"We can specify which SVG element to use for rendering the arrow through ",paraId:25,tocIndex:10},{value:"tagName",paraId:25,tocIndex:10},{value:". For example, below we specify the use of the ",paraId:25,tocIndex:10},{value:"<path>",paraId:25,tocIndex:10},{value:" element to render the arrow. All options except ",paraId:25,tocIndex:10},{value:"tagName",paraId:25,tocIndex:10},{value:" will be added as attributes to the created ",paraId:25,tocIndex:10},{value:"<path>",paraId:25,tocIndex:10},{value:" element. The fill color ",paraId:25,tocIndex:10},{value:"fill",paraId:25,tocIndex:10},{value:" and stroke color ",paraId:25,tocIndex:10},{value:"stroke",paraId:25,tocIndex:10},{value:" default to inheriting from the edge, but can be overridden by specifying the ",paraId:25,tocIndex:10},{value:"fill",paraId:25,tocIndex:10},{value:" and ",paraId:25,tocIndex:10},{value:"stroke",paraId:25,tocIndex:10},{value:" properties.",paraId:25,tocIndex:10},{value:"edge.attr({\n  line: {\n    sourceMarker: {\n      tagName: 'path',\n      d: 'M 20 -10 0 0 20 10 Z',\n    },\n    targetMarker: {\n      tagName: 'path',\n      fill: 'yellow', // Use custom fill color\n      stroke: 'green', // Use custom stroke color\n      strokeWidth: 2,\n      d: 'M 20 -10 0 0 20 10 Z',\n    },\n  },\n})\n",paraId:26,tocIndex:10},{value:"In the code above, it is worth noting that our starting and ending arrows use the same ",paraId:27,tocIndex:10},{value:"'d'",paraId:27,tocIndex:10},{value:" attribute value because we automatically calculate the arrow direction. In simple terms, we only need to define an arrow that points ",paraId:27,tocIndex:10},{value:"left towards the origin",paraId:27,tocIndex:10},{value:".",paraId:27,tocIndex:10},{value:"Sometimes, the coordinates of the ",paraId:28},{value:"d",paraId:28},{value:" attribute of the path element we obtain may not be standardized. If used directly as an arrow, it may result in positional deviation. Therefore, we provide the ",paraId:28},{value:"normalizeMarker",paraId:28},{value:" utility method in the ",paraId:28},{value:"Util",paraId:28},{value:" namespace to standardize the coordinates of ",paraId:28},{value:"d",paraId:28},{value:".",paraId:28},{value:"Method Signature",paraId:29},{value:"Registry.Marker.normalize(d: string, offset: { x?: number; y?: number }): string\nRegistry.Marker.normalize(d: string, offsetX?: number, offsetY?: number): string\n",paraId:30},{value:"Parameter Name",paraId:31},{value:"Type",paraId:31},{value:"Description",paraId:31},{value:"d",paraId:31},{value:"string",paraId:31},{value:"offset",paraId:31},{value:"{ x?: number; y?: number }",paraId:31},{value:"Offset relative to the origin",paraId:31},{value:"offsetX",paraId:31},{value:"number",paraId:31},{value:"x-axis offset relative to the origin",paraId:31},{value:"offsetY",paraId:31},{value:"number",paraId:31},{value:"y-axis offset relative to the origin",paraId:31},{value:"Comparing the starting and ending arrows below, it is clear that the starting arrow has a certain offset. After processing with ",paraId:32},{value:"normalizeMarker",paraId:32},{value:", the position of the ending arrow is corrected.",paraId:32},{value:"const d =\n  'M4.834,4.834L4.833,4.833c-5.889,5.892-5.89,15.443,0.001,21.334s15.44,5.888,21.33-0.002c5.891-5.891,5.893-15.44,0.002-21.33C20.275-1.056,10.725-1.056,4.834,4.834zM25.459,5.542c0.833,0.836,1.523,1.757,2.104,2.726l-4.08,4.08c-0.418-1.062-1.053-2.06-1.912-2.918c-0.859-0.859-1.857-1.494-2.92-1.913l4.08-4.08C23.7,4.018,24.622,4.709,25.459,5.542zM10.139,20.862c-2.958-2.968-2.959-7.758-0.001-10.725c2.966-2.957,7.756-2.957,10.725,0c2.954,2.965,2.955,7.757-0.001,10.724C17.896,23.819,13.104,23.817,10.139,20.862zM5.542,25.459c-0.833-0.837-1.524-1.759-2.105-2.728l4.081-4.081c0.418,1.063,1.055,2.06,1.914,2.919c0.858,0.859,1.855,1.494,2.917,1.913l-4.081,4.081C7.299,26.982,6.379,26.292,5.542,25.459zM8.268,3.435l4.082,4.082C11.288,7.935,10.29,8.571,9.43,9.43c-0.858,0.859-1.494,1.855-1.912,2.918L3.436,8.267c0.58-0.969,1.271-1.89,2.105-2.727C6.377,4.707,7.299,4.016,8.268,3.435zM22.732,27.563l-4.082-4.082c1.062-0.418,2.061-1.053,2.919-1.912c0.859-0.859,1.495-1.857,1.913-2.92l4.082,4.082c-0.58,0.969-1.271,1.891-2.105,2.728C24.623,26.292,23.701,26.983,22.732,27.563z'\n\ngraph.addEdge({\n  source: { x: 160, y: 40 },\n  target: { x: 420, y: 40 },\n  attrs: {\n    line: {\n      stroke: '#31d0c6',\n      sourceMarker: {\n        d,\n        tagName: 'path',\n      },\n      targetMarker: {\n        tagName: 'path',\n        d: Util.normalizeMarker(d),\n      },\n    },\n  },\n})\n",paraId:33},{value:"In addition to ",paraId:34},{value:"<path>",paraId:34},{value:", we can also use ",paraId:34},{value:"<circle>",paraId:34},{value:", ",paraId:34},{value:"<image>",paraId:34},{value:", ",paraId:34},{value:"<ellipse>",paraId:34},{value:", ",paraId:34},{value:"<rect>",paraId:34},{value:", ",paraId:34},{value:"<polyline>",paraId:34},{value:", ",paraId:34},{value:"<polygon>",paraId:34},{value:", and other elements to define arrows. You just need to specify the tag name through ",paraId:34},{value:"tagName",paraId:34},{value:" and set other necessary attributes for the element. For example, using an image to customize an arrow is also simple. First, we set ",paraId:34},{value:"tagName",paraId:34},{value:" to ",paraId:34},{value:"image",paraId:34},{value:" and specify the image URL through the ",paraId:34},{value:"xlink:href",paraId:34},{value:" attribute, and then adjust the ",paraId:34},{value:"y",paraId:34},{value:" attribute to center the image.",paraId:34},{value:"edge.attr({\n  line: {\n    sourceMarker: {\n      tagName: 'image',\n      'xlink:href':\n        'http://cdn3.iconfinder.com/data/icons/49handdrawing/24x24/left.png',\n      width: 24,\n      height: 24,\n      y: -12,\n    },\n    targetMarker: {\n      tagName: 'image',\n      'xlink:href':\n        'http://cdn3.iconfinder.com/data/icons/49handdrawing/24x24/left.png',\n      width: 24,\n      height: 24,\n      y: -12,\n    },\n  },\n})\n",paraId:35},{value:"It is important to note that when using ",paraId:36},{value:"<circle>",paraId:36},{value:" and ",paraId:36},{value:"<ellipse>",paraId:36},{value:" to customize arrows, you can set their ",paraId:36},{value:"cx",paraId:36},{value:" attribute to the corresponding axis radius to avoid the arrow overflowing the edge boundary. Other elements can be adjusted using the ",paraId:36},{value:"y",paraId:36},{value:" attribute to center the arrow vertically.",paraId:36},{value:"edge.attr({\n  line: {\n    sourceMarker: {\n      tagName: 'ellipse',\n      rx: 20,\n      ry: 10,\n      cx: 20,\n      fill: 'rgba(255,0,0,0.3)',\n    },\n    targetMarker: {\n      tagName: 'circle',\n      r: 12,\n      cx: 12,\n      fill: 'rgba(0,255,0,0.3)',\n    },\n  },\n})\n",paraId:37},{value:"Registration refers to the process of registering a method for generating arrows within the X6 system, which we call an arrow factory method. Once registered, the arrow can be used just like built-in arrows.",paraId:38,tocIndex:11},{value:"When do we need to register arrows?",paraId:39,tocIndex:11},{value:"To unify the abstraction of classic arrows and extract key parameters, allowing parameters to influence the rendering of arrows for multi-scenario reuse, as described in the ",paraId:40,tocIndex:11},{value:"Built-in Arrows",paraId:41,tocIndex:11},{value:" section.",paraId:40,tocIndex:11},{value:"To provide a unified definition for complex arrows, allowing for a single definition to be reused in multiple places, such as arrows with complex properties and style configurations.",paraId:40,tocIndex:11},{value:"To enhance code readability through semantic arrow names and parameter names. For example, we can replace the ",paraId:40,tocIndex:11},{value:"xlink:href",paraId:40,tocIndex:11},{value:" attribute of the ",paraId:40,tocIndex:11},{value:"<image>",paraId:40,tocIndex:11},{value:" arrow with the parameter name ",paraId:40,tocIndex:11},{value:"'imageUrl'",paraId:40,tocIndex:11},{value:" to make it more semantic.",paraId:40,tocIndex:11},{value:"And more...",paraId:40,tocIndex:11},{value:"Before continuing, let's take a look at the definition of the arrow factory method.",paraId:42,tocIndex:11},{value:"type Factory<T extends KeyValue = KeyValue> = (args: T) => Result\n\ntype Result = Attr.SimpleAttrs & {\n  tagName?: string\n  children?: Result[]\n}\n",paraId:43,tocIndex:11},{value:"The arrow factory method has only one parameter ",paraId:44,tocIndex:11},{value:"args",paraId:44,tocIndex:11},{value:", which is passed in when configuring the arrow. For example:",paraId:44,tocIndex:11},{value:"edge.attr({\n  line: {\n    sourceMarker: 'block',\n    targetMarker: {\n      name: 'ellipse',\n      rx: 10,\n      ry: 6,\n    },\n  },\n})\n",paraId:45,tocIndex:11},{value:"The above configuration is parsed to obtain the arrow name and parameters for both the starting and ending arrows.",paraId:46,tocIndex:11},{value:"Arrow Type",paraId:47,tocIndex:11},{value:"Arrow Name ",paraId:47,tocIndex:11},{value:"name",paraId:47,tocIndex:11},{value:"Arrow Parameters ",paraId:47,tocIndex:11},{value:"args",paraId:47,tocIndex:11},{value:"sourceMarker",paraId:47,tocIndex:11},{value:"block",paraId:47,tocIndex:11},{value:"{ }",paraId:47,tocIndex:11},{value:"targetMarker",paraId:47,tocIndex:11},{value:"ellipse",paraId:47,tocIndex:11},{value:"{ rx: 10, ry: 6 }",paraId:47,tocIndex:11},{value:"Internally, X6 finds the corresponding factory method by the arrow name and calls that method with the provided parameters ",paraId:48,tocIndex:11},{value:"args",paraId:48,tocIndex:11},{value:", returning the result. The structure of the result ",paraId:48,tocIndex:11},{value:"Result",paraId:48,tocIndex:11},{value:" is the same as that of the custom arrow structure introduced above, specifying which SVG element to use for rendering the arrow through ",paraId:48,tocIndex:11},{value:"tagName",paraId:48,tocIndex:11},{value:", while the remaining key-value pairs are attached as attributes to that element, supporting nesting through ",paraId:48,tocIndex:11},{value:"children",paraId:48,tocIndex:11},{value:".",paraId:48,tocIndex:11},{value:"Once we understand the principle of the factory method, we can register the factory method using the static method ",paraId:49,tocIndex:11},{value:"registerMarker",paraId:49,tocIndex:11},{value:" provided by Graph.",paraId:49,tocIndex:11},{value:"Graph.registerMarker(name: string, factory: Factory, overwrite?: boolean)\n",paraId:50,tocIndex:11},{value:"Parameter Name",paraId:51,tocIndex:11},{value:"Parameter Type",paraId:51,tocIndex:11},{value:"Default Value",paraId:51,tocIndex:11},{value:"Description",paraId:51,tocIndex:11},{value:"name",paraId:51,tocIndex:11},{value:"String",paraId:51,tocIndex:11},{value:"Arrow name.",paraId:51,tocIndex:11},{value:"factory",paraId:51,tocIndex:11},{value:"Factory",paraId:51,tocIndex:11},{value:"Arrow factory method.",paraId:51,tocIndex:11},{value:"overwrite",paraId:51,tocIndex:11},{value:"Boolean",paraId:51,tocIndex:11},{value:"false",paraId:51,tocIndex:11},{value:"Whether to overwrite the old factory method when encountering a name conflict; set to ",paraId:51,tocIndex:11},{value:"true",paraId:51,tocIndex:11},{value:" to overwrite, otherwise an error will be thrown.",paraId:51,tocIndex:11},{value:"Finally, let's register an image arrow.",paraId:52,tocIndex:11},{value:"/**\n * Parameter Definition\n */\ninterface ImageMarkerArgs extends Attr.SimpleAttrs {\n  imageUrl: string\n  imageWidth?: number\n  imageHeight?: number\n}\n\nGraph.registerMarker('image', (args: ImageMarkerArgs) => {\n  const { imageUrl, imageWidth, imageHeight, ...attrs } = args\n  return {\n    ...attrs, // Return non-special parameters as is\n    tagName: 'image', // Use <image> tag to render the arrow; other key-value pairs will be treated as attributes of that element.\n    width: imageWidth,\n    height: imageHeight,\n    'xlink:href': imageUrl,\n  }\n})\n",paraId:53,tocIndex:11},{value:"After registration, we can use the image arrow like this:",paraId:54,tocIndex:11},{value:"edge.attr({\n  line: {\n    sourceMarker: {\n      name: 'image',\n      imageUrl:\n        'http://cdn3.iconfinder.com/data/icons/49handdrawing/24x24/left.png',\n      imageWidth: 24,\n      imageHeight: 24,\n      y: -12,\n    },\n    targetMarker: {\n      name: 'image',\n      imageUrl:\n        'http://cdn3.iconfinder.com/data/icons/49handdrawing/24x24/left.png',\n      imageWidth: 24,\n      imageHeight: 24,\n      y: -12,\n    },\n  },\n})\n",paraId:55,tocIndex:11}]},72300:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(93629);const n=[{value:"Node is the base class for all nodes, inheriting from ",paraId:0},{value:"Cell",paraId:1},{value:", and defines the common properties and methods for nodes.",paraId:0},{value:"In addition to inheriting from Cell ",paraId:2,tocIndex:0},{value:"attributes",paraId:3,tocIndex:0},{value:", the following attributes are also supported.",paraId:2,tocIndex:0},{value:"Option",paraId:4,tocIndex:0},{value:"Type",paraId:4,tocIndex:0},{value:"Default Value",paraId:4,tocIndex:0},{value:"Required",paraId:4,tocIndex:0},{value:"Description",paraId:4,tocIndex:0},{value:"size",paraId:4,tocIndex:0},{value:"{ width: number; height: number }",paraId:4,tocIndex:0},{value:"{ width: 1, height: 1 }",paraId:4,tocIndex:0},{value:"Node size.",paraId:4,tocIndex:0},{value:"position",paraId:4,tocIndex:0},{value:"{ x: number; y: number }",paraId:4,tocIndex:0},{value:"-",paraId:4,tocIndex:0},{value:"Node position.",paraId:4,tocIndex:0},{value:"angle",paraId:4,tocIndex:0},{value:"number",paraId:4,tocIndex:0},{value:"-",paraId:4,tocIndex:0},{value:"Node rotation angle.",paraId:4,tocIndex:0},{value:"ports",paraId:4,tocIndex:0},{value:"object",paraId:4,tocIndex:0},{value:"-",paraId:4,tocIndex:0},{value:"Connection ports.",paraId:4,tocIndex:0},{value:"portMarkup",paraId:4,tocIndex:0},{value:"Markup",paraId:4,tocIndex:0},{value:"object",paraId:4,tocIndex:0},{value:"DOM structure of the connection ports.",paraId:4,tocIndex:0},{value:"portLabelMarkup",paraId:4,tocIndex:0},{value:"Markup",paraId:4,tocIndex:0},{value:"object",paraId:4,tocIndex:0},{value:"DOM structure of the connection port labels.",paraId:4,tocIndex:0},{value:"The size of the node, which is an object containing ",paraId:5,tocIndex:1},{value:"width",paraId:5,tocIndex:1},{value:" and ",paraId:5,tocIndex:1},{value:"height",paraId:5,tocIndex:1},{value:" properties, can be retrieved and set using the ",paraId:5,tocIndex:1},{value:"size(...)",paraId:6,tocIndex:1},{value:" method.",paraId:5,tocIndex:1},{value:"The position of the node, which is an object containing ",paraId:7,tocIndex:2},{value:"x",paraId:7,tocIndex:2},{value:" and ",paraId:7,tocIndex:2},{value:"y",paraId:7,tocIndex:2},{value:" properties, can be retrieved and set using the ",paraId:7,tocIndex:2},{value:"position(...)",paraId:8,tocIndex:2},{value:" method.",paraId:7,tocIndex:2},{value:"The rotation angle of the node, with the rotation center being the center of the node, can be retrieved and set using the ",paraId:9,tocIndex:3},{value:"rotate(...)",paraId:10,tocIndex:3},{value:" method.",paraId:9,tocIndex:3},{value:"Connection ports are fixed connection points on the node. Many graph applications have connection ports, and some applications also categorize them into input and output ports.",paraId:11,tocIndex:4},{value:"The ",paraId:12,tocIndex:4},{value:"ports",paraId:12,tocIndex:4},{value:" option is a complex object that can be used as follows:",paraId:12,tocIndex:4},{value:"const node = new Node({\n  ports: {\n    group: { ... }, // Connection port group definition\n    items: [ ... ], // Connection ports\n  }\n})\n",paraId:13,tocIndex:4},{value:"Or",paraId:14,tocIndex:4},{value:"const node = new Node({\n  ports: [ ... ], // Connection ports\n})\n",paraId:15,tocIndex:4},{value:"Typically, we group connection ports with the same behavior and appearance into the same group and set the grouping through the ",paraId:16,tocIndex:4},{value:"group",paraId:16,tocIndex:4},{value:" option, which is an object ",paraId:16,tocIndex:4},{value:"{ [groupName: string]: PortGroupMetadata }",paraId:16,tocIndex:4},{value:", where the group name is the key and the value is the default options for each group of connection ports. The supported options are as follows:",paraId:16,tocIndex:4},{value:"interface PortGroupMetadata {\n  /**\n   * Connection port DOM structure definition.\n   */\n  markup?: Markup\n\n  /**\n   * Attributes and styles.\n   */\n  attrs?: Attr.CellAttrs\n\n  /**\n   * DOM hierarchy of the connection ports, the higher the value, the higher the hierarchy.\n   */\n  zIndex?: number | 'auto'\n\n  /**\n   * Layout of the connection ports in the group.\n   */\n  position?:\n    | [number, number] // Absolute positioning\n    | string // Name of the connection port layout method\n    | {\n        // Name and parameters of the connection port layout method\n        name: string\n        args?: object\n      }\n\n  /**\n   * Connection port label.\n   */\n  label?: {\n    markup?: Markup\n    position?: {\n      // Layout of the connection port label\n      name: string // Layout name\n      args?: object // Layout parameters\n    }\n  }\n}\n",paraId:17,tocIndex:4},{value:"For example:",paraId:18,tocIndex:4},{value:"const node = new Node({\n  ports: {\n    group: {\n      group1: {\n        markup: { tagName: 'circle' },\n        attrs: { },\n        zIndex: 1,\n        position: {\n          name: 'top',\n          args: {},\n        },\n      },\n      group2: { ... },\n      group3: { ... },\n    },\n    items: [ ... ],\n  }\n})\n",paraId:19,tocIndex:4},{value:"Another option, ",paraId:20,tocIndex:4},{value:"items",paraId:20,tocIndex:4},{value:", is an array ",paraId:20,tocIndex:4},{value:"PortMetadata[]",paraId:20,tocIndex:4},{value:", where each item represents a connection port. The supported options for connection ports are as follows:",paraId:20,tocIndex:4},{value:"interface PortMetadata {\n  /**\n   * Unique ID of the connection port, automatically generated by default.\n   */\n  id?: string\n\n  /**\n   * Group name, specifying a group will inherit the connection port options from the group.\n   */\n  group?: string\n\n  /**\n   * Provides parameters for the layout algorithm specified in the group for the designated connection port.\n   * We cannot specify a layout algorithm for a single connection port, but we can provide different parameters for the layout algorithm specified in the group.\n   */\n  args?: object\n\n  /**\n   * DOM element and structure definition of the connection port. Specifying this option will override the default options provided by the group.\n   */\n  markup?: Markup\n\n  /**\n   * Element attribute styles. Specifying this option will override the default options provided by the group.\n   */\n  attrs?: Attr.CellAttrs\n\n  /**\n   * DOM hierarchy of the connection port, the higher the value, the higher the hierarchy. Specifying this option will override the default options provided by the group.\n   */\n  zIndex?: number | 'auto'\n\n  /**\n   * Connection port label. Specifying this option will override the default options provided by the group.\n   */\n  label?: {\n    markup?: Markup\n    position?: {\n      // Layout of the connection port label\n      name: string // Layout name\n      args?: object // Layout parameters\n    }\n  }\n}\n",paraId:21,tocIndex:4},{value:"For example:",paraId:22,tocIndex:4},{value:"const node = new Node({\n  ports: {\n    group: { ... },\n    items: [\n      { id: 'port1', group: 'group1', ... },\n      { id: 'port2', group: 'group1', ... },\n      { id: 'port3', group: 'group2', ... },\n    ],\n  }\n})\n",paraId:23,tocIndex:4},{value:"For more details, please refer to the ",paraId:24,tocIndex:4},{value:"Configure Connection Ports",paraId:25,tocIndex:4},{value:" documentation.",paraId:24,tocIndex:4},{value:"The DOM structure of the connection ports. When neither ",paraId:26,tocIndex:5},{value:"ports.groups",paraId:26,tocIndex:5},{value:" nor ",paraId:26,tocIndex:5},{value:"ports.items",paraId:26,tocIndex:5},{value:" specifies ",paraId:26,tocIndex:5},{value:"markup",paraId:26,tocIndex:5},{value:" for the corresponding connection port, this default option is used to render the connection port, with the default value being:",paraId:26,tocIndex:5},{value:"{\n  tagName: 'circle',\n  selector: 'circle',\n  attrs: {\n    r: 10,\n    fill: '#fff',\n    stroke: '#000',\n  },\n}\n",paraId:27,tocIndex:5},{value:"This indicates that the connection port is rendered as a circle with a radius of ",paraId:28,tocIndex:5},{value:"10px",paraId:28,tocIndex:5},{value:".",paraId:28,tocIndex:5},{value:"The DOM structure of the connection port labels. When neither ",paraId:29,tocIndex:6},{value:"ports.groups",paraId:29,tocIndex:6},{value:" nor ",paraId:29,tocIndex:6},{value:"ports.items",paraId:29,tocIndex:6},{value:" specifies ",paraId:29,tocIndex:6},{value:"markup",paraId:29,tocIndex:6},{value:" for the corresponding connection port label, this default option is used to render the connection port label, with the default value being:",paraId:29,tocIndex:6},{value:"{\n  tagName: 'text',\n  selector: 'text',\n  attrs: {\n    fill: '#000000',\n  },\n}\n",paraId:30,tocIndex:6},{value:"isNode(): true\n",paraId:31,tocIndex:9},{value:"Determines if it is a node; this method always returns ",paraId:32,tocIndex:9},{value:"true",paraId:32,tocIndex:9},{value:".",paraId:32,tocIndex:9},{value:"getBBox(options: { deep?: boolean }): Rectangle\n",paraId:33,tocIndex:10},{value:"Gets the bounding box of the node.",paraId:34,tocIndex:10},{value:"Name",paraId:35,tocIndex:10},{value:"Type",paraId:35,tocIndex:10},{value:"Required",paraId:35,tocIndex:10},{value:"Default Value",paraId:35,tocIndex:10},{value:"Description",paraId:35,tocIndex:10},{value:"options.deep",paraId:35,tocIndex:10},{value:"boolean",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"When ",paraId:35,tocIndex:10},{value:"true",paraId:35,tocIndex:10},{value:", includes the bounding box of all child nodes and edges; defaults to ",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:".",paraId:35,tocIndex:10},{value:"const rect1 = node.getBBox()\nconst rect2 = node.getBBox({ deep: true })\n",paraId:36,tocIndex:10},{value:"/**\n * Gets the size of the node.\n */\nsize(): Size\n\n/**\n * Sets the size of the node.\n */\nsize(size: Size, options?: Node.ResizeOptions): this\n\n/**\n * Sets the size of the node.\n */\nsize(width: number, height: number, options?: Node.ResizeOptions): this\n",paraId:37,tocIndex:12},{value:"Gets the size of the node.",paraId:38,tocIndex:12},{value:"const size = node.size()\nconsole.log(size.width, size.height)\n",paraId:39,tocIndex:12},{value:"The parameters and usage for setting the node size are the same as the ",paraId:40,tocIndex:12},{value:"resize",paraId:41,tocIndex:12},{value:" method.",paraId:40,tocIndex:12},{value:"Changes the size of the node. Depending on the rotation angle and ",paraId:42,tocIndex:13},{value:"options.direction",paraId:42,tocIndex:13},{value:", both the position and size of the node may change.",paraId:42,tocIndex:13},{value:"Name",paraId:43,tocIndex:13},{value:"Type",paraId:43,tocIndex:13},{value:"Required",paraId:43,tocIndex:13},{value:"Default Value",paraId:43,tocIndex:13},{value:"Description",paraId:43,tocIndex:13},{value:"width",paraId:43,tocIndex:13},{value:"number",paraId:43,tocIndex:13},{value:"Node width.",paraId:43,tocIndex:13},{value:"height",paraId:43,tocIndex:13},{value:"number",paraId:43,tocIndex:13},{value:"Node height.",paraId:43,tocIndex:13},{value:"options.direction",paraId:43,tocIndex:13},{value:"Direction",paraId:43,tocIndex:13},{value:"'bottom-right'",paraId:43,tocIndex:13},{value:"The direction in which to change the size; defaults to fixing the top-left corner and resizing towards the bottom-right.",paraId:43,tocIndex:13},{value:"options.silent",paraId:43,tocIndex:13},{value:"boolean",paraId:43,tocIndex:13},{value:"false",paraId:43,tocIndex:13},{value:"When ",paraId:43,tocIndex:13},{value:"true",paraId:43,tocIndex:13},{value:", does not trigger ",paraId:43,tocIndex:13},{value:"'change:size'",paraId:43,tocIndex:13},{value:" and ",paraId:43,tocIndex:13},{value:"'change:position'",paraId:43,tocIndex:13},{value:" events and does not redraw the canvas.",paraId:43,tocIndex:13},{value:"options...others",paraId:43,tocIndex:13},{value:"object",paraId:43,tocIndex:13},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:43,tocIndex:13},{value:"Supports resizing the node in 8 directions, with the default being ",paraId:44,tocIndex:13},{value:"'bottom-right'",paraId:44,tocIndex:13},{value:", which means fixing the top-left corner and resizing towards the bottom-right.",paraId:44,tocIndex:13},{value:"top",paraId:45,tocIndex:13},{value:"right",paraId:45,tocIndex:13},{value:"bottom",paraId:45,tocIndex:13},{value:"left",paraId:45,tocIndex:13},{value:"top-left",paraId:45,tocIndex:13},{value:"top-right",paraId:45,tocIndex:13},{value:"bottom-left",paraId:45,tocIndex:13},{value:"bottom-right",paraId:45,tocIndex:13},{value:"node.resize(100, 40)\n\n// Fixing the bottom-right corner, resizing towards the top-left\nnode.resize(100, 40, { direction: 'top-left' })\n\n// Do not trigger events and redraw\nnode.resize(100, 40, { silent: true })\n",paraId:46,tocIndex:13},{value:"scale(\n  sx: number,\n  sy: number,\n  origin?: Point.PointLike,\n  options?: Node.SetOptions,\n): this\n",paraId:47,tocIndex:14},{value:"Scales the node. Depending on the scaling center and scaling ratio, both the size and position of the node may change.",paraId:48,tocIndex:14},{value:"Name",paraId:49,tocIndex:14},{value:"Type",paraId:49,tocIndex:14},{value:"Required",paraId:49,tocIndex:14},{value:"Default Value",paraId:49,tocIndex:14},{value:"Description",paraId:49,tocIndex:14},{value:"sx",paraId:49,tocIndex:14},{value:"number",paraId:49,tocIndex:14},{value:"",paraId:49,tocIndex:14},{value:"Scaling ratio in the X direction.",paraId:49,tocIndex:14},{value:"sy",paraId:49,tocIndex:14},{value:"number",paraId:49,tocIndex:14},{value:"",paraId:49,tocIndex:14},{value:"Scaling ratio in the Y direction.",paraId:49,tocIndex:14},{value:"origin",paraId:49,tocIndex:14},{value:"Point.PointLike | null",paraId:49,tocIndex:14},{value:"-",paraId:49,tocIndex:14},{value:"Scaling center, defaults to the center of the node.",paraId:49,tocIndex:14},{value:"options.silent",paraId:49,tocIndex:14},{value:"boolean",paraId:49,tocIndex:14},{value:"false",paraId:49,tocIndex:14},{value:"When ",paraId:49,tocIndex:14},{value:"true",paraId:49,tocIndex:14},{value:", does not trigger ",paraId:49,tocIndex:14},{value:"'change:size'",paraId:49,tocIndex:14},{value:" and ",paraId:49,tocIndex:14},{value:"'change:position'",paraId:49,tocIndex:14},{value:" events and does not redraw the canvas.",paraId:49,tocIndex:14},{value:"options...others",paraId:49,tocIndex:14},{value:"object",paraId:49,tocIndex:14},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:49,tocIndex:14},{value:"node.scale(1.5, 1.5)\n\n// Custom scaling center\nnode.scale(1.5, 1.5, { x: 100, y: 30 })\n\n// Do not trigger events and redraw\nnode.scale(1.5, 1.5, null, { silent: true })\n",paraId:50,tocIndex:14},{value:"fit(options?: Node.FitEmbedsOptions): this\n",paraId:51,tocIndex:15},{value:"Automatically adjusts the size and position of the node based on the size and position of child nodes and edges, ensuring that all child nodes and edges are within the bounding box of the node.",paraId:52,tocIndex:15},{value:"Name",paraId:53,tocIndex:15},{value:"Type",paraId:53,tocIndex:15},{value:"Required",paraId:53,tocIndex:15},{value:"Default Value",paraId:53,tocIndex:15},{value:"Description",paraId:53,tocIndex:15},{value:"options.padding",paraId:53,tocIndex:15},{value:"number | ",paraId:53,tocIndex:15},{value:"{ top: number; right: number; bottom: number; left: number }",paraId:53,tocIndex:15},{value:"0",paraId:53,tocIndex:15},{value:"Padding.",paraId:53,tocIndex:15},{value:"options.deep",paraId:53,tocIndex:15},{value:"boolean",paraId:53,tocIndex:15},{value:"false",paraId:53,tocIndex:15},{value:"Whether to include all descendant nodes and edges; defaults to only including direct child nodes and edges.",paraId:53,tocIndex:15},{value:"options.silent",paraId:53,tocIndex:15},{value:"boolean",paraId:53,tocIndex:15},{value:"false",paraId:53,tocIndex:15},{value:"When ",paraId:53,tocIndex:15},{value:"true",paraId:53,tocIndex:15},{value:", does not trigger events and redraw the canvas.",paraId:53,tocIndex:15},{value:"options...others",paraId:53,tocIndex:15},{value:"object",paraId:53,tocIndex:15},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:53,tocIndex:15},{value:"node.fit()\nnode.fit({ padding: 10 })\nnode.fit({ padding: { top: 20, bottom: 20, left: 10, right: 10 } })\n",paraId:54,tocIndex:15},{value:"/**\n * Gets the position of the node.\n */\nposition(options?: Node.GetPositionOptions): Point.PointLike\n\n/**\n * Sets the position of the node.\n */\nposition(x: number, y: number, options?: Node.SetPositionOptions): this\n",paraId:55,tocIndex:17},{value:"Gets the position of the node.",paraId:56,tocIndex:17},{value:"Name",paraId:57,tocIndex:17},{value:"Type",paraId:57,tocIndex:17},{value:"Required",paraId:57,tocIndex:17},{value:"Default Value",paraId:57,tocIndex:17},{value:"Description",paraId:57,tocIndex:17},{value:"options.relative",paraId:57,tocIndex:17},{value:"boolean",paraId:57,tocIndex:17},{value:"false",paraId:57,tocIndex:17},{value:"Whether to return the relative position to the parent node; defaults to ",paraId:57,tocIndex:17},{value:"false",paraId:57,tocIndex:17},{value:", indicating that the absolute position relative to the canvas is returned.",paraId:57,tocIndex:17},{value:"const pos = rect.position()\nconsole.log(pos.x, pos.y)\n\nconst relativePos = child.position({ relative: true })\nconsole.log(relativePos.x, relativePos.y)\n",paraId:58,tocIndex:17},{value:"Sets the position of the node.",paraId:59,tocIndex:17},{value:"Name",paraId:60,tocIndex:17},{value:"Type",paraId:60,tocIndex:17},{value:"Required",paraId:60,tocIndex:17},{value:"Default Value",paraId:60,tocIndex:17},{value:"Description",paraId:60,tocIndex:17},{value:"x",paraId:60,tocIndex:17},{value:"number",paraId:60,tocIndex:17},{value:"",paraId:60,tocIndex:17},{value:"Absolute or relative X-axis coordinate of the node.",paraId:60,tocIndex:17},{value:"y",paraId:60,tocIndex:17},{value:"number",paraId:60,tocIndex:17},{value:"",paraId:60,tocIndex:17},{value:"Absolute or relative Y-axis coordinate of the node.",paraId:60,tocIndex:17},{value:"options.relative",paraId:60,tocIndex:17},{value:"boolean",paraId:60,tocIndex:17},{value:"false",paraId:60,tocIndex:17},{value:"Whether the provided coordinates are relative coordinates. When ",paraId:60,tocIndex:17},{value:"true",paraId:60,tocIndex:17},{value:", indicates that the provided coordinates are relative to the parent node; defaults to ",paraId:60,tocIndex:17},{value:"false",paraId:60,tocIndex:17},{value:", indicating that the provided coordinates are absolute coordinates relative to the canvas.",paraId:60,tocIndex:17},{value:"options.deep",paraId:60,tocIndex:17},{value:"boolean",paraId:60,tocIndex:17},{value:"false",paraId:60,tocIndex:17},{value:"Whether to also change the position of child nodes/edges.",paraId:60,tocIndex:17},{value:"options.silent",paraId:60,tocIndex:17},{value:"boolean",paraId:60,tocIndex:17},{value:"false",paraId:60,tocIndex:17},{value:"When ",paraId:60,tocIndex:17},{value:"true",paraId:60,tocIndex:17},{value:", does not trigger ",paraId:60,tocIndex:17},{value:"'change:position'",paraId:60,tocIndex:17},{value:" events and does not redraw the canvas.",paraId:60,tocIndex:17},{value:"options...others",paraId:60,tocIndex:17},{value:"object",paraId:60,tocIndex:17},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:60,tocIndex:17},{value:"By default, absolute coordinates are used. When ",paraId:61,tocIndex:17},{value:"options.relative",paraId:61,tocIndex:17},{value:" is ",paraId:61,tocIndex:17},{value:"true",paraId:61,tocIndex:17},{value:", relative coordinates are used.",paraId:61,tocIndex:17},{value:"// Move the node to the canvas position [30, 30]\nnode.position(30, 30)\n\n// Move the child node to the relative position [30, 30] at the top-left corner of the parent node\nchild.position(30, 30, { relative: true })\n",paraId:62,tocIndex:17},{value:"When ",paraId:63,tocIndex:17},{value:"options.deep",paraId:63,tocIndex:17},{value:" is ",paraId:63,tocIndex:17},{value:"true",paraId:63,tocIndex:17},{value:", child nodes and edges will also be moved simultaneously.",paraId:63,tocIndex:17},{value:"parent.position(30, 30, { deep: true })\n",paraId:64,tocIndex:17},{value:"When ",paraId:65,tocIndex:17},{value:"options.silent",paraId:65,tocIndex:17},{value:" is ",paraId:65,tocIndex:17},{value:"true",paraId:65,tocIndex:17},{value:", it does not trigger ",paraId:65,tocIndex:17},{value:"'change:position'",paraId:65,tocIndex:17},{value:" events and does not redraw the canvas.",paraId:65,tocIndex:17},{value:"node.position(30, 30, { silent: true })\n",paraId:66,tocIndex:17},{value:"Other custom key-value pairs can be used in event callbacks.",paraId:67,tocIndex:17},{value:"node.position(30, 30, { otherKey: 'otherValue', ... })\n",paraId:68,tocIndex:17},{value:"translate(tx?: number, ty?: number, options?: Node.TranslateOptions): this\n",paraId:69,tocIndex:18},{value:"Translates the node along with its child nodes and edges.",paraId:70,tocIndex:18},{value:"Name",paraId:71,tocIndex:18},{value:"Type",paraId:71,tocIndex:18},{value:"Required",paraId:71,tocIndex:18},{value:"Default Value",paraId:71,tocIndex:18},{value:"Description",paraId:71,tocIndex:18},{value:"tx",paraId:71,tocIndex:18},{value:"number",paraId:71,tocIndex:18},{value:"0",paraId:71,tocIndex:18},{value:"The offset of the node in the X direction.",paraId:71,tocIndex:18},{value:"ty",paraId:71,tocIndex:18},{value:"number",paraId:71,tocIndex:18},{value:"0",paraId:71,tocIndex:18},{value:"The offset of the node in the Y direction.",paraId:71,tocIndex:18},{value:"options.restrict",paraId:71,tocIndex:18},{value:"Rectangle.RectangleLike",paraId:71,tocIndex:18},{value:"undefined",paraId:71,tocIndex:18},{value:"Restricts the movable range of the node to the specified rectangular area.",paraId:71,tocIndex:18},{value:"options.transition",paraId:71,tocIndex:18},{value:"boolean | KeyframeEffectOptions",paraId:71,tocIndex:18},{value:"false",paraId:71,tocIndex:18},{value:"Whether to use animation or specify an animation option.",paraId:71,tocIndex:18},{value:"options.silent",paraId:71,tocIndex:18},{value:"boolean",paraId:71,tocIndex:18},{value:"false",paraId:71,tocIndex:18},{value:"When ",paraId:71,tocIndex:18},{value:"true",paraId:71,tocIndex:18},{value:", does not trigger ",paraId:71,tocIndex:18},{value:"'change:position'",paraId:71,tocIndex:18},{value:" events and does not redraw the canvas.",paraId:71,tocIndex:18},{value:"options...others",paraId:71,tocIndex:18},{value:"object",paraId:71,tocIndex:18},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:71,tocIndex:18},{value:"When the specified ",paraId:72,tocIndex:18},{value:"tx",paraId:72,tocIndex:18},{value:" and ",paraId:72,tocIndex:18},{value:"ty",paraId:72,tocIndex:18},{value:" are ",paraId:72,tocIndex:18},{value:"undefined",paraId:72,tocIndex:18},{value:", it indicates that the corresponding direction's translation amount is ",paraId:72,tocIndex:18},{value:"0",paraId:72,tocIndex:18},{value:".",paraId:72,tocIndex:18},{value:"node.translate(30, 30)\nnode.translate(30) // Move only in the X direction\nnode.translate(undefined, 30) // Move only in the Y direction\n",paraId:73,tocIndex:18},{value:"We can restrict the movement of the node within a specified rectangle ",paraId:74,tocIndex:18},{value:"{x: number; y: number; width: number; height: number}",paraId:74,tocIndex:18},{value:" using the ",paraId:74,tocIndex:18},{value:"options.restrict",paraId:74,tocIndex:18},{value:" option.",paraId:74,tocIndex:18},{value:"For example, we can restrict the movement of child nodes within the bounding box of the parent node:",paraId:75,tocIndex:18},{value:"child.translate(30, 30, {\n  restrict: child.getParent().getBBox(),\n})\n",paraId:76,tocIndex:18},{value:"When ",paraId:77,tocIndex:18},{value:"options.transition",paraId:77,tocIndex:18},{value:" is ",paraId:77,tocIndex:18},{value:"true",paraId:77,tocIndex:18},{value:" or an animation option is specified, it indicates that animation should be used to translate the node.",paraId:77,tocIndex:18},{value:"// Translate the node using the default animation\nnode.translate(30, 30, {\n  transition: true,\n})\n\n// Custom animation options\nnode.translate(30, 30, {\n  transition: {\n    duration: 2000,\n  },\n})\n",paraId:78,tocIndex:18},{value:"When ",paraId:79,tocIndex:18},{value:"options.silent",paraId:79,tocIndex:18},{value:" is true, it does not trigger ",paraId:79,tocIndex:18},{value:"'change:position'",paraId:79,tocIndex:18},{value:" events and does not redraw the canvas.",paraId:79,tocIndex:18},{value:"node.translate(30, 30, { silent: true })\n",paraId:80,tocIndex:18},{value:"Other custom key-value pairs can be used in event callbacks.",paraId:81,tocIndex:18},{value:"node.translate(30, 30, { otherKey: 'otherValue', ... })\n",paraId:82,tocIndex:18},{value:"getAngle(): number\n",paraId:83,tocIndex:20},{value:"Gets the rotation angle of the node.",paraId:84,tocIndex:20},{value:"if (node.getAngle() !== 0) {\n  // do something\n}\n",paraId:85,tocIndex:20},{value:"rotate(\n  deg: number,\n  absolute?: boolean,\n  origin?: Point.PointLike,\n  options?: Node.RotateOptions,\n): this\n",paraId:86,tocIndex:21},{value:"Rotates the node.",paraId:87,tocIndex:21},{value:"Name",paraId:88,tocIndex:21},{value:"Type",paraId:88,tocIndex:21},{value:"Required",paraId:88,tocIndex:21},{value:"Default Value",paraId:88,tocIndex:21},{value:"Description",paraId:88,tocIndex:21},{value:"deg",paraId:88,tocIndex:21},{value:"number",paraId:88,tocIndex:21},{value:"",paraId:88,tocIndex:21},{value:"Rotation degree.",paraId:88,tocIndex:21},{value:"options.absolute",paraId:88,tocIndex:21},{value:"boolean",paraId:88,tocIndex:21},{value:"false",paraId:88,tocIndex:21},{value:"When ",paraId:88,tocIndex:21},{value:"true",paraId:88,tocIndex:21},{value:", indicates that the given degree is the absolute degree after rotation; defaults to ",paraId:88,tocIndex:21},{value:"false",paraId:88,tocIndex:21},{value:", indicating that the node rotates the given degree based on the current rotation angle.",paraId:88,tocIndex:21},{value:"options.center",paraId:88,tocIndex:21},{value:"Point.PointLike",paraId:88,tocIndex:21},{value:"undefined",paraId:88,tocIndex:21},{value:"Defaults to rotating around the center of the node; when ",paraId:88,tocIndex:21},{value:"options.center",paraId:88,tocIndex:21},{value:" is given, it indicates rotating around the specified center.",paraId:88,tocIndex:21},{value:"options.silent",paraId:88,tocIndex:21},{value:"boolean",paraId:88,tocIndex:21},{value:"false",paraId:88,tocIndex:21},{value:"When ",paraId:88,tocIndex:21},{value:"true",paraId:88,tocIndex:21},{value:", does not trigger ",paraId:88,tocIndex:21},{value:"'change:angle'",paraId:88,tocIndex:21},{value:" events and does not redraw the canvas.",paraId:88,tocIndex:21},{value:"options...others",paraId:88,tocIndex:21},{value:"object",paraId:88,tocIndex:21},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:88,tocIndex:21},{value:"By default, it is a relative rotation, meaning that the node rotates the given degree based on the current rotation angle. When ",paraId:89,tocIndex:21},{value:"options.absolute",paraId:89,tocIndex:21},{value:" is ",paraId:89,tocIndex:21},{value:"true",paraId:89,tocIndex:21},{value:", it indicates absolute rotation, meaning that the given degree is the angle of the node after rotation.",paraId:89,tocIndex:21},{value:"// Relative rotation, the node rotates 30 degrees based on the current rotation angle\nnode.rotate(30)\n\n// Absolute rotation, the angle of the node after rotation is 30 degrees\nnode.rotate(30, { absolute: true })\n",paraId:90,tocIndex:21},{value:"By default, it rotates around the center of the node. You can specify a rotation center using the ",paraId:91,tocIndex:21},{value:"options.center",paraId:91,tocIndex:21},{value:" option.",paraId:91,tocIndex:21},{value:"node.rotate(30, { center: { x: 10, y: 10 } })\n",paraId:92,tocIndex:21},{value:"By default, it triggers ",paraId:93,tocIndex:21},{value:"'change:angle'",paraId:93,tocIndex:21},{value:" events and redraws the canvas. When ",paraId:93,tocIndex:21},{value:"options.silent",paraId:93,tocIndex:21},{value:" is ",paraId:93,tocIndex:21},{value:"true",paraId:93,tocIndex:21},{value:", it does not trigger ",paraId:93,tocIndex:21},{value:"'change:angle'",paraId:93,tocIndex:21},{value:" events and does not redraw the canvas.",paraId:93,tocIndex:21},{value:"node.rotate(30, { silent: true })\n",paraId:94,tocIndex:21},{value:"Other custom key-value pairs can be used in event callbacks.",paraId:95,tocIndex:21},{value:"node.rotate(30, { otherKey: 'otherValue', ... })\n",paraId:96,tocIndex:21},{value:"Connection ports are fixed connection points on the node. Many graph applications have connection ports, and some applications also categorize them into input and output ports.",paraId:97,tocIndex:22},{value:"In the above, we introduced the data structure of connection ports. Here, we will continue to introduce some methods for operating connection ports on the node.",paraId:98,tocIndex:22},{value:"addPort(port: PortMetadata, options?: Node.SetOptions): this\n",paraId:99,tocIndex:23},{value:"Adds a single connection port. The connection port is added to the end of the connection port array.",paraId:100,tocIndex:23},{value:"Name",paraId:101,tocIndex:23},{value:"Type",paraId:101,tocIndex:23},{value:"Required",paraId:101,tocIndex:23},{value:"Default Value",paraId:101,tocIndex:23},{value:"Description",paraId:101,tocIndex:23},{value:"port",paraId:101,tocIndex:23},{value:"PortMetadata",paraId:102,tocIndex:23},{value:"",paraId:101,tocIndex:23},{value:"Connection port.",paraId:101,tocIndex:23},{value:"options.silent",paraId:101,tocIndex:23},{value:"boolean",paraId:101,tocIndex:23},{value:"false",paraId:101,tocIndex:23},{value:"When ",paraId:101,tocIndex:23},{value:"true",paraId:101,tocIndex:23},{value:", does not trigger ",paraId:101,tocIndex:23},{value:"'change:ports'",paraId:101,tocIndex:23},{value:" events and does not redraw the canvas.",paraId:101,tocIndex:23},{value:"options...others",paraId:101,tocIndex:23},{value:"object",paraId:101,tocIndex:23},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:101,tocIndex:23},{value:"addPorts(ports: PortMetadata[], options?: Node.SetOptions)\n",paraId:103,tocIndex:24},{value:"Adds multiple connection ports. The connection ports are added to the end of the connection port array.",paraId:104,tocIndex:24},{value:"Name",paraId:105,tocIndex:24},{value:"Type",paraId:105,tocIndex:24},{value:"Required",paraId:105,tocIndex:24},{value:"Default Value",paraId:105,tocIndex:24},{value:"Description",paraId:105,tocIndex:24},{value:"port",paraId:105,tocIndex:24},{value:"PortMetadata",paraId:106,tocIndex:24},{value:"[]",paraId:105,tocIndex:24},{value:"",paraId:105,tocIndex:24},{value:"Array of connection ports.",paraId:105,tocIndex:24},{value:"options.silent",paraId:105,tocIndex:24},{value:"boolean",paraId:105,tocIndex:24},{value:"false",paraId:105,tocIndex:24},{value:"When ",paraId:105,tocIndex:24},{value:"true",paraId:105,tocIndex:24},{value:", does not trigger ",paraId:105,tocIndex:24},{value:"'change:ports'",paraId:105,tocIndex:24},{value:" events and does not redraw the canvas.",paraId:105,tocIndex:24},{value:"options...others",paraId:105,tocIndex:24},{value:"object",paraId:105,tocIndex:24},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:105,tocIndex:24},{value:"insertPort(index: number, port: PortMetadata, options?: Node.SetOptions): this\n",paraId:107,tocIndex:25},{value:"Adds a connection port at the specified position. Note that the ",paraId:108,tocIndex:25},{value:"port",paraId:108,tocIndex:25},{value:" parameter needs to include the ",paraId:108,tocIndex:25},{value:"id",paraId:108,tocIndex:25},{value:" property.",paraId:108,tocIndex:25},{value:"Name",paraId:109,tocIndex:25},{value:"Type",paraId:109,tocIndex:25},{value:"Required",paraId:109,tocIndex:25},{value:"Default Value",paraId:109,tocIndex:25},{value:"Description",paraId:109,tocIndex:25},{value:"index",paraId:109,tocIndex:25},{value:"number",paraId:109,tocIndex:25},{value:"",paraId:109,tocIndex:25},{value:"Position of the connection port.",paraId:109,tocIndex:25},{value:"port",paraId:109,tocIndex:25},{value:"PortMetadata",paraId:110,tocIndex:25},{value:"",paraId:109,tocIndex:25},{value:"Connection port.",paraId:109,tocIndex:25},{value:"options.silent",paraId:109,tocIndex:25},{value:"boolean",paraId:109,tocIndex:25},{value:"false",paraId:109,tocIndex:25},{value:"When ",paraId:109,tocIndex:25},{value:"true",paraId:109,tocIndex:25},{value:", does not trigger ",paraId:109,tocIndex:25},{value:"'change:ports'",paraId:109,tocIndex:25},{value:" events and does not redraw the canvas.",paraId:109,tocIndex:25},{value:"options...others",paraId:109,tocIndex:25},{value:"object",paraId:109,tocIndex:25},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:109,tocIndex:25},{value:"hasPort(portId: string): boolean\n",paraId:111,tocIndex:26},{value:"Checks if the specified connection port exists.",paraId:112,tocIndex:26},{value:"Name",paraId:113,tocIndex:26},{value:"Type",paraId:113,tocIndex:26},{value:"Required",paraId:113,tocIndex:26},{value:"Default Value",paraId:113,tocIndex:26},{value:"Description",paraId:113,tocIndex:26},{value:"portId",paraId:113,tocIndex:26},{value:"string",paraId:113,tocIndex:26},{value:"",paraId:113,tocIndex:26},{value:"Connection port ID.",paraId:113,tocIndex:26},{value:"if (node.hasPort('port1')) {\n  // do something\n}\n",paraId:114,tocIndex:26},{value:"hasPorts(): boolean\n",paraId:115,tocIndex:27},{value:"Checks if the node contains connection ports.",paraId:116,tocIndex:27},{value:"if (node.hasPorts()) {\n  // do something\n}\n",paraId:117,tocIndex:27},{value:"getPort(portId: string): PortMetadata\n",paraId:118,tocIndex:28},{value:"Gets the connection port by ID.",paraId:119,tocIndex:28},{value:"Name",paraId:120,tocIndex:28},{value:"Type",paraId:120,tocIndex:28},{value:"Required",paraId:120,tocIndex:28},{value:"Default Value",paraId:120,tocIndex:28},{value:"Description",paraId:120,tocIndex:28},{value:"portId",paraId:120,tocIndex:28},{value:"string",paraId:120,tocIndex:28},{value:"",paraId:120,tocIndex:28},{value:"Connection port ID.",paraId:120,tocIndex:28},{value:"getPortAt(index: number): PortMetadata | null\n",paraId:121,tocIndex:29},{value:"Gets the connection port at the specified index.",paraId:122,tocIndex:29},{value:"Name",paraId:123,tocIndex:29},{value:"Type",paraId:123,tocIndex:29},{value:"Required",paraId:123,tocIndex:29},{value:"Default Value",paraId:123,tocIndex:29},{value:"Description",paraId:123,tocIndex:29},{value:"index",paraId:123,tocIndex:29},{value:"number",paraId:123,tocIndex:29},{value:"",paraId:123,tocIndex:29},{value:"Connection port index.",paraId:123,tocIndex:29},{value:"getPorts(): PortMetadata[]\n",paraId:124,tocIndex:30},{value:"Gets all connection ports.",paraId:125,tocIndex:30},{value:"getPortsByGroup(groupName: string): PortMetadata[]\n",paraId:126,tocIndex:31},{value:"Gets all connection ports under the specified group.",paraId:127,tocIndex:31},{value:"Name",paraId:128,tocIndex:31},{value:"Type",paraId:128,tocIndex:31},{value:"Required",paraId:128,tocIndex:31},{value:"Default Value",paraId:128,tocIndex:31},{value:"Description",paraId:128,tocIndex:31},{value:"groupName",paraId:128,tocIndex:31},{value:"string",paraId:128,tocIndex:31},{value:"",paraId:128,tocIndex:31},{value:"Group name.",paraId:128,tocIndex:31},{value:"/**\n * Removes the specified connection port.\n */\nremovePort(port: PortMetadata, options?: Node.SetOptions): this\n\n/**\n * Removes the connection port with the specified ID.\n */\nremovePort(portId: string, options?: Node.SetOptions): this\n",paraId:129,tocIndex:32},{value:"Removes the specified connection port.",paraId:130,tocIndex:32},{value:"Name",paraId:131,tocIndex:32},{value:"Type",paraId:131,tocIndex:32},{value:"Required",paraId:131,tocIndex:32},{value:"Default Value",paraId:131,tocIndex:32},{value:"Description",paraId:131,tocIndex:32},{value:"port",paraId:131,tocIndex:32},{value:"PortMetadata",paraId:131,tocIndex:32},{value:"",paraId:131,tocIndex:32},{value:"Connection port.",paraId:131,tocIndex:32},{value:"options.silent",paraId:131,tocIndex:32},{value:"boolean",paraId:131,tocIndex:32},{value:"false",paraId:131,tocIndex:32},{value:"When ",paraId:131,tocIndex:32},{value:"true",paraId:131,tocIndex:32},{value:", does not trigger ",paraId:131,tocIndex:32},{value:"'change:ports'",paraId:131,tocIndex:32},{value:" events and does not redraw the canvas.",paraId:131,tocIndex:32},{value:"options...others",paraId:131,tocIndex:32},{value:"object",paraId:131,tocIndex:32},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:131,tocIndex:32},{value:"Removes the connection port with the specified ID.",paraId:132,tocIndex:32},{value:"Name",paraId:133,tocIndex:32},{value:"Type",paraId:133,tocIndex:32},{value:"Required",paraId:133,tocIndex:32},{value:"Default Value",paraId:133,tocIndex:32},{value:"Description",paraId:133,tocIndex:32},{value:"portId",paraId:133,tocIndex:32},{value:"string",paraId:133,tocIndex:32},{value:"",paraId:133,tocIndex:32},{value:"Connection port ID.",paraId:133,tocIndex:32},{value:"options.silent",paraId:133,tocIndex:32},{value:"boolean",paraId:133,tocIndex:32},{value:"false",paraId:133,tocIndex:32},{value:"When ",paraId:133,tocIndex:32},{value:"true",paraId:133,tocIndex:32},{value:", does not trigger ",paraId:133,tocIndex:32},{value:"'change:ports'",paraId:133,tocIndex:32},{value:" events and does not redraw the canvas.",paraId:133,tocIndex:32},{value:"options...others",paraId:133,tocIndex:32},{value:"object",paraId:133,tocIndex:32},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:133,tocIndex:32},{value:"removePortAt(index: number, options?: Node.SetOptions): this\n",paraId:134,tocIndex:33},{value:"Removes the connection port at the specified index.",paraId:135,tocIndex:33},{value:"Name",paraId:136,tocIndex:33},{value:"Type",paraId:136,tocIndex:33},{value:"Required",paraId:136,tocIndex:33},{value:"Default Value",paraId:136,tocIndex:33},{value:"Description",paraId:136,tocIndex:33},{value:"index",paraId:136,tocIndex:33},{value:"number",paraId:136,tocIndex:33},{value:"",paraId:136,tocIndex:33},{value:"Connection port index.",paraId:136,tocIndex:33},{value:"options.silent",paraId:136,tocIndex:33},{value:"boolean",paraId:136,tocIndex:33},{value:"false",paraId:136,tocIndex:33},{value:"When ",paraId:136,tocIndex:33},{value:"true",paraId:136,tocIndex:33},{value:", does not trigger ",paraId:136,tocIndex:33},{value:"'change:ports'",paraId:136,tocIndex:33},{value:" events and does not redraw the canvas.",paraId:136,tocIndex:33},{value:"options...others",paraId:136,tocIndex:33},{value:"object",paraId:136,tocIndex:33},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:136,tocIndex:33},{value:"/**\n * Removes all connection ports.\n */\nremovePorts(options?: Node.SetOptions): this\n\n/**\n * Removes the specified connection ports.\n */\nremovePorts(ports: (PortMetadata | string)[], options?: Node.SetOptions): this\n",paraId:137,tocIndex:34},{value:"Removes the specified multiple connection ports.",paraId:138,tocIndex:34},{value:"Name",paraId:139,tocIndex:34},{value:"Type",paraId:139,tocIndex:34},{value:"Required",paraId:139,tocIndex:34},{value:"Default Value",paraId:139,tocIndex:34},{value:"Description",paraId:139,tocIndex:34},{value:"ports",paraId:139,tocIndex:34},{value:"(PortMetadata | string)[]",paraId:139,tocIndex:34},{value:"Array of connection ports to be removed.",paraId:139,tocIndex:34},{value:"options.silent",paraId:139,tocIndex:34},{value:"boolean",paraId:139,tocIndex:34},{value:"false",paraId:139,tocIndex:34},{value:"When ",paraId:139,tocIndex:34},{value:"true",paraId:139,tocIndex:34},{value:", does not trigger ",paraId:139,tocIndex:34},{value:"'change:ports'",paraId:139,tocIndex:34},{value:" events and does not redraw the canvas.",paraId:139,tocIndex:34},{value:"options...others",paraId:139,tocIndex:34},{value:"object",paraId:139,tocIndex:34},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:139,tocIndex:34},{value:"getPortIndex(port: PortMetadata | string): number\n",paraId:140,tocIndex:35},{value:"Obtain the index position of the connection port.",paraId:141,tocIndex:35},{value:"getPortProp<T>(portId: string, path?: string | string[]): any\n",paraId:142,tocIndex:36},{value:"Retrieves the property value at the specified path of the port. When the path is empty, it returns the complete port.",paraId:143,tocIndex:36},{value:"Name",paraId:144,tocIndex:36},{value:"Type",paraId:144,tocIndex:36},{value:"Required",paraId:144,tocIndex:36},{value:"Default Value",paraId:144,tocIndex:36},{value:"Description",paraId:144,tocIndex:36},{value:"portId",paraId:144,tocIndex:36},{value:"string",paraId:144,tocIndex:36},{value:"",paraId:144,tocIndex:36},{value:"Port ID.",paraId:144,tocIndex:36},{value:"path",paraId:144,tocIndex:36},{value:"string | string[]",paraId:144,tocIndex:36},{value:"Property path. When ",paraId:144,tocIndex:36},{value:"path",paraId:144,tocIndex:36},{value:" is of type ",paraId:144,tocIndex:36},{value:"string",paraId:144,tocIndex:36},{value:", the path is a string separated by ",paraId:144,tocIndex:36},{value:"'/'",paraId:144,tocIndex:36},{value:". When ",paraId:144,tocIndex:36},{value:"path",paraId:144,tocIndex:36},{value:" is of type ",paraId:144,tocIndex:36},{value:"string[]",paraId:144,tocIndex:36},{value:", the path is an array of keys that make up the port object path.",paraId:144,tocIndex:36},{value:"node.getPortProp('port1')\nnode.getPortProp('port1', 'attrs/circle')\nnode.getPortProp('port1', ['attrs', 'circle'])\n",paraId:145,tocIndex:36},{value:"setPortProp(\n  portId: string,\n  path: string | string[],\n  value: any,\n  options?: Node.SetOptions,\n): this\n",paraId:146,tocIndex:37},{value:"Sets the property of the port based on the path.",paraId:147,tocIndex:37},{value:"Name",paraId:148,tocIndex:37},{value:"Type",paraId:148,tocIndex:37},{value:"Required",paraId:148,tocIndex:37},{value:"Default Value",paraId:148,tocIndex:37},{value:"Description",paraId:148,tocIndex:37},{value:"portId",paraId:148,tocIndex:37},{value:"string",paraId:148,tocIndex:37},{value:"",paraId:148,tocIndex:37},{value:"Port ID.",paraId:148,tocIndex:37},{value:"path",paraId:148,tocIndex:37},{value:"string | string[]",paraId:148,tocIndex:37},{value:"",paraId:148,tocIndex:37},{value:"Property path. When ",paraId:148,tocIndex:37},{value:"path",paraId:148,tocIndex:37},{value:" is of type ",paraId:148,tocIndex:37},{value:"string",paraId:148,tocIndex:37},{value:", the path is a string separated by ",paraId:148,tocIndex:37},{value:"'/'",paraId:148,tocIndex:37},{value:". When ",paraId:148,tocIndex:37},{value:"path",paraId:148,tocIndex:37},{value:" is of type ",paraId:148,tocIndex:37},{value:"string[]",paraId:148,tocIndex:37},{value:", the path is an array of keys that make up the port object path.",paraId:148,tocIndex:37},{value:"value",paraId:148,tocIndex:37},{value:"any",paraId:148,tocIndex:37},{value:"",paraId:148,tocIndex:37},{value:"Property value.",paraId:148,tocIndex:37},{value:"options.silent",paraId:148,tocIndex:37},{value:"boolean",paraId:148,tocIndex:37},{value:"false",paraId:148,tocIndex:37},{value:"If ",paraId:148,tocIndex:37},{value:"true",paraId:148,tocIndex:37},{value:", does not trigger the ",paraId:148,tocIndex:37},{value:"'change:ports'",paraId:148,tocIndex:37},{value:" event and canvas redraw.",paraId:148,tocIndex:37},{value:"options...others",paraId:148,tocIndex:37},{value:"object",paraId:148,tocIndex:37},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:148,tocIndex:37},{value:"node.setPortProp('port1', 'attrs/circle', {\n  fill: '#ffffff',\n  stroke: '#000000',\n})\nnode.setPortProp('port1', ['attrs', 'circle'], {\n  fill: '#ffffff',\n  stroke: '#000000',\n})\n",paraId:149,tocIndex:37},{value:"setPortProp(\n  portId: string,\n  value: DeepPartial<PortMetadata>,\n  options?: Node.SetOptions,\n): this\n",paraId:150,tocIndex:37},{value:"Sets the properties of the port, merging the provided property options with the current values using ",paraId:151,tocIndex:37},{value:"deep merge",paraId:151,tocIndex:37},{value:".",paraId:151,tocIndex:37},{value:"Name",paraId:152,tocIndex:37},{value:"Type",paraId:152,tocIndex:37},{value:"Required",paraId:152,tocIndex:37},{value:"Default Value",paraId:152,tocIndex:37},{value:"Description",paraId:152,tocIndex:37},{value:"portId",paraId:152,tocIndex:37},{value:"string",paraId:152,tocIndex:37},{value:"",paraId:152,tocIndex:37},{value:"Port ID.",paraId:152,tocIndex:37},{value:"value",paraId:152,tocIndex:37},{value:"DeepPartial<PortMetadata>",paraId:152,tocIndex:37},{value:"",paraId:152,tocIndex:37},{value:"Port options.",paraId:152,tocIndex:37},{value:"options.silent",paraId:152,tocIndex:37},{value:"boolean",paraId:152,tocIndex:37},{value:"false",paraId:152,tocIndex:37},{value:"If ",paraId:152,tocIndex:37},{value:"true",paraId:152,tocIndex:37},{value:", does not trigger the ",paraId:152,tocIndex:37},{value:"'change:ports'",paraId:152,tocIndex:37},{value:" event and canvas redraw.",paraId:152,tocIndex:37},{value:"options...others",paraId:152,tocIndex:37},{value:"object",paraId:152,tocIndex:37},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:152,tocIndex:37},{value:"node.setPortProp('port1', {\n  attrs: {\n    circle: {\n      fill: '#ffffff',\n      stroke: '#000000',\n    },\n  },\n})\n",paraId:153,tocIndex:37},{value:"removePortProp(portId: string, options?: Node.SetOptions): this\n",paraId:154,tocIndex:38},{value:"Removes the options of the specified port.",paraId:155,tocIndex:38},{value:"Name",paraId:156,tocIndex:38},{value:"Type",paraId:156,tocIndex:38},{value:"Required",paraId:156,tocIndex:38},{value:"Default Value",paraId:156,tocIndex:38},{value:"Description",paraId:156,tocIndex:38},{value:"portId",paraId:156,tocIndex:38},{value:"string",paraId:156,tocIndex:38},{value:"",paraId:156,tocIndex:38},{value:"Port ID.",paraId:156,tocIndex:38},{value:"options.silent",paraId:156,tocIndex:38},{value:"boolean",paraId:156,tocIndex:38},{value:"false",paraId:156,tocIndex:38},{value:"If ",paraId:156,tocIndex:38},{value:"true",paraId:156,tocIndex:38},{value:", does not trigger the ",paraId:156,tocIndex:38},{value:"'change:ports'",paraId:156,tocIndex:38},{value:" event and canvas redraw.",paraId:156,tocIndex:38},{value:"options...others",paraId:156,tocIndex:38},{value:"object",paraId:156,tocIndex:38},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:156,tocIndex:38},{value:"removePortProp(portId: string, path: string | string[], options?: Node.SetOptions): this\n",paraId:157,tocIndex:38},{value:"Removes the options of the specified port at the specified path.",paraId:158,tocIndex:38},{value:"Name",paraId:159,tocIndex:38},{value:"Type",paraId:159,tocIndex:38},{value:"Required",paraId:159,tocIndex:38},{value:"Default Value",paraId:159,tocIndex:38},{value:"Description",paraId:159,tocIndex:38},{value:"portId",paraId:159,tocIndex:38},{value:"string",paraId:159,tocIndex:38},{value:"",paraId:159,tocIndex:38},{value:"Port ID.",paraId:159,tocIndex:38},{value:"path",paraId:159,tocIndex:38},{value:"string | string[]",paraId:159,tocIndex:38},{value:"",paraId:159,tocIndex:38},{value:"Property path. When ",paraId:159,tocIndex:38},{value:"path",paraId:159,tocIndex:38},{value:" is of type ",paraId:159,tocIndex:38},{value:"string",paraId:159,tocIndex:38},{value:", the path is a string separated by ",paraId:159,tocIndex:38},{value:"'/'",paraId:159,tocIndex:38},{value:". When ",paraId:159,tocIndex:38},{value:"path",paraId:159,tocIndex:38},{value:" is of type ",paraId:159,tocIndex:38},{value:"string[]",paraId:159,tocIndex:38},{value:", the path is an array of keys that make up the port object path.",paraId:159,tocIndex:38},{value:"options.silent",paraId:159,tocIndex:38},{value:"boolean",paraId:159,tocIndex:38},{value:"false",paraId:159,tocIndex:38},{value:"If ",paraId:159,tocIndex:38},{value:"true",paraId:159,tocIndex:38},{value:", does not trigger the ",paraId:159,tocIndex:38},{value:"'change:ports'",paraId:159,tocIndex:38},{value:" event and canvas redraw.",paraId:159,tocIndex:38},{value:"options...others",paraId:159,tocIndex:38},{value:"object",paraId:159,tocIndex:38},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:159,tocIndex:38},{value:"portProp(portId: string): PortMetadata\nportProp<T>(portId: string, path: string | string[]): T\nportProp(\n  portId: string,\n  path: string | string[],\n  value: any,\n  options?: Node.SetOptions,\n): this\nportProp(\n  portId: string,\n  value: DeepPartial<PortMetadata>,\n  options?: Node.SetOptions,\n): this\n",paraId:160,tocIndex:39},{value:"This method is a combination of ",paraId:161,tocIndex:39},{value:"getPortProp",paraId:162,tocIndex:39},{value:" and ",paraId:161,tocIndex:39},{value:"setPortProp",paraId:163,tocIndex:39},{value:", with parameter options and usage consistent with these two methods.",paraId:161,tocIndex:39}]},70248:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(16687);const n=[{value:"The model corresponding to the canvas, by default creates a new model.",paraId:0,tocIndex:1},{value:"isNode(cell: Cell): cell is Node\n",paraId:1,tocIndex:3},{value:"Returns whether the specified Cell is a node.",paraId:2,tocIndex:3},{value:"Name",paraId:3,tocIndex:3},{value:"Type",paraId:3,tocIndex:3},{value:"Required",paraId:3,tocIndex:3},{value:"Default",paraId:3,tocIndex:3},{value:"Description",paraId:3,tocIndex:3},{value:"cell",paraId:3,tocIndex:3},{value:"Cell",paraId:3,tocIndex:3},{value:"",paraId:3,tocIndex:3},{value:"The specified Cell.",paraId:3,tocIndex:3},{value:"isEdge(cell: Cell): cell is Edge\n",paraId:4,tocIndex:4},{value:"Returns whether the specified Cell is an edge.",paraId:5,tocIndex:4},{value:"Name",paraId:6,tocIndex:4},{value:"Type",paraId:6,tocIndex:4},{value:"Required",paraId:6,tocIndex:4},{value:"Default",paraId:6,tocIndex:4},{value:"Description",paraId:6,tocIndex:4},{value:"cell",paraId:6,tocIndex:4},{value:"Cell",paraId:6,tocIndex:4},{value:"",paraId:6,tocIndex:4},{value:"The specified Cell.",paraId:6,tocIndex:4},{value:"createNode(metadata: Node.Metadata): Node\n",paraId:7,tocIndex:5},{value:"Creates a node.",paraId:8,tocIndex:5},{value:"Name",paraId:9,tocIndex:5},{value:"Type",paraId:9,tocIndex:5},{value:"Required",paraId:9,tocIndex:5},{value:"Default",paraId:9,tocIndex:5},{value:"Description",paraId:9,tocIndex:5},{value:"metadata",paraId:9,tocIndex:5},{value:"Node.Metadata",paraId:9,tocIndex:5},{value:"",paraId:9,tocIndex:5},{value:"Node metadata.",paraId:9,tocIndex:5},{value:"addNode(metadata: Node.Metadata, options?: AddOptions): Node\naddNode(node: Node, options?: AddOptions): Node\n",paraId:10,tocIndex:6},{value:"Adds a node to the canvas, returns the added node.",paraId:11,tocIndex:6},{value:"Name",paraId:12,tocIndex:6},{value:"Type",paraId:12,tocIndex:6},{value:"Required",paraId:12,tocIndex:6},{value:"Default",paraId:12,tocIndex:6},{value:"Description",paraId:12,tocIndex:6},{value:"node",paraId:12,tocIndex:6},{value:"Node.Metadata | Node",paraId:12,tocIndex:6},{value:"",paraId:12,tocIndex:6},{value:"Node metadata or node instance.",paraId:12,tocIndex:6},{value:"options.silent",paraId:12,tocIndex:6},{value:"boolean",paraId:12,tocIndex:6},{value:"false",paraId:12,tocIndex:6},{value:"If ",paraId:12,tocIndex:6},{value:"true",paraId:12,tocIndex:6},{value:", does not trigger ",paraId:12,tocIndex:6},{value:"'node:added'",paraId:12,tocIndex:6},{value:" and ",paraId:12,tocIndex:6},{value:"'cell:added'",paraId:12,tocIndex:6},{value:" events and canvas redraw.",paraId:12,tocIndex:6},{value:"options.sort",paraId:12,tocIndex:6},{value:"boolean",paraId:12,tocIndex:6},{value:"true",paraId:12,tocIndex:6},{value:"Whether to sort by ",paraId:12,tocIndex:6},{value:"zIndex",paraId:12,tocIndex:6},{value:".",paraId:12,tocIndex:6},{value:"options...others",paraId:12,tocIndex:6},{value:"object",paraId:12,tocIndex:6},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:12,tocIndex:6},{value:"addNodes(nodes: (Node.Metadata | Node)[], options?: AddOptions): Graph\n",paraId:13,tocIndex:7},{value:"Adds multiple nodes to the canvas, returns the graph. When adding nodes in batch, it's recommended to use this method for better performance compared to multiple addNode calls.",paraId:14,tocIndex:7},{value:"Name",paraId:15,tocIndex:7},{value:"Type",paraId:15,tocIndex:7},{value:"Required",paraId:15,tocIndex:7},{value:"Default",paraId:15,tocIndex:7},{value:"Description",paraId:15,tocIndex:7},{value:"nodes",paraId:15,tocIndex:7},{value:"(Node.Metadata | Node)[]",paraId:15,tocIndex:7},{value:"",paraId:15,tocIndex:7},{value:"Array of node metadata or node instances.",paraId:15,tocIndex:7},{value:"options.silent",paraId:15,tocIndex:7},{value:"boolean",paraId:15,tocIndex:7},{value:"false",paraId:15,tocIndex:7},{value:"If ",paraId:15,tocIndex:7},{value:"true",paraId:15,tocIndex:7},{value:", does not trigger ",paraId:15,tocIndex:7},{value:"'node:added'",paraId:15,tocIndex:7},{value:" and ",paraId:15,tocIndex:7},{value:"'cell:added'",paraId:15,tocIndex:7},{value:" events and canvas redraw.",paraId:15,tocIndex:7},{value:"options.sort",paraId:15,tocIndex:7},{value:"boolean",paraId:15,tocIndex:7},{value:"true",paraId:15,tocIndex:7},{value:"Whether to sort by ",paraId:15,tocIndex:7},{value:"zIndex",paraId:15,tocIndex:7},{value:".",paraId:15,tocIndex:7},{value:"options...others",paraId:15,tocIndex:7},{value:"object",paraId:15,tocIndex:7},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:15,tocIndex:7},{value:"removeNode(nodeId: string, options?: RemoveOptions): Node | null\nremoveNode(node: Node, options?: RemoveOptions): Node | null\n",paraId:16,tocIndex:8},{value:"Removes a node, returns the removed node.",paraId:17,tocIndex:8},{value:"Name",paraId:18,tocIndex:8},{value:"Type",paraId:18,tocIndex:8},{value:"Required",paraId:18,tocIndex:8},{value:"Default",paraId:18,tocIndex:8},{value:"Description",paraId:18,tocIndex:8},{value:"node",paraId:18,tocIndex:8},{value:"string | Node",paraId:18,tocIndex:8},{value:"",paraId:18,tocIndex:8},{value:"Node ID or node instance.",paraId:18,tocIndex:8},{value:"options.silent",paraId:18,tocIndex:8},{value:"boolean",paraId:18,tocIndex:8},{value:"false",paraId:18,tocIndex:8},{value:"If ",paraId:18,tocIndex:8},{value:"true",paraId:18,tocIndex:8},{value:", does not trigger ",paraId:18,tocIndex:8},{value:"'node:removed'",paraId:18,tocIndex:8},{value:" and ",paraId:18,tocIndex:8},{value:"'cell:removed'",paraId:18,tocIndex:8},{value:" events and canvas redraw.",paraId:18,tocIndex:8},{value:"options...others",paraId:18,tocIndex:8},{value:"object",paraId:18,tocIndex:8},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:18,tocIndex:8},{value:"createEdge(metadata: Edge.Metadata): Edge\n",paraId:19,tocIndex:9},{value:"Creates an edge.",paraId:20,tocIndex:9},{value:"Name",paraId:21,tocIndex:9},{value:"Type",paraId:21,tocIndex:9},{value:"Required",paraId:21,tocIndex:9},{value:"Default",paraId:21,tocIndex:9},{value:"Description",paraId:21,tocIndex:9},{value:"metadata",paraId:21,tocIndex:9},{value:"Edge.Metadata",paraId:21,tocIndex:9},{value:"",paraId:21,tocIndex:9},{value:"Edge metadata.",paraId:21,tocIndex:9},{value:"addEdge(metadata: Edge.Metadata, options?: AddOptions): Edge\naddEdge(edge:Edge, options?: AddOptions): Edge\n",paraId:22,tocIndex:10},{value:"Adds an edge to the canvas, returns the added edge.",paraId:23,tocIndex:10},{value:"Name",paraId:24,tocIndex:10},{value:"Type",paraId:24,tocIndex:10},{value:"Required",paraId:24,tocIndex:10},{value:"Default",paraId:24,tocIndex:10},{value:"Description",paraId:24,tocIndex:10},{value:"edge",paraId:24,tocIndex:10},{value:"Edge.Metadata | Edge",paraId:24,tocIndex:10},{value:"",paraId:24,tocIndex:10},{value:"Edge metadata or edge instance.",paraId:24,tocIndex:10},{value:"options.silent",paraId:24,tocIndex:10},{value:"boolean",paraId:24,tocIndex:10},{value:"false",paraId:24,tocIndex:10},{value:"If ",paraId:24,tocIndex:10},{value:"true",paraId:24,tocIndex:10},{value:", does not trigger ",paraId:24,tocIndex:10},{value:"'edge:added'",paraId:24,tocIndex:10},{value:" and ",paraId:24,tocIndex:10},{value:"'cell:added'",paraId:24,tocIndex:10},{value:" events and canvas redraw.",paraId:24,tocIndex:10},{value:"options.sort",paraId:24,tocIndex:10},{value:"boolean",paraId:24,tocIndex:10},{value:"true",paraId:24,tocIndex:10},{value:"Whether to sort by ",paraId:24,tocIndex:10},{value:"zIndex",paraId:24,tocIndex:10},{value:".",paraId:24,tocIndex:10},{value:"options...others",paraId:24,tocIndex:10},{value:"object",paraId:24,tocIndex:10},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:24,tocIndex:10},{value:"addEdges(edges: (Edge.Metadata | Edge)[], options?: AddOptions): Graph\n",paraId:25,tocIndex:11},{value:"Adds multiple edges to the canvas, returns the graph.",paraId:26,tocIndex:11},{value:"Name",paraId:27,tocIndex:11},{value:"Type",paraId:27,tocIndex:11},{value:"Required",paraId:27,tocIndex:11},{value:"Default",paraId:27,tocIndex:11},{value:"Description",paraId:27,tocIndex:11},{value:"edges",paraId:27,tocIndex:11},{value:"(Edge.Metadata | Edge)[]",paraId:27,tocIndex:11},{value:"",paraId:27,tocIndex:11},{value:"Array of edge metadata or edge instances.",paraId:27,tocIndex:11},{value:"options.silent",paraId:27,tocIndex:11},{value:"boolean",paraId:27,tocIndex:11},{value:"false",paraId:27,tocIndex:11},{value:"If ",paraId:27,tocIndex:11},{value:"true",paraId:27,tocIndex:11},{value:", does not trigger ",paraId:27,tocIndex:11},{value:"'edge:added'",paraId:27,tocIndex:11},{value:" and ",paraId:27,tocIndex:11},{value:"'cell:added'",paraId:27,tocIndex:11},{value:" events and canvas redraw.",paraId:27,tocIndex:11},{value:"options.sort",paraId:27,tocIndex:11},{value:"boolean",paraId:27,tocIndex:11},{value:"true",paraId:27,tocIndex:11},{value:"Whether to sort by ",paraId:27,tocIndex:11},{value:"zIndex",paraId:27,tocIndex:11},{value:".",paraId:27,tocIndex:11},{value:"options...others",paraId:27,tocIndex:11},{value:"object",paraId:27,tocIndex:11},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:27,tocIndex:11},{value:"removeEdge(edgeId: string, options?: RemoveOptions): Edge | null\nremoveEdge(edge: Edge, options?: RemoveOptions): Edge | null\n",paraId:28,tocIndex:12},{value:"Removes an edge, returns the removed edge.",paraId:29,tocIndex:12},{value:"Name",paraId:30,tocIndex:12},{value:"Type",paraId:30,tocIndex:12},{value:"Required",paraId:30,tocIndex:12},{value:"Default",paraId:30,tocIndex:12},{value:"Description",paraId:30,tocIndex:12},{value:"edge",paraId:30,tocIndex:12},{value:"string | Edge",paraId:30,tocIndex:12},{value:"",paraId:30,tocIndex:12},{value:"Edge ID or edge instance.",paraId:30,tocIndex:12},{value:"options.silent",paraId:30,tocIndex:12},{value:"boolean",paraId:30,tocIndex:12},{value:"false",paraId:30,tocIndex:12},{value:"If ",paraId:30,tocIndex:12},{value:"true",paraId:30,tocIndex:12},{value:", does not trigger ",paraId:30,tocIndex:12},{value:"'edge:removed'",paraId:30,tocIndex:12},{value:" and ",paraId:30,tocIndex:12},{value:"'cell:removed'",paraId:30,tocIndex:12},{value:" events and canvas redraw.",paraId:30,tocIndex:12},{value:"options...others",paraId:30,tocIndex:12},{value:"object",paraId:30,tocIndex:12},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:30,tocIndex:12},{value:"addCell(cell: Cell | Cell[], options?: AddOptions): this\n",paraId:31,tocIndex:13},{value:"Adds a node or edge to the canvas.",paraId:32,tocIndex:13},{value:"Name",paraId:33,tocIndex:13},{value:"Type",paraId:33,tocIndex:13},{value:"Required",paraId:33,tocIndex:13},{value:"Default",paraId:33,tocIndex:13},{value:"Description",paraId:33,tocIndex:13},{value:"cell",paraId:33,tocIndex:13},{value:"Cell | Cell[]",paraId:33,tocIndex:13},{value:"",paraId:33,tocIndex:13},{value:"Node instance or edge instance, supports passing an array to add multiple nodes or edges at once.",paraId:33,tocIndex:13},{value:"options.silent",paraId:33,tocIndex:13},{value:"boolean",paraId:33,tocIndex:13},{value:"false",paraId:33,tocIndex:13},{value:"If ",paraId:33,tocIndex:13},{value:"true",paraId:33,tocIndex:13},{value:", does not trigger ",paraId:33,tocIndex:13},{value:"'cell:added'",paraId:33,tocIndex:13},{value:", ",paraId:33,tocIndex:13},{value:"'node:added'",paraId:33,tocIndex:13},{value:", and ",paraId:33,tocIndex:13},{value:"'edge:added'",paraId:33,tocIndex:13},{value:" events and canvas redraw.",paraId:33,tocIndex:13},{value:"options.sort",paraId:33,tocIndex:13},{value:"boolean",paraId:33,tocIndex:13},{value:"true",paraId:33,tocIndex:13},{value:"Whether to sort by ",paraId:33,tocIndex:13},{value:"zIndex",paraId:33,tocIndex:13},{value:".",paraId:33,tocIndex:13},{value:"options...others",paraId:33,tocIndex:13},{value:"object",paraId:33,tocIndex:13},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:33,tocIndex:13},{value:"removeCell(cellId: string, options?: RemoveOptions): Cell | null\nremoveCell(cell: Cell, options?: RemoveOptions): Cell | null\n",paraId:34,tocIndex:14},{value:"Removes a node or edge, returns the removed node or edge.",paraId:35,tocIndex:14},{value:"Name",paraId:36,tocIndex:14},{value:"Type",paraId:36,tocIndex:14},{value:"Required",paraId:36,tocIndex:14},{value:"Default",paraId:36,tocIndex:14},{value:"Description",paraId:36,tocIndex:14},{value:"cell",paraId:36,tocIndex:14},{value:"string | Cell",paraId:36,tocIndex:14},{value:"",paraId:36,tocIndex:14},{value:"Node/edge ID or node/edge instance.",paraId:36,tocIndex:14},{value:"options.silent",paraId:36,tocIndex:14},{value:"boolean",paraId:36,tocIndex:14},{value:"false",paraId:36,tocIndex:14},{value:"If ",paraId:36,tocIndex:14},{value:"true",paraId:36,tocIndex:14},{value:", does not trigger ",paraId:36,tocIndex:14},{value:"'cell:removed'",paraId:36,tocIndex:14},{value:", ",paraId:36,tocIndex:14},{value:"'node:removed'",paraId:36,tocIndex:14},{value:", and ",paraId:36,tocIndex:14},{value:"'edge:removed'",paraId:36,tocIndex:14},{value:" events and canvas redraw.",paraId:36,tocIndex:14},{value:"options...others",paraId:36,tocIndex:14},{value:"object",paraId:36,tocIndex:14},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:36,tocIndex:14},{value:"removeCells(cells: (Cell | string)[], options?: RemoveOptions): Cell[]\n",paraId:37,tocIndex:15},{value:"Removes multiple nodes/edges, returns an array of removed nodes or edges.",paraId:38,tocIndex:15},{value:"Name",paraId:39,tocIndex:15},{value:"Type",paraId:39,tocIndex:15},{value:"Required",paraId:39,tocIndex:15},{value:"Default",paraId:39,tocIndex:15},{value:"Description",paraId:39,tocIndex:15},{value:"cell",paraId:39,tocIndex:15},{value:"(string | Cell)[]",paraId:39,tocIndex:15},{value:"",paraId:39,tocIndex:15},{value:"Array of node/edge IDs or node/edge instances.",paraId:39,tocIndex:15},{value:"options.silent",paraId:39,tocIndex:15},{value:"boolean",paraId:39,tocIndex:15},{value:"false",paraId:39,tocIndex:15},{value:"If ",paraId:39,tocIndex:15},{value:"true",paraId:39,tocIndex:15},{value:", does not trigger ",paraId:39,tocIndex:15},{value:"'cell:removed'",paraId:39,tocIndex:15},{value:", ",paraId:39,tocIndex:15},{value:"'node:removed'",paraId:39,tocIndex:15},{value:", and ",paraId:39,tocIndex:15},{value:"'edge:removed'",paraId:39,tocIndex:15},{value:" events and canvas redraw.",paraId:39,tocIndex:15},{value:"options...others",paraId:39,tocIndex:15},{value:"object",paraId:39,tocIndex:15},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:39,tocIndex:15},{value:"removeConnectedEdges(cell: Cell | string, options?: RemoveOptions): Edge[]\n",paraId:40,tocIndex:16},{value:"Removes edges connected to the node/edge, returns an array of removed edges.",paraId:41,tocIndex:16},{value:"Name",paraId:42,tocIndex:16},{value:"Type",paraId:42,tocIndex:16},{value:"Required",paraId:42,tocIndex:16},{value:"Default",paraId:42,tocIndex:16},{value:"Description",paraId:42,tocIndex:16},{value:"cell",paraId:42,tocIndex:16},{value:"string | Cell",paraId:42,tocIndex:16},{value:"",paraId:42,tocIndex:16},{value:"Node/edge ID or node/edge.",paraId:42,tocIndex:16},{value:"options.silent",paraId:42,tocIndex:16},{value:"boolean",paraId:42,tocIndex:16},{value:"false",paraId:42,tocIndex:16},{value:"If ",paraId:42,tocIndex:16},{value:"true",paraId:42,tocIndex:16},{value:", does not trigger ",paraId:42,tocIndex:16},{value:"'cell:removed'",paraId:42,tocIndex:16},{value:" and ",paraId:42,tocIndex:16},{value:"'edge:removed'",paraId:42,tocIndex:16},{value:" events and canvas redraw.",paraId:42,tocIndex:16},{value:"options...others",paraId:42,tocIndex:16},{value:"object",paraId:42,tocIndex:16},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:42,tocIndex:16},{value:"disconnectConnectedEdges(cell: Cell | string, options?: Edge.SetOptions): this\n",paraId:43,tocIndex:17},{value:"Sets the source and target of edges connected to the node/edge to the origin ",paraId:44,tocIndex:17},{value:"{x: 0, y: 0}",paraId:44,tocIndex:17},{value:", effectively disconnecting them.",paraId:44,tocIndex:17},{value:"Name",paraId:45,tocIndex:17},{value:"Type",paraId:45,tocIndex:17},{value:"Required",paraId:45,tocIndex:17},{value:"Default",paraId:45,tocIndex:17},{value:"Description",paraId:45,tocIndex:17},{value:"cell",paraId:45,tocIndex:17},{value:"string | Cell",paraId:45,tocIndex:17},{value:"",paraId:45,tocIndex:17},{value:"Node/edge ID or node/edge.",paraId:45,tocIndex:17},{value:"options.silent",paraId:45,tocIndex:17},{value:"boolean",paraId:45,tocIndex:17},{value:"false",paraId:45,tocIndex:17},{value:"If ",paraId:45,tocIndex:17},{value:"true",paraId:45,tocIndex:17},{value:", does not trigger ",paraId:45,tocIndex:17},{value:"'edge:change:source'",paraId:45,tocIndex:17},{value:" and ",paraId:45,tocIndex:17},{value:"'edge:change:target'",paraId:45,tocIndex:17},{value:" events and canvas redraw.",paraId:45,tocIndex:17},{value:"options...others",paraId:45,tocIndex:17},{value:"object",paraId:45,tocIndex:17},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:45,tocIndex:17},{value:"clearCells(options?: SetOptions): this\n",paraId:46,tocIndex:18},{value:"Clears the canvas.",paraId:47,tocIndex:18},{value:"Name",paraId:48,tocIndex:18},{value:"Type",paraId:48,tocIndex:18},{value:"Required",paraId:48,tocIndex:18},{value:"Default",paraId:48,tocIndex:18},{value:"Description",paraId:48,tocIndex:18},{value:"options.silent",paraId:48,tocIndex:18},{value:"boolean",paraId:48,tocIndex:18},{value:"false",paraId:48,tocIndex:18},{value:"If ",paraId:48,tocIndex:18},{value:"true",paraId:48,tocIndex:18},{value:", does not trigger ",paraId:48,tocIndex:18},{value:"'cell:removed'",paraId:48,tocIndex:18},{value:", ",paraId:48,tocIndex:18},{value:"'node:removed'",paraId:48,tocIndex:18},{value:", and ",paraId:48,tocIndex:18},{value:"'edge:removed'",paraId:48,tocIndex:18},{value:" events and canvas redraw.",paraId:48,tocIndex:18},{value:"options...others",paraId:48,tocIndex:18},{value:"object",paraId:48,tocIndex:18},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:48,tocIndex:18},{value:"resetCells(cells: Cell[], options?: SetOptions): this\n",paraId:49,tocIndex:19},{value:"Clears the canvas and adds the specified nodes/edges.",paraId:50,tocIndex:19},{value:"Name",paraId:51,tocIndex:19},{value:"Type",paraId:51,tocIndex:19},{value:"Required",paraId:51,tocIndex:19},{value:"Default",paraId:51,tocIndex:19},{value:"Description",paraId:51,tocIndex:19},{value:"cell",paraId:51,tocIndex:19},{value:"Cell[]",paraId:51,tocIndex:19},{value:"",paraId:51,tocIndex:19},{value:"Array of nodes/edges.",paraId:51,tocIndex:19},{value:"options.silent",paraId:51,tocIndex:19},{value:"boolean",paraId:51,tocIndex:19},{value:"false",paraId:51,tocIndex:19},{value:"If ",paraId:51,tocIndex:19},{value:"true",paraId:51,tocIndex:19},{value:", does not trigger ",paraId:51,tocIndex:19},{value:"'cell:added'",paraId:51,tocIndex:19},{value:", ",paraId:51,tocIndex:19},{value:"'node:added'",paraId:51,tocIndex:19},{value:", ",paraId:51,tocIndex:19},{value:"'edge:added'",paraId:51,tocIndex:19},{value:", ",paraId:51,tocIndex:19},{value:"'cell:removed'",paraId:51,tocIndex:19},{value:", ",paraId:51,tocIndex:19},{value:"'node:removed'",paraId:51,tocIndex:19},{value:", and ",paraId:51,tocIndex:19},{value:"'edge:removed'",paraId:51,tocIndex:19},{value:" events and canvas redraw.",paraId:51,tocIndex:19},{value:"options...others",paraId:51,tocIndex:19},{value:"object",paraId:51,tocIndex:19},{value:"Other custom key-value pairs that can be used in event callbacks.",paraId:51,tocIndex:19},{value:"hasCell(cellId: string): boolean\nhasCell(cell: Cell): boolean\n",paraId:52,tocIndex:20},{value:"Returns whether the canvas contains the specified node/edge.",paraId:53,tocIndex:20},{value:"Name",paraId:54,tocIndex:20},{value:"Type",paraId:54,tocIndex:20},{value:"Required",paraId:54,tocIndex:20},{value:"Default",paraId:54,tocIndex:20},{value:"Description",paraId:54,tocIndex:20},{value:"cell",paraId:54,tocIndex:20},{value:"string | Cell",paraId:54,tocIndex:20},{value:"",paraId:54,tocIndex:20},{value:"Node/edge ID or node/edge.",paraId:54,tocIndex:20},{value:"getCellById(id: string)\n",paraId:55,tocIndex:21},{value:"Gets a node/edge by its ID.",paraId:56,tocIndex:21},{value:"Name",paraId:57,tocIndex:21},{value:"Type",paraId:57,tocIndex:21},{value:"Required",paraId:57,tocIndex:21},{value:"Default",paraId:57,tocIndex:21},{value:"Description",paraId:57,tocIndex:21},{value:"id",paraId:57,tocIndex:21},{value:"string",paraId:57,tocIndex:21},{value:"",paraId:57,tocIndex:21},{value:"ID of the node/edge.",paraId:57,tocIndex:21},{value:"updateCellId(cell: Cell, newId: string)\n",paraId:58,tocIndex:22},{value:"Updates the ID of a node or edge, returns the newly created node/edge.",paraId:59,tocIndex:22},{value:"Name",paraId:60,tocIndex:22},{value:"Type",paraId:60,tocIndex:22},{value:"Required",paraId:60,tocIndex:22},{value:"Default",paraId:60,tocIndex:22},{value:"Description",paraId:60,tocIndex:22},{value:"cell",paraId:60,tocIndex:22},{value:"Cell",paraId:60,tocIndex:22},{value:"",paraId:60,tocIndex:22},{value:"Node/edge.",paraId:60,tocIndex:22},{value:"newId",paraId:60,tocIndex:22},{value:"string",paraId:60,tocIndex:22},{value:"",paraId:60,tocIndex:22},{value:"New ID.",paraId:60,tocIndex:22},{value:"getCells(): Cell[]\n",paraId:61,tocIndex:23},{value:"Returns all nodes and edges in the canvas.",paraId:62,tocIndex:23},{value:"getCellCount(): number\n",paraId:63,tocIndex:24},{value:"Returns the count of all nodes and edges in the canvas.",paraId:64,tocIndex:24},{value:"getNodes(): Node[]\n",paraId:65,tocIndex:25},{value:"Returns all nodes in the canvas.",paraId:66,tocIndex:25},{value:"getEdges(): Edge[]\n",paraId:67,tocIndex:26},{value:"Returns all edges in the canvas.",paraId:68,tocIndex:26},{value:"getOutgoingEdges(cell: Cell | string): Edge[] | null\n",paraId:69,tocIndex:27},{value:"Gets the outgoing edges connected to the node/edge, i.e., edges whose source is the specified node/edge.",paraId:70,tocIndex:27},{value:"Name",paraId:71,tocIndex:27},{value:"Type",paraId:71,tocIndex:27},{value:"Required",paraId:71,tocIndex:27},{value:"Default",paraId:71,tocIndex:27},{value:"Description",paraId:71,tocIndex:27},{value:"cell",paraId:71,tocIndex:27},{value:"string | Cell",paraId:71,tocIndex:27},{value:"",paraId:71,tocIndex:27},{value:"Node/edge ID or node/edge.",paraId:71,tocIndex:27},{value:"getIncomingEdges(cell: Cell | string): Edge[] | null\n",paraId:72,tocIndex:28},{value:"Gets the incoming edges connected to the node/edge, i.e., edges whose target is the specified node/edge.",paraId:73,tocIndex:28},{value:"Name",paraId:74,tocIndex:28},{value:"Type",paraId:74,tocIndex:28},{value:"Required",paraId:74,tocIndex:28},{value:"Default",paraId:74,tocIndex:28},{value:"Description",paraId:74,tocIndex:28},{value:"cell",paraId:74,tocIndex:28},{value:"string | Cell",paraId:74,tocIndex:28},{value:"",paraId:74,tocIndex:28},{value:"Node/edge ID or node/edge.",paraId:74,tocIndex:28},{value:"getConnectedEdges(cell: Cell | string, options?: GetConnectedEdgesOptions): Edge[]\n",paraId:75,tocIndex:29},{value:"Get the edges connected to a node/edge.",paraId:76,tocIndex:29},{value:"Name",paraId:77,tocIndex:29},{value:"Type",paraId:77,tocIndex:29},{value:"Required",paraId:77,tocIndex:29},{value:"Default",paraId:77,tocIndex:29},{value:"Description",paraId:77,tocIndex:29},{value:"cell",paraId:77,tocIndex:29},{value:"string | Cell",paraId:77,tocIndex:29},{value:"",paraId:77,tocIndex:29},{value:"Node/Edge ID or Node/Edge.",paraId:77,tocIndex:29},{value:"options.incoming",paraId:77,tocIndex:29},{value:"boolean",paraId:77,tocIndex:29},{value:"-",paraId:77,tocIndex:29},{value:"Whether to include incoming edges. By default, returns all incoming and outgoing edges. When ",paraId:77,tocIndex:29},{value:"incoming",paraId:77,tocIndex:29},{value:" is ",paraId:77,tocIndex:29},{value:"true",paraId:77,tocIndex:29},{value:", only returns incoming edges.",paraId:77,tocIndex:29},{value:"options.outgoing",paraId:77,tocIndex:29},{value:"boolean",paraId:77,tocIndex:29},{value:"-",paraId:77,tocIndex:29},{value:"Whether to include outgoing edges. By default, returns all incoming and outgoing edges. When ",paraId:77,tocIndex:29},{value:"outgoing",paraId:77,tocIndex:29},{value:" is ",paraId:77,tocIndex:29},{value:"true",paraId:77,tocIndex:29},{value:", only returns outgoing edges.",paraId:77,tocIndex:29},{value:"options.deep",paraId:77,tocIndex:29},{value:"boolean",paraId:77,tocIndex:29},{value:"false",paraId:77,tocIndex:29},{value:"Whether to recursively get edges for all child nodes/edges. When ",paraId:77,tocIndex:29},{value:"true",paraId:77,tocIndex:29},{value:", it will also return edges connected to all descendant nodes/edges.",paraId:77,tocIndex:29},{value:"options.enclosed",paraId:77,tocIndex:29},{value:"boolean",paraId:77,tocIndex:29},{value:"false",paraId:77,tocIndex:29},{value:"Whether to include edges connecting descendant nodes.",paraId:77,tocIndex:29},{value:"options.indirect",paraId:77,tocIndex:29},{value:"boolean",paraId:77,tocIndex:29},{value:"false",paraId:77,tocIndex:29},{value:"Whether to include indirectly connected edges, i.e., edges connected to input or output edges.",paraId:77,tocIndex:29},{value:"const edges = graph.getConnectedEdges(node) // Returns incoming and outgoing edges\nconst edges = graph.getConnectedEdges(node, { incoming: true, outgoing: true }) // Returns incoming and outgoing edges\n\nconst edges = graph.getConnectedEdges(node, { incoming: true }) // Returns incoming edges\nconst edges = graph.getConnectedEdges(node, {\n  incoming: true,\n  outgoing: false,\n}) // Returns incoming edges\n\nconst edges = graph.getConnectedEdges(node, { outgoing: true }) // Returns outgoing edges\nconst edges = graph.getConnectedEdges(node, {\n  incoming: false,\n  outgoing: true,\n}) // Returns outgoing edges\n\nconst edges = graph.getConnectedEdges(node, { deep: true }) // Returns incoming and outgoing edges, including those connected to all descendant nodes/edges\nconst edges = graph.getConnectedEdges(node, { deep: true, incoming: true }) // Returns incoming edges, including those connected to all descendant nodes/edges\nconst edges = graph.getConnectedEdges(node, { deep: true, enclosed: true }) // Returns incoming and outgoing edges, including edges connecting descendant nodes/edges\n\nconst edges = graph.getConnectedEdges(node, { indirect: true }) // Returns incoming and outgoing edges, including indirectly connected edges\n",paraId:78,tocIndex:29},{value:"getRootNodes(): Node[]\n",paraId:79,tocIndex:30},{value:"Get all root nodes, i.e., nodes without incoming edges.",paraId:80,tocIndex:30},{value:"isRootNode(cell: Cell | string): boolean\n",paraId:81,tocIndex:31},{value:"Returns whether the specified node is a root node.",paraId:82,tocIndex:31},{value:"Name",paraId:83,tocIndex:31},{value:"Type",paraId:83,tocIndex:31},{value:"Required",paraId:83,tocIndex:31},{value:"Default",paraId:83,tocIndex:31},{value:"Description",paraId:83,tocIndex:31},{value:"cell",paraId:83,tocIndex:31},{value:"string | Cell",paraId:83,tocIndex:31},{value:"",paraId:83,tocIndex:31},{value:"Node/Edge ID or Node/Edge.",paraId:83,tocIndex:31},{value:"getLeafNodes(): Node[]\n",paraId:84,tocIndex:32},{value:"Returns all leaf nodes, i.e., nodes without outgoing edges.",paraId:85,tocIndex:32},{value:"isLeafNode(cell: Cell | string): boolean\n",paraId:86,tocIndex:33},{value:"Returns whether the specified node is a leaf node.",paraId:87,tocIndex:33},{value:"Name",paraId:88,tocIndex:33},{value:"Type",paraId:88,tocIndex:33},{value:"Required",paraId:88,tocIndex:33},{value:"Default",paraId:88,tocIndex:33},{value:"Description",paraId:88,tocIndex:33},{value:"cell",paraId:88,tocIndex:33},{value:"string | Cell",paraId:88,tocIndex:33},{value:"",paraId:88,tocIndex:33},{value:"Node/Edge ID or Node/Edge.",paraId:88,tocIndex:33},{value:"getNeighbors(cell: Cell, options?: GetNeighborsOptions): Cell[]\n",paraId:89,tocIndex:34},{value:"Get neighboring nodes.",paraId:90,tocIndex:34},{value:"Name",paraId:91,tocIndex:34},{value:"Type",paraId:91,tocIndex:34},{value:"Required",paraId:91,tocIndex:34},{value:"Default",paraId:91,tocIndex:34},{value:"Description",paraId:91,tocIndex:34},{value:"cell",paraId:91,tocIndex:34},{value:"Cell",paraId:91,tocIndex:34},{value:"",paraId:91,tocIndex:34},{value:"Node/Edge.",paraId:91,tocIndex:34},{value:"options.incoming",paraId:91,tocIndex:34},{value:"boolean",paraId:91,tocIndex:34},{value:"-",paraId:91,tocIndex:34},{value:"Whether to include incoming neighboring nodes. By default, includes both incoming and outgoing nodes. When ",paraId:91,tocIndex:34},{value:"incoming",paraId:91,tocIndex:34},{value:" is ",paraId:91,tocIndex:34},{value:"true",paraId:91,tocIndex:34},{value:", only returns incoming nodes.",paraId:91,tocIndex:34},{value:"options.outgoing",paraId:91,tocIndex:34},{value:"boolean",paraId:91,tocIndex:34},{value:"-",paraId:91,tocIndex:34},{value:"Whether to include outgoing neighboring nodes. By default, includes both incoming and outgoing nodes. When ",paraId:91,tocIndex:34},{value:"outgoing",paraId:91,tocIndex:34},{value:" is ",paraId:91,tocIndex:34},{value:"true",paraId:91,tocIndex:34},{value:", only returns outgoing nodes.",paraId:91,tocIndex:34},{value:"options.deep",paraId:91,tocIndex:34},{value:"boolean",paraId:91,tocIndex:34},{value:"false",paraId:91,tocIndex:34},{value:"Whether to recursively get all child nodes/edges. When ",paraId:91,tocIndex:34},{value:"true",paraId:91,tocIndex:34},{value:", it will also return neighboring nodes of all descendant nodes/edges.",paraId:91,tocIndex:34},{value:"options.indirect",paraId:91,tocIndex:34},{value:"boolean",paraId:91,tocIndex:34},{value:"false",paraId:91,tocIndex:34},{value:"Whether to include indirectly connected neighboring nodes, i.e., neighbors connected through multiple edges (edge-to-edge connections).",paraId:91,tocIndex:34},{value:"isNeighbor(cell1: Cell, cell2: Cell, options?: GetNeighborsOptions): boolean\n",paraId:92,tocIndex:35},{value:"Returns whether ",paraId:93,tocIndex:35},{value:"cell2",paraId:93,tocIndex:35},{value:" is a neighbor of ",paraId:93,tocIndex:35},{value:"cell1",paraId:93,tocIndex:35},{value:". The ",paraId:93,tocIndex:35},{value:"options",paraId:93,tocIndex:35},{value:" are the same as those in the ",paraId:93,tocIndex:35},{value:"getNeighbors(...)",paraId:94,tocIndex:35},{value:" method.",paraId:93,tocIndex:35},{value:"getPredecessors(cell: Cell, options?: GetPredecessorsOptions): Cell[]\n",paraId:95,tocIndex:36},{value:"Returns the predecessor nodes of a node, i.e., nodes connected from the root node to the specified node.",paraId:96,tocIndex:36},{value:"Name",paraId:97,tocIndex:36},{value:"Type",paraId:97,tocIndex:36},{value:"Required",paraId:97,tocIndex:36},{value:"Default",paraId:97,tocIndex:36},{value:"Description",paraId:97,tocIndex:36},{value:"cell",paraId:97,tocIndex:36},{value:"Cell",paraId:97,tocIndex:36},{value:"",paraId:97,tocIndex:36},{value:"Node/Edge.",paraId:97,tocIndex:36},{value:"options.breadthFirst",paraId:97,tocIndex:36},{value:"boolean",paraId:97,tocIndex:36},{value:"false",paraId:97,tocIndex:36},{value:"Whether to use breadth-first search algorithm. By default, uses depth-first search algorithm.",paraId:97,tocIndex:36},{value:"options.deep",paraId:97,tocIndex:36},{value:"boolean",paraId:97,tocIndex:36},{value:"false",paraId:97,tocIndex:36},{value:"Whether to recursively get all child nodes/edges. When ",paraId:97,tocIndex:36},{value:"true",paraId:97,tocIndex:36},{value:", it will also return predecessors of all descendant nodes/edges.",paraId:97,tocIndex:36},{value:"options.distance",paraId:97,tocIndex:36},{value:"number | number[] | ((distance: number) => boolean)",paraId:97,tocIndex:36},{value:"-",paraId:97,tocIndex:36},{value:"Get predecessors at a specified distance. The number of edges between nodes is considered as 1 distance unit.",paraId:97,tocIndex:36},{value:"isPredecessor(cell1: Cell, cell2: Cell, options?: GetPredecessorsOptions): boolean\n",paraId:98,tocIndex:37},{value:"Returns whether ",paraId:99,tocIndex:37},{value:"cell2",paraId:99,tocIndex:37},{value:" is a predecessor of ",paraId:99,tocIndex:37},{value:"cell1",paraId:99,tocIndex:37},{value:". The ",paraId:99,tocIndex:37},{value:"options",paraId:99,tocIndex:37},{value:" are the same as those in the ",paraId:99,tocIndex:37},{value:"getPredecessors(...)",paraId:100,tocIndex:37},{value:" method.",paraId:99,tocIndex:37},{value:"getSuccessors(cell: Cell, options?: GetPredecessorsOptions): Cell[]\n",paraId:101,tocIndex:38},{value:"Get all successor nodes, i.e., nodes connected from the specified node to leaf nodes. The ",paraId:102,tocIndex:38},{value:"options",paraId:102,tocIndex:38},{value:" are the same as those in the ",paraId:102,tocIndex:38},{value:"getPredecessors(...)",paraId:103,tocIndex:38},{value:" method.",paraId:102,tocIndex:38},{value:"isSuccessor(cell1: Cell, cell2: Cell, options?: GetPredecessorsOptions): boolean\n",paraId:104,tocIndex:39},{value:"Returns whether ",paraId:105,tocIndex:39},{value:"cell2",paraId:105,tocIndex:39},{value:" is a successor of ",paraId:105,tocIndex:39},{value:"cell1",paraId:105,tocIndex:39},{value:". The ",paraId:105,tocIndex:39},{value:"options",paraId:105,tocIndex:39},{value:" are the same as those in the ",paraId:105,tocIndex:39},{value:"getPredecessors(...)",paraId:106,tocIndex:39},{value:" method.",paraId:105,tocIndex:39},{value:"getCommonAncestor(...cells: {Cell | Cell[])[]): Cell | null\n",paraId:107,tocIndex:40},{value:"Get the common ancestor node of the specified nodes.",paraId:108,tocIndex:40},{value:"getSubGraph(cells: Cell[], options: GetSubgraphOptions): Cell[]\n",paraId:109,tocIndex:41},{value:"Returns a subgraph consisting of the specified nodes and edges. It traverses the given ",paraId:110,tocIndex:41},{value:"cells",paraId:110,tocIndex:41},{value:" array, including the source and target nodes when encountering an edge; when encountering a node, it includes the edge if both nodes connected by the edge are in the ",paraId:110,tocIndex:41},{value:"cells",paraId:110,tocIndex:41},{value:" array.",paraId:110,tocIndex:41},{value:"Name",paraId:111,tocIndex:41},{value:"Type",paraId:111,tocIndex:41},{value:"Required",paraId:111,tocIndex:41},{value:"Default",paraId:111,tocIndex:41},{value:"Description",paraId:111,tocIndex:41},{value:"cells",paraId:111,tocIndex:41},{value:"Cell[]",paraId:111,tocIndex:41},{value:"",paraId:111,tocIndex:41},{value:"Array of nodes/edges.",paraId:111,tocIndex:41},{value:"options.deep",paraId:111,tocIndex:41},{value:"boolean",paraId:111,tocIndex:41},{value:"false",paraId:111,tocIndex:41},{value:"Whether to recursively get all child nodes/edges.",paraId:111,tocIndex:41},{value:"cloneCells(cells: Cell[]): { [oldCellId: string]: Cell }\n",paraId:112,tocIndex:42},{value:"Clone cells, returning a key-value pair of old node/edge IDs and cloned nodes/edges.",paraId:113,tocIndex:42},{value:"cloneSubGraph(cells: Cell[], options?: GetSubgraphOptions): { [oldCellId: string]: Cell }\n",paraId:114,tocIndex:43},{value:"Get and clone a subgraph. The ",paraId:115,tocIndex:43},{value:"options",paraId:115,tocIndex:43},{value:" are the same as those in the ",paraId:115,tocIndex:43},{value:"getSubGraph(...)",paraId:116,tocIndex:43},{value:" method.",paraId:115,tocIndex:43},{value:"getNodesFromPoint(x: number, y: number): Node[]\ngetNodesFromPoint(p: Point.PointLike): Node[]\n",paraId:117,tocIndex:44},{value:"Returns nodes at the specified position, i.e., nodes whose rectangular area contains the specified point.",paraId:118,tocIndex:44},{value:"getNodesInArea(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  options?: Model.GetCellsInAreaOptions,\n): Node[]\ngetNodesInArea(\n  rect: Rectangle.RectangleLike,\n  options?: Model.GetCellsInAreaOptions,\n): Node[]\n",paraId:119,tocIndex:45},{value:"Returns nodes in the specified rectangular area. When ",paraId:120,tocIndex:45},{value:"options.strict",paraId:120,tocIndex:45},{value:" is ",paraId:120,tocIndex:45},{value:"true",paraId:120,tocIndex:45},{value:", it requires the node's rectangular area to be completely contained within the specified rectangle; otherwise, intersection is sufficient.",paraId:120,tocIndex:45},{value:"getNodesUnderNode(\n  node: Node,\n  options: {\n    by?: 'bbox' | Rectangle.KeyPoint\n  },\n): Node[]\n",paraId:121,tocIndex:46},{value:"Returns nodes at the position of the specified node. The ",paraId:122,tocIndex:46},{value:"options.by",paraId:122,tocIndex:46},{value:" option specifies the method of retrieval, including:",paraId:122,tocIndex:46},{value:"null",paraId:123,tocIndex:46},{value:" or ",paraId:123,tocIndex:46},{value:"bbox",paraId:123,tocIndex:46},{value:": Returns nodes that intersect with the specified node's rectangular area",paraId:123,tocIndex:46},{value:"Rectangle.KeyPoint",paraId:123,tocIndex:46},{value:": Returns nodes that contain a specific key point of the rectangle, where ",paraId:123,tocIndex:46},{value:"Rectangle.KeyPoint",paraId:123,tocIndex:46},{value:" can be one of:\n",paraId:123,tocIndex:46},{value:'"center"',paraId:124,tocIndex:46},{value:'"origin"',paraId:124,tocIndex:46},{value:'"corner"',paraId:124,tocIndex:46},{value:'"topLeft"',paraId:124,tocIndex:46},{value:'"topCenter"',paraId:124,tocIndex:46},{value:'"topRight"',paraId:124,tocIndex:46},{value:'"bottomLeft"',paraId:124,tocIndex:46},{value:'"bottomCenter"',paraId:124,tocIndex:46},{value:'"bottomRight"',paraId:124,tocIndex:46},{value:'"leftMiddle"',paraId:124,tocIndex:46},{value:'"rightMiddle"',paraId:124,tocIndex:46},{value:"searchCell(cell: Cell, iterator: SearchIterator, options?: SearchOptions): this\n",paraId:125,tocIndex:47},{value:"Traverse starting from the specified node/edge.",paraId:126,tocIndex:47},{value:"Name",paraId:127,tocIndex:47},{value:"Type",paraId:127,tocIndex:47},{value:"Required",paraId:127,tocIndex:47},{value:"Default",paraId:127,tocIndex:47},{value:"Description",paraId:127,tocIndex:47},{value:"cell",paraId:127,tocIndex:47},{value:"Cell",paraId:127,tocIndex:47},{value:"",paraId:127,tocIndex:47},{value:"Node/Edge.",paraId:127,tocIndex:47},{value:"iterator",paraId:127,tocIndex:47},{value:"(cell: Cell, distance: number) => any",paraId:127,tocIndex:47},{value:"",paraId:127,tocIndex:47},{value:"Traversal method.",paraId:127,tocIndex:47},{value:"options.breadthFirst",paraId:127,tocIndex:47},{value:"boolean",paraId:127,tocIndex:47},{value:"false",paraId:127,tocIndex:47},{value:"Whether to use breadth-first search algorithm. By default, uses depth-first search algorithm.",paraId:127,tocIndex:47},{value:"options.incoming",paraId:127,tocIndex:47},{value:"boolean",paraId:127,tocIndex:47},{value:"-",paraId:127,tocIndex:47},{value:"Whether to traverse incoming neighboring nodes. By default, traverses both incoming and outgoing nodes. When ",paraId:127,tocIndex:47},{value:"incoming",paraId:127,tocIndex:47},{value:" is ",paraId:127,tocIndex:47},{value:"true",paraId:127,tocIndex:47},{value:", only traverses incoming nodes.",paraId:127,tocIndex:47},{value:"options.outgoing",paraId:127,tocIndex:47},{value:"boolean",paraId:127,tocIndex:47},{value:"-",paraId:127,tocIndex:47},{value:"Whether to traverse outgoing neighboring nodes. By default, traverses both incoming and outgoing nodes. When ",paraId:127,tocIndex:47},{value:"outgoing",paraId:127,tocIndex:47},{value:" is ",paraId:127,tocIndex:47},{value:"true",paraId:127,tocIndex:47},{value:", only traverses outgoing nodes.",paraId:127,tocIndex:47},{value:"options.deep",paraId:127,tocIndex:47},{value:"boolean",paraId:127,tocIndex:47},{value:"false",paraId:127,tocIndex:47},{value:"Whether to recursively traverse all child nodes/edges. When ",paraId:127,tocIndex:47},{value:"true",paraId:127,tocIndex:47},{value:", it will also traverse neighboring nodes of all descendant nodes/edges.",paraId:127,tocIndex:47},{value:"options.indirect",paraId:127,tocIndex:47},{value:"boolean",paraId:127,tocIndex:47},{value:"false",paraId:127,tocIndex:47},{value:"Whether to traverse indirectly connected neighboring nodes, i.e., neighbors connected through multiple edges (edge-to-edge connections).",paraId:127,tocIndex:47},{value:"getShortestPath(\n  source: Cell | string,\n  target: Cell | string,\n  options?: GetShortestPathOptions,\n): string[]\n",paraId:128,tocIndex:48},{value:"Get the shortest path between nodes, returning the node IDs on the shortest path.",paraId:129,tocIndex:48},{value:"Name",paraId:130,tocIndex:48},{value:"Type",paraId:130,tocIndex:48},{value:"Required",paraId:130,tocIndex:48},{value:"Default",paraId:130,tocIndex:48},{value:"Description",paraId:130,tocIndex:48},{value:"source",paraId:130,tocIndex:48},{value:"Cell | string",paraId:130,tocIndex:48},{value:"",paraId:130,tocIndex:48},{value:"Start node/edge.",paraId:130,tocIndex:48},{value:"target",paraId:130,tocIndex:48},{value:"Cell | string",paraId:130,tocIndex:48},{value:"",paraId:130,tocIndex:48},{value:"End node/edge.",paraId:130,tocIndex:48},{value:"options.directed",paraId:130,tocIndex:48},{value:"boolean",paraId:130,tocIndex:48},{value:"false",paraId:130,tocIndex:48},{value:"Whether to consider directionality. When ",paraId:130,tocIndex:48},{value:"true",paraId:130,tocIndex:48},{value:", the path must follow the direction from start node to end node.",paraId:130,tocIndex:48},{value:"options.weight",paraId:130,tocIndex:48},{value:"(u: string, v: string) => number",paraId:130,tocIndex:48},{value:"(u, v) => 1",paraId:130,tocIndex:48},{value:"Distance weight algorithm. ",paraId:130,tocIndex:48},{value:"u",paraId:130,tocIndex:48},{value:" and ",paraId:130,tocIndex:48},{value:"v",paraId:130,tocIndex:48},{value:" are adjacent nodes, default distance is ",paraId:130,tocIndex:48},{value:"1",paraId:130,tocIndex:48},{value:".",paraId:130,tocIndex:48},{value:"getAllCellsBBox(): Rectangle | null\n",paraId:131,tocIndex:49},{value:"Returns the rectangular area of all nodes and edges on the canvas.",paraId:132,tocIndex:49},{value:"getCellsBBox(cells: Cell[], options?: Cell.GetCellsBBoxOptions): Rectangle | null\n",paraId:133,tocIndex:50},{value:"Returns the rectangular area formed by the specified nodes and edges.",paraId:134,tocIndex:50},{value:"Name",paraId:135,tocIndex:50},{value:"Type",paraId:135,tocIndex:50},{value:"Required",paraId:135,tocIndex:50},{value:"Default",paraId:135,tocIndex:50},{value:"Description",paraId:135,tocIndex:50},{value:"cells",paraId:135,tocIndex:50},{value:"Cell[]",paraId:135,tocIndex:50},{value:"",paraId:135,tocIndex:50},{value:"Array of nodes and edges.",paraId:135,tocIndex:50},{value:"options.deep",paraId:135,tocIndex:50},{value:"boolean",paraId:135,tocIndex:50},{value:"false",paraId:135,tocIndex:50},{value:"Whether to include all descendant nodes and edges.",paraId:135,tocIndex:50},{value:"toJSON(options?: ToJSONOptions): object\n",paraId:136,tocIndex:51},{value:"Export nodes and edges in the graph, returning an object with a ",paraId:137,tocIndex:51},{value:"{ cells: [] }",paraId:137,tocIndex:51},{value:" structure, where the ",paraId:137,tocIndex:51},{value:"cells",paraId:137,tocIndex:51},{value:" array stores nodes and edges in rendering order.",paraId:137,tocIndex:51},{value:"Name",paraId:138,tocIndex:51},{value:"Type",paraId:138,tocIndex:51},{value:"Required",paraId:138,tocIndex:51},{value:"Default",paraId:138,tocIndex:51},{value:"Description",paraId:138,tocIndex:51},{value:"options.deep",paraId:138,tocIndex:51},{value:"diff",paraId:138,tocIndex:51},{value:"false",paraId:138,tocIndex:51},{value:"Whether to export differential data of nodes and edges (parts that differ from the ",paraId:138,tocIndex:51},{value:"default configuration",paraId:139,tocIndex:51},{value:" of nodes and edges).",paraId:138,tocIndex:51},{value:"Convert specified data to nodes and edges.",paraId:140,tocIndex:52},{value:"Supports an array of node/edge metadata, returning created nodes and edges in array order.",paraId:141,tocIndex:52},{value:"parseJSON(cells: (Node.Metadata | Edge.Metadata)[]): (Node | Edge)[]\n",paraId:142,tocIndex:52},{value:"Or provide an object containing ",paraId:143,tocIndex:52},{value:"cells",paraId:143,tocIndex:52},{value:", ",paraId:143,tocIndex:52},{value:"nodes",paraId:143,tocIndex:52},{value:", ",paraId:143,tocIndex:52},{value:"edges",paraId:143,tocIndex:52},{value:", creating and returning nodes and edges in the order of ",paraId:143,tocIndex:52},{value:"[...cells, ...nodes, ...edges]",paraId:143,tocIndex:52},{value:".",paraId:143,tocIndex:52},{value:"parseJSON({\n  cells?: (Node.Metadata | Edge.Metadata)[],\n  nodes?: Node.Metadata[],\n  edges?: Edge.Metadata[],\n}): (Node | Edge)[]\n",paraId:144,tocIndex:52},{value:"Render nodes and edges according to the specified JSON data.",paraId:145,tocIndex:53},{value:"Supports an array of node/edge metadata, rendering nodes and edges in array order.",paraId:146,tocIndex:53},{value:"fromJSON(data: (Node.Metadata | Edge.Metadata)[], options?: FromJSONOptions): this\n",paraId:147,tocIndex:53},{value:"Or provide an object containing ",paraId:148,tocIndex:53},{value:"cells",paraId:148,tocIndex:53},{value:", ",paraId:148,tocIndex:53},{value:"nodes",paraId:148,tocIndex:53},{value:", ",paraId:148,tocIndex:53},{value:"edges",paraId:148,tocIndex:53},{value:", rendering in the order of ",paraId:148,tocIndex:53},{value:"[...cells, ...nodes, ...edges]",paraId:148,tocIndex:53},{value:".",paraId:148,tocIndex:53},{value:"fromJSON(\n  data: {\n    cells?: (Node.Metadata | Edge.Metadata)[],\n    nodes?: Node.Metadata[],\n    edges?: Edge.Metadata[],\n  },\n  options?: FromJSONOptions,\n): this\n",paraId:149,tocIndex:53},{value:"When ",paraId:150,tocIndex:53},{value:"options.silent",paraId:150,tocIndex:53},{value:" is ",paraId:150,tocIndex:53},{value:"true",paraId:150,tocIndex:53},{value:", it does not trigger ",paraId:150,tocIndex:53},{value:"cell:added",paraId:150,tocIndex:53},{value:", ",paraId:150,tocIndex:53},{value:"node:added",paraId:150,tocIndex:53},{value:", and ",paraId:150,tocIndex:53},{value:"edge:added",paraId:150,tocIndex:53},{value:" events or canvas redrawing, when ",paraId:150,tocIndex:53},{value:"options.diff",paraId:150,tocIndex:53},{value:" is ",paraId:150,tocIndex:53},{value:"true",paraId:150,tocIndex:53},{value:", will incremental updates by ",paraId:150,tocIndex:53},{value:"id",paraId:150,tocIndex:53},{value:".",paraId:150,tocIndex:53}]},63804:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(98983);const n=[{value:"Whether the canvas is rendered asynchronously. Asynchronous rendering does not block the UI and significantly improves performance when adding a large number of nodes and edges. However, it's important to note that some synchronous operations may produce unexpected results, such as getting the view of a node or getting the bounding box of nodes/edges, because these synchronous operations may be triggered before the asynchronous rendering is complete.",paraId:0,tocIndex:1},{value:"Whether to render only the elements in the visible area. Supports passing a ",paraId:1,tocIndex:2},{value:"boolean",paraId:1,tocIndex:2},{value:" or an object ",paraId:1,tocIndex:2},{value:"VirtualOptions",paraId:1,tocIndex:2},{value:", default is ",paraId:1,tocIndex:2},{value:"false",paraId:1,tocIndex:2},{value:".",paraId:1,tocIndex:2},{value:"When set to the boolean value ",paraId:2,tocIndex:2},{value:"true",paraId:2,tocIndex:2},{value:", only the current visible area and the buffer margin (default: ",paraId:2,tocIndex:2},{value:"120px",paraId:2,tocIndex:2},{value:") are rendered.",paraId:2,tocIndex:2},{value:"When an object ",paraId:3,tocIndex:2},{value:"VirtualOptions",paraId:3,tocIndex:2},{value:" is provided:",paraId:3,tocIndex:2},{value:"enabled",paraId:4,tocIndex:2},{value:": Whether to enable virtual rendering.",paraId:4,tocIndex:2},{value:"margin",paraId:4,tocIndex:2},{value:": Buffer margin (px). Elements within this margin outside the viewport are pre-rendered to reduce repaint jitter during drag/zoom and improve interaction continuity.",paraId:4,tocIndex:2},{value:"Example:",paraId:5,tocIndex:2},{value:"new Graph({\n  container: el,\n  virtual: { enabled: true, margin: 200 },\n})\n",paraId:6,tocIndex:2},{value:"When dragging, zooming the graph, or scrolling, the remaining elements are dynamically loaded based on the window size. This significantly improves performance in scenarios with a large number of elements.",paraId:7,tocIndex:2},{value:"The number of mouse movements required before triggering a connection, or set to 'onleave' to trigger a connection when the mouse leaves the element. Default is ",paraId:8,tocIndex:3},{value:"0",paraId:8,tocIndex:3},{value:".",paraId:8,tocIndex:3},{value:"The number of mouse movements allowed before triggering the 'mousemove' event, default is ",paraId:9,tocIndex:4},{value:"0",paraId:9,tocIndex:4},{value:".",paraId:9,tocIndex:4},{value:"When the number of mouse movements exceeds the specified number, the mouse click event will not be triggered. Default is ",paraId:10,tocIndex:5},{value:"0",paraId:10,tocIndex:5},{value:".",paraId:10,tocIndex:5},{value:"Whether to disable the default right-click menu of the canvas, default is ",paraId:11,tocIndex:6},{value:"true",paraId:11,tocIndex:6},{value:".",paraId:11,tocIndex:6},{value:"Whether to disable the default mouse behavior when responding to mouse events in blank areas of the canvas, default is ",paraId:12,tocIndex:7},{value:"true",paraId:12,tocIndex:7},{value:".",paraId:12,tocIndex:7},{value:"(\n  this: Graph,\n  args: {\n    node: Node\n    port: Port\n    container: Element\n    selectors?: Markup.Selectors\n    labelContainer: Element\n    labelSelectors?: Markup.Selectors\n    contentContainer: Element\n    contentSelectors?: Markup.Selectors\n  },\n) => void\n",paraId:13,tocIndex:8},{value:"Callback triggered when a port is rendered, with the following parameters:",paraId:14,tocIndex:8},{value:"Name",paraId:15,tocIndex:8},{value:"Type",paraId:15,tocIndex:8},{value:"Required",paraId:15,tocIndex:8},{value:"Description",paraId:15,tocIndex:8},{value:"node",paraId:15,tocIndex:8},{value:"Node",paraId:15,tocIndex:8},{value:"",paraId:15,tocIndex:8},{value:"Node instance.",paraId:15,tocIndex:8},{value:"port",paraId:15,tocIndex:8},{value:"Port",paraId:15,tocIndex:8},{value:"",paraId:15,tocIndex:8},{value:"Port options.",paraId:15,tocIndex:8},{value:"container",paraId:15,tocIndex:8},{value:"Element",paraId:15,tocIndex:8},{value:"",paraId:15,tocIndex:8},{value:"Container element of the port.",paraId:15,tocIndex:8},{value:"selectors",paraId:15,tocIndex:8},{value:"Markup.Selectors",paraId:15,tocIndex:8},{value:"Selector key-value pairs after port Markup rendering.",paraId:15,tocIndex:8},{value:"labelContainer",paraId:15,tocIndex:8},{value:"Element",paraId:15,tocIndex:8},{value:"",paraId:15,tocIndex:8},{value:"Container element of the port label.",paraId:15,tocIndex:8},{value:"labelSelectors",paraId:15,tocIndex:8},{value:"Markup.Selectors",paraId:15,tocIndex:8},{value:"Selector key-value pairs after port label Markup rendering.",paraId:15,tocIndex:8},{value:"contentContainer",paraId:15,tocIndex:8},{value:"Element",paraId:15,tocIndex:8},{value:"",paraId:15,tocIndex:8},{value:"Container element of the port content.",paraId:15,tocIndex:8},{value:"contentSelectors",paraId:15,tocIndex:8},{value:"Markup.Selectors",paraId:15,tocIndex:8},{value:"Selector key-value pairs after port content Markup rendering.",paraId:15,tocIndex:8},{value:"For example, we can render a React-type port:",paraId:16,tocIndex:8},{value:'const graph = new Graph({\n  container: this.container,\n  onPortRendered(args) {\n    const selectors = args.contentSelectors\n    const container = selectors && selectors.foContent\n    if (container) {\n      ReactDOM.render(\n        <Tooltip title="port">\n          <div className="my-port" />\n        </Tooltip>,\n        container,\n      )\n    }\n  },\n})\n',paraId:17,tocIndex:8},{value:"type OnEdgeLabelRenderedArgs = {\n  edge: Edge\n  label: Edge.Label\n  container: Element\n  selectors: Markup.Selectors\n}\n\n(\n  this: Graph,\n  args: OnEdgeLabelRenderedArgs,\n) => void | ((args: OnEdgeLabelRenderedArgs) => void)\n",paraId:18,tocIndex:9},{value:"The callback triggered when an edge label is rendered, And it can return a cleanup function, which will be executed when the label is destroyed, with the following parameters:",paraId:19,tocIndex:9},{value:"Name",paraId:20,tocIndex:9},{value:"Type",paraId:20,tocIndex:9},{value:"Required",paraId:20,tocIndex:9},{value:"Description",paraId:20,tocIndex:9},{value:"edge",paraId:20,tocIndex:9},{value:"Edge",paraId:20,tocIndex:9},{value:"",paraId:20,tocIndex:9},{value:"Edge instance.",paraId:20,tocIndex:9},{value:"label",paraId:20,tocIndex:9},{value:"Edge.Label",paraId:20,tocIndex:9},{value:"",paraId:20,tocIndex:9},{value:"Text label options.",paraId:20,tocIndex:9},{value:"container",paraId:20,tocIndex:9},{value:"Element",paraId:20,tocIndex:9},{value:"",paraId:20,tocIndex:9},{value:"Text label container.",paraId:20,tocIndex:9},{value:"selectors",paraId:20,tocIndex:9},{value:"Markup.Selectors",paraId:20,tocIndex:9},{value:"",paraId:20,tocIndex:9},{value:"Selector key-value pairs after text label Markup rendering.",paraId:20,tocIndex:9},{value:"We can add a ",paraId:21,tocIndex:9},{value:"<foreignObject>",paraId:21,tocIndex:9},{value:" element when defining the Label Markup to support HTML and React rendering capabilities.",paraId:21,tocIndex:9},{value:'const graph = new Graph({\n  container: this.container,\n  onEdgeLabelRendered: (args) => {\n    const { selectors } = args\n    const content = selectors.foContent as HTMLDivElement\n\n    if (content) {\n      content.style.display = \'flex\'\n      content.style.alignItems = \'center\'\n      content.style.justifyContent = \'center\'\n      ReactDOM.render(<Button size="small">Antd Button</Button>, content)\n    }\n\n    //  And it can return a cleanup function, which will be executed when the label is destroyed.\n    return (edgeLabelRenderedArgs: typeof args) => {\n      // Remove event listeners...\n    }\n  },\n})\n\n\n// The main purpose of this code is to test the cleanup function of onEdgeLabelRendered in a specific scenario.\nconst edge = graph.addEdge({\n  source: [170, 160],\n  target: [550, 160],\n  labels: [\n    {\n      attrs: {\n        text: {\n          text: "Custom Label",\n        },\n      },\n    },\n  ],\n});\n\nsetTimeout(() => {\n  edge.prop("labels", ["Updated Label"]);\n}, 2000);\n',paraId:22,tocIndex:9},{value:"(this: Graph, cell: Cell) => CellView | null | undefined\n",paraId:23,tocIndex:10},{value:"Customize the view of an element. It can return a ",paraId:24,tocIndex:10},{value:"CellView",paraId:24,tocIndex:10},{value:" to replace the default view. If it returns ",paraId:24,tocIndex:10},{value:"null",paraId:24,tocIndex:10},{value:", the element won't be rendered. If it returns ",paraId:24,tocIndex:10},{value:"undefined",paraId:24,tocIndex:10},{value:", the element will be rendered in the default way.",paraId:24,tocIndex:10},{value:"findView(ref: Cell | Element): CellView | null\n",paraId:25,tocIndex:12},{value:"Find the corresponding view based on the node/edge or element.",paraId:26,tocIndex:12},{value:"findViewByCell(cellId: string | number): CellView | null\nfindViewByCell(cell: Cell | null): CellView | null\n",paraId:27,tocIndex:13},{value:"Find the corresponding view based on the node/edge ID or instance.",paraId:28,tocIndex:13},{value:"findViewByElem(elem: string | Element | undefined | null): CellView | null\n",paraId:29,tocIndex:14},{value:"Find the corresponding view based on the element selector or element object.",paraId:30,tocIndex:14},{value:"findViewsFromPoint(x: number, y: number): CellView[]\nfindViewsFromPoint(p: Point.PointLike): CellView[]\n",paraId:31,tocIndex:15},{value:"Return views of nodes/edges whose bounding boxes contain the specified point.",paraId:32,tocIndex:15},{value:"findViewsInArea(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  options?: FindViewsInAreaOptions,\n): CellView[]\nfindViewsInArea(\n  rect: Rectangle.RectangleLike,\n  options?: FindViewsInAreaOptions,\n): CellView[]\n",paraId:33,tocIndex:16},{value:"Return views of nodes/edges whose bounding boxes intersect with the specified rectangle. When ",paraId:34,tocIndex:16},{value:"options.strict",paraId:34,tocIndex:16},{value:" is ",paraId:34,tocIndex:16},{value:"true",paraId:34,tocIndex:16},{value:", the bounding box of the node/edge must completely contain the specified rectangle.",paraId:34,tocIndex:16},{value:"findViews(ref: Point.PointLike | Rectangle.RectangleLike): CellView[]\n",paraId:35,tocIndex:17},{value:"Return views of nodes/edges whose bounding boxes contain the specified point or intersect with the specified rectangle.",paraId:36,tocIndex:17}]},83915:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(61851);const n=[{value:"X6 provides a wide range of built-in attributes as well as methods for custom attributes.",paraId:0},{value:"Specifies a selector pointing to an element, which serves as the reference element.",paraId:1,tocIndex:1},{value:"graph.addNode({\n  ...,\n  markup: [\n    {\n      tagName: 'rect',\n      selector: 'body,'\n    },\n    {\n      tagName: 'rect',\n      selector: 'custom,'\n    }\n  ],\n  attrs: {\n    body: {\n      width: 100,\n      height: 50,\n    },\n    // The length and width of the custom element are half of the body\n    custom: {\n      ref: 'body',\n      refWidth: 0.5,\n      refHeight: 0.5,\n    }\n  }\n})\n",paraId:2,tocIndex:1},{value:"Sets the ",paraId:3,tocIndex:2},{value:"x",paraId:3,tocIndex:2},{value:" coordinate of the element. The target ",paraId:3,tocIndex:2},{value:"x",paraId:3,tocIndex:2},{value:" coordinate is relative to the ",paraId:3,tocIndex:2},{value:"x",paraId:3,tocIndex:2},{value:" coordinate of the top-left corner of the element referenced by ",paraId:3,tocIndex:2},{value:"ref",paraId:4,tocIndex:2},{value:".",paraId:3,tocIndex:2},{value:"When its value is between ",paraId:5,tocIndex:2},{value:"[0, 1]",paraId:5,tocIndex:2},{value:" or a percentage (e.g., ",paraId:5,tocIndex:2},{value:"50%",paraId:5,tocIndex:2},{value:"), it represents the relative offset of the target ",paraId:5,tocIndex:2},{value:"x",paraId:5,tocIndex:2},{value:" coordinate as a percentage of the reference element's width from the reference ",paraId:5,tocIndex:2},{value:"x",paraId:5,tocIndex:2},{value:" coordinate. For example, ",paraId:5,tocIndex:2},{value:"refX: 0.5",paraId:5,tocIndex:2},{value:" means the target ",paraId:5,tocIndex:2},{value:"x",paraId:5,tocIndex:2},{value:" coordinate is offset to the right by 50% of the reference width from the reference ",paraId:5,tocIndex:2},{value:"x",paraId:5,tocIndex:2},{value:" coordinate.",paraId:5,tocIndex:2},{value:"When its value is ",paraId:5,tocIndex:2},{value:"<0",paraId:5,tocIndex:2},{value:" or ",paraId:5,tocIndex:2},{value:">1",paraId:5,tocIndex:2},{value:", it represents the absolute offset of the target ",paraId:5,tocIndex:2},{value:"x",paraId:5,tocIndex:2},{value:" coordinate from the reference ",paraId:5,tocIndex:2},{value:"x",paraId:5,tocIndex:2},{value:" coordinate. For example, ",paraId:5,tocIndex:2},{value:"refX: 20",paraId:5,tocIndex:2},{value:" means the target ",paraId:5,tocIndex:2},{value:"x",paraId:5,tocIndex:2},{value:" coordinate is offset 20px to the right from the reference ",paraId:5,tocIndex:2},{value:"x",paraId:5,tocIndex:2},{value:" coordinate.",paraId:5,tocIndex:2},{value:"Same as ",paraId:6,tocIndex:3},{value:"refX",paraId:7,tocIndex:3},{value:", used when both relative and absolute offsets need to be specified simultaneously.",paraId:6,tocIndex:3},{value:"{\n  refX: '50%',\n  refX2: 20,\n}\n",paraId:8,tocIndex:3},{value:"The above code indicates that the target ",paraId:9,tocIndex:3},{value:"x",paraId:9,tocIndex:3},{value:" coordinate is offset 50% of the reference element's width to the right from the reference ",paraId:9,tocIndex:3},{value:"x",paraId:9,tocIndex:3},{value:" coordinate, plus an additional 20px.",paraId:9,tocIndex:3},{value:"Sets the ",paraId:10,tocIndex:4},{value:"y",paraId:10,tocIndex:4},{value:" coordinate of the element. The target ",paraId:10,tocIndex:4},{value:"y",paraId:10,tocIndex:4},{value:" coordinate is relative to the ",paraId:10,tocIndex:4},{value:"y",paraId:10,tocIndex:4},{value:" coordinate of the top-left corner of the element referenced by ",paraId:10,tocIndex:4},{value:"ref",paraId:11,tocIndex:4},{value:" (reference ",paraId:10,tocIndex:4},{value:"y",paraId:10,tocIndex:4},{value:" coordinate).",paraId:10,tocIndex:4},{value:"When its value is between ",paraId:12,tocIndex:4},{value:"[0, 1]",paraId:12,tocIndex:4},{value:" or a percentage (e.g., ",paraId:12,tocIndex:4},{value:"50%",paraId:12,tocIndex:4},{value:"), it represents the relative offset of the target ",paraId:12,tocIndex:4},{value:"y",paraId:12,tocIndex:4},{value:" coordinate as a percentage of the reference element's height from the reference ",paraId:12,tocIndex:4},{value:"y",paraId:12,tocIndex:4},{value:" coordinate. For example, ",paraId:12,tocIndex:4},{value:"refY: 0.5",paraId:12,tocIndex:4},{value:" means the target ",paraId:12,tocIndex:4},{value:"y",paraId:12,tocIndex:4},{value:" coordinate is offset downward by 50% of the reference height from the reference ",paraId:12,tocIndex:4},{value:"y",paraId:12,tocIndex:4},{value:" coordinate.",paraId:12,tocIndex:4},{value:"When its value is ",paraId:12,tocIndex:4},{value:"<0",paraId:12,tocIndex:4},{value:" or ",paraId:12,tocIndex:4},{value:">1",paraId:12,tocIndex:4},{value:", it represents the absolute offset of the target ",paraId:12,tocIndex:4},{value:"y",paraId:12,tocIndex:4},{value:" coordinate from the reference ",paraId:12,tocIndex:4},{value:"y",paraId:12,tocIndex:4},{value:" coordinate. For example, ",paraId:12,tocIndex:4},{value:"refY: 20",paraId:12,tocIndex:4},{value:" means the target ",paraId:12,tocIndex:4},{value:"y",paraId:12,tocIndex:4},{value:" coordinate is offset 20px downward from the reference ",paraId:12,tocIndex:4},{value:"y",paraId:12,tocIndex:4},{value:" coordinate.",paraId:12,tocIndex:4},{value:"Same as ",paraId:13,tocIndex:5},{value:"refY",paraId:14,tocIndex:5},{value:", used when both relative and absolute offsets need to be specified simultaneously.",paraId:13,tocIndex:5},{value:"{\n  refY: '50%',\n  refY2: 20,\n}\n",paraId:15,tocIndex:5},{value:"The above code indicates that the target ",paraId:16,tocIndex:5},{value:"y",paraId:16,tocIndex:5},{value:" coordinate is offset 50% of the reference element's height downward from the reference ",paraId:16,tocIndex:5},{value:"y",paraId:16,tocIndex:5},{value:" coordinate, plus an additional 20px.",paraId:16,tocIndex:5},{value:"Sets the ",paraId:17,tocIndex:6},{value:"x",paraId:17,tocIndex:6},{value:" coordinate of the element. The target ",paraId:17,tocIndex:6},{value:"x",paraId:17,tocIndex:6},{value:" coordinate is relative to the ",paraId:17,tocIndex:6},{value:"x",paraId:17,tocIndex:6},{value:" coordinate of the bottom-right corner of the element referenced by ",paraId:17,tocIndex:6},{value:"ref",paraId:18,tocIndex:6},{value:" (reference ",paraId:17,tocIndex:6},{value:"x",paraId:17,tocIndex:6},{value:" coordinate).",paraId:17,tocIndex:6},{value:"When its value is between ",paraId:19,tocIndex:6},{value:"[0, 1]",paraId:19,tocIndex:6},{value:" or a percentage (e.g., ",paraId:19,tocIndex:6},{value:"50%",paraId:19,tocIndex:6},{value:"), it represents the relative offset of the target ",paraId:19,tocIndex:6},{value:"x",paraId:19,tocIndex:6},{value:" coordinate as a percentage of the reference element's width from the reference ",paraId:19,tocIndex:6},{value:"x",paraId:19,tocIndex:6},{value:" coordinate. For example, ",paraId:19,tocIndex:6},{value:"refDx: 0.5",paraId:19,tocIndex:6},{value:" means the target ",paraId:19,tocIndex:6},{value:"x",paraId:19,tocIndex:6},{value:" coordinate is offset to the right by 50% of the reference width from the reference ",paraId:19,tocIndex:6},{value:"x",paraId:19,tocIndex:6},{value:" coordinate.",paraId:19,tocIndex:6},{value:"When its value is ",paraId:19,tocIndex:6},{value:"<0",paraId:19,tocIndex:6},{value:" or ",paraId:19,tocIndex:6},{value:">1",paraId:19,tocIndex:6},{value:", it represents the absolute offset of the target ",paraId:19,tocIndex:6},{value:"x",paraId:19,tocIndex:6},{value:" coordinate from the reference ",paraId:19,tocIndex:6},{value:"x",paraId:19,tocIndex:6},{value:" coordinate. For example, ",paraId:19,tocIndex:6},{value:"refDx: 20",paraId:19,tocIndex:6},{value:" means the target ",paraId:19,tocIndex:6},{value:"x",paraId:19,tocIndex:6},{value:" coordinate is offset 20px to the right from the reference ",paraId:19,tocIndex:6},{value:"x",paraId:19,tocIndex:6},{value:" coordinate.",paraId:19,tocIndex:6},{value:"Sets the ",paraId:20,tocIndex:7},{value:"y",paraId:20,tocIndex:7},{value:" coordinate of the element. The target ",paraId:20,tocIndex:7},{value:"y",paraId:20,tocIndex:7},{value:" coordinate is relative to the ",paraId:20,tocIndex:7},{value:"y",paraId:20,tocIndex:7},{value:" coordinate of the bottom-right corner of the element referenced by ",paraId:20,tocIndex:7},{value:"ref",paraId:21,tocIndex:7},{value:" (reference ",paraId:20,tocIndex:7},{value:"y",paraId:20,tocIndex:7},{value:" coordinate).",paraId:20,tocIndex:7},{value:"When its value is between ",paraId:22,tocIndex:7},{value:"[0, 1]",paraId:22,tocIndex:7},{value:" or a percentage (e.g., ",paraId:22,tocIndex:7},{value:"50%",paraId:22,tocIndex:7},{value:"), it represents the relative offset of the target ",paraId:22,tocIndex:7},{value:"y",paraId:22,tocIndex:7},{value:" coordinate as a percentage of the reference element's height from the reference ",paraId:22,tocIndex:7},{value:"y",paraId:22,tocIndex:7},{value:" coordinate. For example, ",paraId:22,tocIndex:7},{value:"refDy: 0.5",paraId:22,tocIndex:7},{value:" means the target ",paraId:22,tocIndex:7},{value:"y",paraId:22,tocIndex:7},{value:" coordinate is offset downward by 50% of the reference height from the reference ",paraId:22,tocIndex:7},{value:"y",paraId:22,tocIndex:7},{value:" coordinate.",paraId:22,tocIndex:7},{value:"When its value is ",paraId:22,tocIndex:7},{value:"<0",paraId:22,tocIndex:7},{value:" or ",paraId:22,tocIndex:7},{value:">1",paraId:22,tocIndex:7},{value:", it represents the absolute offset of the target ",paraId:22,tocIndex:7},{value:"y",paraId:22,tocIndex:7},{value:" coordinate from the reference ",paraId:22,tocIndex:7},{value:"y",paraId:22,tocIndex:7},{value:" coordinate. For example, ",paraId:22,tocIndex:7},{value:"refDy: 20",paraId:22,tocIndex:7},{value:" means the target ",paraId:22,tocIndex:7},{value:"y",paraId:22,tocIndex:7},{value:" coordinate is offset 20px downward from the reference ",paraId:22,tocIndex:7},{value:"y",paraId:22,tocIndex:7},{value:" coordinate.",paraId:22,tocIndex:7},{value:"Sets the width of the element. The width is calculated relative to the width of the element referenced by ",paraId:23,tocIndex:8},{value:"ref",paraId:24,tocIndex:8},{value:" (reference width).",paraId:23,tocIndex:8},{value:"When its value is between ",paraId:25,tocIndex:8},{value:"[0, 1]",paraId:25,tocIndex:8},{value:" or a percentage (e.g., ",paraId:25,tocIndex:8},{value:"75%",paraId:25,tocIndex:8},{value:"), it represents the element's width as a percentage of the reference width. For example, ",paraId:25,tocIndex:8},{value:"refWidth: 0.75",paraId:25,tocIndex:8},{value:" means the element's width is 75% of the reference width.",paraId:25,tocIndex:8},{value:"When its value is ",paraId:25,tocIndex:8},{value:"<0",paraId:25,tocIndex:8},{value:" or ",paraId:25,tocIndex:8},{value:">1",paraId:25,tocIndex:8},{value:", it represents how much the element's width is decreased or increased based on the reference width. For example, ",paraId:25,tocIndex:8},{value:"refWidth: 20",paraId:25,tocIndex:8},{value:" means the element is 20px wider than the reference element.",paraId:25,tocIndex:8},{value:"This attribute only applies to elements that support width and height, such as the ",paraId:26},{value:"<rect>",paraId:26},{value:" element.",paraId:26},{value:"Same as ",paraId:27,tocIndex:9},{value:"refWidth",paraId:28,tocIndex:9},{value:", used when both absolute and relative widths need to be specified simultaneously.",paraId:27,tocIndex:9},{value:"{\n  refWidth: '75%',\n  refWidth2: 20,\n}\n",paraId:29,tocIndex:9},{value:"The above code indicates that the target width is 75% of the reference width plus an additional 20px.",paraId:30,tocIndex:9},{value:"Sets the height of the element. The height is calculated relative to the height of the element referenced by ",paraId:31,tocIndex:10},{value:"ref",paraId:32,tocIndex:10},{value:" (reference height).",paraId:31,tocIndex:10},{value:"When its value is between ",paraId:33,tocIndex:10},{value:"[0, 1]",paraId:33,tocIndex:10},{value:" or a percentage (e.g., ",paraId:33,tocIndex:10},{value:"75%",paraId:33,tocIndex:10},{value:"), it represents the element's height as a percentage of the reference height. For example, ",paraId:33,tocIndex:10},{value:"refHeight: 0.75",paraId:33,tocIndex:10},{value:" means the element's height is 75% of the reference height.",paraId:33,tocIndex:10},{value:"When its value is ",paraId:33,tocIndex:10},{value:"<0",paraId:33,tocIndex:10},{value:" or ",paraId:33,tocIndex:10},{value:">1",paraId:33,tocIndex:10},{value:", it represents how much the element's height is decreased or increased based on the reference height. For example, ",paraId:33,tocIndex:10},{value:"refHeight: 20",paraId:33,tocIndex:10},{value:" means the element is 20px taller than the reference element.",paraId:33,tocIndex:10},{value:"This attribute only applies to elements that support width and height, such as the ",paraId:34},{value:"<rect>",paraId:34},{value:" element.",paraId:34},{value:"Same as ",paraId:35,tocIndex:11},{value:"refHeight",paraId:36,tocIndex:11},{value:", used when both absolute and relative heights need to be specified simultaneously.",paraId:35,tocIndex:11},{value:"{\n  refHeight: '75%',\n  refHeight2: 20,\n}\n",paraId:37,tocIndex:11},{value:"The above code indicates that the target height is 75% of the reference height plus an additional 20px.",paraId:38,tocIndex:11},{value:"Sets the center ",paraId:39,tocIndex:12},{value:"x",paraId:39,tocIndex:12},{value:" coordinate of the element, i.e., the ",paraId:39,tocIndex:12},{value:"native ",paraId:39,tocIndex:12},{value:"cx",paraId:39,tocIndex:12},{value:" attribute",paraId:39,tocIndex:12},{value:". The target value is calculated relative to the width of the element referenced by ",paraId:39,tocIndex:12},{value:"ref",paraId:40,tocIndex:12},{value:" (reference width).",paraId:39,tocIndex:12},{value:"When its value is between ",paraId:41,tocIndex:12},{value:"[0, 1]",paraId:41,tocIndex:12},{value:" or a percentage (e.g., ",paraId:41,tocIndex:12},{value:"75%",paraId:41,tocIndex:12},{value:"), it represents the element's ",paraId:41,tocIndex:12},{value:"cx",paraId:41,tocIndex:12},{value:" as a percentage of the reference width. For example, ",paraId:41,tocIndex:12},{value:"refCx: 0.75",paraId:41,tocIndex:12},{value:" means the element's center ",paraId:41,tocIndex:12},{value:"x",paraId:41,tocIndex:12},{value:" coordinate is at 75% of the reference width.",paraId:41,tocIndex:12},{value:"When its value is ",paraId:41,tocIndex:12},{value:"<0",paraId:41,tocIndex:12},{value:" or ",paraId:41,tocIndex:12},{value:">1",paraId:41,tocIndex:12},{value:", it represents how much the element's ",paraId:41,tocIndex:12},{value:"cx",paraId:41,tocIndex:12},{value:" is decreased or increased based on the reference width. For example, ",paraId:41,tocIndex:12},{value:"refCx: 20",paraId:41,tocIndex:12},{value:" means the element's center ",paraId:41,tocIndex:12},{value:"x",paraId:41,tocIndex:12},{value:" coordinate is at the reference width plus 20px.",paraId:41,tocIndex:12},{value:"This attribute only applies to elements that support ",paraId:42},{value:"cx",paraId:42},{value:" and ",paraId:42},{value:"cy",paraId:42},{value:" attributes, such as the ",paraId:42},{value:"<ellipse>",paraId:42},{value:" element.",paraId:42},{value:"Sets the center ",paraId:43,tocIndex:13},{value:"y",paraId:43,tocIndex:13},{value:" coordinate of the element, i.e., the ",paraId:43,tocIndex:13},{value:"native ",paraId:43,tocIndex:13},{value:"cy",paraId:43,tocIndex:13},{value:" attribute",paraId:43,tocIndex:13},{value:". The target value is calculated relative to the height of the element referenced by ",paraId:43,tocIndex:13},{value:"ref",paraId:44,tocIndex:13},{value:" (reference height).",paraId:43,tocIndex:13},{value:"When its value is between ",paraId:45,tocIndex:13},{value:"[0, 1]",paraId:45,tocIndex:13},{value:" or a percentage (e.g., ",paraId:45,tocIndex:13},{value:"75%",paraId:45,tocIndex:13},{value:"), it represents the element's ",paraId:45,tocIndex:13},{value:"cy",paraId:45,tocIndex:13},{value:" as a percentage of the reference height. For example, ",paraId:45,tocIndex:13},{value:"refCy: 0.75",paraId:45,tocIndex:13},{value:" means the element's center ",paraId:45,tocIndex:13},{value:"y",paraId:45,tocIndex:13},{value:" coordinate is at 75% of the reference height.",paraId:45,tocIndex:13},{value:"When its value is ",paraId:45,tocIndex:13},{value:"<0",paraId:45,tocIndex:13},{value:" or ",paraId:45,tocIndex:13},{value:">1",paraId:45,tocIndex:13},{value:", it represents how much the element's ",paraId:45,tocIndex:13},{value:"cy",paraId:45,tocIndex:13},{value:" is decreased or increased based on the reference height. For example, ",paraId:45,tocIndex:13},{value:"refCy: 20",paraId:45,tocIndex:13},{value:" means the element's center ",paraId:45,tocIndex:13},{value:"y",paraId:45,tocIndex:13},{value:" coordinate is at the reference height plus 20px.",paraId:45,tocIndex:13},{value:"This attribute only applies to elements that support ",paraId:46},{value:"cx",paraId:46},{value:" and ",paraId:46},{value:"cy",paraId:46},{value:" attributes, such as the ",paraId:46},{value:"<ellipse>",paraId:46},{value:" element.",paraId:46},{value:"Sets the ",paraId:47,tocIndex:14},{value:"rx",paraId:47,tocIndex:14},{value:" attribute",paraId:47,tocIndex:14},{value:" of the element. The target value is calculated relative to the width of the element referenced by ",paraId:47,tocIndex:14},{value:"ref",paraId:48,tocIndex:14},{value:" (reference width).",paraId:47,tocIndex:14},{value:"When its value is between ",paraId:49,tocIndex:14},{value:"[0, 1]",paraId:49,tocIndex:14},{value:" or a percentage (e.g., ",paraId:49,tocIndex:14},{value:"75%",paraId:49,tocIndex:14},{value:"), it represents the element's ",paraId:49,tocIndex:14},{value:"rx",paraId:49,tocIndex:14},{value:" as a percentage of the reference width. For example, ",paraId:49,tocIndex:14},{value:"refRx: 0.75",paraId:49,tocIndex:14},{value:" means the element's ",paraId:49,tocIndex:14},{value:"rx",paraId:49,tocIndex:14},{value:" is 75% of the reference width.",paraId:49,tocIndex:14},{value:"When its value is ",paraId:49,tocIndex:14},{value:"<0",paraId:49,tocIndex:14},{value:" or ",paraId:49,tocIndex:14},{value:">1",paraId:49,tocIndex:14},{value:", it represents how much the element's ",paraId:49,tocIndex:14},{value:"rx",paraId:49,tocIndex:14},{value:" is decreased or increased based on the reference width. For example, ",paraId:49,tocIndex:14},{value:"refRx: 20",paraId:49,tocIndex:14},{value:" means the element's ",paraId:49,tocIndex:14},{value:"rx",paraId:49,tocIndex:14},{value:" is the reference width plus 20px.",paraId:49,tocIndex:14},{value:"This attribute only applies to elements that support ",paraId:50},{value:"rx",paraId:50},{value:" and ",paraId:50},{value:"ry",paraId:50},{value:" attributes, such as the ",paraId:50},{value:"<rect>",paraId:50},{value:" element.",paraId:50},{value:"Sets the ",paraId:51,tocIndex:15},{value:"ry",paraId:51,tocIndex:15},{value:" attribute",paraId:51,tocIndex:15},{value:" of the element. The target value is calculated relative to the height of the element referenced by ",paraId:51,tocIndex:15},{value:"ref",paraId:52,tocIndex:15},{value:" (reference height).",paraId:51,tocIndex:15},{value:"When its value is between ",paraId:53,tocIndex:15},{value:"[0, 1]",paraId:53,tocIndex:15},{value:" or a percentage (e.g., ",paraId:53,tocIndex:15},{value:"75%",paraId:53,tocIndex:15},{value:"), it represents the element's ",paraId:53,tocIndex:15},{value:"ry",paraId:53,tocIndex:15},{value:" as a percentage of the reference height. For example, ",paraId:53,tocIndex:15},{value:"refRy: 0.75",paraId:53,tocIndex:15},{value:" means the element's ",paraId:53,tocIndex:15},{value:"ry",paraId:53,tocIndex:15},{value:" is 75% of the reference height.",paraId:53,tocIndex:15},{value:"When its value is ",paraId:53,tocIndex:15},{value:"<0",paraId:53,tocIndex:15},{value:" or ",paraId:53,tocIndex:15},{value:">1",paraId:53,tocIndex:15},{value:", it represents how much the element's ",paraId:53,tocIndex:15},{value:"ry",paraId:53,tocIndex:15},{value:" is decreased or increased based on the reference height. For example, ",paraId:53,tocIndex:15},{value:"refRy: 20",paraId:53,tocIndex:15},{value:" means the element's ",paraId:53,tocIndex:15},{value:"ry",paraId:53,tocIndex:15},{value:" is the reference height plus 20px.",paraId:53,tocIndex:15},{value:"This attribute only applies to elements that support ",paraId:54},{value:"rx",paraId:54},{value:" and ",paraId:54},{value:"ry",paraId:54},{value:" attributes, such as the ",paraId:54},{value:"<rect>",paraId:54},{value:" element.",paraId:54},{value:"Sets the ",paraId:55,tocIndex:16},{value:"r",paraId:55,tocIndex:16},{value:" attribute",paraId:55,tocIndex:16},{value:" of the element. The target value is relative to the ",paraId:55,tocIndex:16},{value:"diagonal length",paraId:55,tocIndex:16},{value:" of the element referenced by ",paraId:55,tocIndex:16},{value:"ref",paraId:56,tocIndex:16},{value:" (reference length).",paraId:55,tocIndex:16},{value:"When its value is between ",paraId:57,tocIndex:16},{value:"[0, 1]",paraId:57,tocIndex:16},{value:" or a percentage (e.g., ",paraId:57,tocIndex:16},{value:"75%",paraId:57,tocIndex:16},{value:"), it represents ",paraId:57,tocIndex:16},{value:"r",paraId:57,tocIndex:16},{value:" as a percentage of the reference length. For example, ",paraId:57,tocIndex:16},{value:"refRCircumscribed: 0.75",paraId:57,tocIndex:16},{value:" means ",paraId:57,tocIndex:16},{value:"r",paraId:57,tocIndex:16},{value:" is 75% of the reference length.",paraId:57,tocIndex:16},{value:"When its value is ",paraId:57,tocIndex:16},{value:"<0",paraId:57,tocIndex:16},{value:" or ",paraId:57,tocIndex:16},{value:">1",paraId:57,tocIndex:16},{value:", it represents how much ",paraId:57,tocIndex:16},{value:"r",paraId:57,tocIndex:16},{value:" is decreased or increased based on the reference length. For example, ",paraId:57,tocIndex:16},{value:"refRCircumscribed: 20",paraId:57,tocIndex:16},{value:" means ",paraId:57,tocIndex:16},{value:"r",paraId:57,tocIndex:16},{value:" is the reference length plus 20px.",paraId:57,tocIndex:16},{value:"This attribute only applies to elements that support the ",paraId:58},{value:"r",paraId:58},{value:" attribute, such as the ",paraId:58},{value:"<rect>",paraId:58},{value:" element.",paraId:58},{value:"Alias",paraId:59,tocIndex:17},{value:": ",paraId:59,tocIndex:17},{value:"refR",paraId:59,tocIndex:17},{value:"Sets the ",paraId:60,tocIndex:17},{value:"r",paraId:60,tocIndex:17},{value:" attribute",paraId:60,tocIndex:17},{value:" of the element. The target value is relative to the ",paraId:60,tocIndex:17},{value:"minimum of the width and height",paraId:60,tocIndex:17},{value:" of the element referenced by ",paraId:60,tocIndex:17},{value:"ref",paraId:61,tocIndex:17},{value:" (reference length).",paraId:60,tocIndex:17},{value:"When its value is between ",paraId:62,tocIndex:17},{value:"[0, 1]",paraId:62,tocIndex:17},{value:" or a percentage (e.g., ",paraId:62,tocIndex:17},{value:"75%",paraId:62,tocIndex:17},{value:"), it represents ",paraId:62,tocIndex:17},{value:"r",paraId:62,tocIndex:17},{value:" as a percentage of the reference length. For example, ",paraId:62,tocIndex:17},{value:"refRInscribed: 0.75",paraId:62,tocIndex:17},{value:" means ",paraId:62,tocIndex:17},{value:"r",paraId:62,tocIndex:17},{value:" is 75% of the reference length.",paraId:62,tocIndex:17},{value:"When its value is ",paraId:62,tocIndex:17},{value:"<0",paraId:62,tocIndex:17},{value:" or ",paraId:62,tocIndex:17},{value:">1",paraId:62,tocIndex:17},{value:", it represents how much ",paraId:62,tocIndex:17},{value:"r",paraId:62,tocIndex:17},{value:" is decreased or increased based on the reference length. For example, ",paraId:62,tocIndex:17},{value:"refRInscribed: 20",paraId:62,tocIndex:17},{value:" means ",paraId:62,tocIndex:17},{value:"r",paraId:62,tocIndex:17},{value:" is the reference length plus 20px.",paraId:62,tocIndex:17},{value:"This attribute only applies to elements that support the ",paraId:63},{value:"r",paraId:63},{value:" attribute, such as the ",paraId:63},{value:"<rect>",paraId:63},{value:" element.",paraId:63},{value:"Sets the ",paraId:64,tocIndex:18},{value:"d",paraId:64,tocIndex:18},{value:" attribute",paraId:64,tocIndex:18},{value:" of the ",paraId:64,tocIndex:18},{value:"<path>",paraId:64,tocIndex:18},{value:" element. It scales the original pathData to make the target ",paraId:64,tocIndex:18},{value:"<path>",paraId:64,tocIndex:18},{value:" element the same size as the element referenced by ",paraId:64,tocIndex:18},{value:"ref",paraId:65,tocIndex:18},{value:", and translates the original pathData to align the starting point of the target ",paraId:64,tocIndex:18},{value:"<path>",paraId:64,tocIndex:18},{value:" element with the starting point of the element referenced by ",paraId:64,tocIndex:18},{value:"ref",paraId:66,tocIndex:18},{value:".",paraId:64,tocIndex:18},{value:"At the same time, the offset of the provided pathData will be preserved, which means that if the top-left corner of the provided pathData is not at the coordinate origin ",paraId:67,tocIndex:18},{value:"0, 0",paraId:67,tocIndex:18},{value:", this offset will be preserved when the ",paraId:67,tocIndex:18},{value:"<path>",paraId:67,tocIndex:18},{value:" element is rendered on the canvas.",paraId:67,tocIndex:18},{value:"import { Graph, Node } from '@antv/x6'\n\nconst Path = Node.define({\n  markup: [{ tagName: 'path' }],\n  attrs: {\n    path: {\n      refDKeepOffset: 'M 10 10 30 10 30 30 z', // path offset is 10,10\n      fill: 'red',\n      stroke: 'black',\n    },\n  },\n})\n\nconst container = document.getElementById('container')!\nconst graph = new Graph({\n  container,\n  width: 800,\n  height: 80,\n  grid: true,\n})\n\nconst path = new Path().resize(40, 40).addTo(graph)\nconst view = graph.findView(path)\nconsole.log(view.findOne('path').getAttribute('d'))\n// 'M 10 10 50 10 50 50 z'\n",paraId:68,tocIndex:18},{value:"Alias",paraId:69,tocIndex:19},{value:": ",paraId:69,tocIndex:19},{value:"refD",paraId:69,tocIndex:19},{value:"Sets the ",paraId:70,tocIndex:19},{value:"d",paraId:70,tocIndex:19},{value:" attribute",paraId:70,tocIndex:19},{value:" of the ",paraId:70,tocIndex:19},{value:"<path>",paraId:70,tocIndex:19},{value:" element. It scales the original pathData to make the target ",paraId:70,tocIndex:19},{value:"<path>",paraId:70,tocIndex:19},{value:" element the same size as the element referenced by ",paraId:70,tocIndex:19},{value:"ref",paraId:71,tocIndex:19},{value:", and translates the original pathData to align the starting point of the target ",paraId:70,tocIndex:19},{value:"<path>",paraId:70,tocIndex:19},{value:" element with the starting point of the element referenced by ",paraId:70,tocIndex:19},{value:"ref",paraId:72,tocIndex:19},{value:".",paraId:70,tocIndex:19},{value:"At the same time, the offset of the provided pathData will be removed, which means that if the top-left corner of the provided pathData is not at the coordinate origin ",paraId:73,tocIndex:19},{value:"0, 0",paraId:73,tocIndex:19},{value:", it will also be translated to the origin, and when the ",paraId:73,tocIndex:19},{value:"<path>",paraId:73,tocIndex:19},{value:" element is rendered on the canvas, it will be strictly aligned with the reference element.",paraId:73,tocIndex:19},{value:"import { Graph, Node } from '@antv/x6'\n\nconst Path = Node.define({\n  markup: [{ tagName: 'path' }],\n  attrs: {\n    path: {\n      refDResetOffset: 'M 10 10 30 10 30 30 z', // path offset is 10,10\n      fill: 'red',\n      stroke: 'black',\n    },\n  },\n})\n\nconst container = document.getElementById('container')!\nconst graph = new Graph({\n  container,\n  width: 800,\n  height: 80,\n  grid: true,\n})\n\nconst path = new Path().resize(40, 40).addTo(graph)\nconst view = graph.findView(path)\nconsole.log(view.findOne('path').getAttribute('d'))\n// 'M 0 0 40 0 40 40 z'\n",paraId:74,tocIndex:19},{value:"When the ",paraId:75,tocIndex:20},{value:"resetOffset",paraId:75,tocIndex:20},{value:" property value is ",paraId:75,tocIndex:20},{value:"true",paraId:75,tocIndex:20},{value:", the point matrix will be translated so that the top-left corner of the matrix is at the origin.",paraId:75,tocIndex:20},{value:"path.attr({\n  path: {\n    d: 'M 10 10 20 20',\n    resetOffset: true, // The d attribute value after translation is \"M 0 0 10 10\"\n  },\n})\n",paraId:76,tocIndex:20},{value:"Sets the ",paraId:77,tocIndex:21},{value:"points attribute",paraId:77,tocIndex:21},{value:" of ",paraId:77,tocIndex:21},{value:"<polygon>",paraId:77,tocIndex:21},{value:" or ",paraId:77,tocIndex:21},{value:"<polyline>",paraId:77,tocIndex:21},{value:" elements by scaling the original point matrix to make the target element the same size as the reference element specified by ",paraId:77,tocIndex:21},{value:"ref",paraId:78,tocIndex:21},{value:", and translating the original point matrix to align the starting coordinates of the target element with the starting coordinates of the reference element specified by ",paraId:77,tocIndex:21},{value:"ref",paraId:79,tocIndex:21},{value:".",paraId:77,tocIndex:21},{value:"At the same time, the offset of the point matrix will be preserved, which means that if the top-left corner of the point matrix is not at the coordinate origin ",paraId:80,tocIndex:21},{value:"0, 0",paraId:80,tocIndex:21},{value:", this offset will be preserved when the element is rendered on the canvas.",paraId:80,tocIndex:21},{value:"import { Graph, Node } from '@antv/x6'\n\nconst Polygon = Node.define({\n  markup: [{ tagName: 'polygon' }],\n  attrs: {\n    polygon: {\n      refPointsKeepOffset: '10,10 30,10 30,30', // points offset is 10,10\n      fill: 'red',\n      stroke: 'black',\n    },\n  },\n})\n\nconst container = document.getElementById('container')!\nconst graph = new Graph({\n  container,\n  width: 800,\n  height: 80,\n  grid: true,\n})\n\nconst polygon = new Polygon().resize(40, 40).addTo(graph)\nconst view = graph.findView(polygon)\nconsole.log(view.findOne('polygon').getAttribute('points'))\n// '10,10 50,10 50,50'\n",paraId:81,tocIndex:21},{value:"Alias",paraId:82,tocIndex:22},{value:": ",paraId:82,tocIndex:22},{value:"refPoints",paraId:82,tocIndex:22},{value:"Sets the ",paraId:83,tocIndex:22},{value:"points attribute",paraId:83,tocIndex:22},{value:" of ",paraId:83,tocIndex:22},{value:"<polygon>",paraId:83,tocIndex:22},{value:" or ",paraId:83,tocIndex:22},{value:"<polyline>",paraId:83,tocIndex:22},{value:" elements by scaling the original point matrix to make the target element the same size as the reference element specified by ",paraId:83,tocIndex:22},{value:"ref",paraId:84,tocIndex:22},{value:", and translating the original point matrix to align the starting coordinates of the target element with the starting coordinates of the reference element specified by ",paraId:83,tocIndex:22},{value:"ref",paraId:85,tocIndex:22},{value:".",paraId:83,tocIndex:22},{value:"At the same time, the offset of the point matrix will be removed, which means that if the top-left corner of the point matrix is not at the coordinate origin ",paraId:86,tocIndex:22},{value:"0, 0",paraId:86,tocIndex:22},{value:", it will be translated to the origin simultaneously. When the ",paraId:86,tocIndex:22},{value:"<path>",paraId:86,tocIndex:22},{value:" element is rendered on the canvas, it will be strictly aligned with the reference element.",paraId:86,tocIndex:22},{value:"import { Graph, Node } from '@antv/x6'\n\nconst Polygon = Node.define({\n  markup: [{ tagName: 'polygon' }],\n  attrs: {\n    polygon: {\n      refPointsResetOffset: '10,10 30,10 30,30', // points offset is 10,10\n      fill: 'red',\n      stroke: 'black',\n    },\n  },\n})\n\nconst container = document.getElementById('container')!\nconst graph = new Graph({\n  container,\n  width: 800,\n  height: 80,\n  grid: true,\n})\n\nconst polygon = new Polygon().resize(40, 40).addTo(graph)\nconst view = graph.findView(polygon)\nconsole.log(view.findOne('polygon').getAttribute('points'))\n// '100,0 40,0 40,40'\n",paraId:87,tocIndex:22},{value:"The horizontal alignment of the element with its ",paraId:88,tocIndex:23},{value:"x",paraId:88,tocIndex:23},{value:" coordinate.",paraId:88,tocIndex:23},{value:"'left'",paraId:89,tocIndex:23},{value:" The left side of the target element aligns with ",paraId:89,tocIndex:23},{value:"x",paraId:89,tocIndex:23},{value:".",paraId:89,tocIndex:23},{value:"'middle'",paraId:89,tocIndex:23},{value:" The center of the target element aligns with ",paraId:89,tocIndex:23},{value:"x",paraId:89,tocIndex:23},{value:".",paraId:89,tocIndex:23},{value:"'right'",paraId:89,tocIndex:23},{value:" The right side of the target element aligns with ",paraId:89,tocIndex:23},{value:"x",paraId:89,tocIndex:23},{value:".",paraId:89,tocIndex:23},{value:"The vertical alignment of the element with its ",paraId:90,tocIndex:24},{value:"y",paraId:90,tocIndex:24},{value:" coordinate.",paraId:90,tocIndex:24},{value:"'top'",paraId:91,tocIndex:24},{value:" The top of the target element aligns with ",paraId:91,tocIndex:24},{value:"y",paraId:91,tocIndex:24},{value:".",paraId:91,tocIndex:24},{value:"'middle'",paraId:91,tocIndex:24},{value:" The center of the target element aligns with ",paraId:91,tocIndex:24},{value:"y",paraId:91,tocIndex:24},{value:".",paraId:91,tocIndex:24},{value:"'bottom'",paraId:91,tocIndex:24},{value:" The bottom of the target element aligns with ",paraId:91,tocIndex:24},{value:"y",paraId:91,tocIndex:24},{value:".",paraId:91,tocIndex:24},{value:"When the provided ",paraId:92,tocIndex:25},{value:"fill",paraId:92,tocIndex:25},{value:" attribute value is an object, it indicates using a gradient fill; otherwise, it uses a string color fill.",paraId:92,tocIndex:25},{value:"rect.attr('body/fill', {\n  type: 'linearGradient',\n  stops: [\n    { offset: '0%', color: '#E67E22' },\n    { offset: '20%', color: '#D35400' },\n    { offset: '40%', color: '#E74C3C' },\n    { offset: '60%', color: '#C0392B' },\n    { offset: '80%', color: '#F39C12' },\n  ],\n})\n",paraId:93,tocIndex:25},{value:"When the provided ",paraId:94,tocIndex:26},{value:"filter",paraId:94,tocIndex:26},{value:" attribute value is an object, it indicates using a custom filter; otherwise, it uses the native string form (e.g., ",paraId:94,tocIndex:26},{value:'"url(#myfilter)"',paraId:94,tocIndex:26},{value:").",paraId:94,tocIndex:26},{value:"rect.attr('body/filter', {\n  name: 'dropShadow',\n  args: {\n    dx: 2,\n    dy: 2,\n    blur: 3,\n  },\n})\n",paraId:95,tocIndex:26},{value:"When the provided ",paraId:96,tocIndex:27},{value:"stroke",paraId:96,tocIndex:27},{value:" attribute value is an object, it indicates using a gradient fill; otherwise, it uses a string color fill. The usage is the same as the ",paraId:96,tocIndex:27},{value:"fill",paraId:97,tocIndex:27},{value:" attribute.",paraId:96,tocIndex:27},{value:"Applies inline CSS styles to the specified element using jQuery's ",paraId:98,tocIndex:28},{value:"css()",paraId:98,tocIndex:28},{value:" method.",paraId:98,tocIndex:28},{value:"Sets the innerHTML of the specified element using jQuery's ",paraId:99,tocIndex:29},{value:"html()",paraId:99,tocIndex:29},{value:" method.",paraId:99,tocIndex:29},{value:"Adds a ",paraId:100,tocIndex:30},{value:"<title>",paraId:100,tocIndex:30},{value:" child element to the specified element. The ",paraId:100,tocIndex:30},{value:"<title>",paraId:100,tocIndex:30},{value:" element does not affect the rendering result but only adds a descriptive explanation.",paraId:100,tocIndex:30},{value:"rect.attr('body/title', 'Description of the rectangle')\n",paraId:101,tocIndex:30},{value:"Only applicable to ",paraId:102,tocIndex:31},{value:"<text>",paraId:102,tocIndex:31},{value:" elements, used to set the text content. If the provided text is a single line (does not contain newline characters ",paraId:102,tocIndex:31},{value:"'\\n'",paraId:102,tocIndex:31},{value:"), the text is directly set as the content of the ",paraId:102,tocIndex:31},{value:"<text>",paraId:102,tocIndex:31},{value:" element; otherwise, a ",paraId:102,tocIndex:31},{value:"<tspan>",paraId:102,tocIndex:31},{value:" element is created for each line of text and then added to the ",paraId:102,tocIndex:31},{value:"<text>",paraId:102,tocIndex:31},{value:" element.",paraId:102,tocIndex:31},{value:"Only applicable to ",paraId:103,tocIndex:32},{value:"<text>",paraId:103,tocIndex:32},{value:" elements, used to set the text content. Unlike the ",paraId:103,tocIndex:32},{value:"text",paraId:104,tocIndex:32},{value:" attribute, this attribute automatically adds line breaks to the text, making the provided text completely enclosed within the bounding box of the reference element.",paraId:103,tocIndex:32},{value:"Its attribute value is a simple object, specifying the text content through ",paraId:105,tocIndex:32},{value:"text",paraId:105,tocIndex:32},{value:". Optional ",paraId:105,tocIndex:32},{value:"width",paraId:105,tocIndex:32},{value:" and ",paraId:105,tocIndex:32},{value:"height",paraId:105,tocIndex:32},{value:" options can be provided to adjust the size of the element. When negative, it indicates reducing the corresponding width or height (equivalent to setting a padding margin for the text); when positive, it increases the corresponding width or height; when a percentage, it indicates how much percentage of the reference element's width or height.",paraId:105,tocIndex:32},{value:"When the provided text exceeds the display range, the text will be automatically truncated. If the ",paraId:106,tocIndex:32},{value:"ellipsis",paraId:106,tocIndex:32},{value:" option is set to ",paraId:106,tocIndex:32},{value:"true",paraId:106,tocIndex:32},{value:", an ellipsis ",paraId:106,tocIndex:32},{value:"...",paraId:106,tocIndex:32},{value:" will be added at the end of the truncated text.",paraId:106,tocIndex:32},{value:"By default, English words will be truncated. If you don't want a complete word to be truncated, you can set ",paraId:107,tocIndex:32},{value:"breakWord: false",paraId:107,tocIndex:32},{value:". In this case, to display the complete word, the text may exceed the width range.",paraId:107,tocIndex:32},{value:"textWrap: {\n  text: 'lorem ipsum dolor sit amet consectetur adipiscing elit',\n  width: -10,      // Width reduced by 10px\n  height: '50%',   // Height is half of the reference element's height\n  ellipsis: true,  // Automatically add ellipsis when text exceeds display range\n  breakWord: true, // Whether to truncate words\n}\n",paraId:108,tocIndex:32},{value:"Only applicable to ",paraId:109,tocIndex:33},{value:"<text>",paraId:109,tocIndex:33},{value:" elements, used to render text along a path.",paraId:109,tocIndex:33},{value:"When the provided attribute value is a string, it indicates that the text is rendered along the path represented by the string (pathData).",paraId:110,tocIndex:33},{value:"When the provided attribute value is an object, you can specify the rendering path of the text through the ",paraId:111,tocIndex:33},{value:"d",paraId:111,tocIndex:33},{value:" option, or specify an SVGPathElement element in a node/edge through the ",paraId:111,tocIndex:33},{value:"selector",paraId:111,tocIndex:33},{value:" option, supporting CSS selectors and selectors defined in ",paraId:111,tocIndex:33},{value:"Markup",paraId:112,tocIndex:33},{value:". You can also specify the position of the text on the path through the ",paraId:111,tocIndex:33},{value:"startOffset",paraId:111,tocIndex:33},{value:" option, for example, ",paraId:111,tocIndex:33},{value:"50%",paraId:111,tocIndex:33},{value:" indicates that the text is at 50% along the path, and ",paraId:111,tocIndex:33},{value:"20",paraId:111,tocIndex:33},{value:" indicates that the text is 20px offset from the start of the path.",paraId:111,tocIndex:33},{value:"Only applicable to ",paraId:113,tocIndex:34},{value:"<text>",paraId:113,tocIndex:34},{value:" elements, used to specify the ",paraId:113,tocIndex:34},{value:"line height",paraId:113,tocIndex:34},{value:" of the text.",paraId:113,tocIndex:34},{value:"Only applicable to ",paraId:114,tocIndex:35},{value:"<text>",paraId:114,tocIndex:35},{value:" elements, the vertical alignment of the element with its ",paraId:114,tocIndex:35},{value:"y",paraId:114,tocIndex:35},{value:" coordinate.",paraId:114,tocIndex:35},{value:"'top'",paraId:115,tocIndex:35},{value:" The top of the target element aligns with ",paraId:115,tocIndex:35},{value:"y",paraId:115,tocIndex:35},{value:".",paraId:115,tocIndex:35},{value:"'middle'",paraId:115,tocIndex:35},{value:" The center of the target element aligns with ",paraId:115,tocIndex:35},{value:"y",paraId:115,tocIndex:35},{value:".",paraId:115,tocIndex:35},{value:"'bottom'",paraId:115,tocIndex:35},{value:" The bottom of the target element aligns with ",paraId:115,tocIndex:35},{value:"y",paraId:115,tocIndex:35},{value:".",paraId:115,tocIndex:35},{value:"Only applicable to the ",paraId:116,tocIndex:36},{value:"<path>",paraId:116,tocIndex:36},{value:" element of edges. When this attribute is ",paraId:116,tocIndex:36},{value:"true",paraId:116,tocIndex:36},{value:", it indicates that the edge will be rendered on this element, i.e., setting the ",paraId:116,tocIndex:36},{value:"d",paraId:116,tocIndex:36},{value:" of this element to the pathData of the edge.",paraId:116,tocIndex:36},{value:"edge.attr('pathSelector', {\n  connection: true,\n  stroke: 'red',\n  fill: 'none',\n})\n",paraId:117,tocIndex:36},{value:"It also supports an object with ",paraId:118,tocIndex:36},{value:"stubs",paraId:118,tocIndex:36},{value:" and ",paraId:118,tocIndex:36},{value:"reserve",paraId:118,tocIndex:36},{value:" options.",paraId:118,tocIndex:36},{value:"When ",paraId:119,tocIndex:36},{value:"reverse",paraId:119,tocIndex:36},{value:" is ",paraId:119,tocIndex:36},{value:"false",paraId:119,tocIndex:36},{value:":",paraId:119,tocIndex:36},{value:"When ",paraId:120,tocIndex:36},{value:"stubs",paraId:120,tocIndex:36},{value:" is positive, it indicates the length of the rendered start and end portions. For example, ",paraId:120,tocIndex:36},{value:"connection: { stubs: 20 }",paraId:120,tocIndex:36},{value:" means only the first ",paraId:120,tocIndex:36},{value:"20px",paraId:120,tocIndex:36},{value:" and last ",paraId:120,tocIndex:36},{value:"20px",paraId:120,tocIndex:36},{value:" of the connection are rendered, and the rest is not rendered.",paraId:120,tocIndex:36},{value:"When ",paraId:120,tocIndex:36},{value:"stubs",paraId:120,tocIndex:36},{value:" is negative, it indicates the length of the middle missing (not rendered) portion. For example, ",paraId:120,tocIndex:36},{value:"connection: { stubs: -20 }",paraId:120,tocIndex:36},{value:" means there is a ",paraId:120,tocIndex:36},{value:"20px",paraId:120,tocIndex:36},{value:" gap in the middle of the connection that is not rendered.",paraId:120,tocIndex:36},{value:"When ",paraId:121,tocIndex:36},{value:"reverse",paraId:121,tocIndex:36},{value:" is ",paraId:121,tocIndex:36},{value:"true",paraId:121,tocIndex:36},{value:":",paraId:121,tocIndex:36},{value:"When ",paraId:122,tocIndex:36},{value:"stubs",paraId:122,tocIndex:36},{value:" is positive, it indicates the length of the start and end portions that are not rendered. For example, ",paraId:122,tocIndex:36},{value:"connection: { stubs: 20 }",paraId:122,tocIndex:36},{value:" means the first ",paraId:122,tocIndex:36},{value:"20px",paraId:122,tocIndex:36},{value:" and last ",paraId:122,tocIndex:36},{value:"20px",paraId:122,tocIndex:36},{value:" are not rendered.",paraId:122,tocIndex:36},{value:"When ",paraId:122,tocIndex:36},{value:"stubs",paraId:122,tocIndex:36},{value:" is negative, it indicates the length of the middle portion. For example, ",paraId:122,tocIndex:36},{value:"connection: { stubs: -20 }",paraId:122,tocIndex:36},{value:" means only the middle ",paraId:122,tocIndex:36},{value:"20px",paraId:122,tocIndex:36},{value:" is rendered.",paraId:122,tocIndex:36},{value:"edge.attr('pathSelector', {\n  connection: { stubs: -20, reverse: true },\n})\n",paraId:123,tocIndex:36},{value:"Alias",paraId:124,tocIndex:37},{value:": ",paraId:124,tocIndex:37},{value:"atConnectionLength",paraId:124,tocIndex:37},{value:"Moves the specified element in the edge to the position at the specified offset and automatically rotates the element so that its direction is consistent with the slope of the edge at that position.",paraId:125,tocIndex:37},{value:"When positive, it indicates the offset from the start point of the edge.",paraId:126,tocIndex:37},{value:"When negative, it indicates the offset from the end point of the edge.",paraId:126,tocIndex:37},{value:"edge.attr('rectSelector', {\n  atConnectionLengthKeepGradient: 30,\n  // atConnectionLength: 30,\n  width: 10,\n  height: 10,\n  fill: 'red',\n})\n",paraId:127,tocIndex:37},{value:"Move the specified element in the edge to the position at the specified offset, ignoring the direction of the edge. This means it will not automatically rotate the element like the ",paraId:128,tocIndex:38},{value:"atConnectionLengthKeepGradient",paraId:129,tocIndex:38},{value:" property.",paraId:128,tocIndex:38},{value:"When positive, it represents the offset from the start point of the edge.",paraId:130,tocIndex:38},{value:"When negative, it represents the offset from the end point of the edge.",paraId:130,tocIndex:38},{value:"edge.attr('rectSelector', {\n  atConnectionLengthIgnoreGradient: 30,\n  width: 10,\n  height: 10,\n  fill: 'red',\n})\n",paraId:131,tocIndex:38},{value:"Alias",paraId:132,tocIndex:39},{value:": ",paraId:132,tocIndex:39},{value:"atConnectionRatio",paraId:132,tocIndex:39},{value:"Moves the specified element in the edge to the specified ratio position ",paraId:133,tocIndex:39},{value:"[0, 1]",paraId:133,tocIndex:39},{value:", and automatically rotates the element to keep its direction consistent with the slope of the edge at that position.",paraId:133,tocIndex:39},{value:"edge.attr('rectSelector', {\n  atConnectionRatioKeepGradient: 0.5,\n  // atConnectionRatio: 0.5,\n  width: 10,\n  height: 10,\n  fill: 'red',\n})\n",paraId:134,tocIndex:39},{value:"Moves the specified element in the edge to the specified ratio position ",paraId:135,tocIndex:40},{value:"[0, 1]",paraId:135,tocIndex:40},{value:", ignoring the direction of the edge, i.e., it will not automatically rotate the element like the ",paraId:135,tocIndex:40},{value:"atConnectionRatioKeepGradient",paraId:136,tocIndex:40},{value:" property.",paraId:135,tocIndex:40},{value:"edge.attr('rectSelector', {\n  atConnectionRatioIgnoreGradient: 0.5,\n  width: 10,\n  height: 10,\n  fill: 'red',\n})\n",paraId:137,tocIndex:40},{value:"Applicable to all ",paraId:138,tocIndex:41},{value:"<path>",paraId:138,tocIndex:41},{value:" elements, adds an SVG element (such as a start arrow) at the start point of the path and automatically rotates the element to keep it consistent with the path direction. For more details, please refer to ",paraId:138,tocIndex:41},{value:"this tutorial",paraId:139,tocIndex:41},{value:".",paraId:138,tocIndex:41},{value:"edge.attr('connection/sourceMarker', {\n  tagName: 'circle',\n  fill: '#666',\n  stroke: '#333',\n  r: 5,\n  cx: 5,\n})\n",paraId:140,tocIndex:41},{value:"Applicable to all ",paraId:141,tocIndex:42},{value:"<path>",paraId:141,tocIndex:42},{value:" elements, adds an SVG element (such as an end arrow) at the end point of the path and automatically rotates the element to keep it consistent with the path direction. For more details, please refer to ",paraId:141,tocIndex:42},{value:"this tutorial",paraId:142,tocIndex:42},{value:".",paraId:141,tocIndex:42},{value:"This element is initially rotated by ",paraId:143},{value:"180",paraId:143},{value:" degrees, and then the rotation angle is automatically adjusted to be consistent with the direction of the path. For example, for a horizontal straight line, if we specify a left-pointing arrow for its start point, we can also specify the same arrow for its end point, and this arrow will automatically point to the right side (automatically rotated by ",paraId:143},{value:"180",paraId:143},{value:" degrees).",paraId:143},{value:"Applicable to all ",paraId:144,tocIndex:43},{value:"<path>",paraId:144,tocIndex:43},{value:" elements, used in the same way as ",paraId:144,tocIndex:43},{value:"sourceMarker",paraId:145,tocIndex:43},{value:", adds additional elements at all vertex positions of the ",paraId:144,tocIndex:43},{value:"<path>",paraId:144,tocIndex:43},{value:" element.",paraId:144,tocIndex:43},{value:"When the ",paraId:146,tocIndex:44},{value:"magnet",paraId:146,tocIndex:44},{value:" attribute is ",paraId:146,tocIndex:44},{value:"true",paraId:146,tocIndex:44},{value:", it indicates that the element can be connected, i.e., it can be used as the start or end point of a connection during the connection process, similar to a connection port.",paraId:146,tocIndex:44},{value:"Specifies a port ID for elements marked as ",paraId:147,tocIndex:45},{value:"magnet",paraId:148,tocIndex:45},{value:". When an edge connects to this element, this ID will be saved in the ",paraId:147,tocIndex:45},{value:"source",paraId:147,tocIndex:45},{value:" or ",paraId:147,tocIndex:45},{value:"target",paraId:147,tocIndex:45},{value:" of the edge.",paraId:147,tocIndex:45},{value:"If it's a string, the string will be used as the port ID.",paraId:149,tocIndex:45},{value:"If it's an object, the ",paraId:149,tocIndex:45},{value:"id",paraId:149,tocIndex:45},{value:" property value of the object will be used as the port ID.",paraId:149,tocIndex:45},{value:"Customizes a click event on the specified element, and then you can add a callback for this event on the Graph.",paraId:150,tocIndex:46},{value:"node.attr({\n  // Represents a delete button, clicking it will delete the node\n  image: {\n    event: 'node:delete',\n    xlinkHref: 'trash.png',\n    width: 20,\n    height: 20,\n  },\n})\n\n// Bind event callback, delete the node when triggered\ngraph.on('node:delete', ({ view, e }) => {\n  e.stopPropagation()\n  view.cell.remove()\n})\n",paraId:151,tocIndex:46},{value:"Alias for the ",paraId:152,tocIndex:47},{value:"xlink:href",paraId:152,tocIndex:47},{value:" attribute, for example:",paraId:152,tocIndex:47},{value:"node.attr({\n  image: {\n    xlinkHref: 'xxx.png',\n  },\n})\n",paraId:153,tocIndex:47},{value:"Alias for the ",paraId:154,tocIndex:48},{value:"xlink:show",paraId:154,tocIndex:48},{value:" attribute.",paraId:154,tocIndex:48},{value:"Alias for the ",paraId:155,tocIndex:49},{value:"xlink:type",paraId:155,tocIndex:49},{value:" attribute.",paraId:155,tocIndex:49},{value:"Alias for the ",paraId:156,tocIndex:50},{value:"xlink:title",paraId:156,tocIndex:50},{value:" attribute.",paraId:156,tocIndex:50},{value:"Alias for the ",paraId:157,tocIndex:51},{value:"xlink:arcrole",paraId:157,tocIndex:51},{value:" attribute.",paraId:157,tocIndex:51},{value:"Alias for the ",paraId:158,tocIndex:52},{value:"xml:space",paraId:158,tocIndex:52},{value:" attribute.",paraId:158,tocIndex:52},{value:"Alias for the ",paraId:159,tocIndex:53},{value:"xml:base",paraId:159,tocIndex:53},{value:" attribute.",paraId:159,tocIndex:53},{value:"Alias for the ",paraId:160,tocIndex:54},{value:"xml:lang",paraId:160,tocIndex:54},{value:" attribute.",paraId:160,tocIndex:54},{value:"We provide two methods, ",paraId:161,tocIndex:55},{value:"register",paraId:162,tocIndex:55},{value:" and ",paraId:161,tocIndex:55},{value:"unregister",paraId:163,tocIndex:55},{value:", on the ",paraId:161,tocIndex:55},{value:"registry",paraId:161,tocIndex:55},{value:" object to register and delete special attributes.",paraId:161,tocIndex:55},{value:"register(entities: { [name: string]: Definition }, force?: boolean): void\nregister(name: string, entity: Definition, force?: boolean): Definition\n",paraId:164,tocIndex:56},{value:"Registers custom attributes.",paraId:165,tocIndex:56},{value:"unregister(name: string): Definition | null\n",paraId:166,tocIndex:57},{value:"Deletes registered attributes.",paraId:167,tocIndex:57},{value:"At the same time, we mount the ",paraId:168,tocIndex:57},{value:"register",paraId:169,tocIndex:57},{value:" and ",paraId:168,tocIndex:57},{value:"unregister",paraId:170,tocIndex:57},{value:" methods as two static methods of ",paraId:168,tocIndex:57},{value:"Graph",paraId:168,tocIndex:57},{value:": ",paraId:168,tocIndex:57},{value:"Graph.registerAttr",paraId:168,tocIndex:57},{value:" and ",paraId:168,tocIndex:57},{value:"Graph.unregisterAttr",paraId:168,tocIndex:57},{value:". It is recommended to use these two static methods to register and delete special attributes.",paraId:168,tocIndex:57},{value:"In the internal implementation, we convert special attributes into attributes that the browser can recognize, so theoretically, the value of special attributes can be of any type, and the definition of special attributes also supports multiple forms.",paraId:171,tocIndex:58},{value:"Defines aliases for native attributes. For example, the definition of the special attribute ",paraId:172,tocIndex:59},{value:"xlinkHref",paraId:172,tocIndex:59},{value:" is actually defining a more easily written alias for the ",paraId:172,tocIndex:59},{value:"xlink:href",paraId:172,tocIndex:59},{value:" attribute.",paraId:172,tocIndex:59},{value:"// Definition\nGraph.registerAttr('xlinkHref', 'xlink:href')\n\n// Usage\nnode.attr({\n  image: {\n    xlinkHref: 'xxx.png',\n  },\n})\n",paraId:173,tocIndex:59},{value:"Before continuing to introduce attribute definitions, let's understand the attribute qualification ",paraId:174,tocIndex:59},{value:"qualify",paraId:174,tocIndex:59},{value:" function. Only attribute values that pass the qualification function's judgment will be processed by special attributes. For example, the ",paraId:174,tocIndex:59},{value:"stroke",paraId:175,tocIndex:59},{value:" attribute is only treated as a special attribute (using gradient color to fill the border) when its value is of ",paraId:174,tocIndex:59},{value:"Object",paraId:174,tocIndex:59},{value:" type. Let's look at the definition of the qualification function.",paraId:174,tocIndex:59},{value:"type QualifyFunction = (\n  this: CellView, // View of the node/edge\n  val: ComplexAttrValue, // Current attribute value\n  options: {\n    elem: Element // Element to which the current attribute is applied\n    attrs: ComplexAttrs // Key-value pairs of attributes applied to this element\n    cell: Cell // Node/edge\n    view: CellView // View of the node/edge\n  },\n) => boolean // Returns true if it passes the qualification function's judgment\n",paraId:176,tocIndex:59},{value:"For example, the definition of the ",paraId:177,tocIndex:59},{value:"stroke",paraId:178,tocIndex:59},{value:" attribute is as follows:",paraId:177,tocIndex:59},{value:"export const stroke: Attr.Definition = {\n  qualify(val) {\n    // Only trigger special attribute processing logic when the attribute value is an object.\n    return ObjectExt.isPlainObject(val)\n  },\n  set(stroke, { view }) {\n    return `url(#${view.graph.defineGradient(stroke as any)})`\n  },\n}\n",paraId:179,tocIndex:59},{value:"Sets the attribute definition, suitable for most scenarios.",paraId:180,tocIndex:60},{value:"export interface SetDefinition {\n  qualify?: QualifyFunction // Qualification function\n  set: (\n    this: CellView, // View of the node/edge\n    val: ComplexAttrValue, // Current attribute value\n    options: {\n      refBBox: Rectangle // Bounding box of the reference element, or a rectangle representing the position and size of the node when there is no reference element\n      elem: Element // Element to which the current attribute is applied\n      attrs: ComplexAttrs // Key-value pairs of attributes applied to this element\n      cell: Cell // Node/edge\n      view: CellView // View of the node/edge\n    },\n  ) => SimpleAttrValue | SimpleAttrs | void\n}\n",paraId:181,tocIndex:60},{value:"When the ",paraId:182,tocIndex:60},{value:"set",paraId:182,tocIndex:60},{value:" method returns a ",paraId:182,tocIndex:60},{value:"string",paraId:182,tocIndex:60},{value:" or ",paraId:182,tocIndex:60},{value:"number",paraId:182,tocIndex:60},{value:", it means to use the return value as the value of the special attribute. This approach is usually used to extend the definition of native attributes, such as the ",paraId:182,tocIndex:60},{value:"stroke",paraId:183,tocIndex:60},{value:" and ",paraId:182,tocIndex:60},{value:"fill",paraId:184,tocIndex:60},{value:" attributes that support gradient color filling.",paraId:182,tocIndex:60},{value:"// stroke attribute definition\nexport const stroke: Attr.SetDefinition = {\n  qualify: ObjectExt.isPlainObject,\n  set(stroke, { view }) {\n    // Returns a string, the return value is used as the attribute value of the stroke attribute.\n    return `url(#${view.graph.defineGradient(stroke as any)})`\n  },\n}\n\n// Using the stroke attribute\nnode.attr({\n  rect: {\n    stroke: {...},\n  },\n})\n",paraId:185,tocIndex:60},{value:"When the ",paraId:186,tocIndex:60},{value:"set",paraId:186,tocIndex:60},{value:" method returns a simple object, this object is applied to the corresponding element as attribute key-value pairs, such as the ",paraId:186,tocIndex:60},{value:"sourceMarker",paraId:187,tocIndex:60},{value:" and ",paraId:186,tocIndex:60},{value:"targetMarker",paraId:188,tocIndex:60},{value:" attributes.",paraId:186,tocIndex:60},{value:"export const sourceMarker: Attr.SetDefinition = {\n  qualify: ObjectExt.isPlainObject,\n  set(marker: string | JSONObject, { view, attrs }) {\n    // Returns a simple object, the return value is applied to the corresponding element as attribute key-value pairs.\n    return {\n      'marker-start': createMarker(marker, view, attrs),\n    }\n  },\n}\n",paraId:189,tocIndex:60},{value:"When the ",paraId:190,tocIndex:60},{value:"set",paraId:190,tocIndex:60},{value:" method doesn't have a return value, it indicates that the property assignment is completed within the method itself, such as the ",paraId:190,tocIndex:60},{value:"html",paraId:191,tocIndex:60},{value:" attribute.",paraId:190,tocIndex:60},{value:"export const html: Attr.Definition = {\n  set(html, { view, elem }) {\n    // No return value, property assignment is completed within the method\n    view.$(elem).html(`${html}`)\n  },\n}\n",paraId:192,tocIndex:60},{value:"Offset property definition.",paraId:193,tocIndex:61},{value:"export interface OffsetDefinition {\n  qualify?: QualifyFunction // Qualification function\n  offset: (\n    this: CellView, // View of the node/edge\n    val: ComplexAttrValue, // Current attribute value\n    options: {\n      refBBox: Rectangle // Bounding box of the reference element, if no reference element, use the rectangle represented by the node's position and size\n      elem: Element // Element to which the current attribute is applied\n      attrs: ComplexAttrs // Key-value pairs of attributes applied to the element\n      cell: Cell // Node/edge\n      view: CellView // View of the node/edge\n    },\n  ) => Point.PointLike // Returns absolute offset\n}\n",paraId:194,tocIndex:61},{value:"Returns a ",paraId:195,tocIndex:61},{value:"Point.PointLike",paraId:195,tocIndex:61},{value:" object representing absolute offsets in ",paraId:195,tocIndex:61},{value:"x",paraId:195,tocIndex:61},{value:" and ",paraId:195,tocIndex:61},{value:"y",paraId:195,tocIndex:61},{value:" directions, like the ",paraId:195,tocIndex:61},{value:"xAlign",paraId:196,tocIndex:61},{value:" attribute.",paraId:195,tocIndex:61},{value:"export const xAlign: Attr.OffsetDefinition = {\n  offset(alignment, { refBBox }) {\n    ...\n    // Returns the absolute offset on the x-axis\n    return { x, y: 0 }\n  },\n}\n",paraId:197,tocIndex:61},{value:"Position attribute definition.",paraId:198,tocIndex:62},{value:"export interface PositionDefinition {\n  qualify?: QualifyFunction // Qualification function\n  offset: (\n    this: CellView, // View of the node/edge\n    val: ComplexAttrValue, // Current attribute value\n    options: {\n      refBBox: Rectangle // Bounding box of the reference element, if no reference element, use the rectangle represented by the node's position and size\n      elem: Element // Element to which the current attribute is applied\n      attrs: ComplexAttrs // Key-value pairs of attributes applied to the element\n      cell: Cell // Node/edge\n      view: CellView // View of the node/edge\n    },\n  ) => Point.PointLike // Returns absolute positioning coordinates\n}\n",paraId:199,tocIndex:62},{value:"Returns absolute positioning coordinates relative to the node, like the ",paraId:200,tocIndex:62},{value:"refX",paraId:201,tocIndex:62},{value:" and ",paraId:200,tocIndex:62},{value:"refDx",paraId:202,tocIndex:62},{value:" attributes.",paraId:200,tocIndex:62},{value:"export const refX: Attr.PositionDefinition = {\n  position(val, { refBBox }) {\n    ...\n    // Returns the absolute positioning on the x-axis\n    return { x, y: 0 }\n  },\n}\n",paraId:203,tocIndex:62}]},45183:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(70367);const n=[{value:"The Connection Point and Anchor jointly determine the starting or ending point of an edge.",paraId:0},{value:"Starting point: Draw a reference line from the center of the first path point or target node (if there is no path point) to the anchor point of the source node, and calculate the intersection point of the reference line and the shape according to the specified connection point calculation method. This intersection point is the starting point of the edge.",paraId:1},{value:"Ending point: Draw a reference line from the center of the last path point or source node (if there is no path point) to the anchor point of the target node, and calculate the intersection point of the reference line and the shape according to the specified connection point calculation method. This intersection point is the ending point of the edge.",paraId:1},{value:"X6 provides the following built-in connection point calculation methods.",paraId:2},{value:"boundary",paraId:3},{value:" Default value, intersection with the boundary of the linked shape.",paraId:4},{value:"bbox",paraId:5},{value:" Intersection with the bounding box of the linked element.",paraId:4},{value:"rect",paraId:6},{value:" Intersection with the rotated rectangular region of the linked element.",paraId:4},{value:"anchor",paraId:7},{value:" Use the anchor point as the connection point.",paraId:4},{value:"You can specify the connection point when creating an edge:",paraId:8},{value:"const edge = graph.addEdge({\n  source: {\n    cell: 'source-id',\n    connectionPoint: {\n      name: 'boundary',\n      args: {\n        sticky: true,\n      },\n    },\n  },\n  target: {\n    cell: 'target-id',\n    connectionPoint: 'boundary', // Simplified writing when there are no parameters\n  },\n})\n",paraId:9},{value:"After creation, you can modify the connection point by calling the ",paraId:10},{value:"edge.setSource",paraId:10},{value:" and ",paraId:10},{value:"edge.setTarget",paraId:10},{value:" methods:",paraId:10},{value:"edge.setSource({\n  cell: 'source-id',\n  connectionPoint: {\n    name: 'boundary',\n    args: {\n      sticky: true,\n    },\n  },\n})\n",paraId:11},{value:"When creating a canvas, you can set the global default connection point through the ",paraId:12},{value:"connecting",paraId:12},{value:" option:",paraId:12},{value:"new Graph({\n  connecting: {\n    connectionPoint: {\n      name: 'boundary',\n      args: {\n        sticky: true,\n      },\n    },\n  },\n})\n",paraId:13},{value:"Simplified writing when there are no parameters:",paraId:14},{value:"new Graph({\n  connecting: {\n    connectionPoint: 'boundary',\n  },\n})\n",paraId:15},{value:"Automatically recognize the boundary of the linked shape and calculate the intersection point of the reference line and the anchor point (Anchor). For example, an ",paraId:16,tocIndex:1},{value:"<ellipse>",paraId:16,tocIndex:1},{value:" element will be recognized as an ellipse, and the intersection point of the ellipse and the reference line will be calculated. Elements that cannot be recognized (such as ",paraId:16,tocIndex:1},{value:"text",paraId:16,tocIndex:1},{value:" or ",paraId:16,tocIndex:1},{value:"<path>",paraId:16,tocIndex:1},{value:") will use the bounding box of the shape as the connection point, which is the same as using ",paraId:16,tocIndex:1},{value:"'bbox'",paraId:16,tocIndex:1},{value:".",paraId:16,tocIndex:1},{value:"Supported parameters are as follows:",paraId:17,tocIndex:1},{value:"Parameter Name",paraId:18,tocIndex:1},{value:"Parameter Type",paraId:18,tocIndex:1},{value:"Required",paraId:18,tocIndex:1},{value:"Default Value",paraId:18,tocIndex:1},{value:"Parameter Description",paraId:18,tocIndex:1},{value:"offset",paraId:18,tocIndex:1},{value:"number | Point.PointLike",paraId:18,tocIndex:1},{value:"No",paraId:18,tocIndex:1},{value:"0",paraId:18,tocIndex:1},{value:"Offset of the connection point.",paraId:18,tocIndex:1},{value:"stroked",paraId:18,tocIndex:1},{value:"boolean",paraId:18,tocIndex:1},{value:"No",paraId:18,tocIndex:1},{value:"true",paraId:18,tocIndex:1},{value:"Whether to consider the stroke width of the shape.",paraId:18,tocIndex:1},{value:"insideout",paraId:18,tocIndex:1},{value:"boolean",paraId:18,tocIndex:1},{value:"No",paraId:18,tocIndex:1},{value:"true",paraId:18,tocIndex:1},{value:"When the reference line is inside the shape and there is no intersection point, whether to extend the reference line to calculate the intersection point, default is ",paraId:18,tocIndex:1},{value:"true",paraId:18,tocIndex:1},{value:".",paraId:18,tocIndex:1},{value:"extrapolate",paraId:18,tocIndex:1},{value:"boolean",paraId:18,tocIndex:1},{value:"No",paraId:18,tocIndex:1},{value:"false",paraId:18,tocIndex:1},{value:"When the reference line is outside the shape and there is no intersection point, whether to extend the reference line to calculate the intersection point, default is ",paraId:18,tocIndex:1},{value:"false",paraId:18,tocIndex:1},{value:". This parameter has higher priority than ",paraId:18,tocIndex:1},{value:"sticky",paraId:18,tocIndex:1},{value:".",paraId:18,tocIndex:1},{value:"sticky",paraId:18,tocIndex:1},{value:"boolean",paraId:18,tocIndex:1},{value:"No",paraId:18,tocIndex:1},{value:"false",paraId:18,tocIndex:1},{value:"When the reference line is outside the shape and there is no intersection point, whether to use the point on the boundary closest to the reference line as the connection point, default is ",paraId:18,tocIndex:1},{value:"false",paraId:18,tocIndex:1},{value:".",paraId:18,tocIndex:1},{value:"precision",paraId:18,tocIndex:1},{value:"number",paraId:18,tocIndex:1},{value:"No",paraId:18,tocIndex:1},{value:"2",paraId:18,tocIndex:1},{value:"Precision of intersection point calculation.",paraId:18,tocIndex:1},{value:"selector",paraId:18,tocIndex:1},{value:"string",paraId:18,tocIndex:1},{value:"No",paraId:18,tocIndex:1},{value:"undefined",paraId:18,tocIndex:1},{value:"Selector, used to identify an element, and use the boundary of the element to calculate the intersection point. Default uses the first child element that is not in the ",paraId:18,tocIndex:1},{value:"<g>",paraId:18,tocIndex:1},{value:" element in the node.",paraId:18,tocIndex:1},{value:"Use the anchor point as the connection point, supporting the following parameters:",paraId:19,tocIndex:2},{value:"Parameter Name",paraId:20,tocIndex:2},{value:"Parameter Type",paraId:20,tocIndex:2},{value:"Required",paraId:20,tocIndex:2},{value:"Default Value",paraId:20,tocIndex:2},{value:"Parameter Description",paraId:20,tocIndex:2},{value:"offset",paraId:20,tocIndex:2},{value:"number | Point.PointLike",paraId:20,tocIndex:2},{value:"No",paraId:20,tocIndex:2},{value:"0",paraId:20,tocIndex:2},{value:"Offset of the connection point.",paraId:20,tocIndex:2},{value:"Intersection point of the bounding box of the linked element and the reference line, supporting the following parameters:",paraId:21,tocIndex:3},{value:"Parameter Name",paraId:22,tocIndex:3},{value:"Parameter Type",paraId:22,tocIndex:3},{value:"Required",paraId:22,tocIndex:3},{value:"Default Value",paraId:22,tocIndex:3},{value:"Parameter Description",paraId:22,tocIndex:3},{value:"offset",paraId:22,tocIndex:3},{value:"number | Point.PointLike",paraId:22,tocIndex:3},{value:"No",paraId:22,tocIndex:3},{value:"0",paraId:22,tocIndex:3},{value:"Offset of the connection point.",paraId:22,tocIndex:3},{value:"stroked",paraId:22,tocIndex:3},{value:"boolean",paraId:22,tocIndex:3},{value:"No",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"Whether to consider the stroke width of the shape.",paraId:22,tocIndex:3},{value:"Intersection point of the rotated rectangular region of the linked element and the reference line, supporting the following parameters:",paraId:23,tocIndex:4},{value:"Parameter Name",paraId:24,tocIndex:4},{value:"Parameter Type",paraId:24,tocIndex:4},{value:"Required",paraId:24,tocIndex:4},{value:"Default Value",paraId:24,tocIndex:4},{value:"Parameter Description",paraId:24,tocIndex:4},{value:"offset",paraId:24,tocIndex:4},{value:"number | Point.PointLike",paraId:24,tocIndex:4},{value:"No",paraId:24,tocIndex:4},{value:"0",paraId:24,tocIndex:4},{value:"Offset of the connection point.",paraId:24,tocIndex:4},{value:"stroked",paraId:24,tocIndex:4},{value:"boolean",paraId:24,tocIndex:4},{value:"No",paraId:24,tocIndex:4},{value:"false",paraId:24,tocIndex:4},{value:"Whether to consider the stroke width of the shape.",paraId:24,tocIndex:4},{value:"A connection point definition is a function with the following signature, returning the connection point.",paraId:25,tocIndex:5},{value:"export type Definition<T> = (\n  line: Line,\n  view: NodeView,\n  magnet: SVGElement,\n  args: T,\n) => Point\n",paraId:26,tocIndex:5},{value:"Parameter Name",paraId:27,tocIndex:5},{value:"Parameter Type",paraId:27,tocIndex:5},{value:"Parameter Description",paraId:27,tocIndex:5},{value:"line",paraId:27,tocIndex:5},{value:"Line",paraId:27,tocIndex:5},{value:"Reference line.",paraId:27,tocIndex:5},{value:"nodeView",paraId:27,tocIndex:5},{value:"NodeView",paraId:27,tocIndex:5},{value:"View of the connected node.",paraId:27,tocIndex:5},{value:"magnet",paraId:27,tocIndex:5},{value:"SVGElement",paraId:27,tocIndex:5},{value:"Element on the connected node.",paraId:27,tocIndex:5},{value:"args",paraId:27,tocIndex:5},{value:"T",paraId:27,tocIndex:5},{value:"Parameters.",paraId:27,tocIndex:5},{value:"After completing the connection point definition, we register the connection point:",paraId:28,tocIndex:5},{value:"Graph.registerConnectionPoint('custom-connection-point', ...)\n",paraId:29,tocIndex:5},{value:"After registration, we can use the connection point by name:",paraId:30,tocIndex:5},{value:"new Graph({\n  connecting: {\n    connectionPoint: 'custom-connection-point'\n  },\n})\n",paraId:31,tocIndex:5}]},54830:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(68075);const n=[{value:"The connector processes the start point, route return point, and end point into a ",paraId:0},{value:"<path>",paraId:0},{value:" element's ",paraId:0},{value:"d",paraId:0},{value:" attribute, determining the style of the edge rendering on the canvas. X6 has several built-in connectors.",paraId:0},{value:"Connector",paraId:1},{value:"Description",paraId:1},{value:"normal",paraId:1},{value:"Simple Connector",paraId:2},{value:", connects the start point, route point, and end point with a straight line.",paraId:1},{value:"smooth",paraId:1},{value:"Smooth Connector",paraId:3},{value:", connects the start point, route point, and end point with a cubic Bezier curve.",paraId:1},{value:"rounded",paraId:1},{value:"Rounded Connector",paraId:4},{value:", connects the start point, route point, and end point with a straight line and uses an arc to connect the line segments (fillet).",paraId:1},{value:"jumpover",paraId:1},{value:"Jumpover Connector",paraId:5},{value:", connects the start point, route point, and end point with a straight line and uses a jump symbol to connect the intersecting edges.",paraId:1},{value:"You can set a route for a specific edge:",paraId:6},{value:"const edge = graph.addEdge({\n  source,\n  target,\n  connector: {\n    name: 'rounded',\n    args: {\n      radius: 20,\n    },\n  },\n})\n",paraId:7},{value:"When there is no connector parameter, it can be simplified to:",paraId:8},{value:"const edge = graph.addEdge({\n  source,\n  target,\n  connector: 'rounded',\n})\n",paraId:9},{value:"You can also call ",paraId:10},{value:"edge.setConnector",paraId:10},{value:" to set the connector:",paraId:10},{value:"edge.setConnector('rounded', { radius: 20 })\n",paraId:11},{value:"When creating a canvas, you can set the global default connector (default is ",paraId:12},{value:"'normal'",paraId:12},{value:") through the ",paraId:12},{value:"connecting",paraId:12},{value:" option:",paraId:12},{value:"new Graph({\n  connecting: {\n    connector: {\n      name: 'rounded',\n      args: {\n        radius: 20,\n      },\n    },\n  },\n})\n",paraId:13},{value:"When there is no route parameter, it can be simplified to:",paraId:14},{value:"new Graph({\n  connecting: {\n    connector: 'rounded',\n  },\n})\n",paraId:15},{value:"Let's take a look at how to use built-in connectors and how to customize and register custom connectors.",paraId:16},{value:"The system's default connector, connects the start point, route point, and end point in sequence with a straight line.",paraId:17,tocIndex:1},{value:"Supported parameters are as follows:",paraId:18,tocIndex:1},{value:"Parameter Name",paraId:19,tocIndex:1},{value:"Parameter Type",paraId:19,tocIndex:1},{value:"Required",paraId:19,tocIndex:1},{value:"Default Value",paraId:19,tocIndex:1},{value:"Parameter Description",paraId:19,tocIndex:1},{value:"raw",paraId:19,tocIndex:1},{value:"boolean",paraId:19,tocIndex:1},{value:"No",paraId:19,tocIndex:1},{value:"false",paraId:19,tocIndex:1},{value:"Whether to return a ",paraId:19,tocIndex:1},{value:"Path",paraId:19,tocIndex:1},{value:" object, default value is ",paraId:19,tocIndex:1},{value:"false",paraId:19,tocIndex:1},{value:" returns a serialized string.",paraId:19,tocIndex:1},{value:"A smooth connector, connects the start point, route point, and end point with a cubic Bezier curve.",paraId:20,tocIndex:2},{value:"Supported parameters are as follows:",paraId:21,tocIndex:2},{value:"Parameter Name",paraId:22,tocIndex:2},{value:"Parameter Type",paraId:22,tocIndex:2},{value:"Required",paraId:22,tocIndex:2},{value:"Default Value",paraId:22,tocIndex:2},{value:"Parameter Description",paraId:22,tocIndex:2},{value:"raw",paraId:22,tocIndex:2},{value:"boolean",paraId:22,tocIndex:2},{value:"No",paraId:22,tocIndex:2},{value:"false",paraId:22,tocIndex:2},{value:"Whether to return a ",paraId:22,tocIndex:2},{value:"Path",paraId:22,tocIndex:2},{value:" object, default value is ",paraId:22,tocIndex:2},{value:"false",paraId:22,tocIndex:2},{value:" returns a serialized string.",paraId:22,tocIndex:2},{value:"direction",paraId:22,tocIndex:2},{value:"H",paraId:22,tocIndex:2},{value:" | ",paraId:22,tocIndex:2},{value:"V",paraId:22,tocIndex:2},{value:"No",paraId:22,tocIndex:2},{value:"-",paraId:22,tocIndex:2},{value:"Keep horizontal connection or keep vertical connection, not set will dynamically calculate based on the start and end points.",paraId:22,tocIndex:2},{value:"For example:",paraId:23,tocIndex:2},{value:"graph.addEdge({\n  source: rect1,\n  target: rect2,\n  vertices: [\n    { x: 100, y: 200 },\n    { x: 300, y: 120 },\n  ],\n  connector: 'smooth',\n})\n",paraId:24,tocIndex:2},{value:"A rounded connector, connects the start point, route point, and end point with a straight line and uses an arc to connect the line segments (fillet).",paraId:25,tocIndex:3},{value:"Supported parameters are as follows:",paraId:26,tocIndex:3},{value:"Parameter Name",paraId:27,tocIndex:3},{value:"Parameter Type",paraId:27,tocIndex:3},{value:"Required",paraId:27,tocIndex:3},{value:"Default Value",paraId:27,tocIndex:3},{value:"Parameter Description",paraId:27,tocIndex:3},{value:"radius",paraId:27,tocIndex:3},{value:"number",paraId:27,tocIndex:3},{value:"No",paraId:27,tocIndex:3},{value:"10",paraId:27,tocIndex:3},{value:"Fillet radius.",paraId:27,tocIndex:3},{value:"raw",paraId:27,tocIndex:3},{value:"boolean",paraId:27,tocIndex:3},{value:"No",paraId:27,tocIndex:3},{value:"false",paraId:27,tocIndex:3},{value:"Whether to return a ",paraId:27,tocIndex:3},{value:"Path",paraId:27,tocIndex:3},{value:" object, default value is ",paraId:27,tocIndex:3},{value:"false",paraId:27,tocIndex:3},{value:" returns a serialized string.",paraId:27,tocIndex:3},{value:"For example:",paraId:28,tocIndex:3},{value:"graph.addEdge({\n  source: rect1,\n  target: rect2,\n  vertices: [\n    { x: 100, y: 200 },\n    { x: 300, y: 120 },\n  ],\n  connector: {\n    name: 'rounded',\n    args: {\n      radius: 10,\n    },\n  },\n})\n",paraId:29,tocIndex:3},{value:"A jumpover connector, connects the start point, route point, and end point with a straight line and uses a jump symbol to connect the intersecting edges.",paraId:30,tocIndex:4},{value:"Supported parameters are as follows:",paraId:31,tocIndex:4},{value:"Parameter Name",paraId:32,tocIndex:4},{value:"Parameter Type",paraId:32,tocIndex:4},{value:"Required",paraId:32,tocIndex:4},{value:"Default Value",paraId:32,tocIndex:4},{value:"Parameter Description",paraId:32,tocIndex:4},{value:"type",paraId:32,tocIndex:4},{value:"'arc' | 'gap' | 'cubic'",paraId:32,tocIndex:4},{value:"No",paraId:32,tocIndex:4},{value:"'arc'",paraId:32,tocIndex:4},{value:"Jump type.",paraId:32,tocIndex:4},{value:"size",paraId:32,tocIndex:4},{value:"number",paraId:32,tocIndex:4},{value:"No",paraId:32,tocIndex:4},{value:"5",paraId:32,tocIndex:4},{value:"Jump size.",paraId:32,tocIndex:4},{value:"radius",paraId:32,tocIndex:4},{value:"number",paraId:32,tocIndex:4},{value:"No",paraId:32,tocIndex:4},{value:"0",paraId:32,tocIndex:4},{value:"Fillet radius.",paraId:32,tocIndex:4},{value:"raw",paraId:32,tocIndex:4},{value:"boolean",paraId:32,tocIndex:4},{value:"No",paraId:32,tocIndex:4},{value:"false",paraId:32,tocIndex:4},{value:"Whether to return a ",paraId:32,tocIndex:4},{value:"Path",paraId:32,tocIndex:4},{value:" object, default value is ",paraId:32,tocIndex:4},{value:"false",paraId:32,tocIndex:4},{value:" returns a serialized string.",paraId:32,tocIndex:4},{value:"A connector is a function with the following signature, returning a ",paraId:33,tocIndex:5},{value:"Path",paraId:33,tocIndex:5},{value:" object or a serialized string.",paraId:33,tocIndex:5},{value:"export type Definition<T> = (\n  this: EdgeView, // Edge view\n  sourcePoint: Point.PointLike, // Start point\n  targetPoint: Point.PointLike, // End point\n  routePoints: Point.PointLike[], // Route return points\n  args: T, // Connector parameters\n  edgeView: EdgeView, // Edge view\n) => Path | string\n",paraId:34,tocIndex:5},{value:"Parameter Name",paraId:35,tocIndex:5},{value:"Parameter Type",paraId:35,tocIndex:5},{value:"Parameter Description",paraId:35,tocIndex:5},{value:"this",paraId:35,tocIndex:5},{value:"EdgeView",paraId:35,tocIndex:5},{value:"Edge view.",paraId:35,tocIndex:5},{value:"sourcePoint",paraId:35,tocIndex:5},{value:"Point.PointLike",paraId:35,tocIndex:5},{value:"Start point.",paraId:35,tocIndex:5},{value:"targetPoint",paraId:35,tocIndex:5},{value:"Point.PointLike",paraId:35,tocIndex:5},{value:"End point.",paraId:35,tocIndex:5},{value:"routePoints",paraId:35,tocIndex:5},{value:"Point.PointLike[]",paraId:35,tocIndex:5},{value:"Route return points.",paraId:35,tocIndex:5},{value:"args",paraId:35,tocIndex:5},{value:"T",paraId:35,tocIndex:5},{value:"Connector parameters.",paraId:35,tocIndex:5},{value:"edgeView",paraId:35,tocIndex:5},{value:"EdgeView",paraId:35,tocIndex:5},{value:"Edge view.",paraId:35,tocIndex:5},{value:"I'll define a ",paraId:36,tocIndex:5},{value:"wobble",paraId:36,tocIndex:5},{value:" connector:",paraId:36,tocIndex:5},{value:"export interface WobbleArgs {\n  spread?: number\n  raw?: boolean\n}\n\nfunction wobble(\n  sourcePoint: Point.PointLike,\n  targetPoint: Point.PointLike,\n  vertices: Point.PointLike[],\n  args: WobbleArgs,\n) {\n  const spread = args.spread || 20\n  const points = [...vertices, targetPoint].map((p) => Point.create(p))\n  let prev = Point.create(sourcePoint)\n  const path = new Path(Path.createSegment('M', prev))\n\n  for (let i = 0, n = points.length; i < n; i += 1) {\n    const next = points[i]\n    const distance = prev.distance(next)\n    let d = spread\n\n    while (d < distance) {\n      const current = prev.clone().move(next, -d)\n      current.translate(\n        Math.floor(7 * Math.random()) - 3,\n        Math.floor(7 * Math.random()) - 3,\n      )\n      path.appendSegment(Path.createSegment('L', current))\n      d += spread\n    }\n\n    path.appendSegment(Path.createSegment('L', next))\n    prev = next\n  }\n\n  return args.raw ? path : path.serialize()\n}\n",paraId:37,tocIndex:5},{value:"Then register the connector:",paraId:38,tocIndex:5},{value:"Graph.registerConnector('wobble', wobble)\n",paraId:39,tocIndex:5},{value:"After registration, we can use it by connector name:",paraId:40,tocIndex:5},{value:"edge.setConnector('wobble', { spread: 16 })\n",paraId:41,tocIndex:5}]},11890:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(61039);const n=[{value:"When an edge connects to another edge, you can use EdgeAnchor to specify the anchor point on the connected edge. The anchor point, along with the connection point ",paraId:0},{value:"ConnectionPoint",paraId:1},{value:", determines the starting and ending points of the edge.",paraId:0},{value:"Starting point: Draw a reference line from the first path point or the center of the target node (if there are no path points) to the anchor point of the source node, and then calculate the intersection point of the reference line and the graph according to the intersection calculation method specified by ",paraId:2},{value:"connectionPoint",paraId:3},{value:". This intersection point is the starting point of the edge.",paraId:2},{value:"Ending point: Draw a reference line from the last path point or the center of the source node (if there are no path points) to the anchor point of the target node, and then calculate the intersection point of the reference line and the graph according to the intersection calculation method specified by ",paraId:2},{value:"connectionPoint",paraId:4},{value:". This intersection point is the ending point of the edge.",paraId:2},{value:"X6 provides the following built-in anchor point definitions:",paraId:5},{value:"ratio",paraId:6},{value:" The default value, where the anchor point is located at a specified proportion of the connected edge.",paraId:7},{value:"length",paraId:8},{value:" The anchor point is located at a specified length from the connected edge.",paraId:7},{value:"closest",paraId:9},{value:" Uses the point closest to the reference point as the anchor point.",paraId:7},{value:"orth",paraId:10},{value:" Orthogonal anchor point.",paraId:7},{value:"The anchor point is located at a specified proportion of the connected edge. Supports the following parameters:",paraId:11,tocIndex:1},{value:"Parameter Name",paraId:12,tocIndex:1},{value:"Parameter Type",paraId:12,tocIndex:1},{value:"Required",paraId:12,tocIndex:1},{value:"Default Value",paraId:12,tocIndex:1},{value:"Parameter Description",paraId:12,tocIndex:1},{value:"ratio",paraId:12,tocIndex:1},{value:"number",paraId:12,tocIndex:1},{value:"No",paraId:12,tocIndex:1},{value:"0.5",paraId:12,tocIndex:1},{value:"The proportion of the edge length from the starting point, defaulting to the center of the edge length.",paraId:12,tocIndex:1},{value:"The anchor point is located at a specified length from the connected edge. Supports the following parameters:",paraId:13,tocIndex:2},{value:"Parameter Name",paraId:14,tocIndex:2},{value:"Parameter Type",paraId:14,tocIndex:2},{value:"Required",paraId:14,tocIndex:2},{value:"Default Value",paraId:14,tocIndex:2},{value:"Parameter Description",paraId:14,tocIndex:2},{value:"length",paraId:14,tocIndex:2},{value:"number",paraId:14,tocIndex:2},{value:"No",paraId:14,tocIndex:2},{value:"20",paraId:14,tocIndex:2},{value:"The length from the starting point of the edge, defaulting to 20px from the starting point.",paraId:14,tocIndex:2},{value:"Uses the point closest to the reference point as the anchor point.",paraId:15,tocIndex:3},{value:"Orthogonal anchor point. Supports the following parameters:",paraId:16,tocIndex:4},{value:"Parameter Name",paraId:17,tocIndex:4},{value:"Parameter Type",paraId:17,tocIndex:4},{value:"Required",paraId:17,tocIndex:4},{value:"Default Value",paraId:17,tocIndex:4},{value:"Parameter Description",paraId:17,tocIndex:4},{value:"fallbackAt",paraId:17,tocIndex:4},{value:"number | string",paraId:17,tocIndex:4},{value:"No",paraId:17,tocIndex:4},{value:"undefined",paraId:17,tocIndex:4},{value:"When there is no orthogonal point, use the point specified by ",paraId:17,tocIndex:4},{value:"fallbackAt",paraId:17,tocIndex:4},{value:" as the anchor point.",paraId:17,tocIndex:4},{value:"When ",paraId:17,tocIndex:4},{value:"fallbackAt",paraId:17,tocIndex:4},{value:" is a percentage string, it represents the proportion of the edge length from the starting point.",paraId:17,tocIndex:4},{value:"When ",paraId:17,tocIndex:4},{value:"fallbackAt",paraId:17,tocIndex:4},{value:" is a number, it represents the length from the starting point of the edge.",paraId:17,tocIndex:4},{value:"The edge anchor point definition is a function with the following signature, which returns the anchor point.",paraId:18,tocIndex:5},{value:"export type Definition<T> = (\n  this: EdgeView,\n  view: EdgeView,\n  magnet: SVGElement,\n  ref: Point.PointLike | SVGElement,\n  args: T,\n) => Point\n",paraId:19,tocIndex:5},{value:"Parameter Name",paraId:20,tocIndex:5},{value:"Parameter Type",paraId:20,tocIndex:5},{value:"Parameter Description",paraId:20,tocIndex:5},{value:"this",paraId:20,tocIndex:5},{value:"EdgeView",paraId:20,tocIndex:5},{value:"The view of the edge.",paraId:20,tocIndex:5},{value:"view",paraId:20,tocIndex:5},{value:"EdgeView",paraId:20,tocIndex:5},{value:"The view of the connected edge.",paraId:20,tocIndex:5},{value:"magnet",paraId:20,tocIndex:5},{value:"SVGElement",paraId:20,tocIndex:5},{value:"The element of the connected edge.",paraId:20,tocIndex:5},{value:"ref",paraId:20,tocIndex:5},{value:"Point.PointLike | SVGElement",paraId:20,tocIndex:5},{value:"The reference point/element.",paraId:20,tocIndex:5},{value:"args",paraId:20,tocIndex:5},{value:"T",paraId:20,tocIndex:5},{value:"The arguments.",paraId:20,tocIndex:5},{value:"After completing the anchor point definition, we register the anchor point:",paraId:21,tocIndex:5},{value:"Graph.registerEdgeAnchor('custom-anchor', ...)\n",paraId:22,tocIndex:5},{value:"After registration, we can use the anchor point by name:",paraId:23,tocIndex:5},{value:"new Graph({\n  connecting: {\n    edgeAnchor: {\n      name: 'custom-anchor',\n    },\n  },\n})\n",paraId:24,tocIndex:5}]},88866:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(76953);const n=[{value:"Since edges are typically narrow lines or curves, interacting with them can be inconvenient. To address this issue, we render a transparent ",paraId:0},{value:"<path>",paraId:0},{value:" shape that matches the edge's shape but is wider, allowing users to interact with the edge more easily. Additionally, we can add small tools to edges to enhance their interactivity, such as vertex tools that allow path points to be moved, and segment tools that enable the movement of segments within the edge.",paraId:0},{value:"Scenario 1: Adding specified tools.",paraId:1},{value:"// Add tools when creating an edge\ngraph.addEdge({\n  source,\n  target,\n  tools: [\n    { name: 'vertices' },\n    {\n      name: 'button-remove',\n      args: { distance: 20 },\n    },\n  ],\n})\n\n// Add tools after creating an edge\nedge.addTools([\n  { name: 'vertices' },\n  {\n    name: 'button-remove',\n    args: { distance: 20 },\n  },\n])\n",paraId:2},{value:"Scenario 2: Dynamically adding/removing tools with the mouse.",paraId:3},{value:"graph.on('edge:mouseenter', ({ cell }) => {\n  cell.addTools([\n    { name: 'vertices' },\n    {\n      name: 'button-remove',\n      args: { distance: 20 },\n    },\n  ])\n})\n\ngraph.on('edge:mouseleave', ({ cell }) => {\n  if (cell.hasTool('button-remove')) {\n    cell.removeTool('button-remove')\n  }\n})\n",paraId:4},{value:"In X6, the following tools for edges are provided by default:",paraId:5},{value:"vertices",paraId:6},{value:" Vertex tool, renders a small dot at the position of the path point. Dragging the dot modifies the position of the path point, double-clicking the dot deletes the path point, and clicking on the edge adds a path point.",paraId:7},{value:"segments",paraId:8},{value:" Segment tool. Renders a tool bar at the center of each segment of the edge, allowing the tool bar to be dragged to adjust the positions of the path points at both ends of the segment.",paraId:7},{value:"boundary",paraId:9},{value:" Renders a rectangle surrounding the edge based on its bounding box. Note that this tool only renders a rectangle without any interactivity.",paraId:7},{value:"button",paraId:10},{value:" Renders a button at a specified position, supporting custom click interactions for the button.",paraId:7},{value:"button-remove",paraId:11},{value:" Renders a delete button at a specified position, which deletes the corresponding edge when clicked.",paraId:7},{value:"source-arrowhead and target-arrowhead",paraId:12},{value:" Renders a shape (default is an arrow) at the start or end of the edge, allowing the shape to be dragged to modify the start or end of the edge.",paraId:7},{value:"edge-editor",paraId:13},{value:" Provides text editing functionality on the edge.",paraId:7},{value:"The path point tool renders a small dot at the position of the path point. You can drag the dot to modify the path point's position, double-click the dot to delete the path point, and click on the edge to add a new path point. The configuration is as follows:",paraId:14,tocIndex:1},{value:"Parameter Name",paraId:15,tocIndex:1},{value:"Type",paraId:15,tocIndex:1},{value:"Default Value",paraId:15,tocIndex:1},{value:"Description",paraId:15,tocIndex:1},{value:"attrs",paraId:15,tocIndex:1},{value:"KeyValue",paraId:15,tocIndex:1},{value:"object",paraId:15,tocIndex:1},{value:"Attributes of the small dot.",paraId:15,tocIndex:1},{value:"snapRadius",paraId:15,tocIndex:1},{value:"number",paraId:15,tocIndex:1},{value:"20",paraId:15,tocIndex:1},{value:"The snap radius during the movement of the path point. When the path point is within the radius of a neighboring path point, it will snap to that point.",paraId:15,tocIndex:1},{value:"addable",paraId:15,tocIndex:1},{value:"boolean",paraId:15,tocIndex:1},{value:"true",paraId:15,tocIndex:1},{value:"Whether new path points can be added by clicking the mouse on the edge.",paraId:15,tocIndex:1},{value:"removable",paraId:15,tocIndex:1},{value:"boolean",paraId:15,tocIndex:1},{value:"true",paraId:15,tocIndex:1},{value:"Whether path points can be removed by double-clicking.",paraId:15,tocIndex:1},{value:"removeRedundancies",paraId:15,tocIndex:1},{value:"boolean",paraId:15,tocIndex:1},{value:"true",paraId:15,tocIndex:1},{value:"Whether to automatically remove redundant path points.",paraId:15,tocIndex:1},{value:"stopPropagation",paraId:15,tocIndex:1},{value:"boolean",paraId:15,tocIndex:1},{value:"true",paraId:15,tocIndex:1},{value:"Whether to prevent mouse events on the tool from bubbling up to the edge view. If prevented, mouse interactions with the tool will not trigger the edge's ",paraId:15,tocIndex:1},{value:"mousedown",paraId:15,tocIndex:1},{value:", ",paraId:15,tocIndex:1},{value:"mousemove",paraId:15,tocIndex:1},{value:", and ",paraId:15,tocIndex:1},{value:"mouseup",paraId:15,tocIndex:1},{value:" events.",paraId:15,tocIndex:1},{value:"modifiers",paraId:15,tocIndex:1},{value:"string | ModifierKey[]",paraId:15,tocIndex:1},{value:"-",paraId:15,tocIndex:1},{value:"Keys that must be pressed to add path points, which can resolve the overlap of interactions for adding path points and clicking on edges.",paraId:15,tocIndex:1},{value:"The default value (default style) for ",paraId:16,tocIndex:1},{value:"attrs",paraId:16,tocIndex:1},{value:" is:",paraId:16,tocIndex:1},{value:"{\n  r: 6,\n  fill: '#333',\n  stroke: '#fff',\n  cursor: 'move',\n  'stroke-width': 2,\n}\n",paraId:17,tocIndex:1},{value:"The tool is used as follows:",paraId:18,tocIndex:1},{value:"// Add the small tool when creating an edge\nconst edge1 = graph.addEdge({\n  ...,\n  tools: [\n    {\n      name: 'vertices',\n      args: {\n        attrs: { fill: '#666' },\n      },\n    },\n  ]\n})\n",paraId:19,tocIndex:1},{value:"The line segment tool renders a tool bar at the center of each line segment of the edge, allowing you to drag the tool bar to adjust the positions of the path points at both ends of the segment. The configuration is as follows:",paraId:20,tocIndex:2},{value:"Parameter Name",paraId:21,tocIndex:2},{value:"Type",paraId:21,tocIndex:2},{value:"Default Value",paraId:21,tocIndex:2},{value:"Description",paraId:21,tocIndex:2},{value:"attrs",paraId:21,tocIndex:2},{value:"object",paraId:21,tocIndex:2},{value:"object",paraId:21,tocIndex:2},{value:"Attributes of the element.",paraId:21,tocIndex:2},{value:"precision",paraId:21,tocIndex:2},{value:"number",paraId:21,tocIndex:2},{value:"0.5",paraId:21,tocIndex:2},{value:"The tool is rendered only when the coordinate difference of the X or Y axis of the two endpoints of the segment is less than ",paraId:21,tocIndex:2},{value:"precision",paraId:21,tocIndex:2},{value:". The default ",paraId:21,tocIndex:2},{value:"0.5",paraId:21,tocIndex:2},{value:" means the tool is rendered only for vertical and horizontal segments.",paraId:21,tocIndex:2},{value:"threshold",paraId:21,tocIndex:2},{value:"number",paraId:21,tocIndex:2},{value:"40",paraId:21,tocIndex:2},{value:"The tool is rendered only when the segment length exceeds ",paraId:21,tocIndex:2},{value:"threshold",paraId:21,tocIndex:2},{value:".",paraId:21,tocIndex:2},{value:"snapRadius",paraId:21,tocIndex:2},{value:"number",paraId:21,tocIndex:2},{value:"10",paraId:21,tocIndex:2},{value:"The snap radius during the adjustment of the segment.",paraId:21,tocIndex:2},{value:"removeRedundancies",paraId:21,tocIndex:2},{value:"boolean",paraId:21,tocIndex:2},{value:"true",paraId:21,tocIndex:2},{value:"Whether to automatically remove redundant path points.",paraId:21,tocIndex:2},{value:"stopPropagation",paraId:21,tocIndex:2},{value:"boolean",paraId:21,tocIndex:2},{value:"true",paraId:21,tocIndex:2},{value:"Whether to prevent mouse events on the tool from bubbling up to the edge view. If prevented, mouse interactions with the tool will not trigger the edge's ",paraId:21,tocIndex:2},{value:"mousedown",paraId:21,tocIndex:2},{value:", ",paraId:21,tocIndex:2},{value:"mousemove",paraId:21,tocIndex:2},{value:", and ",paraId:21,tocIndex:2},{value:"mouseup",paraId:21,tocIndex:2},{value:" events.",paraId:21,tocIndex:2},{value:"The default value (default style) for ",paraId:22,tocIndex:2},{value:"attrs",paraId:22,tocIndex:2},{value:" is:",paraId:22,tocIndex:2},{value:"{\n  width: 20,\n  height: 8,\n  x: -10,\n  y: -4,\n  rx: 4,\n  ry: 4,\n  fill: '#333',\n  stroke: '#fff',\n  'stroke-width': 2,\n}\n",paraId:23,tocIndex:2},{value:"The tool is used as follows:",paraId:24,tocIndex:2},{value:"graph.addEdge({\n  ...,\n  tools: [{\n    name: 'segments',\n    args: {\n      snapRadius: 20,\n      attrs: {\n        fill: '#444',\n      },\n    },\n  }]\n})\n",paraId:25,tocIndex:2},{value:"Renders a rectangle surrounding the edge based on its bounding box. Note that this tool only renders a rectangle and does not provide any interaction. The configuration is as follows:",paraId:26,tocIndex:3},{value:"Parameter Name",paraId:27,tocIndex:3},{value:"Type",paraId:27,tocIndex:3},{value:"Default Value",paraId:27,tocIndex:3},{value:"Description",paraId:27,tocIndex:3},{value:"tagName",paraId:27,tocIndex:3},{value:"string",paraId:27,tocIndex:3},{value:"rect",paraId:27,tocIndex:3},{value:"The type of shape to render.",paraId:27,tocIndex:3},{value:"padding",paraId:27,tocIndex:3},{value:"number",paraId:27,tocIndex:3},{value:"10",paraId:27,tocIndex:3},{value:"Margin.",paraId:27,tocIndex:3},{value:"attrs",paraId:27,tocIndex:3},{value:"KeyValue",paraId:27,tocIndex:3},{value:"object",paraId:27,tocIndex:3},{value:"Shape attributes.",paraId:27,tocIndex:3},{value:"useCellGeometry",paraId:27,tocIndex:3},{value:"boolean",paraId:27,tocIndex:3},{value:"true",paraId:27,tocIndex:3},{value:"Whether to use geometric calculations to compute the element's bounding box. Enabling this will improve performance, but if there are accuracy issues, set it to ",paraId:27,tocIndex:3},{value:"false",paraId:27,tocIndex:3},{value:".",paraId:27,tocIndex:3},{value:"The default value (default style) for ",paraId:28,tocIndex:3},{value:"attrs",paraId:28,tocIndex:3},{value:" is:",paraId:28,tocIndex:3},{value:"{\n  fill: 'none',\n  stroke: '#333',\n  'stroke-width': 0.5,\n  'stroke-dasharray': '5, 5',\n  'pointer-events': 'none',\n}\n",paraId:29,tocIndex:3},{value:"The tool is used as follows:",paraId:30,tocIndex:3},{value:"graph.addEdge({\n  ...,\n  tools: [\n    {\n      name: 'boundary',\n      args: {\n        padding: 5,\n        attrs: {\n          fill: '#7c68fc',\n          stroke: '#333',\n          'stroke-width': 0.5,\n          'fill-opacity': 0.2,\n        },\n      },\n    },\n  ]\n})\n",paraId:31,tocIndex:3},{value:"Renders a button at a specified position, supporting custom click interactions. The configuration is as follows:",paraId:32,tocIndex:4},{value:"Parameter Name",paraId:33,tocIndex:4},{value:"Type",paraId:33,tocIndex:4},{value:"Default Value",paraId:33,tocIndex:4},{value:"Description",paraId:33,tocIndex:4},{value:"distance",paraId:33,tocIndex:4},{value:"number | string",paraId:33,tocIndex:4},{value:"undefined",paraId:33,tocIndex:4},{value:"Distance or ratio from the start point.",paraId:33,tocIndex:4},{value:"offset",paraId:33,tocIndex:4},{value:"number | Point.PointLike",paraId:33,tocIndex:4},{value:"0",paraId:33,tocIndex:4},{value:"Offset based on ",paraId:33,tocIndex:4},{value:"distance",paraId:33,tocIndex:4},{value:".",paraId:33,tocIndex:4},{value:"rotate",paraId:33,tocIndex:4},{value:"boolean",paraId:33,tocIndex:4},{value:"undefined",paraId:33,tocIndex:4},{value:"Whether to rotate with the edge.",paraId:33,tocIndex:4},{value:"markup",paraId:33,tocIndex:4},{value:"Markup.JSONMarkup",paraId:33,tocIndex:4},{value:"undefined",paraId:33,tocIndex:4},{value:"Markup definition for rendering the button.",paraId:33,tocIndex:4},{value:"onClick",paraId:33,tocIndex:4},{value:"(args: {e: Dom.MouseDownEvent, cell: Cell, view: CellView }) => void",paraId:33,tocIndex:4},{value:"undefined",paraId:33,tocIndex:4},{value:"Callback function for button click.",paraId:33,tocIndex:4},{value:"The usage is as follows:",paraId:34,tocIndex:4},{value:"graph.addEdge({\n  ...,\n  tools: [\n    {\n      name: 'button',\n      args: {\n        distance: -40,\n        onClick({ view }: any) {\n          //\n        },\n      },\n    },\n  ],\n})\n",paraId:35,tocIndex:4},{value:"Renders a delete button at a specified position, which deletes the corresponding edge when clicked. It is a special case of the ",paraId:36,tocIndex:5},{value:"button",paraId:36,tocIndex:5},{value:" tool above, so it supports all configurations of ",paraId:36,tocIndex:5},{value:"button",paraId:36,tocIndex:5},{value:". The usage is as follows:",paraId:36,tocIndex:5},{value:"graph.addEdge({\n  ...,\n  tools: [\n    {\n      name: 'button-remove',\n      args: { distance: -40 },\n    },\n  ]\n})\n",paraId:37,tocIndex:5},{value:"Renders a shape (default is an arrow) at the start or end of the edge, allowing you to drag the shape to modify the start or end of the edge. The configuration is as follows:",paraId:38,tocIndex:6},{value:"Parameter Name",paraId:39,tocIndex:6},{value:"Type",paraId:39,tocIndex:6},{value:"Default Value",paraId:39,tocIndex:6},{value:"Description",paraId:39,tocIndex:6},{value:"tagName",paraId:39,tocIndex:6},{value:"string",paraId:39,tocIndex:6},{value:"path",paraId:39,tocIndex:6},{value:"The type of shape to render.",paraId:39,tocIndex:6},{value:"attrs",paraId:39,tocIndex:6},{value:"Attr.SimpleAttrs",paraId:39,tocIndex:6},{value:"object",paraId:39,tocIndex:6},{value:"Attributes of the shape.",paraId:39,tocIndex:6},{value:"The default value for ",paraId:40,tocIndex:6},{value:"source-arrowhead",paraId:40,tocIndex:6},{value:" attributes is:",paraId:40,tocIndex:6},{value:"{\n  d: 'M 10 -8 -10 0 10 8 Z',\n  fill: '#333',\n  stroke: '#fff',\n  'stroke-width': 2,\n  cursor: 'move',\n}\n",paraId:41,tocIndex:6},{value:"The default value for ",paraId:42,tocIndex:6},{value:"target-arrowhead",paraId:42,tocIndex:6},{value:" attributes is:",paraId:42,tocIndex:6},{value:"{\n  d: 'M -10 -8 10 0 -10 8 Z',\n  fill: '#333',\n  stroke: '#fff',\n  'stroke-width': 2,\n  cursor: 'move',\n}\n",paraId:43,tocIndex:6},{value:"The tool is used as follows:",paraId:44,tocIndex:6},{value:"graph.on('edge:mouseenter', ({ cell }) => {\n  cell.addTools([\n    'source-arrowhead',\n    {\n      name: 'target-arrowhead',\n      args: {\n        attrs: {\n          fill: 'red',\n        },\n      },\n    },\n  ])\n})\n\ngraph.on('edge:mouseleave', ({ cell }) => {\n  cell.removeTools()\n})\n",paraId:45,tocIndex:6},{value:"Provides text editing functionality on the edge. The configuration is as follows:",paraId:46,tocIndex:7},{value:"Parameter Name",paraId:47,tocIndex:7},{value:"Type",paraId:47,tocIndex:7},{value:"Default Value",paraId:47,tocIndex:7},{value:"Description",paraId:47,tocIndex:7},{value:"labelAddable",paraId:47,tocIndex:7},{value:"boolean",paraId:47,tocIndex:7},{value:"true",paraId:47,tocIndex:7},{value:"Whether to create a new label by clicking on a non-text position.",paraId:47,tocIndex:7},{value:"attrs/fontSize",paraId:47,tocIndex:7},{value:"string",paraId:47,tocIndex:7},{value:"14",paraId:47,tocIndex:7},{value:"Font size for editing text.",paraId:47,tocIndex:7},{value:"attrs/color",paraId:47,tocIndex:7},{value:"string",paraId:47,tocIndex:7},{value:"#000",paraId:47,tocIndex:7},{value:"Font color for editing text.",paraId:47,tocIndex:7},{value:"attrs/fontFamily",paraId:47,tocIndex:7},{value:"string",paraId:47,tocIndex:7},{value:"Arial, helvetica, sans-serif",paraId:47,tocIndex:7},{value:"Font for editing text.",paraId:47,tocIndex:7},{value:"attrs/backgroundColor",paraId:47,tocIndex:7},{value:"string",paraId:47,tocIndex:7},{value:"#fff",paraId:47,tocIndex:7},{value:"Background color for the editing area.",paraId:47,tocIndex:7},{value:"getText",paraId:47,tocIndex:7},{value:"string | ",paraId:47,tocIndex:7},{value:"(this: CellView, args: {cell: Cell}) => string",paraId:47,tocIndex:7},{value:"-",paraId:47,tocIndex:7},{value:"Method to get the original text; needs to be customized in custom ",paraId:47,tocIndex:7},{value:"markup",paraId:47,tocIndex:7},{value:" scenarios.",paraId:47,tocIndex:7},{value:"setText",paraId:47,tocIndex:7},{value:"string | ",paraId:47,tocIndex:7},{value:"(this: CellView, args: {cell: Cell, value: string}) => void",paraId:47,tocIndex:7},{value:"-",paraId:47,tocIndex:7},{value:"Method to set new text; needs to be customized in custom ",paraId:47,tocIndex:7},{value:"markup",paraId:47,tocIndex:7},{value:" scenarios.",paraId:47,tocIndex:7},{value:"Note that after version 2.8.0, there is no need to dynamically add tools in the double-click event, so event parameters do not need to be passed.",paraId:48},{value:"// Usage before version 2.8.0\ngraph.on('node:dblclick', ({ node, e }) => {\n  edge.addTools({\n    name: 'edge-editor',\n    args: {\n      event: e,\n    },\n  })\n})\n\n// Usage after version 2.8.0\nedge.addTools({\n  name: 'edge-editor',\n})\n",paraId:49},{value:"It is also important to note that if a custom ",paraId:50},{value:"markup",paraId:50},{value:" is defined in the edge, it is often necessary to customize the ",paraId:50},{value:"getText",paraId:50},{value:" and ",paraId:50},{value:"setText",paraId:50},{value:" methods to correctly get and set the edited text. Both configurations support function and string forms; the function is straightforward, while the string is the property path of the text to get or set. Generally, it is recommended to use the string form so that the graph data can be fully serialized (since functions cannot be serialized), otherwise, issues may arise with the text editing functionality after rendering the canvas. For example:",paraId:50},{value:"edge.addTools({\n  name: 'edge-editor',\n  args: {\n    getText: 'a/b',\n    setText: 'c/d',\n  },\n})\n",paraId:51},{value:"The above configuration indicates:",paraId:52},{value:"Get edited text: ",paraId:53},{value:"edge.attr('a/b')",paraId:53},{value:"Set edited text: ",paraId:53},{value:"edge.attr('c/d', value)",paraId:53},{value:"Inherit from ",paraId:54,tocIndex:9},{value:"ToolItem",paraId:54,tocIndex:9},{value:" to implement a tool class, which is more complex and requires understanding of the ",paraId:54,tocIndex:9},{value:"ToolItem",paraId:54,tocIndex:9},{value:" class. You can refer to the source code of the built-in tools above; this will not be elaborated here.",paraId:54,tocIndex:9},{value:"Graph.registerEdgeTool('button', Button)\n",paraId:55,tocIndex:9},{value:"Inherit from an already registered tool and modify the configuration based on that. We provide a static method ",paraId:56,tocIndex:10},{value:"define",paraId:56,tocIndex:10},{value:" on the ",paraId:56,tocIndex:10},{value:"ToolItem",paraId:56,tocIndex:10},{value:" base class to quickly implement inheritance and modify configurations.",paraId:56,tocIndex:10},{value:"import { Vertices } from '@antv/x6/es/registry/tool/vertices'\n\nconst RedVertices = Vertices.define<Vertices.Options>({\n  attrs: {\n    fill: 'red',\n  },\n})\n\nGraph.registerEdgeTool('red-vertices', RedVertices, true)\n",paraId:57,tocIndex:10},{value:"Additionally, we provide a quick way to inherit and specify default options for the ",paraId:58},{value:"Graph.registerEdgeTool",paraId:58},{value:" method:",paraId:58},{value:"Graph.registerEdgeTool('red-vertices', {\n  inherit: 'vertices', // Base class name, using the name of the already registered tool.\n  attrs: {\n    // Other options, as default options for the inherited class.\n    fill: 'red',\n  },\n})\n",paraId:59},{value:"Using this method, we can quickly define and register a circular endpoint ",paraId:60},{value:"circle-target-arrowhead",paraId:60},{value:":",paraId:60},{value:"Graph.registerEdgeTool('circle-target-arrowhead', {\n  inherit: 'target-arrowhead',\n  tagName: 'circle',\n  attrs: {\n    r: 18,\n    fill: '#31d0c6',\n    'fill-opacity': 0.3,\n    stroke: '#fe854f',\n    'stroke-width': 4,\n    cursor: 'move',\n  },\n})\n",paraId:61}]},25426:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(99346);const n=[{value:"We can use the special attribute ",paraId:0},{value:"filter",paraId:1},{value:" to specify ",paraId:0},{value:"SVG filters",paraId:0},{value:" for elements. For example, we can define a predefined object for the ",paraId:0},{value:"filter",paraId:0},{value:" attribute of the element, where ",paraId:0},{value:"name",paraId:0},{value:" and ",paraId:0},{value:"args",paraId:0},{value:" specify the filter name and filter parameters, respectively.",paraId:0},{value:"// Create a node by specifying the filter through the attrs option\nconst rect = graph.addNode({\n  x: 40,\n  y: 40,\n  width: 80,\n  height: 30,\n  attrs: {\n    body: {\n      filter: {\n        name: 'dropShadow',\n        args: {\n          dx: 2,\n          dy: 2,\n          blur: 3,\n        },\n      },\n    },\n  },\n})\n\n// After creating the node, we can modify or specify the element's filter using the `attr()` method\nrect.attr('body/filter', {\n  name: 'dropShadow',\n  args: {\n    dx: 2,\n    dy: 2,\n    blur: 3,\n  },\n})\n",paraId:2},{value:"Additionally, we can call the ",paraId:3},{value:"graph.defineFilter(...)",paraId:3},{value:" method to obtain a filter ID, and then set the ",paraId:3},{value:"filter",paraId:3},{value:" attribute to this filter ID.",paraId:3},{value:"const filterId = graph.defineFilter({\n  name: 'dropShadow',\n  args: {\n    dx: 2,\n    dy: 2,\n    blur: 3,\n  },\n})\n\nrect.attr('body/filter', `#${filterId}`)\n",paraId:4},{value:"Through this brief introduction, we have learned how to use filters. Next, let's take a look at the predefined filters available in X6.",paraId:5},{value:"Shadow filter. Refer to ",paraId:6,tocIndex:1},{value:"CSS drop-shadow()",paraId:6,tocIndex:1},{value:" filter.",paraId:6,tocIndex:1},{value:"Parameter Name",paraId:7,tocIndex:1},{value:"Type",paraId:7,tocIndex:1},{value:"Default Value",paraId:7,tocIndex:1},{value:"Description",paraId:7,tocIndex:1},{value:"dx",paraId:7,tocIndex:1},{value:"number",paraId:7,tocIndex:1},{value:"0",paraId:7,tocIndex:1},{value:"Shadow offset on the X-axis.",paraId:7,tocIndex:1},{value:"dy",paraId:7,tocIndex:1},{value:"number",paraId:7,tocIndex:1},{value:"0",paraId:7,tocIndex:1},{value:"Shadow offset on the Y-axis.",paraId:7,tocIndex:1},{value:"blur",paraId:7,tocIndex:1},{value:"number",paraId:7,tocIndex:1},{value:"0",paraId:7,tocIndex:1},{value:"Shadow blur radius.",paraId:7,tocIndex:1},{value:"opacity",paraId:7,tocIndex:1},{value:"number",paraId:7,tocIndex:1},{value:"1",paraId:7,tocIndex:1},{value:"Shadow opacity.",paraId:7,tocIndex:1},{value:"Gaussian blur filter. Refer to ",paraId:8,tocIndex:2},{value:"CSS blur()",paraId:8,tocIndex:2},{value:" filter.",paraId:8,tocIndex:2},{value:"Parameter Name",paraId:9,tocIndex:2},{value:"Type",paraId:9,tocIndex:2},{value:"Default Value",paraId:9,tocIndex:2},{value:"Description",paraId:9,tocIndex:2},{value:"x",paraId:9,tocIndex:2},{value:"number",paraId:9,tocIndex:2},{value:"2",paraId:9,tocIndex:2},{value:"Blur amount in the X direction.",paraId:9,tocIndex:2},{value:"y",paraId:9,tocIndex:2},{value:"number",paraId:9,tocIndex:2},{value:"-",paraId:9,tocIndex:2},{value:"Blur amount in the Y direction; defaults to X.",paraId:9,tocIndex:2},{value:"Grayscale filter. Refer to ",paraId:10,tocIndex:3},{value:"CSS grayscale()",paraId:10,tocIndex:3},{value:" filter.",paraId:10,tocIndex:3},{value:"Parameter Name",paraId:11,tocIndex:3},{value:"Type",paraId:11,tocIndex:3},{value:"Default Value",paraId:11,tocIndex:3},{value:"Description",paraId:11,tocIndex:3},{value:"amount",paraId:11,tocIndex:3},{value:"number",paraId:11,tocIndex:3},{value:"1",paraId:11,tocIndex:3},{value:"Grayscale amount. Ranges from ",paraId:11,tocIndex:3},{value:"[0-1]",paraId:11,tocIndex:3},{value:", where ",paraId:11,tocIndex:3},{value:"0",paraId:11,tocIndex:3},{value:" means no grayscale and ",paraId:11,tocIndex:3},{value:"1",paraId:11,tocIndex:3},{value:" means full grayscale.",paraId:11,tocIndex:3},{value:"Sepia filter. Refer to ",paraId:12,tocIndex:4},{value:"CSS sepia()",paraId:12,tocIndex:4},{value:" filter.",paraId:12,tocIndex:4},{value:"Parameter Name",paraId:13,tocIndex:4},{value:"Type",paraId:13,tocIndex:4},{value:"Default Value",paraId:13,tocIndex:4},{value:"Description",paraId:13,tocIndex:4},{value:"amount",paraId:13,tocIndex:4},{value:"number",paraId:13,tocIndex:4},{value:"1",paraId:13,tocIndex:4},{value:"Sepia amount. Ranges from ",paraId:13,tocIndex:4},{value:"[0-1]",paraId:13,tocIndex:4},{value:", where ",paraId:13,tocIndex:4},{value:"0",paraId:13,tocIndex:4},{value:" means no sepia and ",paraId:13,tocIndex:4},{value:"1",paraId:13,tocIndex:4},{value:" means full sepia.",paraId:13,tocIndex:4},{value:"Saturation filter. Refer to ",paraId:14,tocIndex:5},{value:"CSS saturate()",paraId:14,tocIndex:5},{value:" filter.",paraId:14,tocIndex:5},{value:"Parameter Name",paraId:15,tocIndex:5},{value:"Type",paraId:15,tocIndex:5},{value:"Default Value",paraId:15,tocIndex:5},{value:"Description",paraId:15,tocIndex:5},{value:"amount",paraId:15,tocIndex:5},{value:"number",paraId:15,tocIndex:5},{value:"1",paraId:15,tocIndex:5},{value:"Saturation. Ranges from ",paraId:15,tocIndex:5},{value:"[0-1]",paraId:15,tocIndex:5},{value:".",paraId:15,tocIndex:5},{value:"Hue rotation filter. Refer to ",paraId:16,tocIndex:6},{value:"CSS hue-rotate()",paraId:16,tocIndex:6},{value:" filter.",paraId:16,tocIndex:6},{value:"Parameter Name",paraId:17,tocIndex:6},{value:"Type",paraId:17,tocIndex:6},{value:"Default Value",paraId:17,tocIndex:6},{value:"Description",paraId:17,tocIndex:6},{value:"angle",paraId:17,tocIndex:6},{value:"number",paraId:17,tocIndex:6},{value:"0",paraId:17,tocIndex:6},{value:"Hue rotation angle.",paraId:17,tocIndex:6},{value:"Invert filter. Refer to ",paraId:18,tocIndex:7},{value:"CSS invert()",paraId:18,tocIndex:7},{value:" filter.",paraId:18,tocIndex:7},{value:"Parameter Name",paraId:19,tocIndex:7},{value:"Type",paraId:19,tocIndex:7},{value:"Default Value",paraId:19,tocIndex:7},{value:"Description",paraId:19,tocIndex:7},{value:"amount",paraId:19,tocIndex:7},{value:"number",paraId:19,tocIndex:7},{value:"1",paraId:19,tocIndex:7},{value:"Inversion amount. Ranges from ",paraId:19,tocIndex:7},{value:"[0-1]",paraId:19,tocIndex:7},{value:", where ",paraId:19,tocIndex:7},{value:"0",paraId:19,tocIndex:7},{value:" means no inversion and ",paraId:19,tocIndex:7},{value:"1",paraId:19,tocIndex:7},{value:" means full inversion.",paraId:19,tocIndex:7},{value:"Brightness filter. Refer to ",paraId:20,tocIndex:8},{value:"CSS brightness()",paraId:20,tocIndex:8},{value:" filter.",paraId:20,tocIndex:8},{value:"Parameter Name",paraId:21,tocIndex:8},{value:"Type",paraId:21,tocIndex:8},{value:"Default Value",paraId:21,tocIndex:8},{value:"Description",paraId:21,tocIndex:8},{value:"amount",paraId:21,tocIndex:8},{value:"number",paraId:21,tocIndex:8},{value:"1",paraId:21,tocIndex:8},{value:"Brightness. Ranges from ",paraId:21,tocIndex:8},{value:"[0-1]",paraId:21,tocIndex:8},{value:", where ",paraId:21,tocIndex:8},{value:"0",paraId:21,tocIndex:8},{value:" means completely dark and ",paraId:21,tocIndex:8},{value:"1",paraId:21,tocIndex:8},{value:" means completely bright.",paraId:21,tocIndex:8},{value:"Contrast filter. Refer to ",paraId:22,tocIndex:9},{value:"CSS contrast()",paraId:22,tocIndex:9},{value:" filter.",paraId:22,tocIndex:9},{value:"Parameter Name",paraId:23,tocIndex:9},{value:"Type",paraId:23,tocIndex:9},{value:"Default Value",paraId:23,tocIndex:9},{value:"Description",paraId:23,tocIndex:9},{value:"amount",paraId:23,tocIndex:9},{value:"number",paraId:23,tocIndex:9},{value:"1",paraId:23,tocIndex:9},{value:"Contrast. Ranges from ",paraId:23,tocIndex:9},{value:"[0-1]",paraId:23,tocIndex:9},{value:", where ",paraId:23,tocIndex:9},{value:"0",paraId:23,tocIndex:9},{value:" means completely dark and ",paraId:23,tocIndex:9},{value:"1",paraId:23,tocIndex:9},{value:" means completely bright.",paraId:23,tocIndex:9},{value:"Highlight filter.",paraId:24,tocIndex:10},{value:"Parameter Name",paraId:25,tocIndex:10},{value:"Type",paraId:25,tocIndex:10},{value:"Default Value",paraId:25,tocIndex:10},{value:"Description",paraId:25,tocIndex:10},{value:"color",paraId:25,tocIndex:10},{value:"string",paraId:25,tocIndex:10},{value:"red",paraId:25,tocIndex:10},{value:"Highlight color.",paraId:25,tocIndex:10},{value:"width",paraId:25,tocIndex:10},{value:"number",paraId:25,tocIndex:10},{value:"1",paraId:25,tocIndex:10},{value:"Width of the highlight border.",paraId:25,tocIndex:10},{value:"blur",paraId:25,tocIndex:10},{value:"number",paraId:25,tocIndex:10},{value:"0",paraId:25,tocIndex:10},{value:"Blur radius.",paraId:25,tocIndex:10},{value:"opacity",paraId:25,tocIndex:10},{value:"number",paraId:25,tocIndex:10},{value:"1",paraId:25,tocIndex:10},{value:"Opacity.",paraId:25,tocIndex:10},{value:"Outline filter.",paraId:26,tocIndex:11},{value:"Parameter Name",paraId:27,tocIndex:11},{value:"Type",paraId:27,tocIndex:11},{value:"Default Value",paraId:27,tocIndex:11},{value:"Description",paraId:27,tocIndex:11},{value:"color",paraId:27,tocIndex:11},{value:"string",paraId:27,tocIndex:11},{value:"blue",paraId:27,tocIndex:11},{value:"Outline color.",paraId:27,tocIndex:11},{value:"width",paraId:27,tocIndex:11},{value:"number",paraId:27,tocIndex:11},{value:"1",paraId:27,tocIndex:11},{value:"Outline width.",paraId:27,tocIndex:11},{value:"margin",paraId:27,tocIndex:11},{value:"number",paraId:27,tocIndex:11},{value:"2",paraId:27,tocIndex:11},{value:"Margin.",paraId:27,tocIndex:11},{value:"opacity",paraId:27,tocIndex:11},{value:"number",paraId:27,tocIndex:11},{value:"1",paraId:27,tocIndex:11},{value:"Opacity.",paraId:27,tocIndex:11},{value:"A filter definition is a function with the following signature that returns a ",paraId:28,tocIndex:12},{value:"<filter>",paraId:28,tocIndex:12},{value:" tag string.",paraId:28,tocIndex:12},{value:"export type Definition<T> = (args: T) => string\n",paraId:29,tocIndex:12},{value:"For example, the definition of the Gaussian blur filter is:",paraId:30,tocIndex:12},{value:'export interface BlurArgs {\n  x?: number\n  y?: number\n}\n\nexport function blur(args: BlurArgs = {}) {\n  const x = getNumber(args.x, 2)\n  const stdDeviation = args.y != null && isFinite(args.y) ? [x, args.y] : x\n\n  return `\n    <filter>\n      <feGaussianBlur stdDeviation="${stdDeviation}"/>\n    </filter>\n  `.trim()\n}\n',paraId:31,tocIndex:12},{value:"We can register a filter by calling the ",paraId:32,tocIndex:12},{value:"Graph.registerFilter(...)",paraId:32,tocIndex:12},{value:" method.",paraId:32,tocIndex:12},{value:"Graph.registerFilter('blur', blur)\n",paraId:33,tocIndex:12}]},7517:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(53805);const n=[{value:"Node/edge highlighters used to highlight specified elements. X6 includes the following types of highlighters.",paraId:0},{value:"Name",paraId:1},{value:"Description",paraId:1},{value:"stroke",paraId:1},{value:"Stroke Highlighter",paraId:2},{value:", renders a highlighted border around the bounding box of the element.",paraId:1},{value:"className",paraId:1},{value:"Class Name Highlighter",paraId:3},{value:", highlights elements by adding additional class names.",paraId:1},{value:"When creating a Graph, you can specify the highlighting style triggered by certain interactions through the ",paraId:4},{value:"highlighting",paraId:4},{value:" option, such as:",paraId:4},{value:"new Graph({\n  highlighting: {\n    // When a magnet is available for linking, render a 2px wide red rectangle around the magnet\n    magnetAvailable: {\n      name: 'stroke',\n      args: {\n        padding: 4,\n        attrs: {\n          'stroke-width': 2,\n          stroke: 'red',\n        },\n      },\n    },\n  },\n})\n",paraId:5},{value:"Supported ",paraId:6},{value:"highlighting",paraId:6},{value:" configuration options include:",paraId:6},{value:"'default'",paraId:7},{value:" Default highlighting option, used when the following highlighting configurations are not specified.",paraId:7},{value:"'embedding'",paraId:7},{value:" Used when dragging a node for embedding and the node can be embedded.",paraId:7},{value:"'nodeAvailable'",paraId:7},{value:" Used during the linking process when a node can be linked.",paraId:7},{value:"'magnetAvailable'",paraId:7},{value:" Used during the linking process when a magnet can be linked.",paraId:7},{value:"'magnetAdsorbed'",paraId:7},{value:" Used during the linking process when automatically snapping to a magnet.",paraId:7},{value:"The border highlighter renders a highlighted border along the bounding box of the element.",paraId:8,tocIndex:1},{value:"Parameter Name",paraId:9,tocIndex:1},{value:"Type",paraId:9,tocIndex:1},{value:"Default Value",paraId:9,tocIndex:1},{value:"Description",paraId:9,tocIndex:1},{value:"rx",paraId:9,tocIndex:1},{value:"number",paraId:9,tocIndex:1},{value:"0",paraId:9,tocIndex:1},{value:"Border radius.",paraId:9,tocIndex:1},{value:"ry",paraId:9,tocIndex:1},{value:"number",paraId:9,tocIndex:1},{value:"0",paraId:9,tocIndex:1},{value:"Border radius.",paraId:9,tocIndex:1},{value:"padding",paraId:9,tocIndex:1},{value:"number",paraId:9,tocIndex:1},{value:"3",paraId:9,tocIndex:1},{value:"Padding.",paraId:9,tocIndex:1},{value:"attrs",paraId:9,tocIndex:1},{value:"object",paraId:9,tocIndex:1},{value:"{ 'stroke-width': 3, stroke: '#FEB663' }",paraId:9,tocIndex:1},{value:"Border element attributes.",paraId:9,tocIndex:1},{value:"The style name highlighter highlights elements by adding an additional style name.",paraId:10,tocIndex:2},{value:"Parameter Name",paraId:11,tocIndex:2},{value:"Type",paraId:11,tocIndex:2},{value:"Default Value",paraId:11,tocIndex:2},{value:"Description",paraId:11,tocIndex:2},{value:"className",paraId:11,tocIndex:2},{value:"string",paraId:11,tocIndex:2},{value:"x6-highlighted",paraId:11,tocIndex:2},{value:"Style name.",paraId:11,tocIndex:2},{value:"A highlighter is an object with the following signature, containing two methods: ",paraId:12,tocIndex:3},{value:"highlight",paraId:12,tocIndex:3},{value:" and ",paraId:12,tocIndex:3},{value:"unhighlight",paraId:12,tocIndex:3},{value:", which are used to highlight and unhighlight elements, respectively.",paraId:12,tocIndex:3},{value:"export interface Definition<T> {\n  highlight: (cellView: CellView, magnet: Element, options: T) => void\n  unhighlight: (cellView: CellView, magnet: Element, options: T) => void\n}\n",paraId:13,tocIndex:3},{value:"Parameter Name",paraId:14,tocIndex:3},{value:"Type",paraId:14,tocIndex:3},{value:"Default Value",paraId:14,tocIndex:3},{value:"Description",paraId:14,tocIndex:3},{value:"cellView",paraId:14,tocIndex:3},{value:"CellView",paraId:14,tocIndex:3},{value:"View.",paraId:14,tocIndex:3},{value:"magnet",paraId:14,tocIndex:3},{value:"Element",paraId:14,tocIndex:3},{value:"The highlighted element.",paraId:14,tocIndex:3},{value:"options",paraId:14,tocIndex:3},{value:"T",paraId:14,tocIndex:3},{value:"Highlight options.",paraId:14,tocIndex:3},{value:"Now, let's define a highlighter named ",paraId:15,tocIndex:3},{value:"opacity",paraId:15,tocIndex:3},{value:", which adds a ",paraId:15,tocIndex:3},{value:"'highlight-opacity'",paraId:15,tocIndex:3},{value:" style name to the element.",paraId:15,tocIndex:3},{value:"export interface OpacityHighlighterOptions {}\n\nconst className = 'highlight-opacity'\n\nexport const opacity: Highlighter.Definition<OpacityHighlighterOptions> = {\n  highlight(cellView, magnet) {\n    Dom.addClass(magnet, className)\n  },\n\n  unhighlight(cellView, magnetEl) {\n    Dom.removeClass(magnetEl, className)\n  },\n}\n",paraId:16,tocIndex:3},{value:"After defining it, we can register our highlighter:",paraId:17,tocIndex:3},{value:"Graph.registerHighlighter('opacity', opacity, true)\n",paraId:18,tocIndex:3},{value:"Then we can use this highlighter with the string ",paraId:19,tocIndex:3},{value:"opacity",paraId:19,tocIndex:3},{value:":",paraId:19,tocIndex:3},{value:"new Graph({\n  highlighting: {\n    magnetAvailable: {\n      name: 'opacity',\n    },\n  },\n})\n",paraId:20,tocIndex:3}]},19746:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(7505);const n=[{value:"When connecting to a node, you can specify the anchor point of the connected node using ",paraId:0},{value:"NodeAnchor",paraId:0},{value:", which, together with the connection point ",paraId:0},{value:"ConnectionPoint",paraId:1},{value:", determines the starting and ending points of the edge.",paraId:0},{value:"Starting point: Draw a reference line from the first path point or the center of the target node (when there is no path point) to the anchor point of the source node, and then calculate the intersection point of the reference line and the graph according to the intersection calculation method specified by ",paraId:2},{value:"connectionPoint",paraId:3},{value:", which is the starting point of the edge.",paraId:2},{value:"Ending point: Draw a reference line from the last path point or the center of the source node (when there is no path point) to the anchor point of the target node, and then calculate the intersection point of the reference line and the graph according to the intersection calculation method specified by ",paraId:2},{value:"connectionPoint",paraId:4},{value:", which is the ending point of the edge.",paraId:2},{value:"X6 has built-in the following anchor point definitions.",paraId:5},{value:"center",paraId:6},{value:" The center point of the element connected to the edge (default value).",paraId:7},{value:"top",paraId:8},{value:" The top center point of the element connected to the edge.",paraId:7},{value:"bottom",paraId:9},{value:" The bottom center point of the element connected to the edge.",paraId:7},{value:"left",paraId:10},{value:" The left center point of the element connected to the edge.",paraId:7},{value:"right",paraId:11},{value:" The right center point of the element connected to the edge.",paraId:7},{value:"midSide",paraId:12},{value:" The center point of the nearest side of the element connected to the edge.",paraId:7},{value:"topLeft",paraId:13},{value:" The top-left corner of the element connected to the edge.",paraId:7},{value:"topRight",paraId:14},{value:" The top-right corner of the element connected to the edge.",paraId:7},{value:"bottomLeft",paraId:15},{value:" The bottom-left corner of the element connected to the edge.",paraId:7},{value:"bottomRight",paraId:16},{value:" The bottom-right corner of the element connected to the edge.",paraId:7},{value:"orth",paraId:17},{value:" The orthogonal point.",paraId:7},{value:"nodeCenter",paraId:18},{value:" The center point of the node.",paraId:7},{value:"You can specify the anchor point when creating an edge:",paraId:19},{value:"const edge = graph.addEdge({\n  source: {\n    cell: 'source-id',\n    anchor: {\n      name: 'midSide',\n      args: {\n        dx: 10,\n      },\n    },\n  },\n  target: {\n    cell: 'target-id',\n    anchor: 'orth', // Simplified writing when there are no parameters\n  },\n})\n",paraId:20},{value:"After creation, you can modify the anchor point by calling the ",paraId:21},{value:"edge.setSource",paraId:21},{value:" and ",paraId:21},{value:"edge.setTarget",paraId:21},{value:" methods:",paraId:21},{value:"edge.setSource({\n  cell: 'source-id',\n  anchor: {\n    name: 'midSide',\n    args: {\n      dx: 10,\n    },\n  },\n})\n",paraId:22},{value:"When creating a canvas, you can set the global default anchor point through the ",paraId:23},{value:"connecting",paraId:23},{value:" option:",paraId:23},{value:"new Graph({\n  connecting: {\n    anchor: {\n      name: 'midSide',\n      args: {\n        dx: 10,\n      },\n    },\n  },\n})\n",paraId:24},{value:"Simplified writing when there are no parameters:",paraId:25},{value:"new Graph({\n  connecting: {\n    anchor: 'midSide',\n  },\n})\n",paraId:26},{value:"The center point of the element, supporting the following parameters:",paraId:27,tocIndex:1},{value:"Parameter Name",paraId:28,tocIndex:1},{value:"Parameter Type",paraId:28,tocIndex:1},{value:"Required",paraId:28,tocIndex:1},{value:"Default Value",paraId:28,tocIndex:1},{value:"Parameter Description",paraId:28,tocIndex:1},{value:"dx",paraId:28,tocIndex:1},{value:"number | string",paraId:28,tocIndex:1},{value:"No",paraId:28,tocIndex:1},{value:"0",paraId:28,tocIndex:1},{value:"X-axis offset, supporting absolute offset and percentage relative offset.",paraId:28,tocIndex:1},{value:"dy",paraId:28,tocIndex:1},{value:"number | string",paraId:28,tocIndex:1},{value:"No",paraId:28,tocIndex:1},{value:"0",paraId:28,tocIndex:1},{value:"Y-axis offset, supporting absolute offset and percentage relative offset.",paraId:28,tocIndex:1},{value:"rotate",paraId:28,tocIndex:1},{value:"boolean",paraId:28,tocIndex:1},{value:"No",paraId:28,tocIndex:1},{value:"false",paraId:28,tocIndex:1},{value:"Whether to use the element's bounding box rotated with the node, defaulting to not considering the rotation angle.",paraId:28,tocIndex:1},{value:"The top center point of the element, supporting the following parameters:",paraId:29,tocIndex:2},{value:"Parameter Name",paraId:30,tocIndex:2},{value:"Parameter Type",paraId:30,tocIndex:2},{value:"Required",paraId:30,tocIndex:2},{value:"Default Value",paraId:30,tocIndex:2},{value:"Parameter Description",paraId:30,tocIndex:2},{value:"dx",paraId:30,tocIndex:2},{value:"number | string",paraId:30,tocIndex:2},{value:"No",paraId:30,tocIndex:2},{value:"0",paraId:30,tocIndex:2},{value:"X-axis offset, supporting absolute offset and percentage relative offset.",paraId:30,tocIndex:2},{value:"dy",paraId:30,tocIndex:2},{value:"number | string",paraId:30,tocIndex:2},{value:"No",paraId:30,tocIndex:2},{value:"0",paraId:30,tocIndex:2},{value:"Y-axis offset, supporting absolute offset and percentage relative offset.",paraId:30,tocIndex:2},{value:"rotate",paraId:30,tocIndex:2},{value:"boolean",paraId:30,tocIndex:2},{value:"No",paraId:30,tocIndex:2},{value:"false",paraId:30,tocIndex:2},{value:"Whether to use the element's bounding box rotated with the node, defaulting to not considering the rotation angle.",paraId:30,tocIndex:2},{value:"The bottom center point of the element, supporting the following parameters:",paraId:31,tocIndex:3},{value:"Parameter Name",paraId:32,tocIndex:3},{value:"Parameter Type",paraId:32,tocIndex:3},{value:"Required",paraId:32,tocIndex:3},{value:"Default Value",paraId:32,tocIndex:3},{value:"Parameter Description",paraId:32,tocIndex:3},{value:"dx",paraId:32,tocIndex:3},{value:"number | string",paraId:32,tocIndex:3},{value:"No",paraId:32,tocIndex:3},{value:"0",paraId:32,tocIndex:3},{value:"X-axis offset, supporting absolute offset and percentage relative offset.",paraId:32,tocIndex:3},{value:"dy",paraId:32,tocIndex:3},{value:"number | string",paraId:32,tocIndex:3},{value:"No",paraId:32,tocIndex:3},{value:"0",paraId:32,tocIndex:3},{value:"Y-axis offset, supporting absolute offset and percentage relative offset.",paraId:32,tocIndex:3},{value:"rotate",paraId:32,tocIndex:3},{value:"boolean",paraId:32,tocIndex:3},{value:"No",paraId:32,tocIndex:3},{value:"false",paraId:32,tocIndex:3},{value:"Whether to use the element's bounding box rotated with the node, defaulting to not considering the rotation angle.",paraId:32,tocIndex:3},{value:"The left center point of the element, supporting the following parameters:",paraId:33,tocIndex:4},{value:"Parameter Name",paraId:34,tocIndex:4},{value:"Parameter Type",paraId:34,tocIndex:4},{value:"Required",paraId:34,tocIndex:4},{value:"Default Value",paraId:34,tocIndex:4},{value:"Parameter Description",paraId:34,tocIndex:4},{value:"dx",paraId:34,tocIndex:4},{value:"number | string",paraId:34,tocIndex:4},{value:"No",paraId:34,tocIndex:4},{value:"0",paraId:34,tocIndex:4},{value:"X-axis offset, supporting absolute offset and percentage relative offset.",paraId:34,tocIndex:4},{value:"dy",paraId:34,tocIndex:4},{value:"number | string",paraId:34,tocIndex:4},{value:"No",paraId:34,tocIndex:4},{value:"0",paraId:34,tocIndex:4},{value:"Y-axis offset, supporting absolute offset and percentage relative offset.",paraId:34,tocIndex:4},{value:"rotate",paraId:34,tocIndex:4},{value:"boolean",paraId:34,tocIndex:4},{value:"No",paraId:34,tocIndex:4},{value:"false",paraId:34,tocIndex:4},{value:"Whether to use the element's bounding box rotated with the node, defaulting to not considering the rotation angle.",paraId:34,tocIndex:4},{value:"The right center point of the element, supporting the following parameters:",paraId:35,tocIndex:5},{value:"Parameter Name",paraId:36,tocIndex:5},{value:"Parameter Type",paraId:36,tocIndex:5},{value:"Required",paraId:36,tocIndex:5},{value:"Default Value",paraId:36,tocIndex:5},{value:"Parameter Description",paraId:36,tocIndex:5},{value:"dx",paraId:36,tocIndex:5},{value:"number | string",paraId:36,tocIndex:5},{value:"No",paraId:36,tocIndex:5},{value:"0",paraId:36,tocIndex:5},{value:"X-axis offset, supporting absolute offset and percentage relative offset.",paraId:36,tocIndex:5},{value:"dy",paraId:36,tocIndex:5},{value:"number | string",paraId:36,tocIndex:5},{value:"No",paraId:36,tocIndex:5},{value:"0",paraId:36,tocIndex:5},{value:"Y-axis offset, supporting absolute offset and percentage relative offset.",paraId:36,tocIndex:5},{value:"rotate",paraId:36,tocIndex:5},{value:"boolean",paraId:36,tocIndex:5},{value:"No",paraId:36,tocIndex:5},{value:"false",paraId:36,tocIndex:5},{value:"Whether to use the element's bounding box rotated with the node, defaulting to not considering the rotation angle.",paraId:36,tocIndex:5},{value:"The center point of the nearest side of the element, supporting the following parameters:",paraId:37,tocIndex:6},{value:"Parameter Name",paraId:38,tocIndex:6},{value:"Parameter Type",paraId:38,tocIndex:6},{value:"Required",paraId:38,tocIndex:6},{value:"Default Value",paraId:38,tocIndex:6},{value:"Parameter Description",paraId:38,tocIndex:6},{value:"padding",paraId:38,tocIndex:6},{value:"number",paraId:38,tocIndex:6},{value:"No",paraId:38,tocIndex:6},{value:"0",paraId:38,tocIndex:6},{value:"Offset the center point by ",paraId:38,tocIndex:6},{value:"padding",paraId:38,tocIndex:6},{value:" pixels, supporting absolute offset and percentage relative offset.",paraId:38,tocIndex:6},{value:"rotate",paraId:38,tocIndex:6},{value:"boolean",paraId:38,tocIndex:6},{value:"No",paraId:38,tocIndex:6},{value:"false",paraId:38,tocIndex:6},{value:"Whether to use the element's bounding box rotated with the node, defaulting to not considering the rotation angle.",paraId:38,tocIndex:6},{value:"direction",paraId:38,tocIndex:6},{value:"'H' | 'V'",paraId:38,tocIndex:6},{value:"No",paraId:38,tocIndex:6},{value:"-",paraId:38,tocIndex:6},{value:"The direction of the connection point, such as setting to ",paraId:38,tocIndex:6},{value:"H",paraId:38,tocIndex:6},{value:" to only connect to the left or right center point of the node, automatically judging based on the position.",paraId:38,tocIndex:6},{value:"The top-left corner of the element, supporting the following parameters:",paraId:39,tocIndex:7},{value:"Parameter Name",paraId:40,tocIndex:7},{value:"Parameter Type",paraId:40,tocIndex:7},{value:"Required",paraId:40,tocIndex:7},{value:"Default Value",paraId:40,tocIndex:7},{value:"Parameter Description",paraId:40,tocIndex:7},{value:"dx",paraId:40,tocIndex:7},{value:"number | string",paraId:40,tocIndex:7},{value:"No",paraId:40,tocIndex:7},{value:"0",paraId:40,tocIndex:7},{value:"X-axis offset, supporting absolute offset and percentage relative offset.",paraId:40,tocIndex:7},{value:"dy",paraId:40,tocIndex:7},{value:"number | string",paraId:40,tocIndex:7},{value:"No",paraId:40,tocIndex:7},{value:"0",paraId:40,tocIndex:7},{value:"Y-axis offset, supporting absolute offset and percentage relative offset.",paraId:40,tocIndex:7},{value:"rotate",paraId:40,tocIndex:7},{value:"boolean",paraId:40,tocIndex:7},{value:"No",paraId:40,tocIndex:7},{value:"false",paraId:40,tocIndex:7},{value:"Whether to use the element's bounding box rotated with the node, defaulting to not considering the rotation angle.",paraId:40,tocIndex:7},{value:"The top-right corner of the element, supporting the following parameters:",paraId:41,tocIndex:8},{value:"Parameter Name",paraId:42,tocIndex:8},{value:"Parameter Type",paraId:42,tocIndex:8},{value:"Required",paraId:42,tocIndex:8},{value:"Default Value",paraId:42,tocIndex:8},{value:"Parameter Description",paraId:42,tocIndex:8},{value:"dx",paraId:42,tocIndex:8},{value:"number | string",paraId:42,tocIndex:8},{value:"No",paraId:42,tocIndex:8},{value:"0",paraId:42,tocIndex:8},{value:"X-axis offset, supporting absolute offset and percentage relative offset.",paraId:42,tocIndex:8},{value:"dy",paraId:42,tocIndex:8},{value:"number | string",paraId:42,tocIndex:8},{value:"No",paraId:42,tocIndex:8},{value:"0",paraId:42,tocIndex:8},{value:"Y-axis offset, supporting absolute offset and percentage relative offset.",paraId:42,tocIndex:8},{value:"rotate",paraId:42,tocIndex:8},{value:"boolean",paraId:42,tocIndex:8},{value:"No",paraId:42,tocIndex:8},{value:"false",paraId:42,tocIndex:8},{value:"Whether to use the element's bounding box rotated with the node, defaulting to not considering the rotation angle.",paraId:42,tocIndex:8},{value:"The bottom-left corner of the element, supporting the following parameters:",paraId:43,tocIndex:9},{value:"Parameter Name",paraId:44,tocIndex:9},{value:"Parameter Type",paraId:44,tocIndex:9},{value:"Required",paraId:44,tocIndex:9},{value:"Default Value",paraId:44,tocIndex:9},{value:"Parameter Description",paraId:44,tocIndex:9},{value:"dx",paraId:44,tocIndex:9},{value:"number | string",paraId:44,tocIndex:9},{value:"No",paraId:44,tocIndex:9},{value:"0",paraId:44,tocIndex:9},{value:"X-axis offset, supporting absolute offset and percentage relative offset.",paraId:44,tocIndex:9},{value:"dy",paraId:44,tocIndex:9},{value:"number | string",paraId:44,tocIndex:9},{value:"No",paraId:44,tocIndex:9},{value:"0",paraId:44,tocIndex:9},{value:"Y-axis offset, supporting absolute offset and percentage relative offset.",paraId:44,tocIndex:9},{value:"rotate",paraId:44,tocIndex:9},{value:"boolean",paraId:44,tocIndex:9},{value:"No",paraId:44,tocIndex:9},{value:"false",paraId:44,tocIndex:9},{value:"Whether to use the element's bounding box rotated with the node, defaulting to not considering the rotation angle.",paraId:44,tocIndex:9},{value:"The bottom-right corner of the element, supporting the following parameters:",paraId:45,tocIndex:10},{value:"Parameter Name",paraId:46,tocIndex:10},{value:"Parameter Type",paraId:46,tocIndex:10},{value:"Required",paraId:46,tocIndex:10},{value:"Default Value",paraId:46,tocIndex:10},{value:"Parameter Description",paraId:46,tocIndex:10},{value:"dx",paraId:46,tocIndex:10},{value:"number | string",paraId:46,tocIndex:10},{value:"No",paraId:46,tocIndex:10},{value:"0",paraId:46,tocIndex:10},{value:"X-axis offset, supporting absolute offset and percentage relative offset.",paraId:46,tocIndex:10},{value:"dy",paraId:46,tocIndex:10},{value:"number | string",paraId:46,tocIndex:10},{value:"No",paraId:46,tocIndex:10},{value:"0",paraId:46,tocIndex:10},{value:"Y-axis offset, supporting absolute offset and percentage relative offset.",paraId:46,tocIndex:10},{value:"rotate",paraId:46,tocIndex:10},{value:"boolean",paraId:46,tocIndex:10},{value:"No",paraId:46,tocIndex:10},{value:"false",paraId:46,tocIndex:10},{value:"Whether to use the element's bounding box rotated with the node, defaulting to not considering the rotation angle.",paraId:46,tocIndex:10},{value:"The orthogonal point, supporting the following parameters:",paraId:47,tocIndex:11},{value:"Parameter Name",paraId:48,tocIndex:11},{value:"Parameter Type",paraId:48,tocIndex:11},{value:"Required",paraId:48,tocIndex:11},{value:"Default Value",paraId:48,tocIndex:11},{value:"Parameter Description",paraId:48,tocIndex:11},{value:"padding",paraId:48,tocIndex:11},{value:"number",paraId:48,tocIndex:11},{value:"No",paraId:48,tocIndex:11},{value:"0",paraId:48,tocIndex:11},{value:"X-axis offset.",paraId:48,tocIndex:11},{value:"The center point of the node, supporting the following parameters:",paraId:49,tocIndex:12},{value:"Parameter Name",paraId:50,tocIndex:12},{value:"Parameter Type",paraId:50,tocIndex:12},{value:"Required",paraId:50,tocIndex:12},{value:"Default Value",paraId:50,tocIndex:12},{value:"Parameter Description",paraId:50,tocIndex:12},{value:"dx",paraId:50,tocIndex:12},{value:"number",paraId:50,tocIndex:12},{value:"No",paraId:50,tocIndex:12},{value:"0",paraId:50,tocIndex:12},{value:"X-axis offset.",paraId:50,tocIndex:12},{value:"dy",paraId:50,tocIndex:12},{value:"number",paraId:50,tocIndex:12},{value:"No",paraId:50,tocIndex:12},{value:"0",paraId:50,tocIndex:12},{value:"Y-axis offset.",paraId:50,tocIndex:12},{value:"An anchor point definition is a function with the following signature, returning an anchor point.",paraId:51,tocIndex:13},{value:"export type Definition<T> = (\n  this: EdgeView,\n  nodeView: NodeView,\n  magnet: SVGElement,\n  ref: Point.PointLike | SVGElement,\n  args: T,\n  type: Edge.TerminalType,\n) => Point\n",paraId:52,tocIndex:13},{value:"Parameter Name",paraId:53,tocIndex:13},{value:"Parameter Type",paraId:53,tocIndex:13},{value:"Parameter Description",paraId:53,tocIndex:13},{value:"this",paraId:53,tocIndex:13},{value:"EdgeView",paraId:53,tocIndex:13},{value:"The edge view.",paraId:53,tocIndex:13},{value:"nodeView",paraId:53,tocIndex:13},{value:"NodeView",paraId:53,tocIndex:13},{value:"The node view.",paraId:53,tocIndex:13},{value:"magnet",paraId:53,tocIndex:13},{value:"SVGElement",paraId:53,tocIndex:13},{value:"The magnet element.",paraId:53,tocIndex:13},{value:"ref",paraId:53,tocIndex:13},{value:"Point.PointLike | SVGElement",paraId:53,tocIndex:13},{value:"The reference point/element.",paraId:53,tocIndex:13},{value:"args",paraId:53,tocIndex:13},{value:"T",paraId:53,tocIndex:13},{value:"The arguments.",paraId:53,tocIndex:13},{value:"type",paraId:53,tocIndex:13},{value:"Edge.TerminalType",paraId:53,tocIndex:13},{value:"The edge terminal type.",paraId:53,tocIndex:13},{value:"After completing the anchor point definition, we register the anchor point:",paraId:54,tocIndex:13},{value:"Graph.registerAnchor('custom-anchor', ...)\n",paraId:55,tocIndex:13},{value:"After registration, we can use the anchor point by name:",paraId:56,tocIndex:13},{value:"new Graph({\n  connecting: {\n    anchor: {\n      name: 'custom-anchor',\n    },\n  },\n})\n",paraId:57,tocIndex:13}]},8897:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(39587);const n=[{value:"Node tools are small components rendered on nodes that typically come with some interactive features, such as a delete button that removes the corresponding node when clicked. We can add or remove tools based on the following scenarios.",paraId:0},{value:'// Add tools when creating a node\ngraph.addNode({\n  ...,\n  tools: [\n    {\n      name: \'button-remove\',\n      args: { x: 10, y: 10 },\n    },\n  ],\n})\n\n// Add tools after creating a node\nnode.addTools([\n  {\n    name: \'button-remove\',\n    args: { x: 10, y: 10 },\n  },\n])\n\n// Remove tool\ngraph.on("node:mouseleave", ({ node }) => {\n  if (node.hasTool("button-remove")) {\n    node.removeTool("button-remove");\n  }\n});\n',paraId:1},{value:"X6 provides the following default tools for nodes:",paraId:2},{value:"button",paraId:3},{value:" Renders a button at a specified position, supporting custom click interactions for the button.",paraId:4},{value:"button-remove",paraId:5},{value:" Renders a delete button at a specified position, which deletes the corresponding node when clicked.",paraId:4},{value:"boundary",paraId:6},{value:" Renders a rectangle surrounding the node based on the node's bounding box. Note that this tool only renders a rectangle and does not provide any interaction.",paraId:4},{value:"node-editor",paraId:7},{value:" Provides text editing functionality for the node.",paraId:4},{value:"Renders a button at a specified position, supporting custom click interactions. The configuration is as follows:",paraId:8,tocIndex:1},{value:"Parameter Name",paraId:9,tocIndex:1},{value:"Type",paraId:9,tocIndex:1},{value:"Default Value",paraId:9,tocIndex:1},{value:"Description",paraId:9,tocIndex:1},{value:"x",paraId:9,tocIndex:1},{value:"number | string",paraId:9,tocIndex:1},{value:"0",paraId:9,tocIndex:1},{value:"The X coordinate relative to the top-left corner of the node, with decimals and percentages indicating relative positions.",paraId:9,tocIndex:1},{value:"y",paraId:9,tocIndex:1},{value:"number | string",paraId:9,tocIndex:1},{value:"0",paraId:9,tocIndex:1},{value:"The Y coordinate relative to the top-left corner of the node, with decimals and percentages indicating relative positions.",paraId:9,tocIndex:1},{value:"offset",paraId:9,tocIndex:1},{value:"number | ",paraId:9,tocIndex:1},{value:"{ x: number, y: number }",paraId:9,tocIndex:1},{value:"0",paraId:9,tocIndex:1},{value:"The offset based on ",paraId:9,tocIndex:1},{value:"x",paraId:9,tocIndex:1},{value:" and ",paraId:9,tocIndex:1},{value:"y",paraId:9,tocIndex:1},{value:".",paraId:9,tocIndex:1},{value:"rotate",paraId:9,tocIndex:1},{value:"boolean",paraId:9,tocIndex:1},{value:"-",paraId:9,tocIndex:1},{value:"Whether to follow the rotation of the node.",paraId:9,tocIndex:1},{value:"useCellGeometry",paraId:9,tocIndex:1},{value:"boolean",paraId:9,tocIndex:1},{value:"true",paraId:9,tocIndex:1},{value:"Whether to use geometric calculations to compute the element's bounding box. Enabling this improves performance; if accuracy issues arise, set it to ",paraId:9,tocIndex:1},{value:"false",paraId:9,tocIndex:1},{value:".",paraId:9,tocIndex:1},{value:"markup",paraId:9,tocIndex:1},{value:"Markup.JSONMarkup",paraId:9,tocIndex:1},{value:"-",paraId:9,tocIndex:1},{value:"The Markup definition for rendering the button.",paraId:9,tocIndex:1},{value:"onClick",paraId:9,tocIndex:1},{value:"(args: {e: Dom.MouseDownEvent, cell: Cell, view: CellView }) => void",paraId:9,tocIndex:1},{value:"-",paraId:9,tocIndex:1},{value:"Callback function for button clicks.",paraId:9,tocIndex:1},{value:"// Add button on mouse hover\ngraph.on('node:mouseenter', ({ node }) => {\n  node.addTools({\n    name: 'button',\n    args: {\n      markup: ...,\n      x: 0,\n      y: 0,\n      offset: { x: 18, y: 18 },\n      onClick({ view }) { ... },\n    },\n  })\n})\n\n// Remove button on mouse leave\ngraph.on('node:mouseleave', ({ node }) => {\n   node.removeTools() // Remove all tools\n})\n",paraId:10,tocIndex:1},{value:"Renders a delete button at a specified position, which deletes the corresponding node when clicked. It is a special case of the ",paraId:11,tocIndex:2},{value:"button",paraId:11,tocIndex:2},{value:" tool, so it supports all configurations of ",paraId:11,tocIndex:2},{value:"button",paraId:11,tocIndex:2},{value:".",paraId:11,tocIndex:2},{value:"const source = graph.addNode({\n  ...,\n  // Add a delete button that is always visible\n  tools: [\n    {\n      name: 'button-remove',\n      args: {\n        x: '100%',\n        y: 0,\n        offset: { x: -10, y: 10 },\n      },\n    },\n  ],\n})\n",paraId:12,tocIndex:2},{value:"Renders a rectangle surrounding the node based on its bounding box. Note that this tool only renders a rectangle without any interaction. The configuration is as follows:",paraId:13,tocIndex:3},{value:"Parameter Name",paraId:14,tocIndex:3},{value:"Type",paraId:14,tocIndex:3},{value:"Default Value",paraId:14,tocIndex:3},{value:"Description",paraId:14,tocIndex:3},{value:"tagName",paraId:14,tocIndex:3},{value:"string",paraId:14,tocIndex:3},{value:"rect",paraId:14,tocIndex:3},{value:"The shape used for rendering.",paraId:14,tocIndex:3},{value:"rotate",paraId:14,tocIndex:3},{value:"boolean",paraId:14,tocIndex:3},{value:"-",paraId:14,tocIndex:3},{value:"Whether the shape follows the rotation of the node.",paraId:14,tocIndex:3},{value:"padding",paraId:14,tocIndex:3},{value:"SideOptions",paraId:14,tocIndex:3},{value:"10",paraId:14,tocIndex:3},{value:"Margin.",paraId:14,tocIndex:3},{value:"attrs",paraId:14,tocIndex:3},{value:"KeyValue",paraId:14,tocIndex:3},{value:"object",paraId:14,tocIndex:3},{value:"Shape attributes.",paraId:14,tocIndex:3},{value:"useCellGeometry",paraId:14,tocIndex:3},{value:"boolean",paraId:14,tocIndex:3},{value:"true",paraId:14,tocIndex:3},{value:"Whether to use geometric calculations to compute the element's bounding box. Enabling this improves performance; if accuracy issues arise, set it to ",paraId:14,tocIndex:3},{value:"false",paraId:14,tocIndex:3},{value:".",paraId:14,tocIndex:3},{value:"The default values (default styles) for ",paraId:15,tocIndex:3},{value:"attrs",paraId:15,tocIndex:3},{value:" are:",paraId:15,tocIndex:3},{value:"{\n  fill: 'none',\n  stroke: '#333',\n  'stroke-width': 0.5,\n  'stroke-dasharray': '5, 5',\n  'pointer-events': 'none',\n}\n",paraId:16,tocIndex:3},{value:"The type definition for ",paraId:17,tocIndex:3},{value:"SideOptions",paraId:17,tocIndex:3},{value:" is as follows:",paraId:17,tocIndex:3},{value:"type SideOptions =\n  | number\n  | {\n      vertical?: number\n      horizontal?: number\n      left?: number\n      top?: number\n      right?: number\n      bottom?: number\n    }\n",paraId:18,tocIndex:3},{value:"The tool usage is as follows:",paraId:19,tocIndex:3},{value:"const source = graph.addNode({\n  ...,\n  tools: [\n    {\n      name: 'boundary',\n      args: {\n        padding: 5,\n        attrs: {\n          fill: '#7c68fc',\n          stroke: '#333',\n          'stroke-width': 1,\n          'fill-opacity': 0.2,\n        },\n      },\n    },\n  ],\n})\n",paraId:20,tocIndex:3},{value:"Provides text editing functionality on the node. The configuration is as follows:",paraId:21,tocIndex:4},{value:"Parameter Name",paraId:22,tocIndex:4},{value:"Type",paraId:22,tocIndex:4},{value:"Default Value",paraId:22,tocIndex:4},{value:"Description",paraId:22,tocIndex:4},{value:"x",paraId:22,tocIndex:4},{value:"number | string",paraId:22,tocIndex:4},{value:"-",paraId:22,tocIndex:4},{value:"The X coordinate relative to the top-left corner of the node, with decimals and percentages indicating relative positions.",paraId:22,tocIndex:4},{value:"y",paraId:22,tocIndex:4},{value:"number | string",paraId:22,tocIndex:4},{value:"-",paraId:22,tocIndex:4},{value:"The Y coordinate relative to the top-left corner of the node, with decimals and percentages indicating relative positions.",paraId:22,tocIndex:4},{value:"attrs/fontSize",paraId:22,tocIndex:4},{value:"string",paraId:22,tocIndex:4},{value:"14",paraId:22,tocIndex:4},{value:"Font size of the edited text.",paraId:22,tocIndex:4},{value:"attrs/color",paraId:22,tocIndex:4},{value:"string",paraId:22,tocIndex:4},{value:"#000",paraId:22,tocIndex:4},{value:"Font color of the edited text.",paraId:22,tocIndex:4},{value:"attrs/fontFamily",paraId:22,tocIndex:4},{value:"string",paraId:22,tocIndex:4},{value:"Arial, helvetica, sans-serif",paraId:22,tocIndex:4},{value:"Font of the edited text.",paraId:22,tocIndex:4},{value:"attrs/backgroundColor",paraId:22,tocIndex:4},{value:"string",paraId:22,tocIndex:4},{value:"#fff",paraId:22,tocIndex:4},{value:"Background color of the editing area.",paraId:22,tocIndex:4},{value:"getText",paraId:22,tocIndex:4},{value:"string | ",paraId:22,tocIndex:4},{value:"(this: CellView, args: {cell: Cell}) => string",paraId:22,tocIndex:4},{value:"-",paraId:22,tocIndex:4},{value:"Method to get the original text; needs to customize ",paraId:22,tocIndex:4},{value:"getText",paraId:22,tocIndex:4},{value:" method in custom ",paraId:22,tocIndex:4},{value:"markup",paraId:22,tocIndex:4},{value:" scenarios.",paraId:22,tocIndex:4},{value:"setText",paraId:22,tocIndex:4},{value:"string | ",paraId:22,tocIndex:4},{value:"(this: CellView, args: {cell: Cell, value: string}) => void",paraId:22,tocIndex:4},{value:"-",paraId:22,tocIndex:4},{value:"Method to set new text; needs to customize ",paraId:22,tocIndex:4},{value:"setText",paraId:22,tocIndex:4},{value:" method in custom ",paraId:22,tocIndex:4},{value:"markup",paraId:22,tocIndex:4},{value:" scenarios.",paraId:22,tocIndex:4},{value:"It is important to note that after version 2.8.0, there is no need to dynamically add tools in the double-click event, and event parameters do not need to be passed.",paraId:23},{value:"// Usage before version 2.8.0\ngraph.on('node:dblclick', ({ node, e }) => {\n  node.addTools({\n    name: 'node-editor',\n    args: {\n      event: e,\n    },\n  })\n})\n\n// Usage after version 2.8.0\nnode.addTools({\n  name: 'node-editor',\n})\n",paraId:24},{value:"It is also important to note that if a custom ",paraId:25},{value:"markup",paraId:25},{value:" is defined in the node, it is often necessary to customize the ",paraId:25},{value:"getText",paraId:25},{value:" and ",paraId:25},{value:"setText",paraId:25},{value:" methods to correctly get and set the edited text. Both configurations support both function and string forms; the function form is easier to understand, while the string form is essentially the property path of the text to be retrieved or set. Generally, it is recommended to use the string form so that the graph data can be fully serialized (since functions cannot be serialized), otherwise, issues may arise with the text editing functionality after rendering the canvas, for example:",paraId:25},{value:"node.addTools({\n  name: 'node-editor',\n  args: {\n    getText: 'a/b',\n    setText: 'c/d',\n  },\n})\n",paraId:26},{value:"The above configuration indicates:",paraId:27},{value:"Get edited text: ",paraId:28},{value:"node.attr('a/b')",paraId:28},{value:"Set edited text: ",paraId:28},{value:"node.attr('c/d', value)",paraId:28},{value:"Inherit from ",paraId:29,tocIndex:6},{value:"ToolItem",paraId:29,tocIndex:6},{value:" to implement a tool class, which is more challenging and requires understanding of the ",paraId:29,tocIndex:6},{value:"ToolItem",paraId:29,tocIndex:6},{value:" class. You can refer to the source code of the built-in tools above; this will not be elaborated here.",paraId:29,tocIndex:6},{value:"Graph.registerNodeTool('button', Button)\n",paraId:30,tocIndex:6},{value:"Inherit from an already registered tool and modify the configuration based on the inheritance. We provide a static method ",paraId:31,tocIndex:7},{value:"define",paraId:31,tocIndex:7},{value:" on the ",paraId:31,tocIndex:7},{value:"ToolItem",paraId:31,tocIndex:7},{value:" base class to quickly implement inheritance and modify configurations.",paraId:31,tocIndex:7},{value:"const MyButton = Button.define<Button.Options>({\n  name: 'my-btn',\n  markup: ...,\n  onClick({ view }) { ... },\n})\n\nGraph.registerNodeTool('my-btn', MyButton, true)\n",paraId:32,tocIndex:7},{value:"Additionally, we provide a quick inheritance implementation for the ",paraId:33,tocIndex:7},{value:"Graph.registerNodeTool",paraId:33,tocIndex:7},{value:" method to specify default options:",paraId:33,tocIndex:7},{value:"Graph.registerNodeTool('my-btn', {\n  inherit: 'button', // Base class name, using the name of the already registered tool.\n  markup: ...,\n  onClick: ...,\n})\n",paraId:34,tocIndex:7}]},60212:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(44417);const n=[{value:"The port label layout algorithm is a function with the following signature, returning the position and rotation angle of the label relative to the port.",paraId:0},{value:"type Definition<T> = (\n  portPosition: Point, // port position\n  elemBBox: Rectangle, // node bounding box\n  args: T, // label position arguments\n) => Result\n\ninterface Result {\n  position: Point.PointLike // label position relative to port\n  angle: number // label rotation angle\n  attrs: Attr.CellAttrs // label attributes\n}\n",paraId:1},{value:"When creating a port, you can specify the label layout in the ",paraId:2},{value:"groups",paraId:2},{value:" or override it in ",paraId:2},{value:"items",paraId:2},{value:":",paraId:2},{value:"graph.addNode(\n  ...,\n  ports: {\n    // port group\n    groups: {\n      group1: {\n        label: {\n          position: {      // label layout algorithm\n            name: 'xxx',   // label layout algorithm name\n            args: { ... }, // label layout algorithm arguments\n          },\n        },\n      },\n    },\n\n    // port definition\n    items: [\n      {\n        groups: 'group1',\n        label: {\n          position: { // override label layout algorithm specified in group1\n            name: 'xxx',\n            args: { ... },\n          }\n        },\n      }\n    ],\n  },\n)\n",paraId:3},{value:"Let's take a look at how to use built-in label layout algorithms and how to define and register custom layout algorithms.",paraId:4},{value:"The label is located on one side of the port.",paraId:5,tocIndex:1},{value:"'left'",paraId:6,tocIndex:1},{value:" The label is located on the left side of the port.",paraId:6,tocIndex:1},{value:"'right'",paraId:6,tocIndex:1},{value:" The label is located on the right side of the port.",paraId:6,tocIndex:1},{value:"'top'",paraId:6,tocIndex:1},{value:" The label is located on the top side of the port.",paraId:6,tocIndex:1},{value:"'bottom'",paraId:6,tocIndex:1},{value:" The label is located on the bottom side of the port.",paraId:6,tocIndex:1},{value:"You can specify the label position and rotation angle through ",paraId:7,tocIndex:1},{value:"args",paraId:7,tocIndex:1},{value:".",paraId:7,tocIndex:1},{value:"interface SideArgs {\n  x?: number\n  y?: number\n  angle?: number\n  attrs?: Attr.CellAttrs\n}\n",paraId:8,tocIndex:1},{value:"Name",paraId:9,tocIndex:1},{value:"Type",paraId:9,tocIndex:1},{value:"Required",paraId:9,tocIndex:1},{value:"Default Value",paraId:9,tocIndex:1},{value:"Description",paraId:9,tocIndex:1},{value:"x",paraId:9,tocIndex:1},{value:"number",paraId:9,tocIndex:1},{value:"-",paraId:9,tocIndex:1},{value:"Replace the calculated X coordinate with the specified value.",paraId:9,tocIndex:1},{value:"y",paraId:9,tocIndex:1},{value:"number",paraId:9,tocIndex:1},{value:"-",paraId:9,tocIndex:1},{value:"Replace the calculated Y coordinate with the specified value.",paraId:9,tocIndex:1},{value:"angle",paraId:9,tocIndex:1},{value:"number",paraId:9,tocIndex:1},{value:"-",paraId:9,tocIndex:1},{value:"Replace the calculated rotation angle with the specified value.",paraId:9,tocIndex:1},{value:"attrs",paraId:9,tocIndex:1},{value:"Attr.CellAttrs",paraId:9,tocIndex:1},{value:"-",paraId:9,tocIndex:1},{value:"Label attributes.",paraId:9,tocIndex:1},{value:"label: {\n  position: {\n    name : 'right',\n    args: {\n      y: 10, // Force the y-coordinate to be 10, replacing the calculated y-coordinate\n      attrs: {\n        text: {\n          fill: 'red', // Set the label color to red\n        },\n      },\n    },\n  },\n}\n",paraId:10,tocIndex:1},{value:"The label is located inside or outside the node, supporting the following four layouts:",paraId:11,tocIndex:2},{value:"'inside'",paraId:12,tocIndex:2},{value:" The label is located inside the node, close to the edge.",paraId:12,tocIndex:2},{value:"'outside'",paraId:12,tocIndex:2},{value:" The label is located outside the node, close to the edge.",paraId:12,tocIndex:2},{value:"'insideOriented'",paraId:12,tocIndex:2},{value:" The label is located inside the node and automatically adjusts the text direction based on the position.",paraId:12,tocIndex:2},{value:"'outsideOriented'",paraId:12,tocIndex:2},{value:" The label is located outside the node and automatically adjusts the text direction based on the position.",paraId:12,tocIndex:2},{value:"You can set the offset from the node center to the label position through ",paraId:13,tocIndex:2},{value:"args.offset",paraId:13,tocIndex:2},{value:".",paraId:13,tocIndex:2},{value:"interface InOutArgs {\n  offset?: number\n  x?: number\n  y?: number\n  angle?: number\n  attrs?: Attr.CellAttrs\n}\n",paraId:14,tocIndex:2},{value:"Name",paraId:15,tocIndex:2},{value:"Type",paraId:15,tocIndex:2},{value:"Required",paraId:15,tocIndex:2},{value:"Default Value",paraId:15,tocIndex:2},{value:"Description",paraId:15,tocIndex:2},{value:"offset",paraId:15,tocIndex:2},{value:"number",paraId:15,tocIndex:2},{value:"15",paraId:15,tocIndex:2},{value:"Offset from the node center to the label position.",paraId:15,tocIndex:2},{value:"x",paraId:15,tocIndex:2},{value:"number",paraId:15,tocIndex:2},{value:"-",paraId:15,tocIndex:2},{value:"Replace the calculated X coordinate with the specified value.",paraId:15,tocIndex:2},{value:"y",paraId:15,tocIndex:2},{value:"number",paraId:15,tocIndex:2},{value:"-",paraId:15,tocIndex:2},{value:"Replace the calculated Y coordinate with the specified value.",paraId:15,tocIndex:2},{value:"angle",paraId:15,tocIndex:2},{value:"number",paraId:15,tocIndex:2},{value:"-",paraId:15,tocIndex:2},{value:"Replace the calculated rotation angle with the specified value.",paraId:15,tocIndex:2},{value:"attrs",paraId:15,tocIndex:2},{value:"Attr.CellAttrs",paraId:15,tocIndex:2},{value:"-",paraId:15,tocIndex:2},{value:"Label attributes.",paraId:15,tocIndex:2},{value:"label: {\n  position: {\n    name : 'outside',\n  },\n}\n",paraId:16,tocIndex:2},{value:"Place the label on the outer circle or ellipse of the node. Supports the following two layouts:",paraId:17,tocIndex:3},{value:"'radial'",paraId:18,tocIndex:3},{value:" The label is located on the outer circle or ellipse of the node.",paraId:18,tocIndex:3},{value:"'radialOriented'",paraId:18,tocIndex:3},{value:" The label is located on the outer circle or ellipse of the node and automatically adjusts the text direction based on the position.",paraId:18,tocIndex:3},{value:"interface RadialArgs {\n  offset?: number\n  x?: number\n  y?: number\n  angle?: number\n  attrs?: Attr.CellAttrs\n}\n",paraId:19,tocIndex:3},{value:"Name",paraId:20,tocIndex:3},{value:"Type",paraId:20,tocIndex:3},{value:"Required",paraId:20,tocIndex:3},{value:"Default Value",paraId:20,tocIndex:3},{value:"Description",paraId:20,tocIndex:3},{value:"offset",paraId:20,tocIndex:3},{value:"number",paraId:20,tocIndex:3},{value:"20",paraId:20,tocIndex:3},{value:"Offset from the node center to the label position.",paraId:20,tocIndex:3},{value:"x",paraId:20,tocIndex:3},{value:"number",paraId:20,tocIndex:3},{value:"-",paraId:20,tocIndex:3},{value:"Replace the calculated X coordinate with the specified value.",paraId:20,tocIndex:3},{value:"y",paraId:20,tocIndex:3},{value:"number",paraId:20,tocIndex:3},{value:"-",paraId:20,tocIndex:3},{value:"Replace the calculated Y coordinate with the specified value.",paraId:20,tocIndex:3},{value:"angle",paraId:20,tocIndex:3},{value:"number",paraId:20,tocIndex:3},{value:"-",paraId:20,tocIndex:3},{value:"Replace the calculated rotation angle with the specified value.",paraId:20,tocIndex:3},{value:"attrs",paraId:20,tocIndex:3},{value:"Attr.CellAttrs",paraId:20,tocIndex:3},{value:"-",paraId:20,tocIndex:3},{value:"Label attributes.",paraId:20,tocIndex:3},{value:"label: {\n  position: {\n    name : 'radial',\n  },\n}\n",paraId:21,tocIndex:3},{value:"The port label layout algorithm is a function with the following signature, returning the position and rotation angle of the label relative to the port.",paraId:22,tocIndex:4},{value:"type Definition<T> = (\n  portPosition: Point, // port position\n  elemBBox: Rectangle, // node bounding box\n  args: T, // label position arguments\n) => Result\n\ninterface Result {\n  position: Point.PointLike // label position relative to port\n  angle: number // label rotation angle\n  attrs: Attr.CellAttrs // label attributes\n}\n",paraId:23,tocIndex:4},{value:"So we can create a custom layout algorithm according to the above rules, for example, implementing a layout that is located at the bottom right of the port:",paraId:24,tocIndex:4},{value:"function bottomRight(portPosition, elemBBox, args) {\n  const dx = args.dx || 10\n  const dy = args.dy || 10\n\n  return {\n    position: {\n      x: portPosition.x + dx,\n      y: portPosition.y + dy,\n    }\n  }\n}\n",paraId:25,tocIndex:4},{value:"After implementing the layout algorithm, we need to register it to the system. After registration, we can use it like built-in layout algorithms.",paraId:26,tocIndex:4},{value:"Graph.registerPortLabelLayout('bottomRight', bottomRight)\n",paraId:27,tocIndex:4},{value:"After registration, we can use it like built-in layout algorithms:",paraId:28,tocIndex:4},{value:"const rect = graph.addNode({\n  ports: {\n    groups: {\n      group1: {\n        position: {\n          name: 'top',\n        },\n        label: {\n          position: {\n            name: 'bottomRight',\n          },\n        },\n      },\n    },\n\n    items: [\n      { id: 'port1', group: 'group1' },\n      { id: 'port2', label: { position: 'bottomRight' } },\n    ],\n  },\n})\n",paraId:29,tocIndex:4}]},35519:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(65937);const n=[{value:"The port layout algorithm is a function with the following signature, which returns the relative position of the port relative to the node. For example, if a node is located at ",paraId:0},{value:"{ x: 30, y: 40 }",paraId:0},{value:" on the canvas, and the returned position of a port is ",paraId:0},{value:"{ x: 2, y: 4 }",paraId:0},{value:", then the port will be rendered at ",paraId:0},{value:"{ x: 32, y: 44 }",paraId:0},{value:" on the canvas.",paraId:0},{value:"type Definition<T> = (\n  portsPositionArgs: T[], // layout algorithm parameters specified in the port\n  elemBBox: Rectangle, // bounding box of the node\n  groupPositionArgs: T, // default layout algorithm parameters defined in the group\n) => Result[]\n\ninterface Result {\n  position: Point.PointLike // relative position to the node\n  angle?: number // rotation angle\n}\n",paraId:1},{value:"Note that when configuring the port ",paraId:2},{value:"ports",paraId:2},{value:", we can only configure the layout algorithm through the ",paraId:2},{value:"groups",paraId:2},{value:" option, and provide optional layout algorithm parameters ",paraId:2},{value:"args",paraId:2},{value:" in ",paraId:2},{value:"items",paraId:2},{value:" to affect the layout result.",paraId:2},{value:"graph.addNode(\n  ...,\n  ports: {\n    // port group\n    groups: {\n      group1: {\n        position: {\n          name: 'xxx', // layout algorithm name\n          args: { },   // default parameters of the layout algorithm\n        },\n      },\n    },\n\n    // port definition\n    items: [\n      {\n        groups: 'group1',\n        args: { }, // override the default parameters specified in group1\n      },\n    ],\n  },\n)\n",paraId:3},{value:"Let's take a look at how to use the built-in port layout algorithms and how to customize and register custom layout algorithms.",paraId:4},{value:"Absolute positioning, specifying the port position through ",paraId:5,tocIndex:1},{value:"args",paraId:5,tocIndex:1},{value:".",paraId:5,tocIndex:1},{value:"interface AbsoluteArgs {\n  x?: string | number\n  y?: string | number\n  angle?: number\n}\n",paraId:6,tocIndex:1},{value:"Name",paraId:7,tocIndex:1},{value:"Type",paraId:7,tocIndex:1},{value:"Required",paraId:7,tocIndex:1},{value:"Default Value",paraId:7,tocIndex:1},{value:"Description",paraId:7,tocIndex:1},{value:"x",paraId:7,tocIndex:1},{value:"string | number",paraId:7,tocIndex:1},{value:"0",paraId:7,tocIndex:1},{value:"Relative position on the X-axis.",paraId:7,tocIndex:1},{value:"y",paraId:7,tocIndex:1},{value:"string | number",paraId:7,tocIndex:1},{value:"0",paraId:7,tocIndex:1},{value:"Relative position on the Y-axis.",paraId:7,tocIndex:1},{value:"angle",paraId:7,tocIndex:1},{value:"number",paraId:7,tocIndex:1},{value:"0",paraId:7,tocIndex:1},{value:"Rotation angle.",paraId:7,tocIndex:1},{value:"When ",paraId:8,tocIndex:1},{value:"x",paraId:8,tocIndex:1},{value:" and ",paraId:8,tocIndex:1},{value:"y",paraId:8,tocIndex:1},{value:" are percentage strings or between ",paraId:8,tocIndex:1},{value:"[0, 1]",paraId:8,tocIndex:1},{value:", they represent the percentage offset in the width and height directions, otherwise, they represent absolute offsets.",paraId:8,tocIndex:1},{value:"graph.addNode({\n  ports: {\n    groups: {\n      group1: {\n        position: {\n          name: 'absolute',\n          args: { x: 0, y: 0 },\n        },\n      },\n    },\n    items: [\n      {\n        group: 'group1',\n        args: {\n          x: '60%',\n          y: 32,\n          angle: 45,\n        },\n      },\n    ],\n  },\n})\n",paraId:9,tocIndex:1},{value:"Ports are evenly distributed along the specified edge of the rectangle, and ",paraId:10,tocIndex:2},{value:"left",paraId:10,tocIndex:2},{value:", ",paraId:10,tocIndex:2},{value:"right",paraId:10,tocIndex:2},{value:", ",paraId:10,tocIndex:2},{value:"top",paraId:10,tocIndex:2},{value:", and ",paraId:10,tocIndex:2},{value:"bottom",paraId:10,tocIndex:2},{value:" are four layout algorithms that are very friendly to rectangular nodes. You can set the offset and rotation angle through ",paraId:10,tocIndex:2},{value:"args",paraId:10,tocIndex:2},{value:".",paraId:10,tocIndex:2},{value:"interface SideArgs {\n  dx?: number\n  dy?: number\n  angle?: number\n  x?: number\n  y?: number\n}\n",paraId:11,tocIndex:2},{value:"Name",paraId:12,tocIndex:2},{value:"Type",paraId:12,tocIndex:2},{value:"Required",paraId:12,tocIndex:2},{value:"Default Value",paraId:12,tocIndex:2},{value:"Description",paraId:12,tocIndex:2},{value:"strict",paraId:12,tocIndex:2},{value:"boolean",paraId:12,tocIndex:2},{value:"false",paraId:12,tocIndex:2},{value:"Whether to strictly distribute evenly.",paraId:12,tocIndex:2},{value:"dx",paraId:12,tocIndex:2},{value:"number",paraId:12,tocIndex:2},{value:"0",paraId:12,tocIndex:2},{value:"Offset in the X-axis direction.",paraId:12,tocIndex:2},{value:"dy",paraId:12,tocIndex:2},{value:"number",paraId:12,tocIndex:2},{value:"0",paraId:12,tocIndex:2},{value:"Offset in the Y-axis direction.",paraId:12,tocIndex:2},{value:"angle",paraId:12,tocIndex:2},{value:"number",paraId:12,tocIndex:2},{value:"0",paraId:12,tocIndex:2},{value:"Rotation angle.",paraId:12,tocIndex:2},{value:"x",paraId:12,tocIndex:2},{value:"number",paraId:12,tocIndex:2},{value:"-",paraId:12,tocIndex:2},{value:"Override the calculated X-coordinate with the specified value.",paraId:12,tocIndex:2},{value:"y",paraId:12,tocIndex:2},{value:"number",paraId:12,tocIndex:2},{value:"-",paraId:12,tocIndex:2},{value:"Override the calculated Y-coordinate with the specified value.",paraId:12,tocIndex:2},{value:"graph.addNode({\n  ports: {\n    groups: {\n      group1: {\n        position: 'left',\n      },\n    },\n    items: [\n      {\n        group: 'group1',\n        args: {\n          dx: 2,\n        },\n      },\n    ],\n  },\n})\n",paraId:13,tocIndex:2},{value:"Ports are evenly distributed along the line segment.",paraId:14,tocIndex:3},{value:"interface LineArgs {\n  start?: Point.PointLike\n  end?: Point.PointLike\n  dx?: number\n  dy?: number\n  angle?: number\n  x?: number\n  y?: number\n}\n",paraId:15,tocIndex:3},{value:"Name",paraId:16,tocIndex:3},{value:"Type",paraId:16,tocIndex:3},{value:"Required",paraId:16,tocIndex:3},{value:"Default Value",paraId:16,tocIndex:3},{value:"Description",paraId:16,tocIndex:3},{value:"start",paraId:16,tocIndex:3},{value:"Point.PointLike",paraId:16,tocIndex:3},{value:"Start point of the line segment.",paraId:16,tocIndex:3},{value:"end",paraId:16,tocIndex:3},{value:"Point.PointLike",paraId:16,tocIndex:3},{value:"End point of the line segment.",paraId:16,tocIndex:3},{value:"strict",paraId:16,tocIndex:3},{value:"boolean",paraId:16,tocIndex:3},{value:"false",paraId:16,tocIndex:3},{value:"Whether to strictly distribute evenly.",paraId:16,tocIndex:3},{value:"dx",paraId:16,tocIndex:3},{value:"number",paraId:16,tocIndex:3},{value:"0",paraId:16,tocIndex:3},{value:"Offset in the X-axis direction.",paraId:16,tocIndex:3},{value:"dy",paraId:16,tocIndex:3},{value:"number",paraId:16,tocIndex:3},{value:"0",paraId:16,tocIndex:3},{value:"Offset in the Y-axis direction.",paraId:16,tocIndex:3},{value:"angle",paraId:16,tocIndex:3},{value:"number",paraId:16,tocIndex:3},{value:"0",paraId:16,tocIndex:3},{value:"Rotation angle.",paraId:16,tocIndex:3},{value:"x",paraId:16,tocIndex:3},{value:"number",paraId:16,tocIndex:3},{value:"-",paraId:16,tocIndex:3},{value:"Override the calculated X-coordinate with the specified value.",paraId:16,tocIndex:3},{value:"y",paraId:16,tocIndex:3},{value:"number",paraId:16,tocIndex:3},{value:"-",paraId:16,tocIndex:3},{value:"Override the calculated Y-coordinate with the specified value.",paraId:16,tocIndex:3},{value:"graph.addNode({\n  ports: {\n    groups: {\n      group1: {\n        position: {\n          name: 'line',\n          args: {\n            start: { x: 10, y: 10 },\n            end: { x: 210, y: 10 },\n          },\n        },\n      },\n    },\n    items: [\n      {\n        group: 'group1',\n        args: {\n          dx: 2,\n        },\n      },\n    ],\n  },\n})\n",paraId:17,tocIndex:3},{value:"Ports are distributed along the ellipse, starting from the ",paraId:18,tocIndex:4},{value:"start",paraId:18,tocIndex:4},{value:" angle, with a step size of ",paraId:18,tocIndex:4},{value:"step",paraId:18,tocIndex:4},{value:".",paraId:18,tocIndex:4},{value:"interface EllipseArgs {\n  start?: number\n  step?: number\n  compensateRotate?: boolean\n  dr?: number\n  dx?: number\n  dy?: number\n  angle?: number\n  x?: number\n  y?: number\n}\n",paraId:19,tocIndex:4},{value:"Name",paraId:20,tocIndex:4},{value:"Type",paraId:20,tocIndex:4},{value:"Required",paraId:20,tocIndex:4},{value:"Default Value",paraId:20,tocIndex:4},{value:"Description",paraId:20,tocIndex:4},{value:"start",paraId:20,tocIndex:4},{value:"number",paraId:20,tocIndex:4},{value:"Start angle.",paraId:20,tocIndex:4},{value:"step",paraId:20,tocIndex:4},{value:"number",paraId:20,tocIndex:4},{value:"20",paraId:20,tocIndex:4},{value:"Step size.",paraId:20,tocIndex:4},{value:"compensateRotate",paraId:20,tocIndex:4},{value:"number",paraId:20,tocIndex:4},{value:"false",paraId:20,tocIndex:4},{value:"Whether to compensate for the rotation angle of the ellipse.",paraId:20,tocIndex:4},{value:"dr",paraId:20,tocIndex:4},{value:"number",paraId:20,tocIndex:4},{value:"0",paraId:20,tocIndex:4},{value:"Offset in the radial direction.",paraId:20,tocIndex:4},{value:"dx",paraId:20,tocIndex:4},{value:"number",paraId:20,tocIndex:4},{value:"0",paraId:20,tocIndex:4},{value:"Offset in the X-axis direction.",paraId:20,tocIndex:4},{value:"dy",paraId:20,tocIndex:4},{value:"number",paraId:20,tocIndex:4},{value:"0",paraId:20,tocIndex:4},{value:"Offset in the Y-axis direction.",paraId:20,tocIndex:4},{value:"angle",paraId:20,tocIndex:4},{value:"number",paraId:20,tocIndex:4},{value:"0",paraId:20,tocIndex:4},{value:"Rotation angle.",paraId:20,tocIndex:4},{value:"x",paraId:20,tocIndex:4},{value:"number",paraId:20,tocIndex:4},{value:"-",paraId:20,tocIndex:4},{value:"Override the calculated X-coordinate with the specified value.",paraId:20,tocIndex:4},{value:"y",paraId:20,tocIndex:4},{value:"number",paraId:20,tocIndex:4},{value:"-",paraId:20,tocIndex:4},{value:"Override the calculated Y-coordinate with the specified value.",paraId:20,tocIndex:4},{value:"const node = graph.addNode({\n  ports: {\n    groups: {\n      group1: {\n        position: {\n          name: 'ellipse',\n          args: {\n            start: 45,\n          },\n        },\n      },\n    },\n  },\n})\n\nArray.from({ length: 10 }).forEach((_, index) => {\n  node.addPort({\n    id: `${index}`,\n    group: 'group1',\n    attrs: { text: { text: index } },\n  })\n})\n",paraId:21,tocIndex:4},{value:"Uniformly distributes connection points along an ellipse, starting from the specified angle ",paraId:22,tocIndex:5},{value:"start",paraId:22,tocIndex:5},{value:".",paraId:22,tocIndex:5},{value:"interface EllipseSpreadArgs {\n  start?: number\n  compensateRotate?: boolean\n  dr?: number\n  dx?: number\n  dy?: number\n  angle?: number\n  x?: number\n  y?: number\n}\n",paraId:23,tocIndex:5},{value:"Name",paraId:24,tocIndex:5},{value:"Type",paraId:24,tocIndex:5},{value:"Required",paraId:24,tocIndex:5},{value:"Default Value",paraId:24,tocIndex:5},{value:"Description",paraId:24,tocIndex:5},{value:"start",paraId:24,tocIndex:5},{value:"number",paraId:24,tocIndex:5},{value:"Starting angle.",paraId:24,tocIndex:5},{value:"compensateRotate",paraId:24,tocIndex:5},{value:"number",paraId:24,tocIndex:5},{value:"false",paraId:24,tocIndex:5},{value:"Whether to adjust the rotation angle of the connection points along the arc.",paraId:24,tocIndex:5},{value:"dr",paraId:24,tocIndex:5},{value:"number",paraId:24,tocIndex:5},{value:"0",paraId:24,tocIndex:5},{value:"Offset along the radial direction.",paraId:24,tocIndex:5},{value:"dx",paraId:24,tocIndex:5},{value:"number",paraId:24,tocIndex:5},{value:"0",paraId:24,tocIndex:5},{value:"Offset along the X-axis direction.",paraId:24,tocIndex:5},{value:"dy",paraId:24,tocIndex:5},{value:"number",paraId:24,tocIndex:5},{value:"0",paraId:24,tocIndex:5},{value:"Offset along the Y-axis direction.",paraId:24,tocIndex:5},{value:"angle",paraId:24,tocIndex:5},{value:"number",paraId:24,tocIndex:5},{value:"0",paraId:24,tocIndex:5},{value:"Rotation angle of the connection points.",paraId:24,tocIndex:5},{value:"x",paraId:24,tocIndex:5},{value:"number",paraId:24,tocIndex:5},{value:"-",paraId:24,tocIndex:5},{value:"Override the X-coordinate of the calculated result with a specified X-coordinate.",paraId:24,tocIndex:5},{value:"y",paraId:24,tocIndex:5},{value:"number",paraId:24,tocIndex:5},{value:"-",paraId:24,tocIndex:5},{value:"Override the Y-coordinate of the calculated result with a specified Y-coordinate.",paraId:24,tocIndex:5},{value:"const node = graph.addNode({\n  ports: {\n    groups: {\n      group1: {\n        position: {\n          name: 'ellipseSpread',\n          args: {\n            start: 45,\n          },\n        },\n      },\n    },\n  },\n})\n\nArray.from({ length: 36 }).forEach(function (_, index) {\n  ellipse.addPort({\n    group: 'group1',\n    id: `${index}`,\n    attrs: { text: { text: index } },\n  })\n})\n",paraId:25,tocIndex:5},{value:"A connection point layout algorithm is a function with the following signature, which returns the relative position of each connection point relative to the node. For example, if a node is located at ",paraId:26,tocIndex:6},{value:"{ x: 30, y: 40 }",paraId:26,tocIndex:6},{value:" on the canvas, and the returned position of a connection point is ",paraId:26,tocIndex:6},{value:"{ x: 2, y: 4 }",paraId:26,tocIndex:6},{value:", then the rendered position of the connection point on the canvas would be ",paraId:26,tocIndex:6},{value:"{ x: 32, y: 44 }",paraId:26,tocIndex:6},{value:".",paraId:26,tocIndex:6},{value:"type Definition<T> = (\n  portsPositionArgs: T[], // Layout algorithm parameters specified in the connection points\n  elemBBox: Rectangle, // Node bounding box\n  groupPositionArgs: T, // Default layout algorithm parameters defined in the group\n) => Result[]\n\ninterface Result {\n  position: Point.PointLike // Relative position to the node\n  angle?: number // Rotation angle\n}\n",paraId:27,tocIndex:6},{value:"We can create a custom layout algorithm according to the above rules, for example, implementing a sine distribution layout algorithm:",paraId:28,tocIndex:6},{value:"function sin(portsPositionArgs, elemBBox) {\n  return portsPositionArgs.map((_, index) => {\n    const step = -Math.PI / 8\n    const y = Math.sin(index * step) * 50\n    return {\n      position: {\n        x: index * 12,\n        y: y + elemBBox.height,\n      },\n      angle: 0,\n    }\n  })\n}\n",paraId:29,tocIndex:6},{value:"After implementing the layout algorithm, we need to register it to the system. After registration, we can use it like the built-in layout algorithms.",paraId:30,tocIndex:6},{value:"Graph.registerPortLayout('sin', sin)\n",paraId:31,tocIndex:6},{value:"After registration, we can use it like the built-in layout algorithms:",paraId:32,tocIndex:6},{value:"const rect = graph.addNode({\n  ports: {\n    groups: {\n      sin: {\n        position: {\n          name: 'sin',\n          args: {\n            start: 45,\n          },\n        },\n        attrs: {\n          rect: {\n            fill: '#fe854f',\n            width: 11,\n          },\n          text: {\n            fill: '#fe854f',\n          },\n          circle: {\n            fill: '#fe854f',\n            r: 5,\n            magnet: true,\n          },\n        },\n      },\n    },\n  },\n})\n\nArray.from({ length: 24 }).forEach(() => {\n  rect.addPort({ group: 'sin' })\n})\n",paraId:33,tocIndex:6}]},82066:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(45617);const n=[{value:"Routing further processes the edge's waypoints ",paraId:0},{value:"vertices",paraId:1},{value:", adding additional points when necessary, and then returns the processed points (excluding the start and end points of the edge). For example, after ",paraId:0},{value:"orth",paraId:2},{value:" routing, each segment of the edge is a horizontal or vertical orthogonal segment.",paraId:0},{value:"X6 has the following built-in routing options.",paraId:3},{value:"Routing Name",paraId:4},{value:"Description",paraId:4},{value:"normal",paraId:4},{value:"Default routing",paraId:5},{value:", returns the waypoints as they are.",paraId:4},{value:"orth",paraId:4},{value:"Orthogonal routing",paraId:6},{value:", composed of horizontal or vertical orthogonal segments.",paraId:4},{value:"oneSide",paraId:4},{value:"Restricted orthogonal routing",paraId:7},{value:", composed of three restricted horizontal or vertical orthogonal segments.",paraId:4},{value:"manhattan",paraId:4},{value:"Smart orthogonal routing",paraId:8},{value:", composed of horizontal or vertical orthogonal segments that automatically avoid other nodes (obstacles) on the path.",paraId:4},{value:"metro",paraId:4},{value:"Smart subway line routing",paraId:9},{value:", composed of horizontal or vertical orthogonal segments and diagonal segments, similar to a subway map, and automatically avoids other nodes (obstacles) on the path.",paraId:4},{value:"er",paraId:4},{value:"Entity-relationship routing",paraId:10},{value:", composed of zigzag diagonal segments.",paraId:4},{value:"When using, you can set the routing for an edge:",paraId:11},{value:"const edge = graph.addEdge({\n  source,\n  target,\n  router: {\n    name: 'oneSide',\n    args: {\n      side: 'right',\n    },\n  },\n})\n",paraId:12},{value:"When the router has no parameters, it can also be simplified to:",paraId:13},{value:"const edge = graph.addEdge({\n  source,\n  target,\n  router: 'oneSide',\n})\n",paraId:14},{value:"You can also call the ",paraId:15},{value:"edge.setRouter",paraId:16},{value:" method to set the routing:",paraId:15},{value:"edge.setRouter('oneSide', { side: 'right' })\n",paraId:17},{value:"When creating a canvas, you can set a global default routing through the ",paraId:18},{value:"connecting",paraId:18},{value:" option (the default routing for the canvas is ",paraId:18},{value:"'normal'",paraId:18},{value:"):",paraId:18},{value:"new Graph({\n  connecting: {\n    router: {\n      name: 'oneSide',\n      args: {\n        side: 'right',\n      },\n    },\n  },\n})\n",paraId:19},{value:"When the router has no parameters, it can also be simplified to:",paraId:20},{value:"new Graph({\n  connecting: {\n    router: 'orth',\n  },\n})\n",paraId:21},{value:"Now let's take a look at how to use the built-in routing and how to define and register custom routing.",paraId:22},{value:"The system's default routing, which returns the input ",paraId:23,tocIndex:1},{value:"vertices",paraId:23,tocIndex:1},{value:" path points as is.",paraId:23,tocIndex:1},{value:"Orthogonal routing, which adds extra points along the path to ensure that each line segment of the edge is horizontally or vertically orthogonal.",paraId:24,tocIndex:2},{value:"The supported parameters are as follows:",paraId:25,tocIndex:2},{value:"Parameter Name",paraId:26,tocIndex:2},{value:"Parameter Type",paraId:26,tocIndex:2},{value:"Required",paraId:26,tocIndex:2},{value:"Default Value",paraId:26,tocIndex:2},{value:"Description",paraId:26,tocIndex:2},{value:"padding",paraId:26,tocIndex:2},{value:"SideOptions",paraId:26,tocIndex:2},{value:"No",paraId:26,tocIndex:2},{value:"20",paraId:26,tocIndex:2},{value:"Sets the minimum distance from the anchor point to the corner.",paraId:26,tocIndex:2},{value:"SideOptions",paraId:27,tocIndex:2},{value:" is defined as follows:",paraId:27,tocIndex:2},{value:"export type SideOptions =\n  | number\n  | {\n      vertical?: number\n      horizontal?: number\n      left?: number\n      top?: number\n      right?: number\n      bottom?: number\n    }\n",paraId:28,tocIndex:2},{value:"For example:",paraId:29,tocIndex:2},{value:"graph.addEdge({\n  source,\n  target,\n  vertices: [\n    { x: 100, y: 200 },\n    { x: 300, y: 120 },\n  ],\n  router: {\n    name: 'orth',\n    args: {\n      padding: {\n        left: 50,\n      },\n    },\n  },\n})\n",paraId:30,tocIndex:2},{value:"The ",paraId:31,tocIndex:3},{value:"oneSide",paraId:31,tocIndex:3},{value:" routing is a restricted version of the orthogonal routing ",paraId:31,tocIndex:3},{value:"orth",paraId:31,tocIndex:3},{value:", which generates a strict three-segment route: starting from the ",paraId:31,tocIndex:3},{value:"side",paraId:31,tocIndex:3},{value:" side of the starting node, passing through the middle segment, and ending at the ",paraId:31,tocIndex:3},{value:"side",paraId:31,tocIndex:3},{value:" side of the target node. It is important to note that when using this routing, do not specify ",paraId:31,tocIndex:3},{value:"vertices",paraId:31,tocIndex:3},{value:" at the same time, as it will result in poor routing performance.",paraId:31,tocIndex:3},{value:"The supported parameters are as follows:",paraId:32,tocIndex:3},{value:"Parameter Name",paraId:33,tocIndex:3},{value:"Parameter Type",paraId:33,tocIndex:3},{value:"Required",paraId:33,tocIndex:3},{value:"Default Value",paraId:33,tocIndex:3},{value:"Description",paraId:33,tocIndex:3},{value:"side",paraId:33,tocIndex:3},{value:"'left'",paraId:33,tocIndex:3},{value:" | ",paraId:33,tocIndex:3},{value:"'right'",paraId:33,tocIndex:3},{value:" | ",paraId:33,tocIndex:3},{value:"'top'",paraId:33,tocIndex:3},{value:" | ",paraId:33,tocIndex:3},{value:"'bottom'",paraId:33,tocIndex:3},{value:"No",paraId:33,tocIndex:3},{value:"'bottom'",paraId:33,tocIndex:3},{value:"The starting/ending direction of the route, default is ",paraId:33,tocIndex:3},{value:"'bottom'",paraId:33,tocIndex:3},{value:".",paraId:33,tocIndex:3},{value:"padding",paraId:33,tocIndex:3},{value:"SideOptions",paraId:33,tocIndex:3},{value:"No",paraId:33,tocIndex:3},{value:"20",paraId:33,tocIndex:3},{value:"Sets the minimum distance from the anchor point to the corner.",paraId:33,tocIndex:3},{value:"For example:",paraId:34,tocIndex:3},{value:"graph.addEdge({\n  source,\n  target,\n  router: {\n    name: 'oneSide',\n    args: { side: 'right' },\n  },\n})\n",paraId:35,tocIndex:3},{value:"The Manhattan routing ",paraId:36,tocIndex:4},{value:"manhattan",paraId:36,tocIndex:4},{value:" is an intelligent version of the orthogonal routing ",paraId:36,tocIndex:4},{value:"orth",paraId:36,tocIndex:4},{value:", consisting of horizontal or vertical orthogonal line segments that automatically avoid other nodes (obstacles) along the path.",paraId:36,tocIndex:4},{value:"We provide a rich set of options for this routing algorithm:",paraId:37,tocIndex:4},{value:"Parameter Name",paraId:38,tocIndex:4},{value:"Parameter Type",paraId:38,tocIndex:4},{value:"Required",paraId:38,tocIndex:4},{value:"Default Value",paraId:38,tocIndex:4},{value:"Description",paraId:38,tocIndex:4},{value:"step",paraId:38,tocIndex:4},{value:"number",paraId:38,tocIndex:4},{value:"No",paraId:38,tocIndex:4},{value:"10",paraId:38,tocIndex:4},{value:"The step length of the routing algorithm; smaller values increase computation. It is recommended to use the canvas grid size.",paraId:38,tocIndex:4},{value:"excludeTerminals",paraId:38,tocIndex:4},{value:"('source' | 'target')[]",paraId:38,tocIndex:4},{value:"No",paraId:38,tocIndex:4},{value:"[]",paraId:38,tocIndex:4},{value:"Ignore starting or ending nodes; ignored nodes will not be considered as obstacles.",paraId:38,tocIndex:4},{value:"excludeShapes",paraId:38,tocIndex:4},{value:"string[]",paraId:38,tocIndex:4},{value:"No",paraId:38,tocIndex:4},{value:"[]",paraId:38,tocIndex:4},{value:"Ignore specified shape nodes; ignored nodes will not be considered as obstacles.",paraId:38,tocIndex:4},{value:"excludeNodes",paraId:38,tocIndex:4},{value:"(Node | string)[]",paraId:38,tocIndex:4},{value:"No",paraId:38,tocIndex:4},{value:"[]",paraId:38,tocIndex:4},{value:"Nodes to ignore; ignored nodes will not be considered as obstacles.",paraId:38,tocIndex:4},{value:"startDirections",paraId:38,tocIndex:4},{value:"string[]",paraId:38,tocIndex:4},{value:"No",paraId:38,tocIndex:4},{value:"['top', 'right', 'bottom', 'left']",paraId:38,tocIndex:4},{value:"Supported directions to start routing.",paraId:38,tocIndex:4},{value:"endDirections",paraId:38,tocIndex:4},{value:"string[]",paraId:38,tocIndex:4},{value:"No",paraId:38,tocIndex:4},{value:"['top', 'right', 'bottom', 'left']",paraId:38,tocIndex:4},{value:"Supported directions to end routing.",paraId:38,tocIndex:4},{value:"padding",paraId:38,tocIndex:4},{value:"SideOptions",paraId:38,tocIndex:4},{value:"No",paraId:38,tocIndex:4},{value:"-",paraId:38,tocIndex:4},{value:"Sets the minimum distance from the anchor point to the corner.",paraId:38,tocIndex:4},{value:"fallbackRouter",paraId:38,tocIndex:4},{value:"Router",paraId:38,tocIndex:4},{value:"No",paraId:38,tocIndex:4},{value:"Registry.Router.presets.orth",paraId:38,tocIndex:4},{value:"In scenarios where obstacles cannot be avoided, downgrade to the specified routing.",paraId:38,tocIndex:4},{value:"For example:",paraId:39,tocIndex:4},{value:"graph.addEdge({\n  source,\n  target,\n  router: {\n    name: 'manhattan',\n    args: {\n      startDirections: ['top'],\n      endDirections: ['bottom'],\n    },\n  },\n})\n",paraId:40,tocIndex:4},{value:"When using the ",paraId:41,tocIndex:4},{value:"manhattan",paraId:41,tocIndex:4},{value:" router together with the ",paraId:41,tocIndex:4},{value:"Selection",paraId:41,tocIndex:4},{value:" plugin, if batch dragging multiple nodes causes performance lag, it is recommended to enable temporary routing downgrade in the ",paraId:41,tocIndex:4},{value:"Selection",paraId:41,tocIndex:4},{value:" configuration by setting ",paraId:41,tocIndex:4},{value:"movingRouterFallback: 'orth'",paraId:41,tocIndex:4},{value:". This temporarily switches edges connected to the selected nodes to the lightweight ",paraId:41,tocIndex:4},{value:"orth",paraId:41,tocIndex:4},{value:" router during dragging, reduces frequent path recalculations, and restores the original routers after idle:",paraId:41,tocIndex:4},{value:"graph.use(\n  new Selection({\n    // Switch router during dragging to orth\n    movingRouterFallback: 'orth',\n  }),\n)\n",paraId:42,tocIndex:4},{value:"The characteristic of the manhattan routing is to automatically avoid obstacles in the path. If an unavoidable situation arises, it will automatically downgrade to the orth routing. In this case, to help developers identify the issue, a warning will be logged in the console: Unable to execute manhattan algorithm, use orth instead.",paraId:43},{value:"The metro routing ",paraId:44,tocIndex:5},{value:"metro",paraId:44,tocIndex:5},{value:" is a variant of the Manhattan routing ",paraId:44,tocIndex:5},{value:"manhattan",paraId:44,tocIndex:5},{value:", consisting of horizontal or vertical orthogonal line segments and diagonal segments, similar to a subway map, and automatically avoids other nodes (obstacles) along the path. Its options are the same as ",paraId:44,tocIndex:5},{value:"manhattan",paraId:45,tocIndex:5},{value:", but the default value of ",paraId:44,tocIndex:5},{value:"maxDirectionChange",paraId:44,tocIndex:5},{value:" is ",paraId:44,tocIndex:5},{value:"45",paraId:44,tocIndex:5},{value:", indicating that the maximum slope angle of the routing line segment is ",paraId:44,tocIndex:5},{value:"45",paraId:44,tocIndex:5},{value:" degrees.",paraId:44,tocIndex:5},{value:"For example:",paraId:46,tocIndex:5},{value:"graph.addEdge({\n  source,\n  target,\n  router: {\n    name: 'metro',\n    args: {\n      startDirections: ['top'],\n      endDirections: ['bottom'],\n    },\n  },\n})\n",paraId:47,tocIndex:5},{value:"The entity-relationship routing ",paraId:48,tocIndex:6},{value:"er",paraId:48,tocIndex:6},{value:" consists of zigzag diagonal segments, commonly used to represent connections between entities in an ER diagram.",paraId:48,tocIndex:6},{value:"The supported parameters are as follows:",paraId:49,tocIndex:6},{value:"Parameter Name",paraId:50,tocIndex:6},{value:"Parameter Type",paraId:50,tocIndex:6},{value:"Required",paraId:50,tocIndex:6},{value:"Default Value",paraId:50,tocIndex:6},{value:"Description",paraId:50,tocIndex:6},{value:"offset",paraId:50,tocIndex:6},{value:"number | 'center'",paraId:50,tocIndex:6},{value:"No",paraId:50,tocIndex:6},{value:"32",paraId:50,tocIndex:6},{value:"The distance between the first and last points of the route and the nodes. When set to ",paraId:50,tocIndex:6},{value:"'center'",paraId:50,tocIndex:6},{value:", the center of the node is used as the route point coordinate.",paraId:50,tocIndex:6},{value:"min",paraId:50,tocIndex:6},{value:"number",paraId:50,tocIndex:6},{value:"No",paraId:50,tocIndex:6},{value:"16",paraId:50,tocIndex:6},{value:"The minimum distance between the first and last points of the route and the nodes.",paraId:50,tocIndex:6},{value:"direction",paraId:50,tocIndex:6},{value:"'T'",paraId:50,tocIndex:6},{value:" | ",paraId:50,tocIndex:6},{value:"'B'",paraId:50,tocIndex:6},{value:" | ",paraId:50,tocIndex:6},{value:"'L'",paraId:50,tocIndex:6},{value:" | ",paraId:50,tocIndex:6},{value:"'R'",paraId:50,tocIndex:6},{value:" | ",paraId:50,tocIndex:6},{value:"'H'",paraId:50,tocIndex:6},{value:" | ",paraId:50,tocIndex:6},{value:"'V'",paraId:50,tocIndex:6},{value:"No",paraId:50,tocIndex:6},{value:"-",paraId:50,tocIndex:6},{value:"The routing direction; if omitted, the optimal direction will be automatically selected.",paraId:50,tocIndex:6},{value:"For example:",paraId:51,tocIndex:6},{value:"graph.addEdge({\n  source,\n  target,\n  router: {\n    name: 'er',\n    args: {\n      offset: 24,\n    },\n  },\n})\n",paraId:52,tocIndex:6},{value:"In addition to built-in routing, we can also create custom routing according to certain rules, for example, implementing random routing:",paraId:53,tocIndex:7},{value:"// Routing parameters\ninterface RandomRouterArgs {\n  bounces?: number\n}\n\nfunction randomRouter(\n  vertices: Point.PointLike[],\n  args: RandomRouterArgs,\n  view: EdgeView,\n) {\n  const bounces = args.bounces || 20\n  const points = vertices.map((p) => Point.create(p))\n\n  for (var i = 0; i < bounces; i++) {\n    const sourceCorner = view.sourceBBox.getCenter()\n    const targetCorner = view.targetBBox.getCenter()\n    const randomPoint = Point.random(\n      sourceCorner.x,\n      targetCorner.x,\n      sourceCorner.y,\n      targetCorner.y,\n    )\n    points.push(randomPoint)\n  }\n\n  return points\n}\n\nGraph.registerRouter('random', randomRouter)\nedge.setRouter('random', { bounces: 3 })\n",paraId:54,tocIndex:7}]},62661:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(94164);const n=[{value:"X6 is a graph editing engine based on HTML and SVG, offering low-cost customization capabilities and out-of-the-box built-in extensions, making it easy for us to quickly build applications such as DAG diagrams, ER diagrams, flowcharts, and lineage graphs.",paraId:0},{value:"If you haven't used X6 yet, we recommend experiencing its charm through the ",paraId:1},{value:"Getting Started Guide",paraId:2},{value:".",paraId:1},{value:"  Highly Customizable: Supports customizing node styles and interactions using SVG/HTML/React/Vue.",paraId:3,tocIndex:0},{value:"  Ready to Use: Comes with 10+ built-in graph editing extensions, such as selection, alignment lines, mini-map, etc.",paraId:3,tocIndex:0},{value:"  Data-Driven: Based on MVC architecture, allowing users to focus more on data logic and business logic.",paraId:3,tocIndex:0},{value:"  Event-Driven: Can listen to any events occurring within the graph.",paraId:3,tocIndex:0},{value:"Getting Started",paraId:4,tocIndex:1},{value:"Basics",paraId:5,tocIndex:1},{value:"Advanced",paraId:6,tocIndex:1},{value:"Plugins",paraId:7,tocIndex:1},{value:"API",paraId:8,tocIndex:1},{value:"The X6 documentation is divided into two parts: documentation and API. It is recommended to read the documentation carefully, as it will help you get started with development. The API documentation is extensive, so you can refer to it when you encounter issues by searching for the relevant documents.",paraId:9,tocIndex:1},{value:"If you have any questions, suggestions, feedback, or wish to communicate, you can contact us through the following methods:",paraId:10,tocIndex:2},{value:"Official Recommendation: ",paraId:11,tocIndex:2},{value:"GitHub issues",paraId:11,tocIndex:2},{value:"Yuque Column: ",paraId:11,tocIndex:2},{value:"https://www.yuque.com/antv/blog",paraId:11,tocIndex:2},{value:"If you encounter any issues while using, please check ",paraId:12,tocIndex:4},{value:"issues",paraId:12,tocIndex:4},{value:" to see if there are similar bugs or suggestions. Before reporting a bug, please ensure you have searched existing issues and read our ",paraId:12,tocIndex:4},{value:"FAQ",paraId:12,tocIndex:4},{value:".",paraId:12,tocIndex:4},{value:"We have a ",paraId:13,tocIndex:5},{value:"Code of Conduct",paraId:13,tocIndex:5},{value:" that we hope all contributors will adhere to. Please take the time to read it to understand what is acceptable and what is not.",paraId:13,tocIndex:5},{value:"You can also refer to the contribution guidelines below to become a contributor to X6 step by step:",paraId:14,tocIndex:6},{value:"How to Participate in X6 Open Source Development",paraId:15,tocIndex:6},{value:"How to Contribute Code Elegantly on GitHub",paraId:15,tocIndex:6},{value:"\n  ",paraId:16}]},55681:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(85487);const n=[{value:"In X6, adding animations to nodes or edges can significantly enhance the visual effects and interactive experience of the canvas. It supports multiple animation implementations including the ",paraId:0,tocIndex:0},{value:"animate",paraId:0,tocIndex:0},{value:" API, CSS animations, and SMIL animations. Among these, the ",paraId:0,tocIndex:0},{value:"animate",paraId:0,tocIndex:0},{value:" API is the most powerful, and this article will focus on its usage. Here's a basic animation example:",paraId:0,tocIndex:0},{value:"import { Graph } from '@antv/x6'\n\nconst graph = new Graph({\n  container: document.getElementById('container'),\n  height: 300,\n  background: {\n    color: '#F2F7FA',\n  },\n})\n\nconst node = graph.addNode({\n  shape: 'rect',\n  label: 'hello X6',\n  x: 100,\n  y: 140,\n  width: 100,\n  height: 50,\n  attrs: {\n    body: {\n      strokeWidth: 1,\n      rx: 6,\n      ry: 6,\n    },\n  },\n})\n\nnode.animate(\n  // Move the node's position from its original location to (300, 140) via animation\n  { 'position/x': 300 },\n  // Animation duration is 1000ms, when reaching the end point it will alternate back, with infinite iterations\n  { duration: 1000, direction: 'alternate', iterations: Infinity },\n)\n",paraId:1,tocIndex:0},{value:"For developers familiar with the Web Animations API, it's clear that X6's ",paraId:2,tocIndex:0},{value:"animate",paraId:2,tocIndex:0},{value:" API is based on the ",paraId:2,tocIndex:0},{value:"Web Animations API",paraId:2,tocIndex:0},{value:" standard. Therefore, its usage is largely compatible with the Web Animations API and implements most of its core features.",paraId:2,tocIndex:0},{value:"The ",paraId:3,tocIndex:0},{value:"animate",paraId:3,tocIndex:0},{value:" API accepts two key parameters:",paraId:3,tocIndex:0},{value:"Keyframe configuration",paraId:4,tocIndex:0},{value:": Specifies the properties to animate and their target values. In this example, configured as an object where:\n",paraId:4,tocIndex:0},{value:"key",paraId:5,tocIndex:0},{value:" (position/x): The property path to animate",paraId:5,tocIndex:0},{value:"value",paraId:5,tocIndex:0},{value:" (300): The target value, moving the node from its current position to x-coordinate 300",paraId:5,tocIndex:0},{value:"Animation configuration",paraId:4,tocIndex:0},{value:": Parameters controlling animation behavior, including:",paraId:4,tocIndex:0},{value:"duration",paraId:6,tocIndex:0},{value:": 1000 means each animation cycle lasts 1000ms",paraId:6,tocIndex:0},{value:"direction",paraId:6,tocIndex:0},{value:": 'alternate' means the animation will alternate between start and end points",paraId:6,tocIndex:0},{value:"iterations",paraId:6,tocIndex:0},{value:": Infinity means the animation will repeat indefinitely",paraId:6,tocIndex:0},{value:"Some developers might wonder why we use ",paraId:7,tocIndex:1},{value:"position/x",paraId:7,tocIndex:1},{value:" instead of directly using the ",paraId:7,tocIndex:1},{value:"x",paraId:7,tocIndex:1},{value:" property. This is because X6's animation system is implemented based on the ",paraId:7,tocIndex:1},{value:"cell.setPropByPath()",paraId:7,tocIndex:1},{value:" method, which modifies property values via property paths. A node's property structure typically looks like this (can also be obtained via ",paraId:7,tocIndex:1},{value:"cell.prop()",paraId:7,tocIndex:1},{value:" method):",paraId:7,tocIndex:1},{value:"{\n  // ...\n  position: {x: 370, y: 180},\n  size: {width: 100, height: 60},\n  attrs: {\n    // ...\n  }\n}\n",paraId:8,tocIndex:1},{value:"Therefore, animating the position is done through ",paraId:9,tocIndex:1},{value:"position/x",paraId:9,tocIndex:1},{value:", with child properties concatenated using ",paraId:9,tocIndex:1},{value:"/",paraId:9,tocIndex:1},{value:". Other animation properties follow the same pattern. For example, to animate node size:",paraId:9,tocIndex:1},{value:"// Set node width to 200 with animation\nnode.animate({'size/width': 200 },1000)\n",paraId:10,tocIndex:1},{value:"Understanding this property mechanism means you can animate not just built-in node properties but also custom properties. For example, animating a custom ",paraId:11,tocIndex:1},{value:"ratio",paraId:11,tocIndex:1},{value:" property in the node's ",paraId:11,tocIndex:1},{value:"data",paraId:11,tocIndex:1},{value:":",paraId:11,tocIndex:1},{value:"import { Dom, Graph, Shape } from '@antv/x6'\n\nShape.HTML.register({\n  shape: 'custom-html',\n  width: 160,\n  height: 80,\n  effect: ['data'],\n  html(cell) {\n    // Custom HTML node receives an area ratio to control div size, which can be animated\n    const { ratio } = cell.getData() ?? {}\n    const div = document.createElement('div')\n    const area = 12000\n    const width = Math.sqrt(area / ratio)\n    const height = width * ratio\n    Dom.css(div, {\n      width,\n      height,\n      background: '#fff',\n      borderRadius: 10,\n      border: \"1px solid #000\"\n    })\n\n    return div\n  },\n})\n\nconst graph = new Graph({\n  container: document.getElementById('container'),\n  height: 300,\n  background: {\n    color: '#F2F7FA',\n  },\n})\n\ngraph.addNode({\n  shape: 'custom-html',\n  x: 80,\n  y: 80,\n  data: { ratio: 1 },\n  animation: [\n    // Animate the custom node's aspect ratio\n    [{ 'data/ratio': 3 / 5 }, { duration: 1000, iterations: Infinity }],\n  ],\n})\n",paraId:12,tocIndex:1},{value:"Besides using the API to add animations, the ",paraId:13,tocIndex:2},{value:"animate",paraId:13,tocIndex:2},{value:" API also supports adding animations through node's ",paraId:13,tocIndex:2},{value:"animation",paraId:13,tocIndex:2},{value:" configuration, eliminating an extra step which can be practical in many scenarios. The following example achieves the same animation as above:",paraId:13,tocIndex:2},{value:"import { Graph } from '@antv/x6'\n\nconst graph = new Graph({\n  container: document.getElementById('container'),\n  height: 300,\n  background: {\n    color: '#F2F7FA',\n  },\n})\n\ngraph.addNode({\n  shape: 'rect',\n  label: 'hello X6',\n  x: 100,\n  y: 140,\n  width: 100,\n  height: 50,\n  attrs: {\n    body: {\n      strokeWidth: 1,\n      rx: 6,\n      ry: 6,\n    },\n  },\n  // Write animation configuration directly in node config, animation starts automatically when node is added to canvas\n  animation: [\n    [\n      { 'position/x': 300 },\n      { duration: 1000, direction: 'alternate', iterations: Infinity },\n    ],\n  ],\n})\n",paraId:14,tocIndex:2},{value:"The ",paraId:15,tocIndex:2},{value:"animation",paraId:15,tocIndex:2},{value:" configuration is an array:",paraId:15,tocIndex:2},{value:"Each item is an animation parameter array (corresponding to ",paraId:16,tocIndex:2},{value:"animate",paraId:16,tocIndex:2},{value:" parameters)",paraId:16,tocIndex:2},{value:"After the node is added to the canvas, animations will automatically play according to the configuration",paraId:16,tocIndex:2},{value:"A common scenario is adding the same animation to multiple nodes. Whether through repeated ",paraId:17,tocIndex:3},{value:"animate",paraId:17,tocIndex:3},{value:" API calls or configuration, each node requires repetitive operations. X6 inherently supports reusing nodes by registering ",paraId:17,tocIndex:3},{value:"Shape",paraId:17,tocIndex:3},{value:", and animations can also be registered into ",paraId:17,tocIndex:3},{value:"Shape",paraId:17,tocIndex:3},{value:" to enable animations for a group of nodes:",paraId:17,tocIndex:3},{value:"import { Graph } from '@antv/x6'\n\nGraph.registerNode(\n  'animated-rect',\n  {\n    inherit: 'rect',\n    width: 150,\n    height: 60,\n    attrs: {\n      body: {\n        strokeWidth: 1,\n        rx: 6,\n        ry: 6,\n      },\n    },\n    // Pre-configure animation when registering Shape\n    animation: [\n      [\n        { 'position/x': 300 },\n        { duration: 1000, direction: 'alternate', iterations: Infinity },\n      ],\n    ],\n  },\n  true,\n)\n\nconst graph = new Graph({\n  container: document.getElementById('container'),\n  height: 300,\n  background: {\n    color: '#F2F7FA',\n  },\n})\n\ngraph.addNode({\n  shape: 'animated-rect',\n  x: 100,\n  y: 50,\n  label: \"hello X6\"\n})\n\ngraph.addNode({\n  shape: 'animated-rect',\n  x: 100,\n  y: 150,\n  label: \"hello Animation\"\n})\n",paraId:18,tocIndex:3},{value:"X6's ",paraId:19,tocIndex:4},{value:"animate",paraId:19,tocIndex:4},{value:" API is designed based on the Web Animations API, so it similarly supports flexible animation control capabilities like pause, resume, cancel, etc. Here's a simple animation control example:",paraId:19,tocIndex:4},{value:"import { Graph } from '@antv/x6'\n\nconst graph = new Graph({\n  container: document.getElementById('container'),\n  height: 300,\n  background: {\n    color: '#F2F7FA',\n  },\n})\n\nconst node = graph.addNode({\n  shape: 'rect',\n  label: 'Click me to pause',\n  x: 100,\n  y: 140,\n  width: 150,\n  height: 60,\n  attrs: {\n    body: {\n      strokeWidth: 1,\n      rx: 6,\n      ry: 6,\n    },\n  },\n  animation: [\n    [\n      { 'position/x': 300 },\n      { duration: 1000, direction: 'alternate', iterations: Infinity },\n    ],\n  ],\n})\n\ngraph.on('node:click', ({ cell }) => {\n  if (cell === node) {\n    const [animation] = cell.getAnimations()\n    animation.pause()\n  }\n})\n",paraId:20,tocIndex:4},{value:"Besides pausing animations, the ",paraId:21,tocIndex:4},{value:"animate",paraId:21,tocIndex:4},{value:" API supports the following capabilities:",paraId:21,tocIndex:4},{value:"pause()",paraId:22,tocIndex:4},{value:" Pause animation",paraId:22,tocIndex:4},{value:"play()",paraId:22,tocIndex:4},{value:" Play/resume animation",paraId:22,tocIndex:4},{value:"cancel()",paraId:22,tocIndex:4},{value:" Cancel animation",paraId:22,tocIndex:4},{value:"finish()",paraId:22,tocIndex:4},{value:" Finish animation",paraId:22,tocIndex:4},{value:"reverse()",paraId:22,tocIndex:4},{value:" Play animation in reverse",paraId:22,tocIndex:4},{value:"updatePlaybackRate()",paraId:22,tocIndex:4},{value:" Update animation playback speed",paraId:22,tocIndex:4},{value:"X6 supports two styles of animation events. One is based on Web Animations API design, such as setting ",paraId:23,tocIndex:5},{value:"onfinish",paraId:23,tocIndex:5},{value:" to listen for animation events:",paraId:23,tocIndex:5},{value:"import { Graph } from '@antv/x6'\n\nconst graph = new Graph({\n  container: document.getElementById('container'),\n  height: 300,\n  background: {\n    color: '#F2F7FA',\n  },\n})\n\nconst node = graph.addNode({\n  shape: 'rect',\n  label: 'Click me to start',\n  x: 100,\n  y: 140,\n  width: 150,\n  height: 60,\n  attrs: {\n    body: {\n      strokeWidth: 1,\n      rx: 6,\n      ry: 6,\n    },\n  },\n})\n\ngraph.on('node:click', ({ cell }) => {\n  if (cell !== node) return\n\n  const animation = node.animate(\n    { 'position/x': [100, 300] },\n    { duration: 1000, direction: 'alternate', iterations: 1 },\n  )\n\n// Listen to animation events via onfinish\n  animation.onfinish = () => {\n    console.log('Animation finished')\n  }\n})\n\n",paraId:24,tocIndex:5},{value:"Web Animations API style supports these events:",paraId:25,tocIndex:5},{value:"onfinish",paraId:26,tocIndex:5},{value:" Animation finished",paraId:26,tocIndex:5},{value:"oncancel",paraId:26,tocIndex:5},{value:" Animation canceled",paraId:26,tocIndex:5},{value:"The other style is based on X6's own design, using the ",paraId:27,tocIndex:5},{value:"on",paraId:27,tocIndex:5},{value:" API to listen for animation events:",paraId:27,tocIndex:5},{value:"import { Graph } from '@antv/x6'\n\nconst graph = new Graph({\n  container: document.getElementById('container'),\n  height: 300,\n  background: {\n    color: '#F2F7FA',\n  },\n})\n\nconst node = graph.addNode({\n  shape: 'rect',\n  label: 'Click me to start',\n  x: 100,\n  y: 140,\n  width: 150,\n  height: 60,\n  attrs: {\n    body: {\n      strokeWidth: 1,\n      rx: 6,\n      ry: 6,\n    },\n  },\n})\n\ngraph.on('node:click', ({ cell }) => {\n  if (cell !== node) return\n\n  node.animate(\n    { 'position/x': [100, 300] },\n    { duration: 1000, direction: 'alternate', iterations: 1 },\n  )\n})\n\n// Listen to animation events via on\ngraph.on('node:animation:finish', () => {\n  console.log('Animation finished')\n})\n\n",paraId:28,tocIndex:5},{value:"X6's native event system supports these events:",paraId:29,tocIndex:5},{value:"cell:animation:finish",paraId:30,tocIndex:5},{value:" Animation finished",paraId:30,tocIndex:5},{value:"cell:animation:cancel",paraId:30,tocIndex:5},{value:" Animation canceled",paraId:30,tocIndex:5},{value:"For detailed X6 event system, see ",paraId:31,tocIndex:5},{value:"Events",paraId:32,tocIndex:5},{value:".",paraId:31,tocIndex:5}]},27883:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(96001);const n=[{value:"Methods to add edges",paraId:0},{value:"How to configure the shape of edges",paraId:0},{value:"How to add arrows to edges",paraId:0},{value:"How to customize edges",paraId:0},{value:"How to modify edges through the API",paraId:0},{value:"Both nodes and edges share a common base class ",paraId:1,tocIndex:0},{value:"Cell",paraId:2,tocIndex:0},{value:". In addition to inheriting properties from ",paraId:1,tocIndex:0},{value:"Cell",paraId:1,tocIndex:0},{value:", edges support the following options.",paraId:1,tocIndex:0},{value:"Property Name",paraId:3,tocIndex:0},{value:"Type",paraId:3,tocIndex:0},{value:"Default Value",paraId:3,tocIndex:0},{value:"Description",paraId:3,tocIndex:0},{value:"source",paraId:3,tocIndex:0},{value:"TerminalData",paraId:3,tocIndex:0},{value:"-",paraId:3,tocIndex:0},{value:"Source node or starting point.",paraId:3,tocIndex:0},{value:"target",paraId:3,tocIndex:0},{value:"TerminalData",paraId:3,tocIndex:0},{value:"-",paraId:3,tocIndex:0},{value:"Target node or endpoint.",paraId:3,tocIndex:0},{value:"vertices",paraId:3,tocIndex:0},{value:"Point.PointLike[]",paraId:3,tocIndex:0},{value:"-",paraId:3,tocIndex:0},{value:"Path points.",paraId:3,tocIndex:0},{value:"router",paraId:3,tocIndex:0},{value:"RouterData",paraId:3,tocIndex:0},{value:"-",paraId:3,tocIndex:0},{value:"Router.",paraId:3,tocIndex:0},{value:"connector",paraId:3,tocIndex:0},{value:"ConnectorData",paraId:3,tocIndex:0},{value:"-",paraId:3,tocIndex:0},{value:"Connector.",paraId:3,tocIndex:0},{value:"labels",paraId:3,tocIndex:0},{value:"Label[]",paraId:3,tocIndex:0},{value:"-",paraId:3,tocIndex:0},{value:"Labels.",paraId:3,tocIndex:0},{value:"defaultLabel",paraId:3,tocIndex:0},{value:"Label",paraId:3,tocIndex:0},{value:"Default Label",paraId:4,tocIndex:0},{value:"Default label.",paraId:3,tocIndex:0},{value:"graph.addEdge({\n  shape: 'edge',\n  source: 'node1',\n  target: 'node2',\n})\n",paraId:5,tocIndex:0},{value:"Let's take a look at how to use the configurations mentioned above.",paraId:6,tocIndex:1},{value:"The source and target nodes (points) of the edge.",paraId:7,tocIndex:2},{value:"graph.addEdge({\n  source: rect1, // Source node\n  target: rect2, // Target node\n})\n\ngraph.addEdge({\n  source: 'rect1', // Source node ID\n  target: 'rect2', // Target node ID\n})\n\ngraph.addEdge({\n  source: { cell: rect1, port: 'out-port-1' }, // Source node and connection port ID\n  target: { cell: 'rect2', port: 'in-port-1' }, // Target node ID and connection port ID\n})\n\ngraph.addEdge({\n  source: 'rect1', // Source node ID\n  target: { x: 100, y: 120 }, // Target point\n})\n",paraId:8,tocIndex:2},{value:"Path points. The edge starts from the starting point, passes through the path points in order, and finally reaches the endpoint.",paraId:9,tocIndex:3},{value:"graph.addEdge({\n  source: rect1,\n  target: rect2,\n  vertices: [\n    { x: 100, y: 200 },\n    { x: 300, y: 120 },\n  ],\n})\n",paraId:10,tocIndex:3},{value:"The ",paraId:11,tocIndex:4},{value:"router",paraId:11,tocIndex:4},{value:" will further process the ",paraId:11,tocIndex:4},{value:"vertices",paraId:11,tocIndex:4},{value:", adding additional points if necessary, and then return the processed points. For example, after processing with ",paraId:11,tocIndex:4},{value:"orth routing",paraId:12,tocIndex:4},{value:", each link segment of the edge will be horizontal or vertical.",paraId:11,tocIndex:4},{value:"graph.addEdge({\n  source: rect1,\n  target: rect2,\n  vertices: [\n    { x: 100, y: 200 },\n    { x: 300, y: 120 },\n  ],\n  // If there are no args parameters, it can be simplified to router: 'orth'\n  router: {\n    name: 'orth',\n    args: {},\n  },\n})\n",paraId:13,tocIndex:4},{value:"X6 provides the following routing options by default. Click the links below to see how each routing option is used.",paraId:14},{value:"normal",paraId:15},{value:"orth",paraId:16},{value:"oneSide",paraId:17},{value:"manhattan",paraId:18},{value:"metro",paraId:19},{value:"er",paraId:20},{value:"Additionally, we can register custom routers. For more details, please refer to the ",paraId:21},{value:"Custom Router",paraId:22},{value:" tutorial.",paraId:21},{value:"The ",paraId:23,tocIndex:5},{value:"connector",paraId:23,tocIndex:5},{value:" processes the points returned by the ",paraId:23,tocIndex:5},{value:"router",paraId:23,tocIndex:5},{value:" into the ",paraId:23,tocIndex:5},{value:"pathData",paraId:23,tocIndex:5},{value:" needed for rendering the edge. For example, the ",paraId:23,tocIndex:5},{value:"rounded",paraId:23,tocIndex:5},{value:" connector will round the corners between the lines.",paraId:23,tocIndex:5},{value:"graph.addEdge({\n  source: rect1,\n  target: rect2,\n  vertices: [\n    { x: 100, y: 200 },\n    { x: 300, y: 120 },\n  ],\n  router: 'orth',\n  // If there are no args parameters, it can be simplified to connector: 'rounded'\n  connector: {\n    name: 'rounded',\n    args: {},\n  },\n})\n",paraId:24,tocIndex:5},{value:"X6 provides the following connector options by default. Click the links below to see how each connector is used.",paraId:25},{value:"normal",paraId:26},{value:"rounded",paraId:27},{value:"smooth",paraId:28},{value:"jumpover",paraId:29},{value:"Additionally, we can register custom connectors. For more details, please refer to the ",paraId:30},{value:"Custom Connector",paraId:31},{value:" tutorial.",paraId:30},{value:"Used to set label text, position, style, etc. Supports multiple labels in array form, and each item specified in ",paraId:32,tocIndex:6},{value:"labels",paraId:32,tocIndex:6},{value:" will be used after being ",paraId:32,tocIndex:6},{value:"merged",paraId:32,tocIndex:6},{value:" with the ",paraId:32,tocIndex:6},{value:"defaultLabel",paraId:33,tocIndex:6},{value:".",paraId:32,tocIndex:6},{value:"const edge = graph.addEdge({\n  source: rect1,\n  target: rect2,\n  labels: [\n    {\n      attrs: {\n        label: {\n          text: 'edge',\n        },\n      },\n    },\n  ],\n})\n// Or\nconst edge = graph.addEdge({\n  source: rect1,\n  target: rect2,\n  labels: ['edge'], // Multiple labels can be set through labels, and when only setting label text, this syntax can be simplified\n})\n// Or\nconst edge = graph.addEdge({\n  source: rect1,\n  target: rect2,\n  label: 'edge', // A single label can be set through label, and when only setting label text, this syntax can be simplified\n})\n",paraId:34,tocIndex:6},{value:"In addition to setting text, you can also create complex shapes on the edge using Label, which we will detail in the ",paraId:35},{value:"API",paraId:36},{value:".",paraId:35},{value:"Default label. The default label can simplify the label configuration items, and each item specified in ",paraId:37,tocIndex:7},{value:"labels",paraId:37,tocIndex:7},{value:" will be used after being merged with ",paraId:37,tocIndex:7},{value:"defaultLabel",paraId:37,tocIndex:7},{value:".",paraId:37,tocIndex:7},{value:"We define two special properties, ",paraId:38,tocIndex:8},{value:"sourceMarker",paraId:38,tocIndex:8},{value:" and ",paraId:38,tocIndex:8},{value:"targetMarker",paraId:38,tocIndex:8},{value:", to customize the starting and ending arrows of the edge. For example, for ",paraId:38,tocIndex:8},{value:"Shape.Edge",paraId:38,tocIndex:8},{value:", we can specify the starting and ending arrows using the ",paraId:38,tocIndex:8},{value:"line",paraId:38,tocIndex:8},{value:" selector.",paraId:38,tocIndex:8},{value:"X6 provides the following built-in arrows. When using them, you only need to specify the arrow name and parameters (optional).",paraId:39,tocIndex:9},{value:"block",paraId:40,tocIndex:9},{value:"classic",paraId:41,tocIndex:9},{value:"diamond",paraId:42,tocIndex:9},{value:"cross",paraId:43,tocIndex:9},{value:"async",paraId:44,tocIndex:9},{value:"path",paraId:45,tocIndex:9},{value:"circle",paraId:46,tocIndex:9},{value:"circlePlus",paraId:47,tocIndex:9},{value:"ellipse",paraId:48,tocIndex:9},{value:"graph.addEdge({\n  shape: 'edge',\n  source: [100, 100],\n  target: [500, 500],\n  attrs: {\n    line: {\n      sourceMarker: 'block', // Solid arrow\n      targetMarker: {\n        name: 'ellipse', // Ellipse\n        rx: 10, // X radius of the ellipse arrow\n        ry: 6, // Y radius of the ellipse arrow\n      },\n    },\n  },\n})\n",paraId:49,tocIndex:9},{value:"By default, X6 edges come with a ",paraId:50},{value:"classic",paraId:50},{value:" arrow. If you want to remove it, you can set ",paraId:50},{value:"targetMarker",paraId:50},{value:" to ",paraId:50},{value:"null",paraId:50},{value:".",paraId:50},{value:"We can also render arrows using SVG elements specified by ",paraId:51,tocIndex:10},{value:"tagName",paraId:51,tocIndex:10},{value:". For example, below we use the ",paraId:51,tocIndex:10},{value:"<path>",paraId:51,tocIndex:10},{value:" element to render the arrow, which inherits the edge's fill color ",paraId:51,tocIndex:10},{value:"fill",paraId:51,tocIndex:10},{value:" and border color ",paraId:51,tocIndex:10},{value:"stroke",paraId:51,tocIndex:10},{value:" by default.",paraId:51,tocIndex:10},{value:"graph.addEdge({\n  shape: 'edge',\n  source: [100, 100],\n  target: [500, 500],\n  attrs: {\n    line: {\n      sourceMarker: {\n        tagName: 'path',\n        d: 'M 20 -10 0 0 20 10 Z',\n      },\n      targetMarker: {\n        tagName: 'path',\n        fill: 'yellow', // Use custom fill color\n        stroke: 'green', // Use custom border color\n        strokeWidth: 2,\n        d: 'M 20 -10 0 0 20 10 Z',\n      },\n    },\n  },\n})\n",paraId:52,tocIndex:10},{value:"Our starting and ending arrows use the same ",paraId:53},{value:"d",paraId:53},{value:" attribute because we automatically calculate the arrow direction. In simple terms, when defining the arrow, we only need to define an arrow that points ",paraId:53},{value:"towards the origin",paraId:53},{value:".",paraId:53},{value:"For more examples and customization tips for arrows, please refer to the ",paraId:54},{value:"API",paraId:55},{value:".",paraId:54},{value:"Like nodes, we can customize the shape and style of edges using ",paraId:56,tocIndex:11},{value:"markup",paraId:56,tocIndex:11},{value:" and ",paraId:56,tocIndex:11},{value:"attrs",paraId:56,tocIndex:11},{value:", and we can also register custom edges for reuse. The default edge ",paraId:56,tocIndex:11},{value:"Shape.Edge",paraId:56,tocIndex:11},{value:" in X6 defines two selectors: ",paraId:56,tocIndex:11},{value:"line",paraId:56,tocIndex:11},{value:" (representing the path element) and ",paraId:56,tocIndex:11},{value:"wrap",paraId:56,tocIndex:11},{value:" (representing a transparent path element for interaction). We can define the style of the edge as shown below.",paraId:56,tocIndex:11},{value:"Similar to nodes, after rendering is complete, we can modify all properties of edges through the API. We commonly use the following two methods:",paraId:57,tocIndex:12},{value:"edge.prop(path, value), for detailed usage see ",paraId:58,tocIndex:12},{value:"prop",paraId:59,tocIndex:12},{value:".",paraId:58,tocIndex:12},{value:"edge.attr(path, value), for detailed usage see ",paraId:58,tocIndex:12},{value:"attr",paraId:60,tocIndex:12},{value:".",paraId:58,tocIndex:12},{value:"Let's take a look at the ",paraId:61,tocIndex:12},{value:"prop",paraId:61,tocIndex:12},{value:" of the default edge provided by X6.",paraId:61,tocIndex:12},{value:'const edge = graph.addEdge({\n  source: [200, 140],\n  target: [500, 140],\n  label: \'edge\',\n})\nconsole.log(edge.prop())\n\n// Output\n{\n  "shape": "edge",\n  "attrs": {\n    "lines": {\n      "connection": true,\n      "strokeLinejoin": "round"\n    },\n    "wrap": {\n      "strokeWidth": 10\n    },\n    "line": {\n      "stroke": "#333",\n      "strokeWidth": 2,\n      "targetMarker": "classic"\n    }\n  },\n  "id": "9d5e4f54-1ed3-429e-8d8c-a1526cff2cd8",\n  "source": {\n    "x": 200,\n    "y": 140\n  },\n  "target": {\n    "x": 500,\n    "y": 140\n  },\n  "labels": [{\n    "attrs": {\n      "label": {\n        "text": "edge"\n      }\n    }\n  }],\n  "zIndex": 1\n}\n',paraId:62,tocIndex:12},{value:"From the output above, we can see that ",paraId:63,tocIndex:12},{value:"prop",paraId:63,tocIndex:12},{value:" is a new configuration after processing, and its values can be updated through methods. After updating, the edge will immediately refresh to the latest state. To modify the edge's ",paraId:63,tocIndex:12},{value:"attrs",paraId:63,tocIndex:12},{value:" more conveniently, X6 provides the ",paraId:63,tocIndex:12},{value:"attr",paraId:63,tocIndex:12},{value:" method.",paraId:63,tocIndex:12},{value:"edge.prop('target', { x: 300, y: 300 }) // Modify the endpoint\nedge.attr('line/stroke', '#ccc') // Modify the edge color, equivalent to edge.prop('attrs/line/stroke', '#ccc')\n",paraId:64,tocIndex:12}]},17774:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(67719);const n=[{value:"Which event categories you can listen to",paraId:0},{value:"How to listen to events",paraId:0},{value:"Events triggered when interacting with the application through mouse, keyboard, or various interactive components.",paraId:1,tocIndex:0},{value:"Event",paraId:2,tocIndex:1},{value:"Cell",paraId:2,tocIndex:1},{value:"Node",paraId:2,tocIndex:1},{value:"Port",paraId:2,tocIndex:1},{value:"Edge",paraId:2,tocIndex:1},{value:"Graph",paraId:2,tocIndex:1},{value:"Click",paraId:2,tocIndex:1},{value:"cell:click",paraId:2,tocIndex:1},{value:"node:click",paraId:2,tocIndex:1},{value:"node:port:click",paraId:2,tocIndex:1},{value:"edge:click",paraId:2,tocIndex:1},{value:"blank:click",paraId:2,tocIndex:1},{value:"Double Click",paraId:2,tocIndex:1},{value:"cell:dblclick",paraId:2,tocIndex:1},{value:"node:dblclick",paraId:2,tocIndex:1},{value:"node:port:dblclick",paraId:2,tocIndex:1},{value:"edge:dblclick",paraId:2,tocIndex:1},{value:"blank:dblclick",paraId:2,tocIndex:1},{value:"Right Click",paraId:2,tocIndex:1},{value:"cell:contextmenu",paraId:2,tocIndex:1},{value:"node:contextmenu",paraId:2,tocIndex:1},{value:"node:port:contextmenu",paraId:2,tocIndex:1},{value:"edge:contextmenu",paraId:2,tocIndex:1},{value:"blank:contextmenu",paraId:2,tocIndex:1},{value:"Mouse Down",paraId:2,tocIndex:1},{value:"cell:mousedown",paraId:2,tocIndex:1},{value:"node:mousedown",paraId:2,tocIndex:1},{value:"node:port:mousedown",paraId:2,tocIndex:1},{value:"edge:mousedown",paraId:2,tocIndex:1},{value:"blank:mousedown",paraId:2,tocIndex:1},{value:"Mouse Move",paraId:2,tocIndex:1},{value:"cell:mousemove",paraId:2,tocIndex:1},{value:"node:mousemove",paraId:2,tocIndex:1},{value:"node:port:mousemove",paraId:2,tocIndex:1},{value:"edge:mousemove",paraId:2,tocIndex:1},{value:"blank:mousemove",paraId:2,tocIndex:1},{value:"Mouse Up",paraId:2,tocIndex:1},{value:"cell:mouseup",paraId:2,tocIndex:1},{value:"node:mouseup",paraId:2,tocIndex:1},{value:"node:port:mouseup",paraId:2,tocIndex:1},{value:"edge:mouseup",paraId:2,tocIndex:1},{value:"blank:mouseup",paraId:2,tocIndex:1},{value:"Mouse Wheel",paraId:2,tocIndex:1},{value:"cell:mousewheel",paraId:2,tocIndex:1},{value:"node:mousewheel",paraId:2,tocIndex:1},{value:"-",paraId:2,tocIndex:1},{value:"edge:mousewheel",paraId:2,tocIndex:1},{value:"blank:mousewheel",paraId:2,tocIndex:1},{value:"Mouse Enter",paraId:2,tocIndex:1},{value:"cell:mouseenter",paraId:2,tocIndex:1},{value:"node:mouseenter",paraId:2,tocIndex:1},{value:"node:port:mouseenter",paraId:2,tocIndex:1},{value:"edge:mouseenter",paraId:2,tocIndex:1},{value:"graph:mouseenter",paraId:2,tocIndex:1},{value:"Mouse Leave",paraId:2,tocIndex:1},{value:"cell:mouseleave",paraId:2,tocIndex:1},{value:"node:mouseleave",paraId:2,tocIndex:1},{value:"node:port:mouseleave",paraId:2,tocIndex:1},{value:"edge:mouseleave",paraId:2,tocIndex:1},{value:"graph:mouseleave",paraId:2,tocIndex:1},{value:"It is important to note that the ",paraId:3},{value:"mousemove",paraId:3},{value:" event here differs from the usual mouse move event; it requires the mouse to be moved after being pressed down to trigger.",paraId:3},{value:"Except for ",paraId:4},{value:"mouseenter",paraId:4},{value:" and ",paraId:4},{value:"mouseleave",paraId:4},{value:", the parameters of the event callback functions include the mouse position relative to the canvas ",paraId:4},{value:"x",paraId:4},{value:", ",paraId:4},{value:"y",paraId:4},{value:", and the mouse event object ",paraId:4},{value:"e",paraId:4},{value:", among other parameters.",paraId:4},{value:"graph.on('cell:click', ({ e, x, y, cell, view }) => {})\ngraph.on('node:click', ({ e, x, y, node, view }) => {})\ngraph.on('edge:click', ({ e, x, y, edge, view }) => {})\ngraph.on('blank:click', ({ e, x, y }) => {})\n\ngraph.on('cell:mouseenter', ({ e, cell, view }) => {})\ngraph.on('node:mouseenter', ({ e, node, view }) => {})\ngraph.on('edge:mouseenter', ({ e, edge, view }) => {})\ngraph.on('graph:mouseenter', ({ e }) => {})\n",paraId:5},{value:"We can add custom attributes ",paraId:6,tocIndex:2},{value:"event",paraId:6,tocIndex:2},{value:" or ",paraId:6,tocIndex:2},{value:"data-event",paraId:6,tocIndex:2},{value:" to the DOM elements of nodes/edges to listen for click events on that element, for example:",paraId:6,tocIndex:2},{value:"node.attr({\n  // Represents a delete button, which deletes the node when clicked\n  image: {\n    event: 'node:delete',\n    xlinkHref: 'trash.png',\n    width: 20,\n    height: 20,\n  },\n})\n",paraId:7,tocIndex:2},{value:"You can listen for the bound event name ",paraId:8,tocIndex:2},{value:"node:delete",paraId:8,tocIndex:2},{value:" or the generic ",paraId:8,tocIndex:2},{value:"cell:customevent",paraId:8,tocIndex:2},{value:", ",paraId:8,tocIndex:2},{value:"node:customevent",paraId:8,tocIndex:2},{value:", ",paraId:8,tocIndex:2},{value:"edge:customevent",paraId:8,tocIndex:2},{value:" event names.",paraId:8,tocIndex:2},{value:"graph.on('node:delete', ({ view, e }) => {\n  e.stopPropagation()\n  view.cell.remove()\n})\n\ngraph.on('node:customevent', ({ name, view, e }) => {\n  if (name === 'node:delete') {\n    e.stopPropagation()\n    view.cell.remove()\n  }\n})\n",paraId:9,tocIndex:2},{value:"Event Name",paraId:10,tocIndex:3},{value:"Callback Parameters",paraId:10,tocIndex:3},{value:"Description",paraId:10,tocIndex:3},{value:"scale",paraId:10,tocIndex:3},{value:"{ sx: number; sy: number; ox: number; oy: number }",paraId:10,tocIndex:3},{value:"Triggered when zooming the canvas; ",paraId:10,tocIndex:3},{value:"sx",paraId:10,tocIndex:3},{value:" and ",paraId:10,tocIndex:3},{value:"sy",paraId:10,tocIndex:3},{value:" are the scale factors, ",paraId:10,tocIndex:3},{value:"ox",paraId:10,tocIndex:3},{value:" and ",paraId:10,tocIndex:3},{value:"oy",paraId:10,tocIndex:3},{value:" are the zoom center.",paraId:10,tocIndex:3},{value:"resize",paraId:10,tocIndex:3},{value:"{ width: number; height: number }",paraId:10,tocIndex:3},{value:"Triggered when changing the canvas size; ",paraId:10,tocIndex:3},{value:"width",paraId:10,tocIndex:3},{value:" and ",paraId:10,tocIndex:3},{value:"height",paraId:10,tocIndex:3},{value:" are the canvas dimensions.",paraId:10,tocIndex:3},{value:"translate",paraId:10,tocIndex:3},{value:"{ tx: number; ty: number }",paraId:10,tocIndex:3},{value:"Triggered when panning the canvas; ",paraId:10,tocIndex:3},{value:"tx",paraId:10,tocIndex:3},{value:" and ",paraId:10,tocIndex:3},{value:"ty",paraId:10,tocIndex:3},{value:" are the offsets on the X and Y axes.",paraId:10,tocIndex:3},{value:"graph.on('scale', ({ sx, sy, ox, oy }) => {})\ngraph.on('resize', ({ width, height }) => {})\ngraph.on('translate', ({ tx, ty }) => {})\n",paraId:11,tocIndex:3},{value:"Event Name",paraId:12,tocIndex:4},{value:"Callback Parameters",paraId:12,tocIndex:4},{value:"Description",paraId:12,tocIndex:4},{value:"node:move",paraId:12,tocIndex:4},{value:"{ e: Dom.MouseDownEvent; x: number; y: number; node: Node; view: NodeView }",paraId:12,tocIndex:4},{value:"Triggered when starting to move a node.",paraId:12,tocIndex:4},{value:"node:moving",paraId:12,tocIndex:4},{value:"{ e: Dom.MouseMoveEvent; x: number; y: number; node: Node; view: NodeView }",paraId:12,tocIndex:4},{value:"Triggered while moving a node.",paraId:12,tocIndex:4},{value:"node:moved",paraId:12,tocIndex:4},{value:"{ e: Dom.MouseUpEvent; x: number; y: number; node: Node; view: NodeView }",paraId:12,tocIndex:4},{value:"Triggered after moving a node.",paraId:12,tocIndex:4},{value:"edge:move",paraId:12,tocIndex:4},{value:"{ e: Dom.MouseDownEvent; x: number; y: number; node: Node; view: NodeView }",paraId:12,tocIndex:4},{value:"Triggered when starting to move an edge.",paraId:12,tocIndex:4},{value:"edge:moving",paraId:12,tocIndex:4},{value:"{ e: Dom.MouseMoveEvent; x: number; y: number; node: Node; view: NodeView }",paraId:12,tocIndex:4},{value:"Triggered while moving an edge.",paraId:12,tocIndex:4},{value:"edge:moved",paraId:12,tocIndex:4},{value:"{ e: Dom.MouseUpEvent; x: number; y: number; node: Node; view: NodeView }",paraId:12,tocIndex:4},{value:"Triggered after moving an edge.",paraId:12,tocIndex:4},{value:"The ",paraId:13,tocIndex:4},{value:"x",paraId:13,tocIndex:4},{value:" and ",paraId:13,tocIndex:4},{value:"y",paraId:13,tocIndex:4},{value:" parameters are the coordinates of the mouse relative to the canvas.",paraId:13,tocIndex:4},{value:"graph.on('node:moved', ({ e, x, y, node, view }) => {})\n",paraId:14,tocIndex:4},{value:"Event Name",paraId:15,tocIndex:5},{value:"Callback Parameters",paraId:15,tocIndex:5},{value:"Description",paraId:15,tocIndex:5},{value:"node:embed",paraId:15,tocIndex:5},{value:"{ e: Dom.MouseDownEvent; x: number; y: number; node: Node; view: NodeView, currentParent: Node }",paraId:15,tocIndex:5},{value:"Triggered when starting to embed a node.",paraId:15,tocIndex:5},{value:"node:embedding",paraId:15,tocIndex:5},{value:"{ e: Dom.MouseMoveEvent; x: number; y: number; node: Node; view: NodeView, currentParent: Node, candidateParent: Node }",paraId:15,tocIndex:5},{value:"Triggered while searching for the target node.",paraId:15,tocIndex:5},{value:"node:embedded",paraId:15,tocIndex:5},{value:"{ e: Dom.MouseUpEvent; x: number; y: number; node: Node; view: NodeView, previousParent: Node, currentParent: Node }",paraId:15,tocIndex:5},{value:"Triggered after completing node embedding.",paraId:15,tocIndex:5},{value:"The ",paraId:16,tocIndex:6},{value:"edge:connected",paraId:16,tocIndex:6},{value:" event fires when dragging an edge terminal to connect/disconnect it to/from a node or edge. The callback parameters are as follows.",paraId:16,tocIndex:6},{value:"interface Args {\n  e: Dom.MouseUpEvent // Mouse event object\n  edge: Edge // Edge\n  view: EdgeView // Edge view\n  isNew: boolean // Whether it is a newly created edge\n  type: Edge.TerminalType // Whether the operation is on the source or target arrow ('source' | 'target')\n\n  previousCell?: Cell | null // The node/edge connected before the interaction\n  previousView?: CellView | null // The view of the node/edge connected before the interaction\n  previousPort?: string | null // The port ID connected before the interaction\n  previousPoint?: Point.PointLike | null // The point connected before the interaction (records the position of the start terminal when dragging the edge terminal from blank to node/edge)\n  previousMagnet?: Element | null // The element connected before the interaction\n\n  currentCell?: Cell | null // The node/edge connected after the interaction\n  currentView?: CellView | null // The view of the node/edge connected after the interaction\n  currentPort?: string | null // The port ID connected after the interaction\n  currentPoint?: Point.PointLike | null // The point connected after the interaction (records the position of the terminal after dragging from node/edge to blank)\n  currentMagnet?: Element | null // The element connected after the interaction\n}\n",paraId:17,tocIndex:6},{value:"We can use ",paraId:18,tocIndex:6},{value:"isNew",paraId:18,tocIndex:6},{value:" to determine whether the corresponding edge is newly created after the connection is completed. For example, if an edge is created starting from a port and connected to another node/port, ",paraId:18,tocIndex:6},{value:"isNew",paraId:18,tocIndex:6},{value:" will be ",paraId:18,tocIndex:6},{value:"true",paraId:18,tocIndex:6},{value:".",paraId:18,tocIndex:6},{value:"graph.on('edge:connected', ({ isNew, edge }) => {\n  if (isNew) {\n    // Perform database insertion or other persistence operations for the newly created edge\n  }\n})\n",paraId:19,tocIndex:6},{value:"It is particularly important to note that the ",paraId:20,tocIndex:6},{value:"previous...",paraId:20,tocIndex:6},{value:" parameters record the state of the terminal before the connection/disconnection operation, and do not refer to ",paraId:20,tocIndex:6},{value:"sourceCell",paraId:20,tocIndex:6},{value:". When obtaining ",paraId:20,tocIndex:6},{value:"sourceCell",paraId:20,tocIndex:6},{value:" after creating a new edge, do not use ",paraId:20,tocIndex:6},{value:"previousCell",paraId:20,tocIndex:6},{value:"; the correct usage is:",paraId:20,tocIndex:6},{value:"graph.on('edge:connected', ({ isNew, edge }) => {\n  if (isNew) {\n    const source = edge.getSourceCell()\n  }\n})\n",paraId:21,tocIndex:6},{value:"When a node/edge is added to the canvas, the following events are triggered:",paraId:22,tocIndex:8},{value:"added",paraId:23,tocIndex:8},{value:"cell:added",paraId:23,tocIndex:8},{value:"node:added",paraId:23,tocIndex:8},{value:" (only triggered when the cell is a node)",paraId:23,tocIndex:8},{value:"edge:added",paraId:23,tocIndex:8},{value:" (only triggered when the cell is an edge)",paraId:23,tocIndex:8},{value:"When a node/edge is removed, the following events are triggered:",paraId:24,tocIndex:8},{value:"removed",paraId:25,tocIndex:8},{value:"cell:removed",paraId:25,tocIndex:8},{value:"node:removed",paraId:25,tocIndex:8},{value:" (only triggered when the cell is a node)",paraId:25,tocIndex:8},{value:"edge:removed",paraId:25,tocIndex:8},{value:" (only triggered when the cell is an edge)",paraId:25,tocIndex:8},{value:"When a node/edge undergoes any changes, the following events are triggered:",paraId:26,tocIndex:8},{value:"changed",paraId:27,tocIndex:8},{value:"cell:changed",paraId:27,tocIndex:8},{value:"node:changed",paraId:27,tocIndex:8},{value:" (only triggered when the cell is a node)",paraId:27,tocIndex:8},{value:"edge:changed",paraId:27,tocIndex:8},{value:" (only triggered when the cell is an edge)",paraId:27,tocIndex:8},{value:"You can listen on the node/edge:",paraId:28,tocIndex:8},{value:"cell.on('added', ({ cell, index, options }) => {})\ncell.on('removed', ({ cell, index, options }) => {})\ncell.on('changed', ({ cell, options }) => {})\n",paraId:29,tocIndex:8},{value:"Or listen on the Graph:",paraId:30,tocIndex:8},{value:"graph.on('cell:added', ({ cell, index, options }) => {})\ngraph.on('cell:removed', ({ cell, index, options }) => {})\ngraph.on('cell:changed', ({ cell, options }) => {})\n\ngraph.on('node:added', ({ node, index, options }) => {})\ngraph.on('node:removed', ({ node, index, options }) => {})\ngraph.on('node:changed', ({ node, options }) => {})\n\ngraph.on('edge:added', ({ edge, index, options }) => {})\ngraph.on('edge:removed', ({ edge, index, options }) => {})\ngraph.on('edge:changed', ({ edge, options }) => {})\n",paraId:31,tocIndex:8},{value:"When calling ",paraId:32,tocIndex:9},{value:"setXxx(val, options)",paraId:32,tocIndex:9},{value:" and ",paraId:32,tocIndex:9},{value:"removeXxx(options)",paraId:32,tocIndex:9},{value:" methods to change the data of a node/edge, and ",paraId:32,tocIndex:9},{value:"options.silent",paraId:32,tocIndex:9},{value:" is not ",paraId:32,tocIndex:9},{value:"true",paraId:32,tocIndex:9},{value:", the corresponding ",paraId:32,tocIndex:9},{value:"change",paraId:32,tocIndex:9},{value:" event will be triggered, and the node/edge will be redrawn. For example:",paraId:32,tocIndex:9},{value:"cell.setZIndex(2)\ncell.setZIndex(2, { silent: false })\ncell.setZIndex(2, { anyKey: 'anyValue' })\n",paraId:33,tocIndex:9},{value:"This will trigger the following events on the Cell:",paraId:34,tocIndex:9},{value:"change:*",paraId:35,tocIndex:9},{value:"change:zIndex",paraId:35,tocIndex:9},{value:"And the following events on the Graph:",paraId:36,tocIndex:9},{value:"cell:change:*",paraId:37,tocIndex:9},{value:"node:change:*",paraId:37,tocIndex:9},{value:" (only triggered when the cell is a node)",paraId:37,tocIndex:9},{value:"edge:change:*",paraId:37,tocIndex:9},{value:" (only triggered when the cell is an edge)",paraId:37,tocIndex:9},{value:"cell:change:zIndex",paraId:37,tocIndex:9},{value:"node:change:zIndex",paraId:37,tocIndex:9},{value:" (only triggered when the cell is a node)",paraId:37,tocIndex:9},{value:"edge:change:zIndex",paraId:37,tocIndex:9},{value:" (only triggered when the cell is an edge)",paraId:37,tocIndex:9},{value:"You can listen on the node/edge:",paraId:38,tocIndex:9},{value:"// Triggered when any change occurs on the cell, can determine the changed item through key\ncell.on(\n  'change:*',\n  (args: {\n    cell: Cell\n    key: string // Determine the changed item through key\n    current: any // Current value\n    previous: any // Value before change\n    options: any // Pass-through options\n  }) => {\n    if (key === 'zIndex') {\n      //\n    }\n  },\n)\n\ncell.on(\n  'change:zIndex',\n  (args: {\n    cell: Cell\n    current?: number // Current value\n    previous?: number // Value before change\n    options: any // Pass-through options\n  }) => {},\n)\n",paraId:39,tocIndex:9},{value:"Or listen on the Graph:",paraId:40,tocIndex:9},{value:"graph.on(\n  'cell:change:zIndex',\n  (args: {\n    cell: Cell\n    current?: number // Current value\n    previous?: number // Value before change\n    options: any // Pass-through options\n  }) => {},\n)\n\n// Triggered when the cell is a node\ngraph.on(\n  'node:change:zIndex',\n  (args: {\n    cell: Cell\n    node: Node\n    current?: number // Current value\n    previous?: number // Value before change\n    options: any // Pass-through options\n  }) => {},\n)\n\n// Triggered when the cell is an edge\ngraph.on(\n  'edge:change:zIndex',\n  (args: {\n    cell: Cell\n    edge: Edge\n    current?: number // Current value\n    previous?: number // Value before change\n    options: any // Pass-through options\n  }) => {},\n)\n",paraId:41,tocIndex:9},{value:"Other ",paraId:42,tocIndex:9},{value:"change",paraId:42,tocIndex:9},{value:" events are listed below, and the callback function parameters have the same structure as the parameters mentioned for ",paraId:42,tocIndex:9},{value:"change:zIndex",paraId:42,tocIndex:9},{value:".",paraId:42,tocIndex:9},{value:"Cell\n",paraId:43,tocIndex:9},{value:"change:*",paraId:44,tocIndex:9},{value:"change:attrs",paraId:44,tocIndex:9},{value:"change:zIndex",paraId:44,tocIndex:9},{value:"change:markup",paraId:44,tocIndex:9},{value:"change:visible",paraId:44,tocIndex:9},{value:"change:parent",paraId:44,tocIndex:9},{value:"change:children",paraId:44,tocIndex:9},{value:"change:tools",paraId:44,tocIndex:9},{value:"change:view",paraId:44,tocIndex:9},{value:"change:data",paraId:44,tocIndex:9},{value:"Node\n",paraId:43,tocIndex:9},{value:"change:size",paraId:45,tocIndex:9},{value:"change:angle",paraId:45,tocIndex:9},{value:"change:position",paraId:45,tocIndex:9},{value:"change:ports",paraId:45,tocIndex:9},{value:"change:portMarkup",paraId:45,tocIndex:9},{value:"change:portLabelMarkup",paraId:45,tocIndex:9},{value:"change:portContainerMarkup",paraId:45,tocIndex:9},{value:"ports:added",paraId:45,tocIndex:9},{value:"ports:removed",paraId:45,tocIndex:9},{value:"Edge\n",paraId:43,tocIndex:9},{value:"change:source",paraId:46,tocIndex:9},{value:"change:target",paraId:46,tocIndex:9},{value:"change:terminal",paraId:46,tocIndex:9},{value:"change:router",paraId:46,tocIndex:9},{value:"change:connector",paraId:46,tocIndex:9},{value:"change:vertices",paraId:46,tocIndex:9},{value:"change:labels",paraId:46,tocIndex:9},{value:"change:defaultLabel",paraId:46,tocIndex:9},{value:"vertexs:added",paraId:46,tocIndex:9},{value:"vertexs:removed",paraId:46,tocIndex:9},{value:"labels:added",paraId:46,tocIndex:9},{value:"labels:removed",paraId:46,tocIndex:9},{value:"In addition to the built-in keys mentioned above, we also support listening to custom keys, for example:",paraId:47,tocIndex:9},{value:"cell.on('change:custom', ({ cell, current, previous, options }) => {\n  console.log(current)\n})\n",paraId:48,tocIndex:9},{value:"When modifying the value of the ",paraId:49,tocIndex:9},{value:"custom",paraId:49,tocIndex:9},{value:" property using the ",paraId:49,tocIndex:9},{value:"cell.prop('custom', 'any data')",paraId:49,tocIndex:9},{value:" method, the ",paraId:49,tocIndex:9},{value:"change:custom",paraId:49,tocIndex:9},{value:" event will be triggered.",paraId:49,tocIndex:9},{value:"The animation system supports the following events",paraId:50,tocIndex:10},{value:"cell:animation:finish",paraId:51,tocIndex:10},{value:" Triggered when the animation finish.",paraId:51,tocIndex:10},{value:"cell:animation:cancel",paraId:51,tocIndex:10},{value:" Triggered when the animation cancel.",paraId:51,tocIndex:10},{value:"node:animation:finish",paraId:51,tocIndex:10},{value:" Triggered when the animation finish. (only triggered when the cell is a node)",paraId:51,tocIndex:10},{value:"node:animation:cancel",paraId:51,tocIndex:10},{value:" Triggered when the animation cancel. (only triggered when the cell is a node)",paraId:51,tocIndex:10},{value:"edge:animation:finish",paraId:51,tocIndex:10},{value:" Triggered when the animation finish. (only triggered when the cell is a edge)",paraId:51,tocIndex:10},{value:"edge:animation:cancel",paraId:51,tocIndex:10},{value:" Triggered when the animation cancel. (only triggered when the cell is a edge)",paraId:51,tocIndex:10},{value:"Since X6 implements an asynchronous rendering scheduling algorithm, adding a node does not necessarily mean it is mounted on the canvas. Separate events are triggered when a node is mounted to or unmounted from the canvas.",paraId:52,tocIndex:11},{value:"Event Name",paraId:53,tocIndex:11},{value:"Callback Parameters",paraId:53,tocIndex:11},{value:"Description",paraId:53,tocIndex:11},{value:"view:mounted",paraId:53,tocIndex:11},{value:"{ view: CellView }",paraId:53,tocIndex:11},{value:"Triggered when a node is mounted to the canvas.",paraId:53,tocIndex:11},{value:"view:unmounted",paraId:53,tocIndex:11},{value:"{ view: CellView }",paraId:53,tocIndex:11},{value:"Triggered when a node is unmounted from the canvas.",paraId:53,tocIndex:11},{value:"graph.on('view:mounted', ({ view }) => {})\ngraph.on('view:unmounted', ({ view }) => {})\n",paraId:54,tocIndex:11},{value:"You may also often need to listen for the completion of rendering events after calling ",paraId:55,tocIndex:11},{value:"fromJSON",paraId:55,tocIndex:11},{value:" or ",paraId:55,tocIndex:11},{value:"resetCells",paraId:55,tocIndex:11},{value:". In this case, you can use the ",paraId:55,tocIndex:11},{value:"render:done",paraId:55,tocIndex:11},{value:" event to listen (added in version 2.15.1).",paraId:55,tocIndex:11},{value:"graph.on('render:done', () => {\n  // pass\n})\n\ngraph.fromJSON([...])\n",paraId:56,tocIndex:11}]},61868:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(43437);const n=[{value:"How to make the graph size responsive",paraId:0},{value:"Optimizing graph style by setting background and grid",paraId:0},{value:"How to make the graph draggable and resizable",paraId:0},{value:"Common graph size and position manipulation APIs",paraId:0},{value:"When instantiating a ",paraId:1,tocIndex:0},{value:"Graph",paraId:1,tocIndex:0},{value:" object, you can set the ",paraId:1,tocIndex:0},{value:"width",paraId:1,tocIndex:0},{value:" and ",paraId:1,tocIndex:0},{value:"height",paraId:1,tocIndex:0},{value:" to fix the graph size. If not set, the graph will initialize based on the size of the graph container.",paraId:1,tocIndex:0},{value:"In practical projects, you often encounter the following two scenarios:",paraId:2,tocIndex:0},{value:"The graph container has not finished rendering (at this point, its size is 0), leading to abnormal display of the graph elements when the graph object is instantiated.",paraId:3,tocIndex:0},{value:"The page's ",paraId:3,tocIndex:0},{value:"resize",paraId:3,tocIndex:0},{value:" causes the graph container size to change, resulting in abnormal display of the graph elements.",paraId:3,tocIndex:0},{value:"We can use the ",paraId:4,tocIndex:0},{value:"autoResize",paraId:4,tocIndex:0},{value:" configuration to solve the above problems.",paraId:4,tocIndex:0},{value:'\x3c!-- Note: When using the autoResize configuration, you need to wrap the graph container in an outer container that has a width and height of 100%. Listen for size changes on the outer container, and when the outer container size changes, the graph will automatically recalculate its width, height, and element positions. --\x3e\n<div style="width:100%; height:100%">\n  <div id="container"></div>\n</div>\n',paraId:5,tocIndex:0},{value:"const graph = new Graph({\n  container: document.getElementById('container'),\n  autoResize: true,\n})\n",paraId:6,tocIndex:0},{value:"In the example below, you can drag the gray area with the mouse to change the container size. You can see through the background color that the sizes of the three graphs are adaptive.",paraId:7,tocIndex:0},{value:"You can set the graph background and grid using the ",paraId:8,tocIndex:1},{value:"background",paraId:8,tocIndex:1},{value:" and ",paraId:8,tocIndex:1},{value:"grid",paraId:8,tocIndex:1},{value:" configurations.",paraId:8,tocIndex:1},{value:"In X6, the grid is the minimum unit for rendering/moving nodes, with a default size of 10px. This means that a node positioned at ",paraId:9},{value:"{ x: 24, y: 38 }",paraId:9},{value:" will actually render at ",paraId:9},{value:"{ x: 20, y: 40 }",paraId:9},{value:" on the graph.",paraId:9},{value:"The background supports not only colors but also background images. For detailed configurations and methods, refer to the ",paraId:10},{value:"API",paraId:11},{value:". Additionally, the grid supports four different types and allows configuration of grid line colors and widths. For detailed configurations and methods, refer to the ",paraId:10},{value:"API",paraId:12},{value:".",paraId:10},{value:"Dragging and zooming the graph are also common operations. In Graph, these two functionalities are implemented through the ",paraId:13,tocIndex:2},{value:"panning",paraId:13,tocIndex:2},{value:" and ",paraId:13,tocIndex:2},{value:"mousewheel",paraId:13,tocIndex:2},{value:" configurations. When you press down on the graph and move the mouse, it will drag the graph, and scrolling the mouse wheel will zoom the graph.",paraId:13,tocIndex:2},{value:"const graph = new Graph({\n  ...,\n  panning: true,\n  mousewheel: true\n})\n",paraId:14,tocIndex:2},{value:"Let's experience this through an example:",paraId:15,tocIndex:2},{value:"Of course, ",paraId:16},{value:"panning",paraId:16},{value:" and ",paraId:16},{value:"mousewheel",paraId:16},{value:" also support many other configurations, such as modifier keys (which must be pressed to trigger the corresponding behavior), zoom factors (rates), etc. Learn more from ",paraId:16},{value:"Panning API",paraId:17},{value:" and ",paraId:16},{value:"Mousewheel API",paraId:18},{value:".",paraId:16},{value:"Beyond built-in background, grid, zoom, and pan, X6 also provides useful canvas plugins such as scrolling and alignment guides that you can enable as needed.",paraId:19,tocIndex:3},{value:"import { Graph, Scroller, Snapline } from '@antv/x6'\n\nconst graph = new Graph({\n  container: document.getElementById('container'),\n  height: 300,\n  width: 800,\n})\n\n// Snapline helps show alignment guides when dragging nodes near others\ngraph.use(\n  new Snapline({\n    enabled: true,\n  }),\n)\n\n// Scroller enables scrollable canvas (with optional drag-to-pan)\ngraph.use(\n  new Scroller({\n    enabled: true,\n    pannable: true,\n  }),\n)\n",paraId:20,tocIndex:3},{value:"In the demo below, enabling ",paraId:21,tocIndex:3},{value:"Scroller",paraId:21,tocIndex:3},{value:" allows scrolling the canvas, and enabling ",paraId:21,tocIndex:3},{value:"Snapline",paraId:21,tocIndex:3},{value:" shows alignment lines when dragging nodes close to others.",paraId:21,tocIndex:3},{value:"import { Graph, Scroller, Snapline } from '@antv/x6'\n\nconst data = {\n  nodes: [\n    {\n      id: 'node1',\n      shape: 'rect',\n      x: 40,\n      y: 160,\n      width: 100,\n      height: 40,\n      label: 'hello',\n      attrs: {\n        body: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n          fill: '#fff',\n          rx: 6,\n          ry: 6,\n        },\n      },\n    },\n    {\n      id: 'node2',\n      shape: 'rect',\n      x: 160,\n      y: 180,\n      width: 100,\n      height: 40,\n      label: 'world',\n      attrs: {\n        body: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n          fill: '#fff',\n          rx: 6,\n          ry: 6,\n        },\n      },\n    },\n  ],\n}\n\nconst graph = new Graph({\n  container: document.getElementById('container'),\n  height: 300,\n  background: {\n    color: '#F2F7FA',\n  },\n})\n\ngraph.use(new Snapline({ enabled: true }))\ngraph.use(new Scroller({ enabled: true, pannable: true }))\n\ngraph.fromJSON(data)\ngraph.centerContent()\n",paraId:22,tocIndex:3},{value:"For more details, see ",paraId:23,tocIndex:3},{value:"Snapline",paraId:24,tocIndex:3},{value:" and ",paraId:23,tocIndex:3},{value:"Scroller",paraId:25,tocIndex:3},{value:".",paraId:23,tocIndex:3},{value:"In addition to the configurations mentioned above, X6 also provides a rich set of APIs for manipulating graph size and position. Here are some commonly used APIs; for more detailed content, see ",paraId:26,tocIndex:4},{value:"Transform API",paraId:27,tocIndex:4},{value:".",paraId:26,tocIndex:4},{value:"graph.resize(800, 600) // Resize the graph size\ngraph.translate(20, 20) // Translate the graph in the x and y directions\ngraph.zoom(0.2) // Increase the graph zoom level by 0.2 (default is 1)\ngraph.zoom(-0.2) // Decrease the graph zoom level by 0.2\ngraph.zoomTo(1.2) // Set the graph zoom level to 1.2\n// Scale the elements in the graph to fit all elements, with maxScale configuration for the maximum zoom level\ngraph.zoomToFit({ maxScale: 1 })\ngraph.centerContent() // Center the elements in the graph for display\n",paraId:28,tocIndex:4},{value:"More APIs:",paraId:29},{value:"Graph Options",paraId:30},{value:"Grid",paraId:31},{value:"Background",paraId:32},{value:"Panning",paraId:33},{value:"Mousewheel",paraId:34},{value:"Transform",paraId:35},{value:"Coordinate",paraId:36}]},79739:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(13669);const n=[{value:"How to set connection rules",paraId:0},{value:"How to embed nodes",paraId:0},{value:"How to configure highlight styles",paraId:0},{value:"How to disable or enable interactions",paraId:0},{value:"Connection interaction rules are all completed through the ",paraId:1,tocIndex:0},{value:"connecting",paraId:1,tocIndex:0},{value:" configuration. For a complete configuration, refer to ",paraId:1,tocIndex:0},{value:"API",paraId:2,tocIndex:0},{value:". Below, we introduce some commonly used functions.",paraId:1,tocIndex:0},{value:"You can use the ",paraId:3,tocIndex:1},{value:"allowXXX",paraId:3,tocIndex:1},{value:" configuration to define whether a connection can be connected to a corresponding position. The default supports the following items:",paraId:3,tocIndex:1},{value:"allowBlank",paraId:4,tocIndex:1},{value:": Whether to allow connection to a blank position on the canvas, default is ",paraId:4,tocIndex:1},{value:"true",paraId:4,tocIndex:1},{value:".",paraId:4,tocIndex:1},{value:"allowLoop",paraId:4,tocIndex:1},{value:": Whether to allow creating a loop connection, i.e., the starting node and ending node are the same node, default is ",paraId:4,tocIndex:1},{value:"true",paraId:4,tocIndex:1},{value:".",paraId:4,tocIndex:1},{value:"allowNode",paraId:4,tocIndex:1},{value:": Whether to allow connecting to a node (non-port region), default is ",paraId:4,tocIndex:1},{value:"true",paraId:4,tocIndex:1},{value:".",paraId:4,tocIndex:1},{value:"allowEdge",paraId:4,tocIndex:1},{value:": Whether to allow connection to another edge, default is ",paraId:4,tocIndex:1},{value:"true",paraId:4,tocIndex:1},{value:".",paraId:4,tocIndex:1},{value:"allowPort",paraId:4,tocIndex:1},{value:": Whether to allow connection to a connection point, default is ",paraId:4,tocIndex:1},{value:"true",paraId:4,tocIndex:1},{value:".",paraId:4,tocIndex:1},{value:"allowMulti",paraId:4,tocIndex:1},{value:": Whether to allow creating multiple edges between the same starting node and ending node, default is ",paraId:4,tocIndex:1},{value:"true",paraId:4,tocIndex:1},{value:".",paraId:4,tocIndex:1},{value:"Each accepts either a boolean or a function:",paraId:5,tocIndex:1},{value:"new Graph({\n  connecting: {\n    allowNode: true, // boolean\n  },\n})\n\n// Function form, often used for dynamic control of connection restrictions\nnew Graph({\n  connecting: {\n    allowNode(args) {\n      return true\n    },\n  },\n})\n",paraId:6,tocIndex:1},{value:"allowMulti",paraId:7},{value:" supports being set to the string ",paraId:7},{value:"withPort",paraId:7},{value:", representing that only one edge can be created between the same connection points of the starting and ending nodes (i.e., multiple edges can be created between the starting and ending nodes, but they must be connected to different connection points).",paraId:7},{value:"In the ",paraId:8,tocIndex:2},{value:"edge tutorial",paraId:9,tocIndex:2},{value:", we know that we can specify ",paraId:8,tocIndex:2},{value:"router",paraId:8,tocIndex:2},{value:" and ",paraId:8,tocIndex:2},{value:"connector",paraId:8,tocIndex:2},{value:" when adding an edge. If most edges in the entire canvas have the same ",paraId:8,tocIndex:2},{value:"router",paraId:8,tocIndex:2},{value:" or ",paraId:8,tocIndex:2},{value:"connector",paraId:8,tocIndex:2},{value:", we can configure them directly in ",paraId:8,tocIndex:2},{value:"connecting",paraId:8,tocIndex:2},{value:", which can avoid repeated configuration in the edge.",paraId:8,tocIndex:2},{value:"new Graph({\n  connecting: {\n    router: 'orth',\n    connector: 'rounded',\n  },\n})\n",paraId:10,tocIndex:2},{value:"In the above demo, we can drag out a connection from a node or port. You may ask: what elements can start a connection? In X6, any element with ",paraId:11,tocIndex:3},{value:"magnet: true",paraId:11,tocIndex:3},{value:" can initiate a connection. Moreover, in ",paraId:11,tocIndex:3},{value:"connecting",paraId:11,tocIndex:3},{value:", we can configure the style of the new connection through the ",paraId:11,tocIndex:3},{value:"createEdge",paraId:11,tocIndex:3},{value:" method.",paraId:11,tocIndex:3},{value:"new Graph({\n  connecting: {\n    createEdge() {\n      return this.createEdge({\n        shape: 'edge',\n        attrs: {\n          line: {\n            stroke: '#8f8f8f',\n            strokeWidth: 1,\n          },\n        },\n      })\n    },\n  },\n})\n",paraId:12,tocIndex:3},{value:"We can also define whether to create a connection or whether the connection is valid through the ",paraId:13,tocIndex:4},{value:"validateXXX",paraId:13,tocIndex:4},{value:" method. Compared to ",paraId:13,tocIndex:4},{value:"allowXXX",paraId:13,tocIndex:4},{value:", ",paraId:13,tocIndex:4},{value:"validateXXX",paraId:13,tocIndex:4},{value:" is more flexible. The default supports the following items:",paraId:13,tocIndex:4},{value:"validateMagnet",paraId:14,tocIndex:4},{value:": When clicking on an element with ",paraId:14,tocIndex:4},{value:"magnet=true",paraId:14,tocIndex:4},{value:", judge whether to create a new edge according to the return value of ",paraId:14,tocIndex:4},{value:"validateMagnet",paraId:14,tocIndex:4},{value:". If it returns ",paraId:14,tocIndex:4},{value:"false",paraId:14,tocIndex:4},{value:", there will be no reaction; if it returns ",paraId:14,tocIndex:4},{value:"true",paraId:14,tocIndex:4},{value:", a new edge will be created at the current element.",paraId:14,tocIndex:4},{value:"validateConnection",paraId:14,tocIndex:4},{value:": When moving an edge, judge whether the connection is valid according to the return value of ",paraId:14,tocIndex:4},{value:"validateConnection",paraId:14,tocIndex:4},{value:". If it returns ",paraId:14,tocIndex:4},{value:"false",paraId:14,tocIndex:4},{value:", the connection will not be connected to the current element when the mouse is released.",paraId:14,tocIndex:4},{value:"validateEdge",paraId:14,tocIndex:4},{value:": When stopping the edge drag, judge whether the edge is valid according to the return value of ",paraId:14,tocIndex:4},{value:"validateEdge",paraId:14,tocIndex:4},{value:". If it returns ",paraId:14,tocIndex:4},{value:"false",paraId:14,tocIndex:4},{value:", the edge will be cleared.",paraId:14,tocIndex:4},{value:"Sometimes we need to drag a node into another node, making it a child node of the other node. At this time, we can enable embedding through the ",paraId:15,tocIndex:5},{value:"embedding",paraId:15,tocIndex:5},{value:" option, and specify the parent node through the ",paraId:15,tocIndex:5},{value:"findParent",paraId:15,tocIndex:5},{value:" method when the node is moved. For more detailed configuration, refer to ",paraId:15,tocIndex:5},{value:"API",paraId:16,tocIndex:5},{value:".",paraId:15,tocIndex:5},{value:"const graph = new Graph({\n  embedding: {\n    enabled: true,\n    findParent({ node }) {\n      // Get the bounding box of the moved node\n      const bbox = node.getBBox()\n      // Find the node with `parent: true` in the data and intersect with the moved node's bounding box\n      return this.getNodes().filter((node) => {\n        const data = node.getData<{ parent: boolean }>()\n        if (data && data.parent) {\n          const targetBBox = node.getBBox()\n          return bbox.isIntersectWithRect(targetBBox)\n        }\n        return false\n      })\n    },\n  },\n})\n",paraId:17,tocIndex:5},{value:"We can specify the highlighting style when triggering certain interactions through the ",paraId:18,tocIndex:6},{value:"highlighting",paraId:18,tocIndex:6},{value:" option, such as:",paraId:18,tocIndex:6},{value:"new Graph({\n  highlighting: {\n    // When the connection point can be connected, render a surrounding box around the connection point\n    magnetAvailable: {\n      name: 'stroke',\n      args: {\n        attrs: {\n          fill: '#fff',\n          stroke: '#A4DEB1',\n          strokeWidth: 4,\n        },\n      },\n    },\n    // When the connection point is adsorbed to the edge, render a surrounding box around the connection point\n    magnetAdsorbed: {\n      name: 'stroke',\n      args: {\n        attrs: {\n          fill: '#fff',\n          stroke: '#31d0c6',\n          strokeWidth: 4,\n        },\n      },\n    },\n  },\n})\n",paraId:19,tocIndex:6},{value:"Supported ",paraId:20,tocIndex:6},{value:"highlighting",paraId:20,tocIndex:6},{value:" configuration items include:",paraId:20,tocIndex:6},{value:"default",paraId:21,tocIndex:6},{value:" Default highlighting option, used when the following highlighting configurations are missing.",paraId:21,tocIndex:6},{value:"embedding",paraId:21,tocIndex:6},{value:" Highlighting option used when dragging a node to embed it into another node.",paraId:21,tocIndex:6},{value:"nodeAvailable",paraId:21,tocIndex:6},{value:" Highlighting option used when a node can be connected during the connection process.",paraId:21,tocIndex:6},{value:"magnetAvailable",paraId:21,tocIndex:6},{value:" Highlighting option used when a connection point can be connected during the connection process.",paraId:21,tocIndex:6},{value:"magnetAdsorbed",paraId:21,tocIndex:6},{value:" Highlighting option used when the connection point is automatically adsorbed to the edge during the connection process.",paraId:21,tocIndex:6},{value:"The ",paraId:22,tocIndex:6},{value:"magnetAvailable.name",paraId:22,tocIndex:6},{value:" above is actually the name of the highlighter, and X6 has built-in ",paraId:22,tocIndex:6},{value:"stroke",paraId:22,tocIndex:6},{value:" and ",paraId:22,tocIndex:6},{value:"className",paraId:22,tocIndex:6},{value:" highlighters. For more information, refer to ",paraId:22,tocIndex:6},{value:"Highlighter",paraId:23,tocIndex:6},{value:".",paraId:22,tocIndex:6},{value:"We can enable or disable some interaction behaviors of elements through the ",paraId:24,tocIndex:7},{value:"interacting",paraId:24,tocIndex:7},{value:" configuration. If the elements on the canvas are purely for preview and cannot be interacted with, we can set it to ",paraId:24,tocIndex:7},{value:"false",paraId:24,tocIndex:7},{value:" directly.",paraId:24,tocIndex:7},{value:"new Graph({\n  interacting: false,\n})\n",paraId:25,tocIndex:7},{value:"If we need to define more detailed interaction limitations, we can configure them according to different property values. Supported properties include:",paraId:26,tocIndex:7},{value:"nodeMovable",paraId:27,tocIndex:7},{value:" Whether nodes can be moved.",paraId:27,tocIndex:7},{value:"magnetConnectable",paraId:27,tocIndex:7},{value:" Whether to trigger connection interaction when clicking on an element with the ",paraId:27,tocIndex:7},{value:"magnet",paraId:27,tocIndex:7},{value:" property.",paraId:27,tocIndex:7},{value:"edgeMovable",paraId:27,tocIndex:7},{value:" Whether edges can be moved.",paraId:27,tocIndex:7},{value:"edgeLabelMovable",paraId:27,tocIndex:7},{value:" Whether edge labels can be moved.",paraId:27,tocIndex:7},{value:"arrowheadMovable",paraId:27,tocIndex:7},{value:" Whether edge arrowheads (after using the arrowhead tool) can be moved.",paraId:27,tocIndex:7},{value:"vertexMovable",paraId:27,tocIndex:7},{value:" Whether edge vertices can be moved.",paraId:27,tocIndex:7},{value:"vertexAddable",paraId:27,tocIndex:7},{value:" Whether edge vertices can be added.",paraId:27,tocIndex:7},{value:"vertexDeletable",paraId:27,tocIndex:7},{value:" Whether edge vertices can be deleted.",paraId:27,tocIndex:7},{value:"Their values all support the following two types:",paraId:28,tocIndex:7},{value:"// Directly set to a boolean value\nnew Graph({\n  interacting: {\n    nodeMovable: false,\n    edgeMovable: true,\n  },\n})\n\n// Function form, often used for dynamic control of interaction behaviors\nnew Graph({\n  interacting: {\n    nodeMovable(view) {\n      const node = view.cell\n      const { enableMove } = node.getData()\n      return enableMove\n    },\n  },\n})\n",paraId:29,tocIndex:7}]},85993:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(90576);const n=[{value:"Node rendering methods supported by X6",paraId:0},{value:"Methods for adding nodes",paraId:0},{value:"Built-in node types in X6",paraId:0},{value:"How to customize nodes",paraId:0},{value:"How to modify nodes through the API",paraId:0},{value:"X6 is based on an ",paraId:1,tocIndex:0},{value:"SVG",paraId:1,tocIndex:0},{value:" rendering engine, which allows for rendering nodes and edges using different SVG elements, making it particularly suitable for scenarios where node content is relatively simple. For more complex nodes, there is a special ",paraId:1,tocIndex:0},{value:"foreignObject",paraId:1,tocIndex:0},{value:" element in ",paraId:1,tocIndex:0},{value:"SVG",paraId:1,tocIndex:0},{value:" that can embed any XHTML elements. This element can be used to render HTML, React/Vue/Angular components at the desired location, greatly facilitating project development.",paraId:1,tocIndex:0},{value:"When choosing a rendering method, we recommend:",paraId:2,tocIndex:0},{value:"If the node content is relatively simple and the requirements are fixed, use ",paraId:3,tocIndex:0},{value:"SVG",paraId:3,tocIndex:0},{value:" nodes.",paraId:3,tocIndex:0},{value:"For other scenarios, it is recommended to use the framework currently employed in the project to render nodes.",paraId:3,tocIndex:0},{value:"The React/Vue/HTML rendering methods also have some limitations. Due to browser compatibility issues, there may occasionally be some abnormal rendering behaviors, primarily manifested as incomplete node content display or flickering of node content. This can be mitigated by avoiding the use of ",paraId:4},{value:"position:absolute",paraId:4},{value:", ",paraId:4},{value:"position:relative",paraId:4},{value:", ",paraId:4},{value:"transform",paraId:4},{value:", and ",paraId:4},{value:"opacity",paraId:4},{value:" in the CSS styles of internal elements of the node.",paraId:4},{value:"The following introduction is based on ",paraId:5},{value:"SVG",paraId:5},{value:" nodes, but the usage of other rendering forms is very similar, and we will revisit this in the advanced tutorial.",paraId:5},{value:"Both nodes and edges share a common base class ",paraId:6,tocIndex:1},{value:"Cell",paraId:7,tocIndex:1},{value:". In addition to inheriting properties from ",paraId:6,tocIndex:1},{value:"Cell",paraId:6,tocIndex:1},{value:", they also support the following options.",paraId:6,tocIndex:1},{value:"Property Name",paraId:8,tocIndex:1},{value:"Type",paraId:8,tocIndex:1},{value:"Default Value",paraId:8,tocIndex:1},{value:"Description",paraId:8,tocIndex:1},{value:"x",paraId:8,tocIndex:1},{value:"number",paraId:8,tocIndex:1},{value:"0",paraId:8,tocIndex:1},{value:"Node position x coordinate, in px.",paraId:8,tocIndex:1},{value:"y",paraId:8,tocIndex:1},{value:"number",paraId:8,tocIndex:1},{value:"0",paraId:8,tocIndex:1},{value:"Node position y coordinate, in px.",paraId:8,tocIndex:1},{value:"width",paraId:8,tocIndex:1},{value:"number",paraId:8,tocIndex:1},{value:"1",paraId:8,tocIndex:1},{value:"Node width, in px.",paraId:8,tocIndex:1},{value:"height",paraId:8,tocIndex:1},{value:"number",paraId:8,tocIndex:1},{value:"1",paraId:8,tocIndex:1},{value:"Node height, in px.",paraId:8,tocIndex:1},{value:"angle",paraId:8,tocIndex:1},{value:"number",paraId:8,tocIndex:1},{value:"0",paraId:8,tocIndex:1},{value:"Node rotation angle.",paraId:8,tocIndex:1},{value:"graph.addNode({\n  shape: 'rect',\n  x: 100,\n  y: 40,\n  width: 100,\n  height: 40,\n})\n",paraId:9,tocIndex:1},{value:"The above example uses ",paraId:10,tocIndex:2},{value:"shape",paraId:10,tocIndex:2},{value:" to specify the node's graphic, with the default value of ",paraId:10,tocIndex:2},{value:"shape",paraId:10,tocIndex:2},{value:" being ",paraId:10,tocIndex:2},{value:"rect",paraId:10,tocIndex:2},{value:". The correspondence between X6 built-in nodes and ",paraId:10,tocIndex:2},{value:"shape",paraId:10,tocIndex:2},{value:" names is as follows:",paraId:10,tocIndex:2},{value:"Constructor",paraId:11,tocIndex:2},{value:"Shape Name",paraId:11,tocIndex:2},{value:"Description",paraId:11,tocIndex:2},{value:"Shape.Rect",paraId:11,tocIndex:2},{value:"rect",paraId:11,tocIndex:2},{value:"Rectangle.",paraId:11,tocIndex:2},{value:"Shape.Circle",paraId:11,tocIndex:2},{value:"circle",paraId:11,tocIndex:2},{value:"Circle.",paraId:11,tocIndex:2},{value:"Shape.Ellipse",paraId:11,tocIndex:2},{value:"ellipse",paraId:11,tocIndex:2},{value:"Ellipse.",paraId:11,tocIndex:2},{value:"Shape.Polygon",paraId:11,tocIndex:2},{value:"polygon",paraId:11,tocIndex:2},{value:"Polygon.",paraId:11,tocIndex:2},{value:"Shape.Polyline",paraId:11,tocIndex:2},{value:"polyline",paraId:11,tocIndex:2},{value:"Polyline.",paraId:11,tocIndex:2},{value:"Shape.Path",paraId:11,tocIndex:2},{value:"path",paraId:11,tocIndex:2},{value:"Path.",paraId:11,tocIndex:2},{value:"Shape.Image",paraId:11,tocIndex:2},{value:"image",paraId:11,tocIndex:2},{value:"Image.",paraId:11,tocIndex:2},{value:"Shape.HTML",paraId:11,tocIndex:2},{value:"html",paraId:11,tocIndex:2},{value:"HTML node, uses ",paraId:11,tocIndex:2},{value:"foreignObject",paraId:11,tocIndex:2},{value:" to render HTML fragments.",paraId:11,tocIndex:2},{value:"We can customize the shape and style of nodes using ",paraId:12,tocIndex:3},{value:"markup",paraId:12,tocIndex:3},{value:" and ",paraId:12,tocIndex:3},{value:"attrs",paraId:12,tocIndex:3},{value:", where ",paraId:12,tocIndex:3},{value:"markup",paraId:12,tocIndex:3},{value:" is analogous to ",paraId:12,tocIndex:3},{value:"HTML",paraId:12,tocIndex:3},{value:" and ",paraId:12,tocIndex:3},{value:"attrs",paraId:12,tocIndex:3},{value:" is analogous to ",paraId:12,tocIndex:3},{value:"CSS",paraId:12,tocIndex:3},{value:". It is strongly recommended to read the documentation on ",paraId:12,tocIndex:3},{value:"markup",paraId:13,tocIndex:3},{value:" and ",paraId:12,tocIndex:3},{value:"attrs",paraId:14,tocIndex:3},{value:" carefully.",paraId:12,tocIndex:3},{value:"Next, we may encounter a problem: if the customized content needs to be used by multiple nodes, do we need to redefine it for each node? The answer is no. X6 provides a convenient way to allow different nodes to reuse configurations.",paraId:15,tocIndex:3},{value:"After rendering is complete, we can also modify all properties of a node through the API. The two methods we commonly use are:",paraId:16,tocIndex:4},{value:"node.prop(path, value), for detailed usage see ",paraId:17,tocIndex:4},{value:"prop",paraId:18,tocIndex:4},{value:".",paraId:17,tocIndex:4},{value:"node.attr(path, value), for detailed usage see ",paraId:17,tocIndex:4},{value:"attr",paraId:19,tocIndex:4},{value:".",paraId:17,tocIndex:4},{value:"First, let's look at ",paraId:20,tocIndex:4},{value:"prop",paraId:20,tocIndex:4},{value:". We will directly print the ",paraId:20,tocIndex:4},{value:"prop",paraId:20,tocIndex:4},{value:" values of the default rect node in X6.",paraId:20,tocIndex:4},{value:'const node = graph.addNode({\n  shape: \'rect\',\n  width: 100,\n  height: 40,\n  x: 100,\n  y: 100,\n  label: \'node\',\n})\nconsole.log(node.prop())\n\n// Result\n{\n  "angle": 0,\n  "position": {\n    "x": 100,\n    "y": 100\n  },\n  "size": {\n    "width": 100,\n    "height": 40\n  },\n  "attrs": {\n    "text": {\n      "fontSize": 14,\n      "fill": "#000000",\n      "refX": 0.5,\n      "refY": 0.5,\n      "textAnchor": "middle",\n      "textVerticalAnchor": "middle",\n      "fontFamily": "Arial, helvetica, sans-serif",\n      "text": "node"\n    },\n    "rect": {\n      "fill": "#ffffff",\n      "stroke": "#333333",\n      "strokeWidth": 2\n    },\n    "body": {\n      "refWidth": "100%",\n      "refHeight": "100%"\n    }\n  },\n  "visible": true,\n  "shape": "rect",\n  "id": "ab47cadc-4104-457c-971f-50fbb077508a",\n  "zIndex": 1\n}\n',paraId:21,tocIndex:4},{value:"From the above result, we can see that ",paraId:22,tocIndex:4},{value:"prop",paraId:22,tocIndex:4},{value:" is a new configuration after processing, and its values can be updated through methods. After updating, the node will immediately refresh to the latest state. To modify the node's ",paraId:22,tocIndex:4},{value:"attrs",paraId:22,tocIndex:4},{value:" more conveniently, X6 provides the ",paraId:22,tocIndex:4},{value:"attr",paraId:22,tocIndex:4},{value:" method.",paraId:22,tocIndex:4},{value:"source.prop('size', { width: 120, height: 50 }) // Modify size\nsource.attr('rect/fill', '#ccc') // Modify fill color, equivalent to source.prop('attrs/rect/fill', '#ccc')\n",paraId:23,tocIndex:4},{value:"In the above JSON output, we can see that some properties like ",paraId:24},{value:"refWidth",paraId:24},{value:" and ",paraId:24},{value:"refHeight",paraId:24},{value:" are not native SVG properties. They are actually special properties built into X6, such as ",paraId:24},{value:"refWidth",paraId:24},{value:", which represents relative width. For more detailed special properties, refer to ",paraId:24},{value:"attrs",paraId:25},{value:".",paraId:24}]},9304:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(27865);const n=[{value:"How to configure ports in nodes",paraId:0},{value:"Adding, deleting, and modifying ports",paraId:0},{value:"How to configure port positions",paraId:0},{value:"How to configure label positions on ports",paraId:0},{value:"First, we group connection ports that have the same behavior and appearance into the same group, and set the grouping using the ",paraId:1,tocIndex:0},{value:"groups",paraId:1,tocIndex:0},{value:" option, which is an object ",paraId:1,tocIndex:0},{value:"{ [groupName: string]: PortGroupMetadata }",paraId:1,tocIndex:0},{value:". The group name is the key, and the value is the default options for each group of connection ports. The supported options are as follows:",paraId:1,tocIndex:0},{value:"interface PortGroupMetadata {\n  markup?: Markup // Definition of the connection port DOM structure.\n  attrs?: Attr.CellAttrs // Attributes and styles.\n  zIndex?: number | 'auto' // The DOM layer level of the connection port; the higher the value, the higher the level.\n  // Layout of connection ports in the group.\n  position?: [number, number] | string | { name: string; args?: object }\n  label?: {\n    // Connection port label\n    markup?: Markup\n    position?: {\n      // Layout of the connection port label\n      name: string // Layout name\n      args?: object // Layout parameters\n    }\n  }\n}\n",paraId:2,tocIndex:0},{value:"Next, we configure ",paraId:3,tocIndex:0},{value:"items",paraId:3,tocIndex:0},{value:", which is an array ",paraId:3,tocIndex:0},{value:"PortMetadata[]",paraId:3,tocIndex:0},{value:". Each item in the array represents a connection port, and the supported options for connection ports are as follows:",paraId:3,tocIndex:0},{value:"interface PortMetadata {\n  id?: string // Unique ID for the connection port, automatically generated by default.\n  group?: string // Group name; specifying a group will inherit the options of the connection ports in that group.\n  args?: object // Parameters for the layout algorithm specified for the connection ports in the group. We cannot specify a layout algorithm for a single connection port, but we can provide different parameters for the layout algorithm specified for the group.\n  markup?: Markup // Definition of the connection port's DOM structure. Specifying this option will override the default options provided by the group referred to by `group`.\n  attrs?: Attr.CellAttrs // Element's attribute styles. Specifying this option will override the default options provided by the group referred to by `group`.\n  zIndex?: number | 'auto' // The DOM layer level of the connection port; the higher the value, the higher the level. Specifying this option will override the default options provided by the group referred to by `group`.\n  label?: {\n    // Label for the connection port. Specifying this option will override the default options provided by the group referred to by `group`.\n    markup?: Markup // Label DOM structure\n    position?: {\n      // Label position\n      name: string // Name of the label position calculation method\n      args?: object // Parameters for the label position calculation method\n    }\n  }\n}\n",paraId:4,tocIndex:0},{value:"The following example code clearly shows how to define connection ports.",paraId:5,tocIndex:0},{value:"There is a rich ",paraId:6,tocIndex:1},{value:"API",paraId:7,tocIndex:1},{value:" for adding, deleting, and modifying connection ports on nodes.",paraId:6,tocIndex:1},{value:"// Add a connection port\nnode.addPort({\n  group: 'top',\n  attrs: {\n    text: {\n      text: 'xx',\n    },\n  },\n})\n\n// Remove a connection port\nnode.removePort(portId)\n\n// Update a connection port\nnode.portProp(portId, 'attrs/circle/stroke', color)\n",paraId:8,tocIndex:1},{value:"The layout algorithm for connection ports can only be specified through the ",paraId:9,tocIndex:2},{value:"position",paraId:9,tocIndex:2},{value:" option in ",paraId:9,tocIndex:2},{value:"groups",paraId:9,tocIndex:2},{value:", as the layout algorithm needs to consider all connection ports in the group when calculating their positions. We can influence the layout result of a single connection port through the ",paraId:9,tocIndex:2},{value:"args",paraId:9,tocIndex:2},{value:" option.",paraId:9,tocIndex:2},{value:"We provide the following layout algorithms for connection ports by default, and also support ",paraId:10,tocIndex:2},{value:"custom connection port layout algorithms and registration",paraId:11,tocIndex:2},{value:". Click the links below to learn how to use each layout algorithm.",paraId:10,tocIndex:2},{value:"absolute",paraId:12,tocIndex:2},{value:" Absolute positioning.",paraId:13,tocIndex:2},{value:"left",paraId:14,tocIndex:2},{value:" Evenly distributed on the left side of rectangular nodes.",paraId:13,tocIndex:2},{value:"right",paraId:15,tocIndex:2},{value:" Evenly distributed on the right side of rectangular nodes.",paraId:13,tocIndex:2},{value:"top",paraId:16,tocIndex:2},{value:" Evenly distributed on the top of rectangular nodes.",paraId:13,tocIndex:2},{value:"bottom",paraId:17,tocIndex:2},{value:" Evenly distributed on the bottom of rectangular nodes.",paraId:13,tocIndex:2},{value:"line",paraId:18,tocIndex:2},{value:" Evenly distributed along a specified line.",paraId:13,tocIndex:2},{value:"ellipse",paraId:19,tocIndex:2},{value:" Distributed along an elliptical arc.",paraId:13,tocIndex:2},{value:"ellipseSpread",paraId:20,tocIndex:2},{value:" Evenly distributed along an ellipse.",paraId:13,tocIndex:2},{value:"The label position can be specified in ",paraId:21,tocIndex:3},{value:"groups.label.position",paraId:21,tocIndex:3},{value:" and in the node's ",paraId:21,tocIndex:3},{value:"ports.items.label.position",paraId:21,tocIndex:3},{value:" option.",paraId:21,tocIndex:3},{value:"We provide the following label positions by default, and also support ",paraId:22,tocIndex:3},{value:"custom label positions and registration",paraId:23,tocIndex:3},{value:". Click the links below to learn how to use each label position.",paraId:22,tocIndex:3},{value:"left",paraId:24,tocIndex:3},{value:" The label is located on the left side of the connection port.",paraId:25,tocIndex:3},{value:"right",paraId:26,tocIndex:3},{value:" The label is located on the right side of the connection port.",paraId:25,tocIndex:3},{value:"top",paraId:27,tocIndex:3},{value:" The label is located above the connection port.",paraId:25,tocIndex:3},{value:"bottom",paraId:28,tocIndex:3},{value:" The label is located below the connection port.",paraId:25,tocIndex:3},{value:"inside",paraId:29,tocIndex:3},{value:" The label is located inside the node (close to the edge).",paraId:25,tocIndex:3},{value:"outside",paraId:30,tocIndex:3},{value:" The label is located outside the node (close to the edge).",paraId:25,tocIndex:3},{value:"insideOriented",paraId:31,tocIndex:3},{value:" The label is located inside the node and automatically adjusts the text direction based on its position.",paraId:25,tocIndex:3},{value:"outsideOriented",paraId:32,tocIndex:3},{value:" The label is located outside the node and automatically adjusts the text direction based on its position.",paraId:25,tocIndex:3},{value:"radial",paraId:33,tocIndex:3},{value:" The label is located outside circular or elliptical nodes.",paraId:25,tocIndex:3},{value:"radialOriented",paraId:34,tocIndex:3},{value:" The label is located outside circular or elliptical nodes and the label text automatically rotates along the arc direction.",paraId:25,tocIndex:3}]},99965:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(2402);const n=[{value:"How to export data",paraId:0},{value:"How to import data",paraId:0},{value:"Call ",paraId:1,tocIndex:0},{value:"graph.toJSON()",paraId:1,tocIndex:0},{value:" to export nodes and edges. It returns an object like ",paraId:1,tocIndex:0},{value:"{ cells: [] }",paraId:1,tocIndex:0},{value:", where the ",paraId:1,tocIndex:0},{value:"cells",paraId:1,tocIndex:0},{value:" array stores nodes and edges ",paraId:1,tocIndex:0},{value:"in render order",paraId:1,tocIndex:0},{value:".",paraId:1,tocIndex:0},{value:"Exported node structure:",paraId:2,tocIndex:0},{value:"{\n  id: string,\n  shape: string,\n  position: {\n    x: number,\n    y: number\n  },\n  size: {\n    width: number,\n    height: number\n  },\n  attrs: object,\n  zIndex: number,\n}\n",paraId:3,tocIndex:0},{value:"Exported edge structure:",paraId:4,tocIndex:0},{value:"{\n  id: string,\n  shape: string,\n  source: object,\n  target: object,\n  attrs: object,\n  zIndex: number,\n}\n",paraId:5,tocIndex:0},{value:"Supports an array of node/edge metadata ",paraId:6,tocIndex:1},{value:"graph.fromJSON(cells: (Node.Metadata | Edge.Metadata)[])",paraId:6,tocIndex:1},{value:".",paraId:6,tocIndex:1},{value:"graph.fromJSON([\n  {\n    id: 'node1',\n    x: 40,\n    y: 40,\n    width: 100,\n    height: 40,\n    label: 'Hello',\n    shape: 'rect',\n  },\n  {\n    id: 'node2',\n    x: 40,\n    y: 40,\n    width: 100,\n    height: 40,\n    label: 'Hello',\n    shape: 'ellipse',\n  },\n  {\n    id: 'edge1',\n    source: 'node1',\n    target: 'node2',\n    shape: 'edge',\n  },\n])\n",paraId:7,tocIndex:1},{value:"Alternatively, provide an object containing ",paraId:8,tocIndex:1},{value:"cells",paraId:8,tocIndex:1},{value:", ",paraId:8,tocIndex:1},{value:"nodes",paraId:8,tocIndex:1},{value:", and ",paraId:8,tocIndex:1},{value:"edges",paraId:8,tocIndex:1},{value:", rendered in the order of ",paraId:8,tocIndex:1},{value:"[...cells, ...nodes, ...edges]",paraId:8,tocIndex:1},{value:".",paraId:8,tocIndex:1},{value:"graph.fromJSON({\n  nodes: [],\n  edges: [],\n})\n",paraId:9,tocIndex:1},{value:"Typically, we render the data exported by ",paraId:10,tocIndex:1},{value:"graph.toJSON()",paraId:10,tocIndex:1},{value:" using ",paraId:10,tocIndex:1},{value:"graph.fromJSON(...)",paraId:10,tocIndex:1},{value:".",paraId:10,tocIndex:1},{value:"When the data does not provide a ",paraId:11},{value:"zIndex",paraId:11},{value:", the rendering is done according to the order of nodes/edges in the array, meaning that nodes/edges that appear earlier have a smaller ",paraId:11},{value:"zIndex",paraId:11},{value:", resulting in a lower layer in the canvas.",paraId:11}]},17010:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(606);const n=[{value:"We provide a plugin for inspecting page elements to help developers more easily develop applications.",paraId:0},{value:"First, initialize in your project code:",paraId:1,tocIndex:1},{value:"// init window hook\nwindow.__x6_instances__ = []\n\nconst graph = new Graph({ ...blablabla })\n\nwindow.__x6_instances__.push(graph)\n",paraId:2,tocIndex:1},{value:"Then you can see the AntV X6 section in the developer panel.",paraId:3,tocIndex:1},{value:"Here, we can inspect the graph object and the elements within the graph:",paraId:4,tocIndex:1},{value:"It also supports modifying element properties:",paraId:5,tocIndex:1}]},30632:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(49457);const n=[{value:"X6 is published on npm as @antv/x6.",paraId:0,tocIndex:0},{value:"# npm\n$ npm install @antv/x6 --save\n\n# yarn\n$ yarn add @antv/x6\n\n# pnpm\n$ pnpm add @antv/x6\n",paraId:1,tocIndex:0},{value:"If using the UMD package, you can use any of the following CDN URLs.",paraId:2,tocIndex:0},{value:"https://unpkg.com/@antv/x6/dist/index.js",paraId:3,tocIndex:0},{value:"https://cdn.jsdelivr.net/npm/@antv/x6/dist/index.js",paraId:3,tocIndex:0},{value:"https://cdnjs.cloudflare.com/ajax/libs/antv-x6/2.0.0/index.js",paraId:3,tocIndex:0},{value:"It's recommended to learn ",paraId:4,tocIndex:1},{value:"SVG Basics",paraId:4,tocIndex:1},{value:" before you begin, and with some basic SVG knowledge in mind, let's start with a simple example to play with X6.",paraId:4,tocIndex:1},{value:"Creating a graph container on the page and then initializing the graph object, then you can set the graph style through configuration, such as the background color.",paraId:5,tocIndex:2},{value:'<div id="container"></div>\n',paraId:6,tocIndex:2},{value:"import { Graph } from '@antv/x6'\n\nconst graph = new Graph({\n  container: document.getElementById('container'),\n  width: 800,\n  height: 600,\n  background: {\n    color: '#F2F7FA',\n  },\n})\n",paraId:7,tocIndex:2},{value:"X6 supports json data, you can also use the ",paraId:8,tocIndex:3},{value:"attrs",paraId:8,tocIndex:3},{value:" attribute to customize the styles of nodes and edges (like ",paraId:8,tocIndex:3},{value:"CSS",paraId:8,tocIndex:3},{value:").",paraId:8,tocIndex:3},{value:"X6 supports using ",paraId:9,tocIndex:4},{value:"SVG",paraId:9,tocIndex:4},{value:" and ",paraId:9,tocIndex:4},{value:"HTML",paraId:9,tocIndex:4},{value:" to render node content. On this basis, we can also use ",paraId:9,tocIndex:4},{value:"React",paraId:9,tocIndex:4},{value:" and ",paraId:9,tocIndex:4},{value:"Vue",paraId:9,tocIndex:4},{value:" components to render nodes, which will be very convenient in the development process.",paraId:9,tocIndex:4},{value:"For example, we have a new requirement: add a right-click menu to the node. It would be more complicated to implement using ",paraId:10,tocIndex:4},{value:"SVG",paraId:10,tocIndex:4},{value:", We can easily implement it with a React node. You can use the React render package ",paraId:10,tocIndex:4},{value:"@antv/x6-react-shape",paraId:10,tocIndex:4},{value:" provided by the X6 ecosystem.",paraId:10,tocIndex:4},{value:"In addition to the basic element rendering capabilities, X6 also comes with a large number of built-in plugins for graph editing. Using these mature plugins, we can improve the development efficiency. For example, we add a snapline plugin to the graph, when a moving node is aligned with other nodes, the snapline will automatically appear.",paraId:11,tocIndex:5},{value:"import { Snapline } from '@antv/x6'\n\ngraph.use(\n  new Snapline({\n    enabled: true,\n  }),\n)\n",paraId:12,tocIndex:5},{value:"In addition to using ",paraId:13,tocIndex:6},{value:"fromJSON",paraId:13,tocIndex:6},{value:" to render JSON data to the graph, of course, there is also support for exporting the data from the graph with ",paraId:13,tocIndex:6},{value:"toJSON",paraId:13,tocIndex:6},{value:", so that we can serialize the graph data and store it to the server.",paraId:13,tocIndex:6},{value:"graph.toJSON()\n",paraId:14,tocIndex:6},{value:"That's the end of our demo. If you want to continue learning about some capabilities of X6, you can start reading from the ",paraId:15,tocIndex:6},{value:"Basic Tutorial",paraId:16,tocIndex:6},{value:".",paraId:15,tocIndex:6}]},53899:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(34739);const n=[{value:"How to use Angular to render node content",paraId:0},{value:"How to update node content",paraId:0},{value:"FAQ",paraId:0},{value:"We provide a standalone package ",paraId:1,tocIndex:0},{value:"@antv/x6-angular-shape",paraId:1,tocIndex:0},{value:" for rendering Angular components/templates as nodes.",paraId:1,tocIndex:0},{value:"Version compatibility: X6 3.x must use x6-angular-shape 3.x.",paraId:2},{value:"@Component({\n  selector: 'app-node',\n  templateUrl: './node.component.html',\n  styleUrls: ['./node.component.scss'],\n})\nexport class NodeComponent implements AfterViewInit, OnChanges {\n  @Input() value: string;\n}\n",paraId:3,tocIndex:1},{value:"import { register } from '@antv/x6-angular-shape';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss'],\n})\nexport class AppComponent implements AfterViewInit {\n  ngAfterViewInit(): void {\n    register({\n      shape: 'custom-angular-component-node',\n      width: 120,\n      height: 20,\n      content: NodeComponent,\n      injector: this.injector,\n    });\n\n    this.graph.addNode({\n      shape: 'custom-angular-component-node',\n      x: 100,\n      y: 100,\n      data: {\n        // Input parameters must be placed here\n        ngArguments: {\n          value: 'Oh my god, what a mess',\n        },\n      },\n    });\n  }\n}\n",paraId:4,tocIndex:1},{value:'<ng-template #template let-data="ngArguments">\n  <section class="template-container">\n    <span class="value">{{ data.value }}</span>\n  </section>\n</ng-template>\n',paraId:5,tocIndex:2},{value:"import { register } from '@antv/x6-angular-shape';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss'],\n})\nexport class AppComponent implements AfterViewInit {\n  @ViewChild('template') template: TemplateRef<{}>;\n\n  ngAfterViewInit(): void {\n    register({\n      shape: 'custom-angular-template-node',\n      width: 120,\n      height: 20,\n      content: this.template,\n      injector: this.injector,\n    });\n\n    this.graph.addNode({\n      shape: 'custom-angular-template-node',\n      x: 100,\n      y: 100,\n      data: {\n        ngArguments: {\n          value: 'Why is the magic failing?',\n        },\n      },\n    });\n  }\n}\n",paraId:6,tocIndex:2},{value:"Whether using Component or TemplateRef, the update method is the same.",paraId:7,tocIndex:3},{value:"node.setData({\n  ngArguments: {\n    value: 'A few frames from the past in the evening breeze',\n  },\n});\n",paraId:8,tocIndex:3},{value:"Yes, because the rendering of nodes in X6 is decoupled from the framework, the ",paraId:9,tocIndex:4},{value:"x6-angular-shape",paraId:9,tocIndex:4},{value:" package is not directly modified in the source code but developed in a separate Angular environment. The demo also provides performance tests for various node types. For more details, please refer to ",paraId:9,tocIndex:4},{value:"Eve-Sama/x6-angular-shape",paraId:9,tocIndex:4},{value:" and ",paraId:9,tocIndex:4},{value:"Performance comparison between X6 and G6, as well as discussions on FPS thresholds for multiple node types in X6",paraId:9,tocIndex:4},{value:".",paraId:9,tocIndex:4},{value:"Not all properties in ",paraId:10,tocIndex:6},{value:"node.data",paraId:10,tocIndex:6},{value:" are input properties, so it is inappropriate to iterate over all properties in ",paraId:10,tocIndex:6},{value:"data",paraId:10,tocIndex:6},{value:" for assignment. The reason it is called ",paraId:10,tocIndex:6},{value:"ngArguments",paraId:10,tocIndex:6},{value:" is mainly due to two considerations:",paraId:10,tocIndex:6},{value:"The 1.x version has already used this, and maintaining this API can reduce the upgrade cost for users.",paraId:11,tocIndex:6},{value:"The concept of ",paraId:12,tocIndex:6},{value:"Input",paraId:12,tocIndex:6},{value:" actually comes from ",paraId:12,tocIndex:6},{value:"Component",paraId:12,tocIndex:6},{value:", while in ",paraId:12,tocIndex:6},{value:"TemplateRef",paraId:12,tocIndex:6},{value:" it is ",paraId:12,tocIndex:6},{value:"context",paraId:12,tocIndex:6},{value:". Abstracting a concept of ",paraId:12,tocIndex:6},{value:"Arguments",paraId:12,tocIndex:6},{value:" based on the two is more general.",paraId:12,tocIndex:6},{value:"The implementation approach is quite similar to before, but there are indeed a few points worth mentioning.",paraId:13,tocIndex:7},{value:"The demo in version 1.x included a series of cases such as rendering components, drawing connections, clearing, etc. While it seemed like an extension, it was actually overwhelming. The demo for version 2.x of ",paraId:14,tocIndex:8},{value:"x6-angular-shape",paraId:14,tocIndex:8},{value:" is more focused, concentrating on the usage and performance testing of shapes. For unrelated content, please refer to the X6 official website.",paraId:14,tocIndex:8},{value:"In version 1.x, although functionality was implemented, the consideration of usage scenarios was not comprehensive. For example, changes to ",paraId:15,tocIndex:9},{value:"ngArguments",paraId:15,tocIndex:9},{value:" did not affect the ",paraId:15,tocIndex:9},{value:"TemplateRef",paraId:15,tocIndex:9},{value:" scenario. While it worked for ",paraId:15,tocIndex:9},{value:"Component",paraId:15,tocIndex:9},{value:", it could not trigger ",paraId:15,tocIndex:9},{value:"ngOnChanges",paraId:15,tocIndex:9},{value:". In the new version, these issues will no longer exist.",paraId:15,tocIndex:9},{value:"Your Angular version must be at least 14 or above. Below version 14, some features need to be implemented using hacks, which can be cumbersome. This is not currently provided, but if needed, you can raise an issue, and I will explain how to implement it.",paraId:16,tocIndex:10}]},15881:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(36518);const n=[{value:"Concepts of anchors and connection points",paraId:0},{value:"How to use anchors and connection points to customize special edges",paraId:0},{value:"Let's start with an example:",paraId:1},{value:"When you move the node above, the edge connection points on the node remain fixed, and multiple edges keep a gap between them. This differs from the previous example. How is this achieved? Let's understand anchors and connection points with the following diagram.",paraId:2},{value:"By default, the anchor is ",paraId:3,tocIndex:0},{value:"center",paraId:3,tocIndex:0},{value:" (the element center). ",paraId:3,tocIndex:0},{value:"connectionPoint",paraId:3,tocIndex:0},{value:" specifies how to compute intersection points; its default is ",paraId:3,tocIndex:0},{value:"boundary",paraId:3,tocIndex:0},{value:" (intersection with the element boundary). An edge is drawn by connecting a reference line from the source anchor to the target anchor. The intersection of that line with the element, computed per ",paraId:3,tocIndex:0},{value:"connectionPoint",paraId:3,tocIndex:0},{value:", becomes the edge's start/end point.",paraId:3,tocIndex:0},{value:"You can configure ",paraId:4,tocIndex:1},{value:"anchor",paraId:4,tocIndex:1},{value:" and ",paraId:4,tocIndex:1},{value:"connectionPoint",paraId:4,tocIndex:1},{value:" globally in ",paraId:4,tocIndex:1},{value:"connecting",paraId:4,tocIndex:1},{value:", or per edge via ",paraId:4,tocIndex:1},{value:"source",paraId:4,tocIndex:1},{value:" and ",paraId:4,tocIndex:1},{value:"target",paraId:4,tocIndex:1},{value:".",paraId:4,tocIndex:1},{value:"// Configuring in connecting\nconst graph = new Graph({\n  connecting: {\n    sourceAnchor: {\n      name: 'right', // Offsets the anchor 10px upward from the center on the right side of the node\n      args: {\n        dy: -10,\n      },\n    },\n    targetAnchor: {\n      name: 'right', // Offsets the anchor 10px upward from the center on the right side of the node\n      args: {\n        dy: -10,\n      },\n    },\n    connectionPoint: 'anchor',\n  },\n})\n\n// Per-edge configuration takes precedence\ngraph.addEdge({\n  source: {\n    cell: source,\n    anchor: {\n      name: 'right',\n      args: {\n        dy: -10,\n      },\n    },\n    connectionPoint: 'anchor',\n  },\n  target: {\n    cell: target,\n    anchor: {\n      name: 'left',\n      args: {\n        dy: -10,\n      },\n    },\n    connectionPoint: 'anchor',\n  },\n})\n",paraId:5,tocIndex:1},{value:"X6 also supports a wide variety of anchor and connection point types. To customize special edges, refer to ",paraId:6,tocIndex:1},{value:"NodeAnchor",paraId:7,tocIndex:1},{value:" and ",paraId:6,tocIndex:1},{value:"ConnectionPoint",paraId:8,tocIndex:1},{value:".",paraId:6,tocIndex:1}]},69372:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(80818);const n=[{value:"How to group nodes",paraId:0},{value:"How to group nodes via interaction",paraId:0},{value:"How to restrict child node movement in a group",paraId:0},{value:"How to automatically expand the parent node",paraId:0},{value:"How to expand and collapse the parent node",paraId:0},{value:"You can build groups via parentchild relationships, with ",paraId:1,tocIndex:0},{value:"methods",paraId:2,tocIndex:0},{value:" to get and set them.",paraId:1,tocIndex:0},{value:"From the example above:",paraId:3},{value:"Moving the parent node also moves its children, even if they are outside.",paraId:4},{value:"By default, the edges parent is the common parent of its terminals. Moving the parent moves the edges vertices.",paraId:4},{value:"Sometimes you need to drag one node into another to make it a child. Enable ",paraId:5,tocIndex:1},{value:"embedding",paraId:5,tocIndex:1},{value:" and implement ",paraId:5,tocIndex:1},{value:"findParent",paraId:5,tocIndex:1},{value:" to return the parent on move. See the ",paraId:5,tocIndex:1},{value:"API",paraId:6,tocIndex:1},{value:" for details.",paraId:5,tocIndex:1},{value:"Limit the movement range of child nodes within the parent by using the ",paraId:7,tocIndex:2},{value:"translating.restrict",paraId:7,tocIndex:2},{value:" option when creating the ",paraId:7,tocIndex:2},{value:"Graph",paraId:7,tocIndex:2},{value:" instance.",paraId:7,tocIndex:2},{value:"Listen to ",paraId:8,tocIndex:3},{value:"node:change:position",paraId:8,tocIndex:3},{value:" to automatically expand/shrink the parent when a child moves, ensuring it fully encompasses the children. The example code is a bit involved; click the demos ",paraId:8,tocIndex:3},{value:"CodeSandbox",paraId:8,tocIndex:3},{value:" link to view the full implementation.",paraId:8,tocIndex:3},{value:"First, define a custom ",paraId:9,tocIndex:4},{value:"Group",paraId:9,tocIndex:4},{value:" node that renders an expand/collapse button at the top-left corner and sets a custom event ",paraId:9,tocIndex:4},{value:"node:collapse",paraId:9,tocIndex:4},{value:" on that button:",paraId:9,tocIndex:4},{value:"import { Node } from '@antv/x6'\n\nexport class Group extends Node {\n  private collapsed: boolean = false\n  private expandSize: { width: number; height: number }\n\n  protected postprocess() {\n    this.toggleCollapse(false)\n  }\n\n  isCollapsed() {\n    return this.collapsed\n  }\n\n  toggleCollapse(collapsed?: boolean) {\n    const target = collapsed == null ? !this.collapsed : collapsed\n    if (target) {\n      this.attr('buttonSign', { d: 'M 1 5 9 5 M 5 1 5 9' })\n      this.expandSize = this.getSize()\n      this.resize(100, 32)\n    } else {\n      this.attr('buttonSign', { d: 'M 2 5 8 5' })\n      if (this.expandSize) {\n        this.resize(this.expandSize.width, this.expandSize.height)\n      }\n    }\n    this.collapsed = target\n  }\n}\n\nGroup.config({\n  markup: [\n    {\n      tagName: 'rect',\n      selector: 'body',\n    },\n    {\n      tagName: 'text',\n      selector: 'label',\n    },\n    {\n      tagName: 'g',\n      selector: 'buttonGroup',\n      children: [\n        {\n          tagName: 'rect',\n          selector: 'button',\n        },\n        {\n          tagName: 'path',\n          selector: 'buttonSign',\n        },\n      ],\n    },\n  ],\n  attrs: {\n    body: { ... },\n    label: { ... },\n    buttonGroup: { ... },\n    button: {\n      ...\n      // Custom event\n      event: 'node:collapse',\n    },\n    buttonSign: { ... },\n  },\n})\n",paraId:10,tocIndex:4},{value:"Then listen for ",paraId:11,tocIndex:4},{value:"node:collapse",paraId:11,tocIndex:4},{value:" on the ",paraId:11,tocIndex:4},{value:"graph",paraId:11,tocIndex:4},{value:", and show/hide the corresponding child nodes when the parent node is expanded/collapsed:",paraId:11,tocIndex:4},{value:"graph.on('node:collapse', ({ node }: { node: Group }) => {\n  node.toggleCollapse()\n  const collapsed = node.isCollapsed()\n  const cells = node.getDescendants()\n  cells.forEach((node) => {\n    if (collapsed) {\n      node.hide()\n    } else {\n      node.show()\n    }\n  })\n})\n",paraId:12,tocIndex:4}]},94295:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(63126);const n=[{value:"How to use HTML to render node content",paraId:0},{value:"How to update node content",paraId:0},{value:"X6 comes with built-in ",paraId:1,tocIndex:0},{value:"HTML",paraId:1,tocIndex:0},{value:" rendering capabilities, and it's very easy to use:",paraId:1,tocIndex:0},{value:"import { Shape } from '@antv/x6'\n\nShape.HTML.register({\n  shape: 'custom-html',\n  width: 160,\n  height: 80,\n  html() {\n    const div = document.createElement('div')\n    div.className = 'custom-html'\n    return div\n  },\n})\n\ngraph.addNode({\n  shape: 'custom-html',\n  x: 60,\n  y: 100,\n})\n",paraId:2,tocIndex:0},{value:"In the example below, we add a hover animation effect to the ",paraId:3,tocIndex:0},{value:"HTML",paraId:3,tocIndex:0},{value:" element, which would be quite complex to implement using ",paraId:3,tocIndex:0},{value:"SVG",paraId:3,tocIndex:0},{value:".",paraId:3,tocIndex:0},{value:"When registering the node, provide an ",paraId:4,tocIndex:1},{value:"effect",paraId:4,tocIndex:1},{value:" fieldthe array of the nodes ",paraId:4,tocIndex:1},{value:"props",paraId:4,tocIndex:1},{value:". When any listed prop changes, the ",paraId:4,tocIndex:1},{value:"html",paraId:4,tocIndex:1},{value:" method runs again and returns a new DOM to update the node content.",paraId:4,tocIndex:1},{value:"Shape.HTML.register({\n  shape: 'custom-html',\n  width: 160,\n  height: 80,\n  effect: ['data'],\n  html(cell) {\n    const { color } = cell.getData()\n    const div = document.createElement('div')\n    div.className = 'custom-html'\n    div.style.background = color\n    return div\n  },\n})\n",paraId:5,tocIndex:1}]},95026:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(86346);const n=[{value:"How to use React components to render node content",paraId:0},{value:"How to update node content",paraId:0},{value:"We provide a standalone package ",paraId:1,tocIndex:0},{value:"@antv/x6-react-shape",paraId:1,tocIndex:0},{value:" for rendering nodes with React.",paraId:1,tocIndex:0},{value:"Version compatibility: X6 3.x must use x6-react-shape 3.x. Since 2.0.8, x6-react-shape supports React 18+ only; if your project uses React < 18, lock x6-react-shape to 2.0.8 and use X6 2.x.",paraId:2},{value:"import { register } from '@antv/x6-react-shape'\n\nconst NodeComponent = () => {\n  return (\n    <div className=\"react-node\">\n      <Progress type=\"circle\" percent={30} width={80} />\n    </div>\n  )\n}\n\nregister({\n  shape: 'custom-basic-react-node',\n  width: 100,\n  height: 100,\n  component: NodeComponent,\n})\n\ngraph.addNode({\n  shape: 'custom-basic-react-node',\n  x: 60,\n  y: 100,\n})\n",paraId:3},{value:"Similar to ",paraId:4,tocIndex:1},{value:"HTML",paraId:4,tocIndex:1},{value:", register a node with an ",paraId:4,tocIndex:1},{value:"effect",paraId:4,tocIndex:1},{value:" fieldan array of the nodes ",paraId:4,tocIndex:1},{value:"props",paraId:4,tocIndex:1},{value:". When any listed prop changes, the React component re-renders.",paraId:4,tocIndex:1},{value:"register({\n  shape: 'custom-update-react-node',\n  width: 100,\n  height: 100,\n  effect: ['data'],\n  component: NodeComponent,\n})\n\nconst node = graph.addNode({\n  shape: 'custom-update-react-node',\n  x: 60,\n  y: 100,\n  data: {\n    progress: 30,\n  },\n})\n\nsetInterval(() => {\n  const { progress } = node.getData<{ progress: number }>()\n  node.setData({\n    progress: (progress + 10) % 100,\n  })\n}, 1000)\n",paraId:5,tocIndex:1},{value:"The approach above renders the component directly into the nodes DOM:",paraId:6,tocIndex:2},{value:"import { createRoot, Root } from 'react-dom/client'\n\nconst root = createRoot(container) // container is the node container\nroot.render(component)\n",paraId:7,tocIndex:2},{value:"This detaches the component from the normal React tree, so it cannot access external ",paraId:8,tocIndex:2},{value:"Context",paraId:8,tocIndex:2},{value:". Use ",paraId:8,tocIndex:2},{value:"Portal",paraId:8,tocIndex:2},{value:" mode when you need access to app-level context.",paraId:8,tocIndex:2}]},51337:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(86856);const n=[{value:"How to add tools for nodes or edges",paraId:0},{value:"Common tools built into X6",paraId:0},{value:"When creating nodes/edges, you can add tools through the ",paraId:1,tocIndex:0},{value:"tools",paraId:2,tocIndex:0},{value:" option:",paraId:1,tocIndex:0},{value:"graph.addNode({\n  tools: [\n    {\n      name: 'button-remove', // Tool name\n      args: {\n        // Tool parameters\n        x: 10,\n        y: 10,\n      },\n    },\n  ],\n})\n\n// If no parameters are needed, you can abbreviate as:\ngraph.addNode({\n  tools: ['button-remove'],\n})\n\ngraph.addEdge({\n  source,\n  target,\n  vertices: [\n    {\n      x: 90,\n      y: 160,\n    },\n    {\n      x: 210,\n      y: 160,\n    },\n  ],\n  tools: ['vertices', 'segments'],\n})\n",paraId:3,tocIndex:0},{value:"After nodes/edges are created, you can call methods like ",paraId:4},{value:"hasTool(name)",paraId:5},{value:", ",paraId:4},{value:"addTools(...)",paraId:6},{value:", and ",paraId:4},{value:"removeTools()",paraId:7},{value:" to add or remove tools.",paraId:4},{value:"Tools are widgets rendered on nodes/edges to enhance interactivity. We provide the following built-in tools for nodes and edges:",paraId:8,tocIndex:1},{value:"button",paraId:9,tocIndex:2},{value:" Renders a button at a specified position; supports custom click interactions.",paraId:10,tocIndex:2},{value:"button-remove",paraId:11,tocIndex:2},{value:" Renders a delete button at a specified position; clicking deletes the node.",paraId:10,tocIndex:2},{value:"boundary",paraId:12,tocIndex:2},{value:" Renders a rectangle around the node based on its bounding box. Note: visualization only; no interaction.",paraId:10,tocIndex:2},{value:"vertices",paraId:13,tocIndex:3},{value:" Renders dots at path points. Drag to move; double-click to delete; click on the edge to add.",paraId:14,tocIndex:3},{value:"segments",paraId:15,tocIndex:3},{value:" Renders a handle at each segments center; drag to adjust the adjacent path points.",paraId:14,tocIndex:3},{value:"boundary",paraId:16,tocIndex:3},{value:" Renders a rectangle around the edge based on its bounding box. Note: visualization only; no interaction.",paraId:14,tocIndex:3},{value:"button",paraId:17,tocIndex:3},{value:" Renders a button at a specified position; supports custom click interactions.",paraId:14,tocIndex:3},{value:"button-remove",paraId:18,tocIndex:3},{value:" Renders a delete button at a specified position; clicking deletes the edge.",paraId:14,tocIndex:3},{value:"source-arrowhead and target-arrowhead",paraId:19,tocIndex:3},{value:" Renders a shape (arrow by default) at the source/target terminal; drag to adjust the terminal.",paraId:14,tocIndex:3}]},35574:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(41245);const n=[{value:"How to use Vue components to render node content",paraId:0},{value:"How to update node content",paraId:0},{value:"We provide a standalone package ",paraId:1,tocIndex:0},{value:"@antv/x6-vue-shape",paraId:1,tocIndex:0},{value:" for rendering nodes with Vue components.",paraId:1,tocIndex:0},{value:"Version compatibility: X6 3.x must use x6-vue-shape 3.x.",paraId:2},{value:"<template>\n  <div class=\"app-content\">\n    <div id=\"container\"></div>\n    <TeleportContainer />\n  </div>\n</template>\n\n<script lang=\"ts\">\n  import { defineComponent } from 'vue'\n  import ProgressNode from './components/ProgressNode.vue'\n  import { Graph } from '@antv/x6'\n  import { register, getTeleport } from '@antv/x6-vue-shape'\n\n  register({\n    shape: 'custom-vue-node',\n    width: 100,\n    height: 100,\n    component: ProgressNode,\n  })\n  const TeleportContainer = getTeleport()\n\n  export default defineComponent({\n    name: 'App',\n    components: {\n      TeleportContainer,\n    },\n    mounted() {\n      const graph = new Graph({\n        container: document.getElementById('container')!,\n        background: {\n          color: '#F2F7FA',\n        },\n        autoResize: true,\n      })\n\n      graph.addNode({\n        shape: 'custom-vue-node',\n        x: 100,\n        y: 60,\n      })\n    },\n  })\n<\/script>\n",paraId:3},{value:"The content of the node component is as follows:",paraId:4},{value:'<template>\n  <el-progress type="dashboard" :percentage="percentage" :width="80">\n    <template #default="{ percentage }">\n      <span class="percentage-value">{{ percentage }}%</span>\n    </template>\n  </el-progress>\n</template>\n\n<script lang="ts">\n  import { defineComponent } from \'vue\'\n\n  export default defineComponent({\n    name: \'ProgressNode\',\n    inject: [\'getNode\'],\n    data() {\n      return {\n        percentage: 80,\n      }\n    },\n    mounted() {\n      const node = (this as any).getNode()\n      console.log(node)\n    },\n  })\n<\/script>\n',paraId:5},{value:"The result is as follows:",paraId:6},{value:"To update the content of a ",paraId:7,tocIndex:1},{value:"Vue",paraId:7,tocIndex:1},{value:" node, there are two methods:",paraId:7,tocIndex:1},{value:"Listen for node events within the component and trigger events externally.",paraId:8,tocIndex:1},{value:"Use state management tools like ",paraId:8,tocIndex:1},{value:"Vuex",paraId:8,tocIndex:1},{value:" (not elaborated here, but used in the same way as regular ",paraId:8,tocIndex:1},{value:"Vue",paraId:8,tocIndex:1},{value:" components with ",paraId:8,tocIndex:1},{value:"Vuex",paraId:8,tocIndex:1},{value:" data).",paraId:8,tocIndex:1},{value:"Below is an introduction to dynamically updating node content using events:",paraId:9,tocIndex:1},{value:"const node = graph.addNode({\n  shape: 'custom-vue-node',\n  x: 100,\n  y: 60,\n  data: {\n    progress: 80,\n  },\n})\n\nsetInterval(() => {\n  const { progress } = node.getData()\n  node.setData({\n    progress: (progress + 10) % 100,\n  })\n}, 2000)\n",paraId:10,tocIndex:1},{value:"Inside the node component, we can listen for changes to the node's ",paraId:11,tocIndex:1},{value:"data",paraId:11,tocIndex:1},{value:":",paraId:11,tocIndex:1},{value:"export default defineComponent({\n  name: 'ProgressNode',\n  inject: ['getNode'],\n  data() {\n    return {\n      percentage: 80,\n    }\n  },\n  mounted() {\n    const node = (this as any).getNode() as Node\n    node.on('change:data', ({ current }) => {\n      const { progress } = current\n      this.percentage = progress\n    })\n  },\n})\n",paraId:12,tocIndex:1},{value:"In the above example, we used ",paraId:13,tocIndex:2},{value:"Teleport",paraId:13,tocIndex:2},{value:", a feature in ",paraId:13,tocIndex:2},{value:"Vue 3",paraId:13,tocIndex:2},{value:". How can we use it in ",paraId:13,tocIndex:2},{value:"Vue 2",paraId:13,tocIndex:2},{value:"?",paraId:13,tocIndex:2},{value:"<template>\n  <div id=\"app\"></div>\n</template>\n\n<script lang=\"ts\">\n  import Vue from 'vue'\n  import CustomNode from './components/CustomNode.vue'\n  import { Graph } from '@antv/x6'\n  import { register } from '@antv/x6-vue-shape'\n\n  register({\n    shape: 'custom-vue-node',\n    width: 100,\n    height: 100,\n    component: CustomNode,\n  })\n\n  export default Vue.extend({\n    name: 'App',\n    mounted() {\n      const graph = new Graph({\n        container: document.getElementById('app'),\n        width: 1000,\n        height: 1000,\n      })\n\n      graph.addNode({\n        shape: 'custom-vue-node',\n        x: 100,\n        y: 100,\n      })\n    },\n  })\n<\/script>\n",paraId:14,tocIndex:2},{value:"The node component is written in the same way as above.",paraId:15,tocIndex:2},{value:"In Vue 2, node components have some limitations, such as the inability to use Vuex, i18n, and Element UI.",paraId:16}]},3544:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(63874);const n=[{value:"How to use copy and paste",paraId:0},{value:"The clipboard is used for copying/pasting nodes and edges. Enable the feature via the ",paraId:1,tocIndex:0},{value:"Clipboard",paraId:1,tocIndex:0},{value:" plugin:",paraId:1,tocIndex:0},{value:"import { Graph, Clipboard } from '@antv/x6'\n\nconst graph = new Graph({\n  background: {\n    color: '#F2F7FA',\n  },\n})\ngraph.use(\n  new Clipboard({\n    enabled: true,\n  }),\n)\n",paraId:2,tocIndex:0},{value:"After selecting a node, click the copy button to copy the node.",paraId:3,tocIndex:1},{value:"Set different ",paraId:3,tocIndex:1},{value:"offset",paraId:3,tocIndex:1},{value:" values to observe the effect on the node's position when pasting.",paraId:3,tocIndex:1},{value:"After enabling ",paraId:3,tocIndex:1},{value:"localStorage",paraId:3,tocIndex:1},{value:", copy a node, refresh the page or reopen the browser, then click the paste button.",paraId:3,tocIndex:1},{value:"Property Name",paraId:4,tocIndex:2},{value:"Type",paraId:4,tocIndex:2},{value:"Default Value",paraId:4,tocIndex:2},{value:"Required",paraId:4,tocIndex:2},{value:"Description",paraId:4,tocIndex:2},{value:"useLocalStorage",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:"When enabled, the copied nodes/edges are also saved to ",paraId:4,tocIndex:2},{value:"localStorage",paraId:4,tocIndex:2},{value:", allowing copy/paste to work after refreshing or reopening the browser.",paraId:4,tocIndex:2},{value:"copy(cells: Cell[], options: CopyOptions = {}): this\n",paraId:5,tocIndex:4},{value:"Copy nodes/edges. Parameters are as follows:",paraId:6,tocIndex:4},{value:"Name",paraId:7,tocIndex:4},{value:"Type",paraId:7,tocIndex:4},{value:"Required",paraId:7,tocIndex:4},{value:"Default Value",paraId:7,tocIndex:4},{value:"Description",paraId:7,tocIndex:4},{value:"cells",paraId:7,tocIndex:4},{value:"Cell[]",paraId:7,tocIndex:4},{value:"",paraId:7,tocIndex:4},{value:"The nodes/edges to be copied.",paraId:7,tocIndex:4},{value:"options.deep",paraId:7,tocIndex:4},{value:"boolean",paraId:7,tocIndex:4},{value:"-",paraId:7,tocIndex:4},{value:"Whether to recursively copy all child nodes/edges.",paraId:7,tocIndex:4},{value:"options.useLocalStorage",paraId:7,tocIndex:4},{value:"boolean",paraId:7,tocIndex:4},{value:"-",paraId:7,tocIndex:4},{value:"Whether to save the copied nodes/edges in ",paraId:7,tocIndex:4},{value:"localStorage",paraId:7,tocIndex:4},{value:".",paraId:7,tocIndex:4},{value:"cut(cells: Cell[], options: CopyOptions = {}): this\n",paraId:8,tocIndex:5},{value:"Cut nodes/edges. Parameters are as follows:",paraId:9,tocIndex:5},{value:"Name",paraId:10,tocIndex:5},{value:"Type",paraId:10,tocIndex:5},{value:"Required",paraId:10,tocIndex:5},{value:"Default Value",paraId:10,tocIndex:5},{value:"Description",paraId:10,tocIndex:5},{value:"cells",paraId:10,tocIndex:5},{value:"Cell[]",paraId:10,tocIndex:5},{value:"",paraId:10,tocIndex:5},{value:"The nodes/edges to be cut.",paraId:10,tocIndex:5},{value:"options.deep",paraId:10,tocIndex:5},{value:"boolean",paraId:10,tocIndex:5},{value:"-",paraId:10,tocIndex:5},{value:"Whether to recursively copy all child nodes/edges.",paraId:10,tocIndex:5},{value:"options.useLocalStorage",paraId:10,tocIndex:5},{value:"boolean",paraId:10,tocIndex:5},{value:"-",paraId:10,tocIndex:5},{value:"Whether to save the copied nodes/edges in ",paraId:10,tocIndex:5},{value:"localStorage",paraId:10,tocIndex:5},{value:".",paraId:10,tocIndex:5},{value:"paste(options?: PasteOptions, graph?: Graph): Cell[]\n",paraId:11,tocIndex:6},{value:"Paste and return the nodes/edges pasted onto the canvas. Parameters are as follows:",paraId:12,tocIndex:6},{value:"Name",paraId:13,tocIndex:6},{value:"Type",paraId:13,tocIndex:6},{value:"Required",paraId:13,tocIndex:6},{value:"Default Value",paraId:13,tocIndex:6},{value:"Description",paraId:13,tocIndex:6},{value:"options.useLocalStorage",paraId:13,tocIndex:6},{value:"boolean",paraId:13,tocIndex:6},{value:"-",paraId:13,tocIndex:6},{value:"Whether to use nodes/edges from ",paraId:13,tocIndex:6},{value:"localStorage",paraId:13,tocIndex:6},{value:".",paraId:13,tocIndex:6},{value:"options.offset",paraId:13,tocIndex:6},{value:"number | ",paraId:13,tocIndex:6},{value:"{ dx: number; dy: number }",paraId:13,tocIndex:6},{value:"20",paraId:13,tocIndex:6},{value:"The offset for the nodes/edges pasted onto the canvas.",paraId:13,tocIndex:6},{value:"options.nodeProps",paraId:13,tocIndex:6},{value:"Node.Properties",paraId:13,tocIndex:6},{value:"-",paraId:13,tocIndex:6},{value:"Additional properties for the nodes pasted onto the canvas.",paraId:13,tocIndex:6},{value:"options.edgeProps",paraId:13,tocIndex:6},{value:"Edge.Properties",paraId:13,tocIndex:6},{value:"-",paraId:13,tocIndex:6},{value:"Additional properties for the edges pasted onto the canvas.",paraId:13,tocIndex:6},{value:"graph",paraId:13,tocIndex:6},{value:"Graph",paraId:13,tocIndex:6},{value:"this",paraId:13,tocIndex:6},{value:"The target canvas for pasting, defaults to the current canvas.",paraId:13,tocIndex:6},{value:"getCellsInClipboard(): Cell[]\n",paraId:14,tocIndex:7},{value:"Get the nodes/edges in the clipboard.",paraId:15,tocIndex:7},{value:"cleanClipboard(): this\n",paraId:16,tocIndex:8},{value:"Clear the clipboard.",paraId:17,tocIndex:8},{value:"isClipboardEmpty(): boolean\n",paraId:18,tocIndex:9},{value:"Return whether the clipboard is empty.",paraId:19,tocIndex:9},{value:"isClipboardEnabled(): boolean\n",paraId:20,tocIndex:10},{value:"Return whether the clipboard is enabled.",paraId:21,tocIndex:10},{value:"enableClipboard(): this\n",paraId:22,tocIndex:11},{value:"Enable the clipboard.",paraId:23,tocIndex:11},{value:"disableClipboard(): this\n",paraId:24,tocIndex:12},{value:"Disable the clipboard.",paraId:25,tocIndex:12},{value:"toggleClipboard(enabled?: boolean): this\n",paraId:26,tocIndex:13},{value:"Toggle the clipboard's enabled state. Parameters are as follows:",paraId:27,tocIndex:13},{value:"Name",paraId:28,tocIndex:13},{value:"Type",paraId:28,tocIndex:13},{value:"Required",paraId:28,tocIndex:13},{value:"Default Value",paraId:28,tocIndex:13},{value:"Description",paraId:28,tocIndex:13},{value:"enabled",paraId:28,tocIndex:13},{value:"boolean",paraId:28,tocIndex:13},{value:"-",paraId:28,tocIndex:13},{value:"Whether to enable the clipboard; if omitted, toggles the current enabled state.",paraId:28,tocIndex:13},{value:"Event Name",paraId:29,tocIndex:14},{value:"Parameter Type",paraId:29,tocIndex:14},{value:"Description",paraId:29,tocIndex:14},{value:"clipboard:changed",paraId:29,tocIndex:14},{value:"{ cells: Cell[] }",paraId:29,tocIndex:14},{value:"Triggered when copying, cutting, or clearing the clipboard.",paraId:29,tocIndex:14},{value:"graph.on('clipboard:changed', ({ cells }) => {\n  console.log(cells)\n})\n\n// We can also listen to events on the plugin instance\nclipboard.on('clipboard:changed', ({ cells }) => {\n  console.log(cells)\n})\n",paraId:30,tocIndex:14}]},11162:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(45514);const n=[{value:"How to add nodes via drag-and-drop",paraId:0},{value:"How to customize the dragged and dropped nodes",paraId:0},{value:"We often need to add nodes to the canvas through drag-and-drop interactions, such as in process graph editing scenarios, where we drag and drop components from the process graph component library onto the canvas. You can enable drag-and-drop with the ",paraId:1,tocIndex:0},{value:"Dnd",paraId:1,tocIndex:0},{value:" plugin. Example:",paraId:1,tocIndex:0},{value:"import { Graph, Dnd } from '@antv/x6'\n\nconst graph = new Graph({\n  background: {\n    color: '#F2F7FA',\n  },\n})\n\nconst dnd = new Dnd({\n  target: graph,\n})\n",paraId:2,tocIndex:0},{value:"When starting to drag, we need to call the ",paraId:3,tocIndex:0},{value:"dnd.start(node, e)",paraId:3,tocIndex:0},{value:" method. In React, we use it like this:",paraId:3,tocIndex:0},{value:"export default () => {\n  const startDrag = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    // The node is the node being dragged, which is also the node placed on the canvas by default, and can be customized with any properties\n    const node = graph.createNode({\n      shape: 'rect',\n      width: 100,\n      height: 40,\n    })\n    dnd.start(node, e.nativeEvent)\n  }\n\n  return (\n    <ul>\n      <li onMouseDown={startDrag}></li>\n    </ul>\n  )\n}\n",paraId:4,tocIndex:0},{value:"Option",paraId:5,tocIndex:2},{value:"Type",paraId:5,tocIndex:2},{value:"Required",paraId:5,tocIndex:2},{value:"Default Value",paraId:5,tocIndex:2},{value:"Description",paraId:5,tocIndex:2},{value:"target",paraId:5,tocIndex:2},{value:"Graph",paraId:5,tocIndex:2},{value:"",paraId:5,tocIndex:2},{value:"The target canvas.",paraId:5,tocIndex:2},{value:"getDragNode",paraId:5,tocIndex:2},{value:"(sourceNode: Node, options: GetDragNodeOptions) => Node",paraId:5,tocIndex:2},{value:"Get the node being dragged when dragging starts, default to cloning the node passed to ",paraId:5,tocIndex:2},{value:"dnd.start",paraId:5,tocIndex:2},{value:".",paraId:5,tocIndex:2},{value:"getDropNode",paraId:5,tocIndex:2},{value:"(draggingNode: Node, options: GetDropNodeOptions) => Node",paraId:5,tocIndex:2},{value:"Get the node to be placed on the target canvas when dragging ends, default to cloning the dragged node.",paraId:5,tocIndex:2},{value:"validateNode",paraId:5,tocIndex:2},{value:"(droppingNode: Node, options: ValidateNodeOptions) => boolean | Promise<boolean>",paraId:5,tocIndex:2},{value:"Validate whether the node can be placed on the target canvas when dragging ends.",paraId:5,tocIndex:2},{value:"dndContainer",paraId:5,tocIndex:2},{value:"HTMLElement",paraId:5,tocIndex:2},{value:"If ",paraId:5,tocIndex:2},{value:"dndContainer",paraId:5,tocIndex:2},{value:" is set, releasing the mouse on ",paraId:5,tocIndex:2},{value:"dndContainer",paraId:5,tocIndex:2},{value:" will not place the node, commonly used in scenarios where the ",paraId:5,tocIndex:2},{value:"dnd",paraId:5,tocIndex:2},{value:" container is above the canvas.",paraId:5,tocIndex:2},{value:"draggingContainer",paraId:5,tocIndex:2},{value:"HTMLElement",paraId:5,tocIndex:2},{value:"document.body",paraId:5,tocIndex:2},{value:"Customize the dragging canvas container.",paraId:5,tocIndex:2},{value:"Why does the node ID change after dragging and dropping it onto the canvas?",paraId:6,tocIndex:3},{value:"According to the dragging details above, we can see that the overall dragging process is: source node -> dragging node -> dropped node. By default, we clone the source node to get the dragging node, and clone the dragging node to get the dropped node. During the cloning process, the node ID will be reset. If you want to keep the original node ID, you can do the following:",paraId:7,tocIndex:3},{value:"// This way, the ID of the node placed on the canvas will be the same as the ID of the node passed to `dnd.start`.\nconst dnd = new Dnd({\n  getDragNode: (node) => node.clone({ keepId: true }),\n  getDropNode: (node) => node.clone({ keepId: true }),\n})\n",paraId:8,tocIndex:3},{value:"How to customize the style of the dragged node?",paraId:9,tocIndex:3},{value:"const dnd = new Dnd({\n  getDragNode(node) {\n    // Return a new node as the dragged node\n    return graph.createNode({\n      width: 100,\n      height: 100,\n      shape: 'rect',\n      attrs: {\n        body: {\n          fill: '#ccc',\n        },\n      },\n    })\n  },\n})\n",paraId:10,tocIndex:3},{value:"How to customize the style of the node placed on the canvas?",paraId:11,tocIndex:3},{value:"const dnd = new Dnd({\n  getDropNode(node) {\n    const { width, height } = node.size()\n    // Return a new node as the node placed on the canvas\n    return node.clone().size(width * 3, height * 3)\n  },\n})\n",paraId:12,tocIndex:3},{value:"How to get the position of the node placed on the canvas?",paraId:13,tocIndex:3},{value:"graph.on('node:added', ({ node }) => {\n  const { x, y } = node.position()\n})\n",paraId:14,tocIndex:3},{value:"How to set the zIndex of the node placed on the canvas?",paraId:15,tocIndex:3},{value:"graph.on('node:added', ({ node }) => {\n  node.setZIndex(5)\n})\n",paraId:16,tocIndex:3}]},12162:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(99078);const n=[{value:"How to export the canvas content in image format",paraId:0},{value:"You can export the canvas content as images via the ",paraId:1,tocIndex:0},{value:"Export",paraId:1,tocIndex:0},{value:" plugin. Example:",paraId:1,tocIndex:0},{value:"import { Graph, Export } from '@antv/x6'\n\nconst graph = new Graph({\n  background: {\n    color: '#F2F7FA',\n  },\n})\n\ngraph.use(new Export())\n",paraId:2,tocIndex:0},{value:"exportSVG(fileName?: string, options?: Export.ToSVGOptions): void\n",paraId:3,tocIndex:2},{value:"fileName",paraId:4,tocIndex:2},{value:" is the name of the file, defaulting to ",paraId:4,tocIndex:2},{value:"chart",paraId:4,tocIndex:2},{value:". ",paraId:4,tocIndex:2},{value:"Export.ToSVGOptions",paraId:4,tocIndex:2},{value:" is described as follows:",paraId:4,tocIndex:2},{value:"Property Name",paraId:5,tocIndex:2},{value:"Type",paraId:5,tocIndex:2},{value:"Default Value",paraId:5,tocIndex:2},{value:"Required",paraId:5,tocIndex:2},{value:"Description",paraId:5,tocIndex:2},{value:"preserveDimensions",paraId:5,tocIndex:2},{value:"boolean | Size",paraId:5,tocIndex:2},{value:"-",paraId:5,tocIndex:2},{value:"Controls the exported SVG size. When unset, width/height are ",paraId:5,tocIndex:2},{value:"100%",paraId:5,tocIndex:2},{value:"; when ",paraId:5,tocIndex:2},{value:"true",paraId:5,tocIndex:2},{value:", they are auto-calculated to the actual content size; you can also pass ",paraId:5,tocIndex:2},{value:"{ width, height }",paraId:5,tocIndex:2},{value:" to explicitly set the export size.",paraId:5,tocIndex:2},{value:"viewBox",paraId:5,tocIndex:2},{value:"RectangleLike",paraId:5,tocIndex:2},{value:"-",paraId:5,tocIndex:2},{value:"Sets the viewBox of the exported SVG.",paraId:5,tocIndex:2},{value:"copyStyles",paraId:5,tocIndex:2},{value:"boolean",paraId:5,tocIndex:2},{value:"true",paraId:5,tocIndex:2},{value:"Whether to copy styles from external stylesheets. When enabled, computed style differences of nodes are inlined into the exported SVG to keep visuals consistent with the page; this adds export time. If you prefer speed or styles are set via ",paraId:5,tocIndex:2},{value:"attrs",paraId:5,tocIndex:2},{value:", set to ",paraId:5,tocIndex:2},{value:"false",paraId:5,tocIndex:2},{value:" and pair with ",paraId:5,tocIndex:2},{value:"stylesheet",paraId:5,tocIndex:2},{value:" to inject necessary CSS.",paraId:5,tocIndex:2},{value:"stylesheet",paraId:5,tocIndex:2},{value:"string",paraId:5,tocIndex:2},{value:"-",paraId:5,tocIndex:2},{value:"Custom stylesheet.",paraId:5,tocIndex:2},{value:"serializeImages",paraId:5,tocIndex:2},{value:"boolean",paraId:5,tocIndex:2},{value:"true",paraId:5,tocIndex:2},{value:"Whether to convert the ",paraId:5,tocIndex:2},{value:"xlink:href",paraId:5,tocIndex:2},{value:"/",paraId:5,tocIndex:2},{value:"href",paraId:5,tocIndex:2},{value:" of image elements to DataURI (forced for PNG/JPEG).",paraId:5,tocIndex:2},{value:"beforeSerialize",paraId:5,tocIndex:2},{value:"(this: Graph, svg: SVGSVGElement) => any",paraId:5,tocIndex:2},{value:"-",paraId:5,tocIndex:2},{value:"You can call ",paraId:5,tocIndex:2},{value:"beforeSerialize",paraId:5,tocIndex:2},{value:" to modify the SVG string before exporting it.",paraId:5,tocIndex:2},{value:"exportPNG(fileName?: string, options?: Export.ToImageOptions): void\n",paraId:6,tocIndex:3},{value:"fileName",paraId:7,tocIndex:3},{value:" is the name of the file, defaulting to ",paraId:7,tocIndex:3},{value:"chart",paraId:7,tocIndex:3},{value:". ",paraId:7,tocIndex:3},{value:"Export.ToImageOptions",paraId:7,tocIndex:3},{value:" inherits from the above ",paraId:7,tocIndex:3},{value:"Export.ToSVGOptions",paraId:7,tocIndex:3},{value:" and has the following additional configurations:",paraId:7,tocIndex:3},{value:"Property Name",paraId:8,tocIndex:3},{value:"Type",paraId:8,tocIndex:3},{value:"Default Value",paraId:8,tocIndex:3},{value:"Required",paraId:8,tocIndex:3},{value:"Description",paraId:8,tocIndex:3},{value:"width",paraId:8,tocIndex:3},{value:"number",paraId:8,tocIndex:3},{value:"-",paraId:8,tocIndex:3},{value:"Width of the exported image.",paraId:8,tocIndex:3},{value:"height",paraId:8,tocIndex:3},{value:"number",paraId:8,tocIndex:3},{value:"-",paraId:8,tocIndex:3},{value:"Height of the exported image.",paraId:8,tocIndex:3},{value:"ratio",paraId:8,tocIndex:3},{value:"number",paraId:8,tocIndex:3},{value:"1",paraId:8,tocIndex:3},{value:"Scale factor (e.g., device pixel ratio) used to compute export resolution.",paraId:8,tocIndex:3},{value:"backgroundColor",paraId:8,tocIndex:3},{value:"string",paraId:8,tocIndex:3},{value:"-",paraId:8,tocIndex:3},{value:"Background color of the exported image, defaults to white.",paraId:8,tocIndex:3},{value:"padding",paraId:8,tocIndex:3},{value:"NumberExt.SideOptions",paraId:8,tocIndex:3},{value:"-",paraId:8,tocIndex:3},{value:"Padding for the image.",paraId:8,tocIndex:3},{value:"quality",paraId:8,tocIndex:3},{value:"number",paraId:8,tocIndex:3},{value:"-",paraId:8,tocIndex:3},{value:"Image quality (01). If out of range, the default value ",paraId:8,tocIndex:3},{value:"0.92",paraId:8,tocIndex:3},{value:" is used.",paraId:8,tocIndex:3},{value:"exportJPEG(fileName?: string, options?: Export.ToImageOptions): void\n",paraId:9,tocIndex:4},{value:"toSVG(callback: (dataUri: string) => any, options?: Export.ToSVGOptions): void\n",paraId:10,tocIndex:5},{value:"toPNG(callback: (dataUri: string) => any, options?: Export.ToImageOptions): void\n",paraId:11,tocIndex:6},{value:"toJPEG(callback: (dataUri: string) => any, options?: Export.ToImageOptions): void\n",paraId:12,tocIndex:7}]},53414:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(3609);const n=[{value:"How to implement undo and redo for element operations",paraId:0},{value:"How to configure whether to record additions, removals, and property changes",paraId:0},{value:"How to merge multiple changes into a single history entry",paraId:0},{value:"You can enable undo/redo with the ",paraId:1,tocIndex:0},{value:"History",paraId:1,tocIndex:0},{value:" plugin, for example:",paraId:1,tocIndex:0},{value:"import { Graph, History } from '@antv/x6'\n\nconst graph = new Graph({\n  background: {\n    color: '#F2F7FA',\n  },\n})\ngraph.use(\n  new History({\n    enabled: true,\n  }),\n)\n",paraId:2,tocIndex:0},{value:"After moving a node freely, the Undo button becomes available.",paraId:3,tocIndex:1},{value:"Clicking the Undo button restores the node's position, and then the Redo button becomes available.",paraId:3,tocIndex:1},{value:"Clicking the Redo button updates the node's position.",paraId:3,tocIndex:1},{value:"Property Name",paraId:4,tocIndex:2},{value:"Type",paraId:4,tocIndex:2},{value:"Default Value",paraId:4,tocIndex:2},{value:"Required",paraId:4,tocIndex:2},{value:"Description",paraId:4,tocIndex:2},{value:"stackSize",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"0",paraId:4,tocIndex:2},{value:"A ",paraId:4,tocIndex:2},{value:"stackSize",paraId:4,tocIndex:2},{value:" of 0 means no limit; otherwise only that many entries are kept.",paraId:4,tocIndex:2},{value:"ignoreAdd",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:"If ",paraId:4,tocIndex:2},{value:"ignoreAdd",paraId:4,tocIndex:2},{value:" is ",paraId:4,tocIndex:2},{value:"true",paraId:4,tocIndex:2},{value:", adding elements will not be recorded in the history.",paraId:4,tocIndex:2},{value:"ignoreRemove",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:"If ",paraId:4,tocIndex:2},{value:"ignoreRemove",paraId:4,tocIndex:2},{value:" is ",paraId:4,tocIndex:2},{value:"true",paraId:4,tocIndex:2},{value:", removing elements will not be recorded in the history.",paraId:4,tocIndex:2},{value:"ignoreChange",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:"If ",paraId:4,tocIndex:2},{value:"ignoreChange",paraId:4,tocIndex:2},{value:" is ",paraId:4,tocIndex:2},{value:"true",paraId:4,tocIndex:2},{value:", changes to element properties will not be recorded in the history.",paraId:4,tocIndex:2},{value:"beforeAddCommand",paraId:4,tocIndex:2},{value:"(event, args) => any",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Called before a command is added to the Undo queue; if this method returns ",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:", the command will not be added to the Undo queue.",paraId:4,tocIndex:2},{value:"afterAddCommand",paraId:4,tocIndex:2},{value:"(event, args, cmd) => any",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Called after a command is added to the Undo queue.",paraId:4,tocIndex:2},{value:"executeCommand",paraId:4,tocIndex:2},{value:"(cmd, revert, options) => any",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Called when a command is undone or redone; ",paraId:4,tocIndex:2},{value:"revert",paraId:4,tocIndex:2},{value:" is ",paraId:4,tocIndex:2},{value:"true",paraId:4,tocIndex:2},{value:" if the command is undone, otherwise it indicates the command is redone.",paraId:4,tocIndex:2},{value:"In actual projects, we often need to undo or redo multiple changes at once. X6 provides the concept of ",paraId:5},{value:"batch",paraId:5},{value:", which allows multiple changes to be merged into a single history entry. Heres how to use it:",paraId:5},{value:"// Method 1\ngraph.startBatch('custom-batch-name')\n// Changing the border color of the node and modifying its position will be merged into a single record, allowing for a single undo.\nnode.attr('body/stroke', 'red')\nnode.position(30, 30)\ngraph.stopBatch('custom-batch-name')\n\n// Method 2\ngraph.batchUpdate(() => {\n  node.prop('zIndex', 10)\n  node.attr('label/text', 'hello')\n  node.attr('label/fill', '#ff0000')\n})\n",paraId:6},{value:"undo(options?: KeyValue): this\n",paraId:7,tocIndex:4},{value:"Undo. ",paraId:8,tocIndex:4},{value:"options",paraId:8,tocIndex:4},{value:" will be passed to the event callback.",paraId:8,tocIndex:4},{value:"undoAndCancel(options?: KeyValue): this\n",paraId:9,tocIndex:5},{value:"Undo and do not add to the redo queue; the command cannot be redone. ",paraId:10,tocIndex:5},{value:"options",paraId:10,tocIndex:5},{value:" will be passed to the event callback.",paraId:10,tocIndex:5},{value:"redo(options?: KeyValue): this\n",paraId:11,tocIndex:6},{value:"Redo. ",paraId:12,tocIndex:6},{value:"options",paraId:12,tocIndex:6},{value:" will be passed to the event callback.",paraId:12,tocIndex:6},{value:"canUndo(): boolean\n",paraId:13,tocIndex:7},{value:"Returns whether undo is available.",paraId:14,tocIndex:7},{value:"canRedo(): boolean\n",paraId:15,tocIndex:8},{value:"Returns whether redo is available.",paraId:16,tocIndex:8},{value:"cleanHistory(options?: KeyValue): this\n",paraId:17,tocIndex:9},{value:"Clear the history queue. ",paraId:18,tocIndex:9},{value:"options",paraId:18,tocIndex:9},{value:" will be passed to the event callback.",paraId:18,tocIndex:9},{value:"getHistoryStackSize(): number\n",paraId:19,tocIndex:10},{value:"Get the size of the history stack.",paraId:20,tocIndex:10},{value:"getUndoRemainSize(): number\n",paraId:21,tocIndex:11},{value:"Get the remaining size of the history undo stack.",paraId:22,tocIndex:11},{value:"getUndoStackSize(): number\n",paraId:23,tocIndex:12},{value:"Get the size of the history undo stack.",paraId:24,tocIndex:12},{value:"getRedoStackSize(): number\n",paraId:25,tocIndex:13},{value:"Get the size of the history redo stack.",paraId:26,tocIndex:13},{value:"isHistoryEnabled(): boolean\n",paraId:27,tocIndex:14},{value:"Returns whether history is enabled.",paraId:28,tocIndex:14},{value:"enableHistory(): this\n",paraId:29,tocIndex:15},{value:"Enable history state.",paraId:30,tocIndex:15},{value:"disableHistory(): this\n",paraId:31,tocIndex:16},{value:"Disable history state.",paraId:32,tocIndex:16},{value:"toggleHistory(enabled?: boolean): this\n",paraId:33,tocIndex:17},{value:"Toggle the enabled state of history. Parameters are as follows:",paraId:34,tocIndex:17},{value:"Name",paraId:35,tocIndex:17},{value:"Type",paraId:35,tocIndex:17},{value:"Required",paraId:35,tocIndex:17},{value:"Default Value",paraId:35,tocIndex:17},{value:"Description",paraId:35,tocIndex:17},{value:"enabled",paraId:35,tocIndex:17},{value:"boolean",paraId:35,tocIndex:17},{value:"-",paraId:35,tocIndex:17},{value:"Whether to enable history state; defaults to toggling the enabled state of history.",paraId:35,tocIndex:17},{value:"Event Name",paraId:36,tocIndex:18},{value:"Parameter Type",paraId:36,tocIndex:18},{value:"Description",paraId:36,tocIndex:18},{value:"history:undo",paraId:36,tocIndex:18},{value:"{ cmds: Command[], options: KeyValue }",paraId:36,tocIndex:18},{value:"Triggered when a command is undone.",paraId:36,tocIndex:18},{value:"history:redo",paraId:36,tocIndex:18},{value:"{ cmds: Command[], options: KeyValue }",paraId:36,tocIndex:18},{value:"Triggered when a command is redone.",paraId:36,tocIndex:18},{value:"history:cancel",paraId:36,tocIndex:18},{value:"{ cmds: Command[], options: KeyValue }",paraId:36,tocIndex:18},{value:"Triggered when a command is canceled.",paraId:36,tocIndex:18},{value:"history:add",paraId:36,tocIndex:18},{value:"{ cmds: Command[], options: KeyValue }",paraId:36,tocIndex:18},{value:"Triggered when a command is added to the queue.",paraId:36,tocIndex:18},{value:"history:clean",paraId:36,tocIndex:18},{value:"{ cmds: Command[] | null, options: KeyValue }",paraId:36,tocIndex:18},{value:"Triggered when the history queue is cleared.",paraId:36,tocIndex:18},{value:"history:change",paraId:36,tocIndex:18},{value:"{ cmds: Command[] | null, options: KeyValue }",paraId:36,tocIndex:18},{value:"Triggered when the history queue changes.",paraId:36,tocIndex:18},{value:"history:batch",paraId:36,tocIndex:18},{value:"{ cmds: Command, options: KeyValue }",paraId:36,tocIndex:18},{value:"Triggered when a batch command is received.",paraId:36,tocIndex:18},{value:"graph.on('history:undo', ({ cmds }) => {\n  console.log(cmds)\n})\n\n// We can also listen to events on the plugin instance\nhistory.on('undo', ({ cmds }) => {\n  console.log(cmds)\n})\n",paraId:37,tocIndex:18}]},68660:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(86138);const n=[{value:"How to bind keyboard shortcuts on the canvas",paraId:0},{value:"Enable keyboard shortcuts via the ",paraId:1,tocIndex:0},{value:"Keyboard",paraId:1,tocIndex:0},{value:" plugin:",paraId:1,tocIndex:0},{value:"import { Graph, Keyboard } from '@antv/x6'\n\nconst graph = new Graph({\n  background: {\n    color: '#F2F7FA',\n  },\n})\ngraph.use(\n  new Keyboard({\n    enabled: true,\n  }),\n)\n",paraId:2,tocIndex:0},{value:"Property Name",paraId:3,tocIndex:2},{value:"Type",paraId:3,tocIndex:2},{value:"Default Value",paraId:3,tocIndex:2},{value:"Required",paraId:3,tocIndex:2},{value:"Description",paraId:3,tocIndex:2},{value:"global",paraId:3,tocIndex:2},{value:"boolean",paraId:3,tocIndex:2},{value:"false",paraId:3,tocIndex:2},{value:"Whether to use global keyboard events. When set to ",paraId:3,tocIndex:2},{value:"true",paraId:3,tocIndex:2},{value:", keyboard events are bound to ",paraId:3,tocIndex:2},{value:"document",paraId:3,tocIndex:2},{value:"; otherwise they are bound to the canvas container. When bound to the canvas container, it must be focused to trigger keyboard events.",paraId:3,tocIndex:2},{value:"format",paraId:3,tocIndex:2},{value:"(this: Graph, key: string) => string",paraId:3,tocIndex:2},{value:"-",paraId:3,tocIndex:2},{value:"Format the key string when binding or unbinding keyboard events.",paraId:3,tocIndex:2},{value:"guard",paraId:3,tocIndex:2},{value:"(this: Graph, e: KeyboardEvent) => boolean",paraId:3,tocIndex:2},{value:"-",paraId:3,tocIndex:2},{value:"Determine whether a keyboard event should be processed. If it returns ",paraId:3,tocIndex:2},{value:"false",paraId:3,tocIndex:2},{value:", the corresponding keyboard event is ignored.",paraId:3,tocIndex:2},{value:"The ",paraId:4,tocIndex:2},{value:"format",paraId:4,tocIndex:2},{value:" and ",paraId:4,tocIndex:2},{value:"guard",paraId:4,tocIndex:2},{value:" configurations are used as follows:",paraId:4,tocIndex:2},{value:"graph.use(\n  new Keyboard({\n    enabled: true,\n    format(key) {\n      return key.replace(/\\s/g, '').replace('cmd', 'command')\n    },\n  }),\n)\n// The statement below is equivalent to graph.bindKey('command', (e) => { })\ngraph.bindKey('cmd', (e) => {})\n\ngraph.use(\n  new Keyboard({\n    enabled: true,\n    guard(this: Graph, e: KeyboardEvent) {\n      if (e.altKey) {\n        // Ignore all keyboard events when the alt key is pressed\n        return false\n      }\n      return true\n    },\n  }),\n)\n",paraId:5,tocIndex:2},{value:"bindKey(\n  keys: string | string[],\n  callback: (e: KeyboardEvent) => void,\n  action?: 'keypress' | 'keydown' | 'keyup',\n): this\n",paraId:6,tocIndex:4},{value:"Bind keyboard shortcuts.",paraId:7,tocIndex:4},{value:"unbindKey(\n  keys: string | string[],\n  action?: 'keypress' | 'keydown' | 'keyup',\n): this\n",paraId:8,tocIndex:5},{value:"Unbind keyboard shortcuts.",paraId:9,tocIndex:5},{value:"clearKeys(): this\n",paraId:10,tocIndex:6},{value:"Clear all keyboard shortcuts.",paraId:11,tocIndex:6},{value:"triggerKey(\n  keys: string,\n  action?: 'keypress' | 'keydown' | 'keyup',\n): this\n",paraId:12,tocIndex:7},{value:"Manually trigger keyboard shortcuts.",paraId:13,tocIndex:7},{value:"isKeyboardEnabled(): boolean\n",paraId:14,tocIndex:8},{value:"Returns whether keyboard events are enabled.",paraId:15,tocIndex:8},{value:"enableKeyboard(): this\n",paraId:16,tocIndex:9},{value:"Enable keyboard events.",paraId:17,tocIndex:9},{value:"disableKeyboard(): this\n",paraId:18,tocIndex:10},{value:"Disable keyboard events.",paraId:19,tocIndex:10},{value:"toggleKeyboard(enabled?: boolean): this\n",paraId:20,tocIndex:11},{value:"Toggle the enabled state of keyboard events. The parameters are as follows:",paraId:21,tocIndex:11},{value:"Name",paraId:22,tocIndex:11},{value:"Type",paraId:22,tocIndex:11},{value:"Required",paraId:22,tocIndex:11},{value:"Default Value",paraId:22,tocIndex:11},{value:"Description",paraId:22,tocIndex:11},{value:"enabled",paraId:22,tocIndex:11},{value:"boolean",paraId:22,tocIndex:11},{value:"-",paraId:22,tocIndex:11},{value:"Whether to enable keyboard events; if omitted, toggles the current enabled state.",paraId:22,tocIndex:11}]},32710:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(39070);const n=[{value:"How to use the Mini Map plugin",paraId:0},{value:"You can enable the mini-map with the ",paraId:1,tocIndex:0},{value:"MiniMap",paraId:1,tocIndex:0},{value:" plugin. Example:",paraId:1,tocIndex:0},{value:"import { Graph, MiniMap } from '@antv/x6'\n\nconst graph = new Graph({\n  background: {\n    color: '#F2F7FA',\n  },\n})\ngraph.use(\n  new MiniMap({\n    container: document.getElementById('minimap'),\n  }),\n)\n",paraId:2,tocIndex:0},{value:"Move the mini-map viewport to move the canvas.",paraId:3,tocIndex:1},{value:"Zoom the mini-map viewport to zoom the canvas.",paraId:3,tocIndex:1},{value:"Property Name",paraId:4,tocIndex:2},{value:"Type",paraId:4,tocIndex:2},{value:"Default Value",paraId:4,tocIndex:2},{value:"Required",paraId:4,tocIndex:2},{value:"Description",paraId:4,tocIndex:2},{value:"container",paraId:4,tocIndex:2},{value:"HTMLElement",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"",paraId:4,tocIndex:2},{value:"The container to mount the mini-map",paraId:4,tocIndex:2},{value:"width",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"300",paraId:4,tocIndex:2},{value:"The width of the mini-map",paraId:4,tocIndex:2},{value:"height",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"200",paraId:4,tocIndex:2},{value:"The height of the mini-map",paraId:4,tocIndex:2},{value:"padding",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"10",paraId:4,tocIndex:2},{value:"The padding margin of the mini-map container",paraId:4,tocIndex:2},{value:"scalable",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"true",paraId:4,tocIndex:2},{value:"Whether scaling is enabled",paraId:4,tocIndex:2},{value:"minScale",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"0.01",paraId:4,tocIndex:2},{value:"The minimum scale ratio",paraId:4,tocIndex:2},{value:"maxScale",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"16",paraId:4,tocIndex:2},{value:"The maximum scale ratio",paraId:4,tocIndex:2},{value:"graphOptions",paraId:4,tocIndex:2},{value:"Graph.Options",paraId:4,tocIndex:2},{value:"{}",paraId:4,tocIndex:2},{value:"Options for the internal mini-map Graph",paraId:4,tocIndex:2},{value:"createGraph",paraId:4,tocIndex:2},{value:"(options: Graph.Options) => Graph",paraId:4,tocIndex:2},{value:"options => new Graph(options)",paraId:4,tocIndex:2},{value:"Custom method to create the internal mini-map Graph",paraId:4,tocIndex:2}]},88313:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(59468);const n=[{value:"How to enable scrolling capabilities for the canvas",paraId:0},{value:"The ",paraId:1},{value:"Scroller",paraId:1},{value:" plugin disables the graph's built-in ",paraId:1},{value:"panning",paraId:1},{value:" by default to avoid interaction conflicts.",paraId:1},{value:"You can enable canvas scrolling with the ",paraId:2,tocIndex:0},{value:"Scroller",paraId:2,tocIndex:0},{value:" plugin. For example:",paraId:2,tocIndex:0},{value:"import { Graph, Scroller } from '@antv/x6'\n\nconst graph = new Graph({\n  background: {\n    color: '#F2F7FA',\n  }\n})\ngraph.use(\n  new Scroller({\n    enabled: true,\n  }),\n)\n",paraId:3,tocIndex:0},{value:"Property Name",paraId:4,tocIndex:2},{value:"Type",paraId:4,tocIndex:2},{value:"Default",paraId:4,tocIndex:2},{value:"Required",paraId:4,tocIndex:2},{value:"Description",paraId:4,tocIndex:2},{value:"pannable",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:"Whether to enable canvas panning capability (dragging the canvas after pressing the mouse on a blank area)",paraId:4,tocIndex:2},{value:"className",paraId:4,tocIndex:2},{value:"string",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Additional class name for custom styling",paraId:4,tocIndex:2},{value:"width",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Width of the ",paraId:4,tocIndex:2},{value:"Scroller",paraId:4,tocIndex:2},{value:", defaults to the width of the canvas container",paraId:4,tocIndex:2},{value:"height",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Height of the ",paraId:4,tocIndex:2},{value:"Scroller",paraId:4,tocIndex:2},{value:", defaults to the height of the canvas container",paraId:4,tocIndex:2},{value:"modifiers",paraId:4,tocIndex:2},{value:"ModifierKey",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Set modifier keys that need to be pressed along with the mouse click to trigger canvas dragging",paraId:4,tocIndex:2},{value:"pageWidth",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Width of each page, defaults to the width of the canvas container",paraId:4,tocIndex:2},{value:"pageHeight",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Height of each page, defaults to the height of the canvas container",paraId:4,tocIndex:2},{value:"pageVisible",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:"Whether to enable pagination",paraId:4,tocIndex:2},{value:"pageBreak",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:"Whether to show page breaks",paraId:4,tocIndex:2},{value:"autoResize",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"true",paraId:4,tocIndex:2},{value:"Whether to automatically expand/shrink the canvas. When enabled, moving nodes/edges will automatically calculate the required canvas size, expanding it according to ",paraId:4,tocIndex:2},{value:"pageWidth",paraId:4,tocIndex:2},{value:" and ",paraId:4,tocIndex:2},{value:"pageHeight",paraId:4,tocIndex:2},{value:" when exceeding the current size, and shrinking it otherwise.",paraId:4,tocIndex:2},{value:"minVisibleWidth",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Effective when ",paraId:4,tocIndex:2},{value:"padding",paraId:4,tocIndex:2},{value:" is empty, sets the minimum visible width of the canvas during scrolling",paraId:4,tocIndex:2},{value:"minVisibleHeight",paraId:4,tocIndex:2},{value:"number",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Effective when ",paraId:4,tocIndex:2},{value:"padding",paraId:4,tocIndex:2},{value:" is empty, sets the minimum visible height of the canvas during scrolling",paraId:4,tocIndex:2},{value:"padding",paraId:4,tocIndex:2},{value:"number | Padding",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Sets the padding around the canvas. Defaults to being automatically calculated based on ",paraId:4,tocIndex:2},{value:"minVisibleWidth",paraId:4,tocIndex:2},{value:" and ",paraId:4,tocIndex:2},{value:"minVisibleHeight",paraId:4,tocIndex:2},{value:", ensuring that at least ",paraId:4,tocIndex:2},{value:"minVisibleWidth",paraId:4,tocIndex:2},{value:" and ",paraId:4,tocIndex:2},{value:"minVisibleHeight",paraId:4,tocIndex:2},{value:" of the canvas is visible during scrolling.",paraId:4,tocIndex:2},{value:"The ",paraId:5,tocIndex:2},{value:"Padding",paraId:5,tocIndex:2},{value:" type is defined as follows:",paraId:5,tocIndex:2},{value:"type Padding = { top: number; right: number; bottom: number; left: number }\n",paraId:6,tocIndex:2},{value:"The ",paraId:7,tocIndex:2},{value:"ModifierKey",paraId:7,tocIndex:2},{value:" type is defined as follows:",paraId:7,tocIndex:2},{value:"type ModifierKey = string | ('alt' | 'ctrl' | 'meta' | 'shift' | 'space')[] | null\n",paraId:8,tocIndex:2},{value:"Supports the following forms:",paraId:9,tocIndex:2},{value:"alt",paraId:10,tocIndex:2},{value:" means pressing ",paraId:10,tocIndex:2},{value:"alt",paraId:10,tocIndex:2},{value:".",paraId:10,tocIndex:2},{value:"[alt, ctrl]",paraId:10,tocIndex:2},{value:" means pressing either ",paraId:10,tocIndex:2},{value:"alt",paraId:10,tocIndex:2},{value:" or ",paraId:10,tocIndex:2},{value:"ctrl",paraId:10,tocIndex:2},{value:".",paraId:10,tocIndex:2},{value:"alt|ctrl",paraId:10,tocIndex:2},{value:" means pressing either ",paraId:10,tocIndex:2},{value:"alt",paraId:10,tocIndex:2},{value:" or ",paraId:10,tocIndex:2},{value:"ctrl",paraId:10,tocIndex:2},{value:".",paraId:10,tocIndex:2},{value:"alt&ctrl",paraId:10,tocIndex:2},{value:" means pressing both ",paraId:10,tocIndex:2},{value:"alt",paraId:10,tocIndex:2},{value:" and ",paraId:10,tocIndex:2},{value:"ctrl",paraId:10,tocIndex:2},{value:" simultaneously.",paraId:10,tocIndex:2},{value:"alt|ctrl&shift",paraId:10,tocIndex:2},{value:" means pressing both ",paraId:10,tocIndex:2},{value:"alt",paraId:10,tocIndex:2},{value:" and ",paraId:10,tocIndex:2},{value:"shift",paraId:10,tocIndex:2},{value:" simultaneously or both ",paraId:10,tocIndex:2},{value:"ctrl",paraId:10,tocIndex:2},{value:" and ",paraId:10,tocIndex:2},{value:"shift",paraId:10,tocIndex:2},{value:" simultaneously.",paraId:10,tocIndex:2},{value:"Disables scrolling.",paraId:11,tocIndex:4},{value:"Enables scrolling.",paraId:12,tocIndex:5},{value:"Gets the scrollbar position.",paraId:13,tocIndex:6},{value:"Sets the scrollbar position.",paraId:14,tocIndex:7},{value:"left?: number",paraId:15,tocIndex:7},{value:" The position of the horizontal scrollbar; defaults to no horizontal scrolling.",paraId:15,tocIndex:7},{value:"top?: number",paraId:15,tocIndex:7},{value:" The position of the vertical scrollbar; defaults to no vertical scrolling.",paraId:15,tocIndex:7},{value:"For example:",paraId:16,tocIndex:7},{value:"graph.setScrollbarPosition(100)\ngraph.setScrollbarPosition(100, null)\ngraph.setScrollbarPosition(null, 200)\ngraph.setScrollbarPosition(100, 200)\n",paraId:17,tocIndex:7}]},46482:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(85576);const n=[{value:"How to enable selection and rubberband",paraId:0},{value:"How to configure multi-selection and strict rubberband",paraId:0},{value:"How to set modifier keys and trigger events (",paraId:0},{value:"eventTypes",paraId:0},{value:")",paraId:0},{value:"You can enable selection and rubberband with the ",paraId:1,tocIndex:0},{value:"Selection",paraId:1,tocIndex:0},{value:" plugin, for example:",paraId:1,tocIndex:0},{value:"import { Graph, Selection } from '@antv/x6'\n\nconst graph = new Graph({\n  background: {\n    color: '#F2F7FA',\n  },\n})\ngraph.use(\n  new Selection({\n    enabled: true,\n  }),\n)\n",paraId:2,tocIndex:0},{value:"Click to select nodes.",paraId:3,tocIndex:1},{value:"Enable multi-selection by holding down Ctrl/Command and clicking on nodes.",paraId:3,tocIndex:1},{value:"Enable moving by dragging the selection box to move nodes.",paraId:3,tocIndex:1},{value:"Enable rubberband selection by pressing the left mouse button on a blank area of the canvas and dragging the selection box to select nodes.",paraId:3,tocIndex:1},{value:"Enable strict rubberband mode and observe its effect on selection.",paraId:3,tocIndex:1},{value:"Use modifier keys in conjunction with selection, such as the ",paraId:3,tocIndex:1},{value:"alt",paraId:3,tocIndex:1},{value:" key. Hold down the ",paraId:3,tocIndex:1},{value:"alt",paraId:3,tocIndex:1},{value:" key and press the left mouse button on a blank area of the canvas to drag the selection box to select nodes.",paraId:3,tocIndex:1},{value:"Apply a custom filter (exclude circle nodes), so that circular nodes cannot be selected.",paraId:3,tocIndex:1},{value:"Apply custom additional content (display the number of selected nodes). Select two or more nodes to trigger the display of custom content.",paraId:3,tocIndex:1},{value:"Property Name",paraId:4,tocIndex:2},{value:"Type",paraId:4,tocIndex:2},{value:"Default Value",paraId:4,tocIndex:2},{value:"Required",paraId:4,tocIndex:2},{value:"Description",paraId:4,tocIndex:2},{value:"className",paraId:4,tocIndex:2},{value:"string",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Additional style name for customizing styles",paraId:4,tocIndex:2},{value:"multiple",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"true",paraId:4,tocIndex:2},{value:"Whether to enable multi-selection; when enabled, hold down the ",paraId:4,tocIndex:2},{value:"ctrl",paraId:4,tocIndex:2},{value:" or ",paraId:4,tocIndex:2},{value:"command",paraId:4,tocIndex:2},{value:" key to click nodes for multi-selection",paraId:4,tocIndex:2},{value:"multipleSelectionModifiers",paraId:4,tocIndex:2},{value:"ModifierKey",paraId:4,tocIndex:2},{value:"['ctrl', 'meta']",paraId:4,tocIndex:2},{value:"Used to set the modifier keys for multi-selection",paraId:4,tocIndex:2},{value:"rubberband",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:"Whether to enable the rubberband selection feature",paraId:4,tocIndex:2},{value:"modifiers",paraId:4,tocIndex:2},{value:"ModifierKey",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Used to set the modifier keys for rubberband selection",paraId:4,tocIndex:2},{value:"strict",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:"Whether the selection box needs to completely enclose nodes to select them",paraId:4,tocIndex:2},{value:"movable",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"true",paraId:4,tocIndex:2},{value:"Whether the selected nodes move together when dragging the selection box",paraId:4,tocIndex:2},{value:"content",paraId:4,tocIndex:2},{value:"string",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Set additional display content",paraId:4,tocIndex:2},{value:"filter",paraId:4,tocIndex:2},{value:"Filter",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"Node filter",paraId:4,tocIndex:2},{value:"showNodeSelectionBox",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:"Whether to show the selection box for nodes",paraId:4,tocIndex:2},{value:"showEdgeSelectionBox",paraId:4,tocIndex:2},{value:"boolean",paraId:4,tocIndex:2},{value:"false",paraId:4,tocIndex:2},{value:"Whether to show the selection box for edges",paraId:4,tocIndex:2},{value:"pointerEvents",paraId:4,tocIndex:2},{value:"'none' | 'auto'",paraId:4,tocIndex:2},{value:"auto",paraId:4,tocIndex:2},{value:"When ",paraId:4,tocIndex:2},{value:"showNodeSelectionBox",paraId:4,tocIndex:2},{value:" is enabled, an element overlays the node and its events may not respond; set ",paraId:4,tocIndex:2},{value:"pointerEvents: none",paraId:4,tocIndex:2},{value:" to resolve this. Default is ",paraId:4,tocIndex:2},{value:"auto",paraId:4,tocIndex:2},{value:".",paraId:4,tocIndex:2},{value:"eventTypes",paraId:4,tocIndex:2},{value:"SelectionEventType[]",paraId:4,tocIndex:2},{value:"['leftMouseDown', 'mouseWheelDown']",paraId:4,tocIndex:2},{value:"Used to set the trigger event types for rubberband selection",paraId:4,tocIndex:2},{value:"movingRouterFallback",paraId:4,tocIndex:2},{value:"string",paraId:4,tocIndex:2},{value:"-",paraId:4,tocIndex:2},{value:"During batch dragging of multiple nodes, temporarily downgrade the routing of edges connected to the selected nodes to the specified router, and automatically restore to the original routers after idle (recommended to set ",paraId:4,tocIndex:2},{value:"'orth'",paraId:4,tocIndex:2},{value:" when dragging many nodes and edges originally use ",paraId:4,tocIndex:2},{value:"'manhattan'",paraId:4,tocIndex:2},{value:" to improve dragging smoothness)",paraId:4,tocIndex:2},{value:"The type definition for ",paraId:5,tocIndex:2},{value:"Filter",paraId:5,tocIndex:2},{value:" is as follows:",paraId:5,tocIndex:2},{value:"type Filter = string[] | { id: string }[] | (this: Graph, cell: Cell) => boolean\n",paraId:6,tocIndex:2},{value:"string[]",paraId:7,tocIndex:2},{value:": An array of node shapes; only specified node/edge shapes can be selected.",paraId:7,tocIndex:2},{value:"({ id: string })[]",paraId:7,tocIndex:2},{value:": An array of node IDs; only specified nodes/edges can be selected.",paraId:7,tocIndex:2},{value:"(this: Graph, cell: Cell) => boolean",paraId:7,tocIndex:2},{value:": Only nodes/edges that return true can be selected.",paraId:7,tocIndex:2},{value:"The type definition for ",paraId:8,tocIndex:2},{value:"ModifierKey",paraId:8,tocIndex:2},{value:" is as follows:",paraId:8,tocIndex:2},{value:"type ModifierKey = string | ('alt' | 'ctrl' | 'meta' | 'shift' | 'space')[] | null\n",paraId:9,tocIndex:2},{value:"The modifier keys in X6 include ",paraId:10,tocIndex:2},{value:"alt",paraId:10,tocIndex:2},{value:", ",paraId:10,tocIndex:2},{value:"ctrl",paraId:10,tocIndex:2},{value:", ",paraId:10,tocIndex:2},{value:"meta",paraId:10,tocIndex:2},{value:", ",paraId:10,tocIndex:2},{value:"shift",paraId:10,tocIndex:2},{value:", and ",paraId:10,tocIndex:2},{value:"space",paraId:10,tocIndex:2},{value:". When modifiers are configured, clicking the mouse while holding a modifier triggers the corresponding behavior. If rubberband selection and canvas panning have identical triggers (same ",paraId:10,tocIndex:2},{value:"eventTypes",paraId:10,tocIndex:2},{value:" and same ",paraId:10,tocIndex:2},{value:"modifiers",paraId:10,tocIndex:2},{value:"), rubberband selection takes precedence and the default panning is disabled; if they differ, they work independently. When both start on ",paraId:10,tocIndex:2},{value:"leftMouseDown",paraId:10,tocIndex:2},{value:" over blank areas, configure different modifiers for selection and panning to avoid conflicts. You can configure a single key (e.g., ",paraId:10,tocIndex:2},{value:"alt",paraId:10,tocIndex:2},{value:") or multiple keys (e.g., ",paraId:10,tocIndex:2},{value:"['alt', 'ctrl']",paraId:10,tocIndex:2},{value:"). Multiple keys in an array are treated as OR. For more flexible configurations, use the following forms:",paraId:10,tocIndex:2},{value:"alt",paraId:11,tocIndex:2},{value:" indicates pressing ",paraId:11,tocIndex:2},{value:"alt",paraId:11,tocIndex:2},{value:".",paraId:11,tocIndex:2},{value:"[alt, ctrl]",paraId:11,tocIndex:2},{value:" indicates pressing ",paraId:11,tocIndex:2},{value:"alt",paraId:11,tocIndex:2},{value:" or ",paraId:11,tocIndex:2},{value:"ctrl",paraId:11,tocIndex:2},{value:".",paraId:11,tocIndex:2},{value:"alt|ctrl",paraId:11,tocIndex:2},{value:" indicates pressing ",paraId:11,tocIndex:2},{value:"alt",paraId:11,tocIndex:2},{value:" or ",paraId:11,tocIndex:2},{value:"ctrl",paraId:11,tocIndex:2},{value:".",paraId:11,tocIndex:2},{value:"alt&ctrl",paraId:11,tocIndex:2},{value:" indicates pressing ",paraId:11,tocIndex:2},{value:"alt",paraId:11,tocIndex:2},{value:" and ",paraId:11,tocIndex:2},{value:"ctrl",paraId:11,tocIndex:2},{value:" simultaneously.",paraId:11,tocIndex:2},{value:"alt|ctrl&shift",paraId:11,tocIndex:2},{value:" indicates pressing ",paraId:11,tocIndex:2},{value:"alt",paraId:11,tocIndex:2},{value:" and ",paraId:11,tocIndex:2},{value:"shift",paraId:11,tocIndex:2},{value:" simultaneously or pressing ",paraId:11,tocIndex:2},{value:"ctrl",paraId:11,tocIndex:2},{value:" and ",paraId:11,tocIndex:2},{value:"shift",paraId:11,tocIndex:2},{value:" simultaneously.",paraId:11,tocIndex:2},{value:"The type definition for ",paraId:12,tocIndex:2},{value:"SelectionEventType",paraId:12,tocIndex:2},{value:" is as follows:",paraId:12,tocIndex:2},{value:"type SelectionEventType = 'leftMouseDown' | 'mouseWheelDown';\n",paraId:13,tocIndex:2},{value:"Interaction methods that trigger rubberband selection. Supports two forms or combinations of them:",paraId:14,tocIndex:2},{value:"leftMouseDown",paraId:15,tocIndex:2},{value:": Pressing the left mouse button to drag.",paraId:15,tocIndex:2},{value:"mouseWheelDown",paraId:15,tocIndex:2},{value:": Pressing the mouse wheel to drag.",paraId:15,tocIndex:2},{value:"select(cells: Cell | string | (Cell | string)[]): this\n",paraId:16,tocIndex:4},{value:"Selects the specified nodes/edges. Note that this method does not unselect currently selected nodes/edges; it appends the specified nodes/edges to the selection. If you also need to unselect currently selected nodes/edges, please use the ",paraId:17,tocIndex:4},{value:"resetSelection(...)",paraId:18,tocIndex:4},{value:" method.",paraId:17,tocIndex:4},{value:"unselect(cells: Cell | string | (Cell | string)[]): this\n",paraId:19,tocIndex:5},{value:"Unselects the specified nodes/edges.",paraId:20,tocIndex:5},{value:"isSelected(cell: Cell | string): boolean\n",paraId:21,tocIndex:6},{value:"Returns whether the specified node/edge is selected.",paraId:22,tocIndex:6},{value:"resetSelection(cells?: Cell | string | (Cell | string)[]): this\n",paraId:23,tocIndex:7},{value:"Clears the selection first, then selects the provided nodes/edges.",paraId:24,tocIndex:7},{value:"getSelectedCells(): Cell[]\n",paraId:25,tocIndex:8},{value:"Gets the selected nodes/edges.",paraId:26,tocIndex:8},{value:"cleanSelection(): this\n",paraId:27,tocIndex:9},{value:"Clears the selection.",paraId:28,tocIndex:9},{value:"isSelectionEmpty(): boolean\n",paraId:29,tocIndex:10},{value:"Returns whether the selection is empty.",paraId:30,tocIndex:10},{value:"isSelectionEnabled(): boolean\n",paraId:31,tocIndex:11},{value:"Returns whether selection is enabled.",paraId:32,tocIndex:11},{value:"enableSelection(): this\n",paraId:33,tocIndex:12},{value:"Enables selection capability.",paraId:34,tocIndex:12},{value:"disableSelection(): this\n",paraId:35,tocIndex:13},{value:"Disables selection capability.",paraId:36,tocIndex:13},{value:"toggleSelection(enabled?: boolean): this\n",paraId:37,tocIndex:14},{value:"Toggles the enabled state of selection. Parameters are as follows:",paraId:38,tocIndex:14},{value:"Name",paraId:39,tocIndex:14},{value:"Type",paraId:39,tocIndex:14},{value:"Required",paraId:39,tocIndex:14},{value:"Default Value",paraId:39,tocIndex:14},{value:"Description",paraId:39,tocIndex:14},{value:"enabled",paraId:39,tocIndex:14},{value:"boolean",paraId:39,tocIndex:14},{value:"-",paraId:39,tocIndex:14},{value:"Whether to enable selection capability; defaults to toggling the enabled state.",paraId:39,tocIndex:14},{value:"isMultipleSelection(): boolean\n",paraId:40,tocIndex:15},{value:"Returns whether multi-selection is enabled.",paraId:41,tocIndex:15},{value:"enableMultipleSelection(): this\n",paraId:42,tocIndex:16},{value:"Enables multi-selection.",paraId:43,tocIndex:16},{value:"disableMultipleSelection(): this\n",paraId:44,tocIndex:17},{value:"Disables multi-selection.",paraId:45,tocIndex:17},{value:"toggleMultipleSelection(multiple?: boolean): this\n",paraId:46,tocIndex:18},{value:"Toggles the enabled state of multi-selection. Parameters are as follows:",paraId:47,tocIndex:18},{value:"Name",paraId:48,tocIndex:18},{value:"Type",paraId:48,tocIndex:18},{value:"Required",paraId:48,tocIndex:18},{value:"Default Value",paraId:48,tocIndex:18},{value:"Description",paraId:48,tocIndex:18},{value:"multiple",paraId:48,tocIndex:18},{value:"boolean",paraId:48,tocIndex:18},{value:"-",paraId:48,tocIndex:18},{value:"Whether to enable multi-selection; defaults to toggling the enabled state.",paraId:48,tocIndex:18},{value:"isSelectionMovable(): boolean\n",paraId:49,tocIndex:19},{value:"Returns whether the selected nodes/edges can be moved.",paraId:50,tocIndex:19},{value:"enableSelectionMovable(): this\n",paraId:51,tocIndex:20},{value:"Enables moving of selected nodes/edges.",paraId:52,tocIndex:20},{value:"disableSelectionMovable(): this\n",paraId:53,tocIndex:21},{value:"Disables moving of selected nodes/edges.",paraId:54,tocIndex:21},{value:"toggleSelectionMovable(enabled?: boolean): this\n",paraId:55,tocIndex:22},{value:"Toggles whether selected nodes/edges can be moved. Parameters are as follows:",paraId:56,tocIndex:22},{value:"Name",paraId:57,tocIndex:22},{value:"Type",paraId:57,tocIndex:22},{value:"Required",paraId:57,tocIndex:22},{value:"Default Value",paraId:57,tocIndex:22},{value:"Description",paraId:57,tocIndex:22},{value:"enabled",paraId:57,tocIndex:22},{value:"boolean",paraId:57,tocIndex:22},{value:"-",paraId:57,tocIndex:22},{value:"Whether to enable moving of selected nodes/edges; defaults to toggling the enabled state.",paraId:57,tocIndex:22},{value:"isRubberbandEnabled(): boolean\n",paraId:58,tocIndex:23},{value:"Returns whether rubberband selection is enabled.",paraId:59,tocIndex:23},{value:"enableRubberband(): this\n",paraId:60,tocIndex:24},{value:"Enables rubberband selection.",paraId:61,tocIndex:24},{value:"disableRubberband(): this\n",paraId:62,tocIndex:25},{value:"Disables rubberband selection.",paraId:63,tocIndex:25},{value:"toggleRubberband(enabled?: boolean): this\n",paraId:64,tocIndex:26},{value:"Toggles the enabled state of rubberband selection. Parameters are as follows:",paraId:65,tocIndex:26},{value:"Name",paraId:66,tocIndex:26},{value:"Type",paraId:66,tocIndex:26},{value:"Required",paraId:66,tocIndex:26},{value:"Default Value",paraId:66,tocIndex:26},{value:"Description",paraId:66,tocIndex:26},{value:"enabled",paraId:66,tocIndex:26},{value:"boolean",paraId:66,tocIndex:26},{value:"-",paraId:66,tocIndex:26},{value:"Whether to enable rubberband selection; defaults to toggling the enabled state.",paraId:66,tocIndex:26},{value:"isStrictRubberband(): boolean\n",paraId:67,tocIndex:27},{value:"Returns whether strict rubberband selection is enabled. When strict rubberband selection is enabled, only nodes/edges that are completely enclosed by the selection box will be selected.",paraId:68,tocIndex:27},{value:"enableStrictRubberband(): this\n",paraId:69,tocIndex:28},{value:"Enables strict rubberband selection. When strict rubberband selection is enabled, only nodes/edges that are completely enclosed by the selection box will be selected.",paraId:70,tocIndex:28},{value:"disableStrictRubberband(): this\n",paraId:71,tocIndex:29},{value:"Disables strict rubberband selection. When strict rubberband selection is disabled, nodes/edges can be selected as long as the selection box intersects with their bounding box.",paraId:72,tocIndex:29},{value:"toggleStrictRubberband(enabled?: boolean): this\n",paraId:73,tocIndex:30},{value:"Toggles the enabled state of strict rubberband selection. Parameters are as follows:",paraId:74,tocIndex:30},{value:"Name",paraId:75,tocIndex:30},{value:"Type",paraId:75,tocIndex:30},{value:"Required",paraId:75,tocIndex:30},{value:"Default Value",paraId:75,tocIndex:30},{value:"Description",paraId:75,tocIndex:30},{value:"enabled",paraId:75,tocIndex:30},{value:"boolean",paraId:75,tocIndex:30},{value:"-",paraId:75,tocIndex:30},{value:"Whether to enable strict rubberband selection; defaults to toggling the enabled state.",paraId:75,tocIndex:30},{value:"setSelectionFilter(\n  filter?:\n   | null\n   | (string | { id: string })[]\n   | ((this: Graph, cell: Cell) => boolean)\n): this\n",paraId:76,tocIndex:31},{value:"Sets the filtering criteria for selection; only nodes/edges that meet the filtering criteria can be selected.",paraId:77,tocIndex:31},{value:"setRubberbandModifiers(modifiers?: string | ModifierKey[] | null): this\n",paraId:78,tocIndex:32},{value:"Sets the modifier keys for rubberband selection; rubberband selection can only be triggered when the modifier keys are pressed simultaneously.",paraId:79,tocIndex:32},{value:"setSelectionDisplayContent(\n  content?:\n   | null\n   | false\n   | string\n   | ((this: Graph, selection: Selection, contentElement: HTMLElement) => string)\n): this\n",paraId:80,tocIndex:33},{value:"Sets additional display content for selected nodes/edges.",paraId:81,tocIndex:33},{value:"Event Name",paraId:82,tocIndex:34},{value:"Parameter Type",paraId:82,tocIndex:34},{value:"Description",paraId:82,tocIndex:34},{value:"cell:selected",paraId:82,tocIndex:34},{value:"{ cell: Cell; options: Model.SetOptions }",paraId:82,tocIndex:34},{value:"Triggered when a node/edge is selected",paraId:82,tocIndex:34},{value:"node:selected",paraId:82,tocIndex:34},{value:"{ node: Node; options: Model.SetOptions }",paraId:82,tocIndex:34},{value:"Triggered when a node is selected",paraId:82,tocIndex:34},{value:"edge:selected",paraId:82,tocIndex:34},{value:"{ edge: Edge; options: Model.SetOptions }",paraId:82,tocIndex:34},{value:"Triggered when an edge is selected",paraId:82,tocIndex:34},{value:"cell:unselected",paraId:82,tocIndex:34},{value:"{ cell: Cell; options: Model.SetOptions }",paraId:82,tocIndex:34},{value:"Triggered when a node/edge is unselected",paraId:82,tocIndex:34},{value:"node:unselected",paraId:82,tocIndex:34},{value:"{ node: Node; options: Model.SetOptions }",paraId:82,tocIndex:34},{value:"Triggered when a node is unselected",paraId:82,tocIndex:34},{value:"edge:unselected",paraId:82,tocIndex:34},{value:"{ edge: Edge; options: Model.SetOptions }",paraId:82,tocIndex:34},{value:"Triggered when an edge is unselected",paraId:82,tocIndex:34},{value:"selection:changed",paraId:82,tocIndex:34},{value:"{added: Cell[]; removed: Cell[]; selected: Cell[]; options: Model.SetOptions}",paraId:82,tocIndex:34},{value:"Triggered when the selected nodes/edges change (add/remove)",paraId:82,tocIndex:34},{value:"graph.on('node:selected', ({ node }) => {\n  console.log(node)\n})\n\n// We can also listen to events on the plugin instance\nselection.on('node:selected', ({ node }) => {\n  console.log(node)\n})\n",paraId:83,tocIndex:34}]},42685:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(6465);const n=[{value:"How to use snaplines on the canvas",paraId:0},{value:"Snaplines help align moving nodes. Enable the feature via the ",paraId:1,tocIndex:0},{value:"Snapline",paraId:1,tocIndex:0},{value:" plugin:",paraId:1,tocIndex:0},{value:"import { Graph, Snapline } from '@antv/x6'\n\nconst graph = new Graph({\n  background: {\n    color: '#F2F7FA',\n  },\n})\ngraph.use(\n  new Snapline({\n    enabled: true,\n  }),\n)\n",paraId:2,tocIndex:0},{value:"Property Name",paraId:3,tocIndex:2},{value:"Type",paraId:3,tocIndex:2},{value:"Default Value",paraId:3,tocIndex:2},{value:"Required",paraId:3,tocIndex:2},{value:"Description",paraId:3,tocIndex:2},{value:"className",paraId:3,tocIndex:2},{value:"string",paraId:3,tocIndex:2},{value:"-",paraId:3,tocIndex:2},{value:"Additional class name to customize snapline styles",paraId:3,tocIndex:2},{value:"tolerance",paraId:3,tocIndex:2},{value:"number",paraId:3,tocIndex:2},{value:"10",paraId:3,tocIndex:2},{value:"Snapline precision; a snapline is shown when the distance to the target position is less than ",paraId:3,tocIndex:2},{value:"tolerance",paraId:3,tocIndex:2},{value:"sharp",paraId:3,tocIndex:2},{value:"boolean",paraId:3,tocIndex:2},{value:"false",paraId:3,tocIndex:2},{value:"Whether to use short snaplines (truncated)",paraId:3,tocIndex:2},{value:"resizing",paraId:3,tocIndex:2},{value:"boolean",paraId:3,tocIndex:2},{value:"false",paraId:3,tocIndex:2},{value:"Whether to trigger snaplines when resizing nodes",paraId:3,tocIndex:2},{value:"clean",paraId:3,tocIndex:2},{value:"boolean",paraId:3,tocIndex:2},{value:"true",paraId:3,tocIndex:2},{value:"If ",paraId:3,tocIndex:2},{value:"true",paraId:3,tocIndex:2},{value:", snaplines are cleared after 3 seconds; if ",paraId:3,tocIndex:2},{value:"false",paraId:3,tocIndex:2},{value:", they are not cleared; if a number (ms), they are cleared after the specified duration",paraId:3,tocIndex:2},{value:"filter",paraId:3,tocIndex:2},{value:"Filter",paraId:3,tocIndex:2},{value:"-",paraId:3,tocIndex:2},{value:"Node filter",paraId:3,tocIndex:2},{value:"The above Filter type is relatively flexible and supports the following forms:",paraId:4,tocIndex:2},{value:"string[]",paraId:5,tocIndex:2},{value:": An array of node ",paraId:5,tocIndex:2},{value:"shape",paraId:5,tocIndex:2},{value:"s; only nodes with those shapes participate in snapline calculations",paraId:5,tocIndex:2},{value:"({ id: string })[]",paraId:5,tocIndex:2},{value:": An array of node IDs; only the specified nodes participate in snapline calculations",paraId:5,tocIndex:2},{value:"(this: Graph, node: Node) => boolean",paraId:5,tocIndex:2},{value:": Only nodes for which the function returns ",paraId:5,tocIndex:2},{value:"true",paraId:5,tocIndex:2},{value:" participate in snapline calculations",paraId:5,tocIndex:2},{value:"isSnaplineEnabled(): boolean\n",paraId:6,tocIndex:4},{value:"Returns whether snaplines are enabled.",paraId:7,tocIndex:4},{value:"enableSnapline(): this\n",paraId:8,tocIndex:5},{value:"Enables snaplines.",paraId:9,tocIndex:5},{value:"disableSnapline(): this\n",paraId:10,tocIndex:6},{value:"Disables snaplines.",paraId:11,tocIndex:6},{value:"toggleSnapline(enabled?: boolean): this\n",paraId:12,tocIndex:7},{value:"Toggles whether snaplines are enabled. Parameters are as follows:",paraId:13,tocIndex:7},{value:"Name",paraId:14,tocIndex:7},{value:"Type",paraId:14,tocIndex:7},{value:"Required",paraId:14,tocIndex:7},{value:"Default Value",paraId:14,tocIndex:7},{value:"Description",paraId:14,tocIndex:7},{value:"enabled",paraId:14,tocIndex:7},{value:"boolean",paraId:14,tocIndex:7},{value:"-",paraId:14,tocIndex:7},{value:"Whether to enable snaplines; if omitted, toggles the current enabled state.",paraId:14,tocIndex:7},{value:"hideSnapline(): this\n",paraId:15,tocIndex:8},{value:"Hides snaplines.",paraId:16,tocIndex:8},{value:"isSnaplineOnResizingEnabled(): boolean\n",paraId:17,tocIndex:9},{value:"Whether to trigger snaplines when resizing nodes.",paraId:18,tocIndex:9},{value:"enableSnaplineOnResizing(): this\n",paraId:19,tocIndex:10},{value:"Enables triggering snaplines during node resizing.",paraId:20,tocIndex:10},{value:"disableSnaplineOnResizing(): this\n",paraId:21,tocIndex:11},{value:"Disables triggering snaplines during node resizing.",paraId:22,tocIndex:11},{value:"toggleSnaplineOnResizing(enabled?: boolean): this\n",paraId:23,tocIndex:12},{value:"Toggles whether to trigger snaplines during node resizing. Parameters are as follows:",paraId:24,tocIndex:12},{value:"Name",paraId:25,tocIndex:12},{value:"Type",paraId:25,tocIndex:12},{value:"Required",paraId:25,tocIndex:12},{value:"Default Value",paraId:25,tocIndex:12},{value:"Description",paraId:25,tocIndex:12},{value:"enabled",paraId:25,tocIndex:12},{value:"boolean",paraId:25,tocIndex:12},{value:"-",paraId:25,tocIndex:12},{value:"Whether to enable snaplines; if omitted, toggles the current enabled state.",paraId:25,tocIndex:12},{value:"isSharpSnapline(): boolean\n",paraId:26,tocIndex:13},{value:"Whether to use short snaplines.",paraId:27,tocIndex:13},{value:"enableSharpSnapline(): this\n",paraId:28,tocIndex:14},{value:"Enables short snaplines; when enabled, snaplines are truncated at relevant node positions; otherwise they span across the canvas.",paraId:29,tocIndex:14},{value:"disableSharpSnapline(): this\n",paraId:30,tocIndex:15},{value:"Disables short snaplines; snaplines span the entire canvas.",paraId:31,tocIndex:15},{value:"toggleSharpSnapline(enabled?: boolean): this\n",paraId:32,tocIndex:16},{value:"Toggles whether short snaplines are enabled. Parameters are as follows:",paraId:33,tocIndex:16},{value:"Name",paraId:34,tocIndex:16},{value:"Type",paraId:34,tocIndex:16},{value:"Required",paraId:34,tocIndex:16},{value:"Default Value",paraId:34,tocIndex:16},{value:"Description",paraId:34,tocIndex:16},{value:"enabled",paraId:34,tocIndex:16},{value:"boolean",paraId:34,tocIndex:16},{value:"-",paraId:34,tocIndex:16},{value:"Whether to enable short snaplines; if omitted, toggles the current enabled state.",paraId:34,tocIndex:16},{value:"getSnaplineTolerance(): number\n",paraId:35,tocIndex:17},{value:"Gets snapline precision.",paraId:36,tocIndex:17},{value:"setSnaplineTolerance(tolerance: number): this\n",paraId:37,tocIndex:18},{value:"Sets snapline precision.",paraId:38,tocIndex:18},{value:"setSnaplineFilter(\n  filter?:\n   | null\n   | (string | { id: string })[]\n   | ((this: Graph, node: Node) => boolean)\n): this\n",paraId:39,tocIndex:19},{value:"Sets the filter; only nodes that meet the condition participate in snapline calculations.",paraId:40,tocIndex:19}]},28050:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(63487);const n=[{value:"How to enhance DnD with the Stencil plugin",paraId:0},{value:"How to configure grouping, collapse, and search",paraId:0},{value:"Stencil is a further encapsulation based on Dnd, providing a sidebar-like UI component that supports grouping, collapsing, searching, and more. You can enable the stencil sidebar with the ",paraId:1,tocIndex:0},{value:"Stencil",paraId:1,tocIndex:0},{value:" plugin. Example:",paraId:1,tocIndex:0},{value:"import { Graph, Stencil } from '@antv/x6'\n\nconst graph = new Graph({\n  background: {\n    color: '#F2F7FA',\n  },\n})\n\nconst stencil = new Stencil({\n  target: graph,\n  groups: [\n    {\n      name: 'group1',\n    },\n    {\n      name: 'group2',\n    },\n  ],\n})\n\nconst rect1 = graph.createNode({\n  shape: 'rect',\n  width: 100,\n  height: 40,\n})\nconst rect2 = rect1.clone()\n\n// A DOM container to hold the stencil, stencilContainer\nstencilContainer.appendChild(stencil.container)\nstencil.load([rect1, rect2], 'group1')\n",paraId:2,tocIndex:0},{value:"Option",paraId:3,tocIndex:2},{value:"Type",paraId:3,tocIndex:2},{value:"Required",paraId:3,tocIndex:2},{value:"Default Value",paraId:3,tocIndex:2},{value:"Description",paraId:3,tocIndex:2},{value:"title",paraId:3,tocIndex:2},{value:"string",paraId:3,tocIndex:2},{value:"'Stencil'",paraId:3,tocIndex:2},{value:"Title.",paraId:3,tocIndex:2},{value:"groups",paraId:3,tocIndex:2},{value:"Group[]",paraId:3,tocIndex:2},{value:"",paraId:3,tocIndex:2},{value:"-",paraId:3,tocIndex:2},{value:"Group information.",paraId:3,tocIndex:2},{value:"search",paraId:3,tocIndex:2},{value:"Filter",paraId:3,tocIndex:2},{value:"false",paraId:3,tocIndex:2},{value:"Search option.",paraId:3,tocIndex:2},{value:"placeholder",paraId:3,tocIndex:2},{value:"string",paraId:3,tocIndex:2},{value:"'Search'",paraId:3,tocIndex:2},{value:"Placeholder text for the search input.",paraId:3,tocIndex:2},{value:"notFoundText",paraId:3,tocIndex:2},{value:"string",paraId:3,tocIndex:2},{value:"'No matches found'",paraId:3,tocIndex:2},{value:"Text displayed when no search results are found.",paraId:3,tocIndex:2},{value:"collapsable",paraId:3,tocIndex:2},{value:"boolean",paraId:3,tocIndex:2},{value:"false",paraId:3,tocIndex:2},{value:"Whether to show a global collapse/expand button.",paraId:3,tocIndex:2},{value:"layout",paraId:3,tocIndex:2},{value:"(this: Stencil, model: Model, group?: Group | null) => any",paraId:3,tocIndex:2},{value:"Grid layout",paraId:3,tocIndex:2},{value:"Layout method for nodes in the stencil canvas.",paraId:3,tocIndex:2},{value:"layoutOptions",paraId:3,tocIndex:2},{value:"any",paraId:3,tocIndex:2},{value:"-",paraId:3,tocIndex:2},{value:"Layout options.",paraId:3,tocIndex:2},{value:"stencilGraphWidth",paraId:3,tocIndex:2},{value:"number",paraId:3,tocIndex:2},{value:"200",paraId:3,tocIndex:2},{value:"Width of the stencil canvas.",paraId:3,tocIndex:2},{value:"stencilGraphHeight",paraId:3,tocIndex:2},{value:"number",paraId:3,tocIndex:2},{value:"800",paraId:3,tocIndex:2},{value:"Height of the stencil canvas. Set to 0 for auto-adjustment.",paraId:3,tocIndex:2},{value:"stencilGraphPadding",paraId:3,tocIndex:2},{value:"number",paraId:3,tocIndex:2},{value:"10",paraId:3,tocIndex:2},{value:"Padding for the stencil canvas.",paraId:3,tocIndex:2},{value:"stencilGraphOptions",paraId:3,tocIndex:2},{value:"Graph.Options",paraId:3,tocIndex:2},{value:"-",paraId:3,tocIndex:2},{value:"Options for the stencil canvas.",paraId:3,tocIndex:2},{value:"In addition to the configurations above, Stencil also inherits all configurations from Dnd.",paraId:4},{value:"When initializing, a template canvas will be rendered in each group according to the ",paraId:5,tocIndex:3},{value:"groups",paraId:5,tocIndex:3},{value:" provided. The type definition for groups is as follows:",paraId:5,tocIndex:3},{value:"export interface Group {\n  name: string // Group name\n  title?: string // Group title, defaults to `name`\n  collapsable?: boolean // Whether the group is collapsible, defaults to true\n  collapsed?: boolean // Initial state whether it is collapsed\n  nodeMovable?: boolean // Whether nodes in the stencil canvas can be dragged\n  graphWidth?: number // Width of the stencil canvas\n  graphHeight?: number // Height of the stencil canvas\n  graphPadding?: number // Padding for the stencil canvas\n  graphOptions?: Graph.Options // Options for the stencil canvas\n  layout?: (this: Stencil, model: Model, group?: Group | null) => any\n  layoutOptions?: any // Layout options\n}\n",paraId:6,tocIndex:3},{value:"As you can see, some configurations within the group overlap with the outer configurations, such as ",paraId:7,tocIndex:3},{value:"graphWidth/stencilGraphWidth",paraId:7,tocIndex:3},{value:" and ",paraId:7,tocIndex:3},{value:"graphHeight/stencilGraphHeight",paraId:7,tocIndex:3},{value:", with the group configurations taking higher priority.",paraId:7,tocIndex:3},{value:"When adding nodes, use the group or global ",paraId:8,tocIndex:4},{value:"layout",paraId:8,tocIndex:4},{value:" and ",paraId:8,tocIndex:4},{value:"layoutOptions",paraId:8,tocIndex:4},{value:" to automatically layout the nodes. By default, the grid layout method is used to layout the template nodes, and the supported layout options are:",paraId:8,tocIndex:4},{value:"Option",paraId:9,tocIndex:4},{value:"Type",paraId:9,tocIndex:4},{value:"Default Value",paraId:9,tocIndex:4},{value:"Description",paraId:9,tocIndex:4},{value:"columns",paraId:9,tocIndex:4},{value:"number",paraId:9,tocIndex:4},{value:"2",paraId:9,tocIndex:4},{value:"Number of columns in the grid layout, defaults to ",paraId:9,tocIndex:4},{value:"2",paraId:9,tocIndex:4},{value:". The number of rows is calculated automatically based on the number of nodes.",paraId:9,tocIndex:4},{value:"columnWidth",paraId:9,tocIndex:4},{value:"number | 'auto' | 'compact'",paraId:9,tocIndex:4},{value:"'auto'",paraId:9,tocIndex:4},{value:"Column width. ",paraId:9,tocIndex:4},{value:"auto",paraId:9,tocIndex:4},{value:": width of the widest node among all nodes, ",paraId:9,tocIndex:4},{value:"compact",paraId:9,tocIndex:4},{value:": width of the widest node in that column.",paraId:9,tocIndex:4},{value:"rowHeight",paraId:9,tocIndex:4},{value:"number | 'auto' | 'compact'",paraId:9,tocIndex:4},{value:"'auto'",paraId:9,tocIndex:4},{value:"Row height. ",paraId:9,tocIndex:4},{value:"auto",paraId:9,tocIndex:4},{value:": height of the tallest node among all nodes, ",paraId:9,tocIndex:4},{value:"compact",paraId:9,tocIndex:4},{value:": height of the tallest node in that row.",paraId:9,tocIndex:4},{value:"dx",paraId:9,tocIndex:4},{value:"number",paraId:9,tocIndex:4},{value:"10",paraId:9,tocIndex:4},{value:"Offset of the cell on the X-axis, defaults to ",paraId:9,tocIndex:4},{value:"10",paraId:9,tocIndex:4},{value:".",paraId:9,tocIndex:4},{value:"dy",paraId:9,tocIndex:4},{value:"number",paraId:9,tocIndex:4},{value:"10",paraId:9,tocIndex:4},{value:"Offset of the cell on the Y-axis, defaults to ",paraId:9,tocIndex:4},{value:"10",paraId:9,tocIndex:4},{value:".",paraId:9,tocIndex:4},{value:"marginX",paraId:9,tocIndex:4},{value:"number",paraId:9,tocIndex:4},{value:"0",paraId:9,tocIndex:4},{value:"Margin of the cell on the X-axis, defaults to ",paraId:9,tocIndex:4},{value:"0",paraId:9,tocIndex:4},{value:".",paraId:9,tocIndex:4},{value:"marginY",paraId:9,tocIndex:4},{value:"number",paraId:9,tocIndex:4},{value:"0",paraId:9,tocIndex:4},{value:"Margin of the cell on the Y-axis, defaults to ",paraId:9,tocIndex:4},{value:"0",paraId:9,tocIndex:4},{value:".",paraId:9,tocIndex:4},{value:"center",paraId:9,tocIndex:4},{value:"boolean",paraId:9,tocIndex:4},{value:"true",paraId:9,tocIndex:4},{value:"Whether the nodes are center-aligned with the grid, defaults to ",paraId:9,tocIndex:4},{value:"true",paraId:9,tocIndex:4},{value:".",paraId:9,tocIndex:4},{value:"resizeToFit",paraId:9,tocIndex:4},{value:"boolean",paraId:9,tocIndex:4},{value:"false",paraId:9,tocIndex:4},{value:"Whether to automatically adjust the size of the nodes to fit the grid size, defaults to ",paraId:9,tocIndex:4},{value:"false",paraId:9,tocIndex:4},{value:".",paraId:9,tocIndex:4},{value:"You can also implement a custom layout according to the signature ",paraId:10,tocIndex:4},{value:"(this: Stencil, model: Model, group?: Group | null) => any",paraId:10,tocIndex:4},{value:".",paraId:10,tocIndex:4},{value:"Stencil also provides search capabilities.",paraId:11,tocIndex:5},{value:"// Only search for rect nodes\nconst stencil = new Stencil({\n  search: (cell, keyword, groupName, stencil) => {\n    if (keyword) {\n      return cell.shape === 'rect'\n    }\n    return true\n  },\n})\n\n// Search for rect nodes whose text contains the keyword\nconst stencil = new Stencil({\n  search: (cell, keyword, groupName, stencil) => {\n    if (keyword) {\n      return cell.shape === 'rect' && cell.attr('text/text').includes(keyword)\n    }\n    return true\n  },\n})\n",paraId:12,tocIndex:5},{value:"load(nodes: (Node | Node.Metadata)[], groupName?: string): this\n",paraId:13,tocIndex:7},{value:"Load nodes. Parameters are as follows:",paraId:14,tocIndex:7},{value:"Name",paraId:15,tocIndex:7},{value:"Type",paraId:15,tocIndex:7},{value:"Required",paraId:15,tocIndex:7},{value:"Default Value",paraId:15,tocIndex:7},{value:"Description",paraId:15,tocIndex:7},{value:"nodes",paraId:15,tocIndex:7},{value:"(Node | Node.Metadata)[]",paraId:15,tocIndex:7},{value:"",paraId:15,tocIndex:7},{value:"-",paraId:15,tocIndex:7},{value:"Nodes to load.",paraId:15,tocIndex:7},{value:"groupName",paraId:15,tocIndex:7},{value:"string",paraId:15,tocIndex:7},{value:"-",paraId:15,tocIndex:7},{value:"Name of the group to load nodes into.",paraId:15,tocIndex:7},{value:"unload(nodes: (Node | Node.Metadata)[], groupName?: string): this\n",paraId:16,tocIndex:8},{value:"Unload nodes. Parameters are as follows:",paraId:17,tocIndex:8},{value:"Name",paraId:18,tocIndex:8},{value:"Type",paraId:18,tocIndex:8},{value:"Required",paraId:18,tocIndex:8},{value:"Default Value",paraId:18,tocIndex:8},{value:"Description",paraId:18,tocIndex:8},{value:"nodes",paraId:18,tocIndex:8},{value:"(Node | Node.Metadata)[]",paraId:18,tocIndex:8},{value:"",paraId:18,tocIndex:8},{value:"-",paraId:18,tocIndex:8},{value:"Nodes to unload.",paraId:18,tocIndex:8},{value:"groupName",paraId:18,tocIndex:8},{value:"string",paraId:18,tocIndex:8},{value:"-",paraId:18,tocIndex:8},{value:"Name of the group to unload nodes from.",paraId:18,tocIndex:8},{value:"addGroup(group: Stencil.Group | Stencil.Group[])\n",paraId:19,tocIndex:9},{value:"Add a new group.",paraId:20,tocIndex:9},{value:"stencil.addGroup({\n  name: 'group1',\n  graphHeight: 100,\n})\n",paraId:21,tocIndex:9},{value:"removeGroup(groupName: string | string[])\n",paraId:22,tocIndex:10},{value:"Remove a group.",paraId:23,tocIndex:10},{value:"resizeGroup(groupName: string, size: { width: number; height: number })\n",paraId:24,tocIndex:11},{value:"Modify the size of a group.",paraId:25,tocIndex:11}]},65815:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(29758);const n=[{value:"How to adjust node size using the interactive plugin",paraId:0},{value:"How to adjust a nodes rotation angle using the interactive plugin",paraId:0},{value:"Using interactive UI components to adjust node size and angle is a common requirement. We provide the ",paraId:1,tocIndex:0},{value:"transform",paraId:1,tocIndex:0},{value:" plugin to implement this. Use it like this:",paraId:1,tocIndex:0},{value:"import { Graph, Transform } from '@antv/x6'\n\nconst graph = new Graph({\n  background: {\n    color: '#F2F7FA',\n  },\n})\ngraph.use(\n  new Transform({\n    resizing: resizingOptions,\n    rotating: rotatingOptions,\n  }),\n)\n",paraId:2,tocIndex:0},{value:"First, let's experience interactive resizing of nodes (clicking on a node brings up the operation component):",paraId:3,tocIndex:1},{value:"Next, let's experience interactive rotation of nodes (clicking on a node brings up the operation component):",paraId:4},{value:"Property Name",paraId:5,tocIndex:3},{value:"Type",paraId:5,tocIndex:3},{value:"Default Value",paraId:5,tocIndex:3},{value:"Required",paraId:5,tocIndex:3},{value:"Description",paraId:5,tocIndex:3},{value:"enabled",paraId:5,tocIndex:3},{value:"boolean",paraId:5,tocIndex:3},{value:"false",paraId:5,tocIndex:3},{value:"Whether resizing of nodes is supported",paraId:5,tocIndex:3},{value:"minWidth",paraId:5,tocIndex:3},{value:"number",paraId:5,tocIndex:3},{value:"0",paraId:5,tocIndex:3},{value:"Minimum resizing width",paraId:5,tocIndex:3},{value:"minHeight",paraId:5,tocIndex:3},{value:"number",paraId:5,tocIndex:3},{value:"0",paraId:5,tocIndex:3},{value:"Minimum resizing height",paraId:5,tocIndex:3},{value:"maxWidth",paraId:5,tocIndex:3},{value:"number",paraId:5,tocIndex:3},{value:"Infinity",paraId:5,tocIndex:3},{value:"Maximum resizing width",paraId:5,tocIndex:3},{value:"maxHeight",paraId:5,tocIndex:3},{value:"number",paraId:5,tocIndex:3},{value:"Infinity",paraId:5,tocIndex:3},{value:"Maximum resizing height",paraId:5,tocIndex:3},{value:"orthogonal",paraId:5,tocIndex:3},{value:"boolean",paraId:5,tocIndex:3},{value:"true",paraId:5,tocIndex:3},{value:"Whether to show intermediate resizing points",paraId:5,tocIndex:3},{value:"restrict",paraId:5,tocIndex:3},{value:"boolean",paraId:5,tocIndex:3},{value:"false",paraId:5,tocIndex:3},{value:"Whether resizing boundaries can exceed canvas edges",paraId:5,tocIndex:3},{value:"autoScroll",paraId:5,tocIndex:3},{value:"boolean",paraId:5,tocIndex:3},{value:"true",paraId:5,tocIndex:3},{value:"Whether to automatically scroll the canvas when dragging exceeds its bounds",paraId:5,tocIndex:3},{value:"preserveAspectRatio",paraId:5,tocIndex:3},{value:"boolean",paraId:5,tocIndex:3},{value:"false",paraId:5,tocIndex:3},{value:"Whether to maintain the aspect ratio during resizing",paraId:5,tocIndex:3},{value:"allowReverse",paraId:5,tocIndex:3},{value:"boolean",paraId:5,tocIndex:3},{value:"true",paraId:5,tocIndex:3},{value:"Whether to allow control points to drag in reverse when reaching minimum width or height",paraId:5,tocIndex:3},{value:"The above configuration supports dynamic modification using functions as well:",paraId:6,tocIndex:3},{value:"new Transform({\n  resizing: {\n    enabled: true,\n    orthogonal(node: Node) {\n      const { enableOrthogonal } = node.getData()\n      return enableOrthogonal\n    },\n  },\n})\n",paraId:7,tocIndex:3},{value:"Property Name",paraId:8,tocIndex:4},{value:"Type",paraId:8,tocIndex:4},{value:"Default Value",paraId:8,tocIndex:4},{value:"Required",paraId:8,tocIndex:4},{value:"Description",paraId:8,tocIndex:4},{value:"enabled",paraId:8,tocIndex:4},{value:"boolean",paraId:8,tocIndex:4},{value:"false",paraId:8,tocIndex:4},{value:"Whether rotating of nodes is supported",paraId:8,tocIndex:4},{value:"grid",paraId:8,tocIndex:4},{value:"number",paraId:8,tocIndex:4},{value:"15",paraId:8,tocIndex:4},{value:"Angle of rotation per step",paraId:8,tocIndex:4},{value:"The above configuration also supports dynamic modification using functions:",paraId:9,tocIndex:4},{value:"new Transform({\n  rotating: {\n    enabled: true,\n    grid() {\n      return 30\n    },\n  },\n})\n",paraId:10,tocIndex:4},{value:"Creates a transform control for the node.",paraId:11,tocIndex:6},{value:"Clears all transform controls.",paraId:12,tocIndex:7},{value:"Event Name",paraId:13,tocIndex:8},{value:"Parameter Type",paraId:13,tocIndex:8},{value:"Description",paraId:13,tocIndex:8},{value:"node:resize",paraId:13,tocIndex:8},{value:"{ e: Dom.MouseDownEvent; x: number; y: number; node: Node; view: NodeView }",paraId:13,tocIndex:8},{value:"Triggered when resizing starts",paraId:13,tocIndex:8},{value:"node:resizing",paraId:13,tocIndex:8},{value:"{ e: Dom.MouseMoveEvent; x: number; y: number; node: Node; view: NodeView }",paraId:13,tocIndex:8},{value:"Triggered during resizing",paraId:13,tocIndex:8},{value:"node:resized",paraId:13,tocIndex:8},{value:"{ e: Dom.MouseUpEvent; x: number; y: number; node: Node; view: NodeView }",paraId:13,tocIndex:8},{value:"Triggered after resizing",paraId:13,tocIndex:8},{value:"node:rotate",paraId:13,tocIndex:8},{value:"{ e: Dom.MouseDownEvent; x: number; y: number; node: Node; view: NodeView }",paraId:13,tocIndex:8},{value:"Triggered when rotation starts",paraId:13,tocIndex:8},{value:"node:rotating",paraId:13,tocIndex:8},{value:"{ e: Dom.MouseMoveEvent; x: number; y: number; node: Node; view: NodeView }",paraId:13,tocIndex:8},{value:"Triggered during rotation",paraId:13,tocIndex:8},{value:"node:rotated",paraId:13,tocIndex:8},{value:"{ e: Dom.MouseUpEvent; x: number; y: number; node: Node; view: NodeView }",paraId:13,tocIndex:8},{value:"Triggered after rotation",paraId:13,tocIndex:8},{value:"graph.on('node:rotated', ({ node }) => {\n  console.log(node.angle())\n})\n\n// We can also listen to events on the plugin instance\ntransform.on('node:rotated', ({ node }) => {\n  console.log(node.angle())\n})\n",paraId:14,tocIndex:8}]},43693:function(e,a,t){t.r(a),t.d(a,{texts:function(){return n}});t(63500);const n=[{value:"Compared to 2.x, 3.x mainly focuses on plugin consolidation (unified export), optimized default interactions, introduces animation capabilities, and adds virtual rendering support. The upgrade cost is low.",paraId:0},{value:"Plugin and subpackage consolidation: ",paraId:1,tocIndex:0},{value:"@antv/x6-plugin-xxxx",paraId:1,tocIndex:0},{value:", ",paraId:1,tocIndex:0},{value:"@antv/x6-common",paraId:1,tocIndex:0},{value:", and ",paraId:1,tocIndex:0},{value:"@antv/x6-geometry",paraId:1,tocIndex:0},{value:" are merged into the main ",paraId:1,tocIndex:0},{value:"@antv/x6",paraId:1,tocIndex:0},{value:" package and exported from there.",paraId:1,tocIndex:0},{value:"Default interaction tweak: canvas ",paraId:1,tocIndex:0},{value:"panning",paraId:1,tocIndex:0},{value:" is enabled by default.",paraId:1,tocIndex:0},{value:"New animation capability: supports imperative, declarative, and custom Shape-based animations.",paraId:1,tocIndex:0},{value:"With ",paraId:1,tocIndex:0},{value:"Scroller",paraId:1,tocIndex:0},{value:", virtual rendering is available via ",paraId:1,tocIndex:0},{value:"virtual: true",paraId:1,tocIndex:0},{value:" for large graphs.",paraId:1,tocIndex:0},{value:"3.x merges commonly used plugins and subpackages into ",paraId:2,tocIndex:2},{value:"@antv/x6",paraId:2,tocIndex:2},{value:", so you no longer need to install separate ",paraId:2,tocIndex:2},{value:"@antv/x6-plugin-xxxx",paraId:2,tocIndex:2},{value:" packages. Additionally, the utility package ",paraId:2,tocIndex:2},{value:"@antv/x6-common",paraId:2,tocIndex:2},{value:" and geometry package ",paraId:2,tocIndex:2},{value:"@antv/x6-geometry",paraId:2,tocIndex:2},{value:" are now part of the main package, and their APIs should be imported from ",paraId:2,tocIndex:2},{value:"@antv/x6",paraId:2,tocIndex:2},{value:".",paraId:2,tocIndex:2},{value:'{\n  "@antv/x6": "^3.0.0"\n}\n',paraId:3,tocIndex:2},{value:"Remove the following dependencies if present:",paraId:4,tocIndex:2},{value:"@antv/x6-plugin-selection",paraId:5,tocIndex:2},{value:"@antv/x6-plugin-transform",paraId:5,tocIndex:2},{value:"@antv/x6-plugin-scroller",paraId:5,tocIndex:2},{value:"@antv/x6-plugin-keyboard",paraId:5,tocIndex:2},{value:"@antv/x6-plugin-history",paraId:5,tocIndex:2},{value:"@antv/x6-plugin-clipboard",paraId:5,tocIndex:2},{value:"@antv/x6-plugin-snapline",paraId:5,tocIndex:2},{value:"@antv/x6-plugin-dnd",paraId:5,tocIndex:2},{value:"@antv/x6-plugin-minimap",paraId:5,tocIndex:2},{value:"@antv/x6-plugin-stencil",paraId:5,tocIndex:2},{value:"@antv/x6-plugin-export",paraId:5,tocIndex:2},{value:"@antv/x6-common",paraId:5,tocIndex:2},{value:"@antv/x6-geometry",paraId:5,tocIndex:2},{value:"Starting from 3.x, the plugins above are exported from ",paraId:6,tocIndex:3},{value:"@antv/x6",paraId:6,tocIndex:3},{value:". Usage remains the same; simply replace the import path:",paraId:6,tocIndex:3},{value:"// 2.x\nimport { Scroller } from '@antv/x6-plugin-scroller'\nimport { Selection } from '@antv/x6-plugin-selection'\ngraph.use(new Scroller())\ngraph.use(new Selection())\n\n// 3.x\nimport { Scroller, Selection } from '@antv/x6'\ngraph.use(new Scroller())\ngraph.use(new Selection())\n",paraId:7,tocIndex:3},{value:"In 3.x, utilities and geometry types previously imported from ",paraId:8,tocIndex:3},{value:"@antv/x6-common",paraId:8,tocIndex:3},{value:" and ",paraId:8,tocIndex:3},{value:"@antv/x6-geometry",paraId:8,tocIndex:3},{value:" are now exported directly from ",paraId:8,tocIndex:3},{value:"@antv/x6",paraId:8,tocIndex:3},{value:". You only need to update the import path:",paraId:8,tocIndex:3},{value:"// 2.x\nimport { Dom, FunctionExt } from '@antv/x6-common'\nimport { Point, Rectangle } from '@antv/x6-geometry'\n\n// 3.x\nimport { Dom, FunctionExt, Point, Rectangle } from '@antv/x6'\n",paraId:9,tocIndex:3},{value:"3.x introduces ",paraId:10,tocIndex:4},{value:"animate",paraId:10,tocIndex:4},{value:" and removes the 2.x ",paraId:10,tocIndex:4},{value:"transition",paraId:10,tocIndex:4},{value:" API, making it easier to add effects to nodes and edges.",paraId:10,tocIndex:4},{value:"See more: ",paraId:11,tocIndex:4},{value:"Animation Docs",paraId:12,tocIndex:4},{value:".",paraId:11,tocIndex:4},{value:"Graph panning ",paraId:13,tocIndex:5},{value:"panning",paraId:13,tocIndex:5},{value:" is enabled by default (",paraId:13,tocIndex:5},{value:"enabled: true",paraId:13,tocIndex:5},{value:"). To disable, set ",paraId:13,tocIndex:5},{value:"panning: false",paraId:13,tocIndex:5},{value:".",paraId:13,tocIndex:5},{value:"When graph ",paraId:13,tocIndex:5},{value:"panning",paraId:13,tocIndex:5},{value:" conflicts with Selection rubberband triggers, Selection takes precedence.",paraId:13,tocIndex:5},{value:"With ",paraId:13,tocIndex:5},{value:"Scroller",paraId:13,tocIndex:5},{value:", graph ",paraId:13,tocIndex:5},{value:"panning",paraId:13,tocIndex:5},{value:" is disabled by default to avoid interaction conflicts, and virtual rendering can be enabled via ",paraId:13,tocIndex:5},{value:"virtual: true",paraId:13,tocIndex:5},{value:".",paraId:13,tocIndex:5},{value:"X6 3.x must use the 3.x versions of the shape packages: ",paraId:14,tocIndex:6},{value:"@antv/x6-react-shape@^3.x",paraId:14,tocIndex:6},{value:", ",paraId:14,tocIndex:6},{value:"@antv/x6-vue-shape@^3.x",paraId:14,tocIndex:6},{value:", and ",paraId:14,tocIndex:6},{value:"@antv/x6-angular-shape@^3.x",paraId:14,tocIndex:6},{value:".",paraId:14,tocIndex:6},{value:'{\n  "@antv/x6-react-shape": "^3.0.0",\n  "@antv/x6-vue-shape": "^3.0.0",\n  "@antv/x6-angular-shape": "^3.0.0"\n}\n',paraId:15,tocIndex:6},{value:"Change 2.x ",paraId:16,tocIndex:7},{value:"Portal.getProvider()",paraId:16,tocIndex:7},{value:" to 3.x ",paraId:16,tocIndex:7},{value:"getProvider()",paraId:16,tocIndex:7},{value:":",paraId:16,tocIndex:7},{value:"// 2.x\nimport { Portal } from '@antv/x6-react-shape'\nconst Provider = Portal.getProvider()\n\n// 3.x\nimport { getProvider } from '@antv/x6-react-shape'\nconst Provider = getProvider()\n",paraId:17,tocIndex:7}]},66043:function(e,a){a.Z="/* eslint-disable no-new */\nimport React from 'react'\nimport { Graph } from '@antv/x6'\nimport { SplitBox } from '@antv/x6-react-components'\nimport '@antv/x6-react-components/es/split-box/style/index.css'\nimport './index.less'\n\nexport default class Example extends React.Component {\n  private container1: HTMLDivElement\n  private container2: HTMLDivElement\n  private container3: HTMLDivElement\n\n  componentDidMount() {\n    new Graph({\n      container: this.container1,\n      background: {\n        color: '#F2F7FA',\n      },\n      autoResize: true,\n    })\n\n    new Graph({\n      container: this.container2,\n      background: {\n        color: '#F2F7FA',\n      },\n      autoResize: true,\n    })\n\n    new Graph({\n      container: this.container3,\n      background: {\n        color: '#F2F7FA',\n      },\n      autoResize: true,\n    })\n  }\n\n  refContainer1 = (container: HTMLDivElement) => {\n    this.container1 = container\n  }\n\n  refContainer2 = (container: HTMLDivElement) => {\n    this.container2 = container\n  }\n\n  refContainer3 = (container: HTMLDivElement) => {\n    this.container3 = container\n  }\n\n  render() {\n    return (\n      <div className=\"auto-resize-app\">\n        <SplitBox split=\"horizontal\">\n          <div className=\"full\">\n            <div ref={this.refContainer1} />\n          </div>\n          <SplitBox split=\"vertical\">\n            <div className=\"full\">\n              <div ref={this.refContainer2} />\n            </div>\n            <div className=\"full\">\n              <div ref={this.refContainer3} />\n            </div>\n          </SplitBox>\n        </SplitBox>\n      </div>\n    )\n  }\n}\n"},95218:function(e,a){a.Z="import React from 'react'\nimport { Graph } from '@antv/x6'\nimport './index.less'\n\nconst data = {\n  nodes: [\n    {\n      id: 'node1',\n      shape: 'rect',\n      x: 40,\n      y: 40,\n      width: 100,\n      height: 40,\n      label: 'hello',\n      attrs: {\n        body: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n          fill: '#fff',\n          rx: 6,\n          ry: 6,\n        },\n      },\n    },\n    {\n      id: 'node2',\n      shape: 'rect',\n      x: 160,\n      y: 180,\n      width: 100,\n      height: 40,\n      label: 'world',\n      attrs: {\n        body: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n          fill: '#fff',\n          rx: 6,\n          ry: 6,\n        },\n      },\n    },\n  ],\n  edges: [\n    {\n      shape: 'edge',\n      source: 'node1',\n      target: 'node2',\n      label: 'x6',\n      attrs: {\n        line: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n        },\n      },\n    },\n  ],\n}\n\nexport default class Example extends React.Component {\n  private container: HTMLDivElement\n\n  componentDidMount() {\n    const graph = new Graph({\n      container: this.container,\n      background: {\n        color: '#F2F7FA',\n      },\n      grid: {\n        visible: true,\n        type: 'doubleMesh',\n        args: [\n          {\n            color: '#eee', // \n            thickness: 1, // \n          },\n          {\n            color: '#ddd', // \n            thickness: 1, // \n            factor: 4, // \n          },\n        ],\n      },\n    })\n\n    graph.fromJSON(data)\n    graph.centerContent()\n  }\n\n  refContainer = (container: HTMLDivElement) => {\n    this.container = container\n  }\n\n  render() {\n    return (\n      <div className=\"backgournd-grid-app\">\n        <div className=\"app-content\" ref={this.refContainer} />\n      </div>\n    )\n  }\n}\n"},205:function(e,a){a.Z="import React from 'react'\nimport { Graph } from '@antv/x6'\nimport './index.less'\n\nconst data = {\n  nodes: [\n    {\n      id: 'node1',\n      shape: 'rect',\n      x: 40,\n      y: 40,\n      width: 100,\n      height: 40,\n      label: 'hello',\n      attrs: {\n        body: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n          fill: '#fff',\n          rx: 6,\n          ry: 6,\n        },\n      },\n    },\n    {\n      id: 'node2',\n      shape: 'rect',\n      x: 160,\n      y: 180,\n      width: 100,\n      height: 40,\n      label: 'world',\n      attrs: {\n        body: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n          fill: '#fff',\n          rx: 6,\n          ry: 6,\n        },\n      },\n    },\n  ],\n  edges: [\n    {\n      shape: 'edge',\n      source: 'node1',\n      target: 'node2',\n      label: 'x6',\n      attrs: {\n        line: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n        },\n      },\n    },\n  ],\n}\n\nexport default class Example extends React.Component {\n  private container: HTMLDivElement\n\n  componentDidMount() {\n    const graph = new Graph({\n      container: this.container,\n      background: {\n        color: '#F2F7FA',\n      },\n      grid: {\n        visible: true,\n        type: 'doubleMesh',\n        args: [\n          {\n            color: '#eee', // \n            thickness: 1, // \n          },\n          {\n            color: '#ddd', // \n            thickness: 1, // \n            factor: 4, // \n          },\n        ],\n      },\n      panning: true,\n      mousewheel: {\n        enabled: true,\n        modifiers: 'Ctrl',\n        maxScale: 4,\n        minScale: 0.2,\n      },\n    })\n\n    graph.fromJSON(data)\n    graph.centerContent()\n  }\n\n  refContainer = (container: HTMLDivElement) => {\n    this.container = container\n  }\n\n  render() {\n    return (\n      <div className=\"panning-mousewheel-app\">\n        <div className=\"app-content\" ref={this.refContainer} />\n      </div>\n    )\n  }\n}\n"},48612:function(e,a){a.Z="import React from 'react'\nimport { Graph } from '@antv/x6'\nimport './index.less'\n\nconst data = {\n  nodes: [\n    {\n      id: 'node1',\n      shape: 'rect',\n      x: 40,\n      y: 40,\n      width: 100,\n      height: 40,\n      label: 'hello',\n      attrs: {\n        // body  rect \n        body: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n          fill: '#fff',\n          rx: 6,\n          ry: 6,\n        },\n      },\n    },\n    {\n      id: 'node2',\n      shape: 'rect',\n      x: 160,\n      y: 180,\n      width: 100,\n      height: 40,\n      label: 'world',\n      attrs: {\n        body: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n          fill: '#fff',\n          rx: 6,\n          ry: 6,\n        },\n      },\n    },\n  ],\n  edges: [\n    {\n      shape: 'edge',\n      source: 'node1',\n      target: 'node2',\n      label: 'x6',\n      attrs: {\n        // line  path \n        line: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n        },\n      },\n    },\n  ],\n}\n\nexport default class Example extends React.Component {\n  private container: HTMLDivElement\n\n  componentDidMount() {\n    const graph = new Graph({\n      container: this.container,\n      // \n      background: {\n        color: '#F2F7FA',\n      },\n    })\n\n    graph.fromJSON(data) // \n    graph.centerContent() // \n  }\n\n  refContainer = (container: HTMLDivElement) => {\n    this.container = container\n  }\n\n  render() {\n    return (\n      <div className=\"helloworld-app\">\n        <div className=\"app-content\" ref={this.refContainer} />\n      </div>\n    )\n  }\n}\n"},10849:function(e,a){a.Z="import React from 'react'\nimport { Graph, Node } from '@antv/x6'\nimport { register } from '@antv/x6-react-shape'\nimport { Dropdown } from 'antd'\nimport './index.less'\n\nconst CustomComponent = ({ node }: { node: Node }) => {\n  const label = node.prop('label')\n  return (\n    <Dropdown\n      menu={{\n        items: [\n          {\n            key: 'copy',\n            label: '',\n          },\n          {\n            key: 'paste',\n            label: '',\n          },\n          {\n            key: 'delete',\n            label: '',\n          },\n        ],\n      }}\n      trigger={['contextMenu']}\n    >\n      <div className=\"custom-react-node\">{label}</div>\n    </Dropdown>\n  )\n}\n\nregister({\n  shape: 'custom-react-node',\n  width: 100,\n  height: 40,\n  component: CustomComponent,\n})\n\nconst data = {\n  nodes: [\n    {\n      id: 'node1',\n      shape: 'custom-react-node',\n      x: 40,\n      y: 40,\n      label: 'hello',\n    },\n    {\n      id: 'node2',\n      shape: 'custom-react-node',\n      x: 160,\n      y: 180,\n      label: 'world',\n    },\n  ],\n  edges: [\n    {\n      shape: 'edge',\n      source: 'node1',\n      target: 'node2',\n      label: 'x6',\n      attrs: {\n        line: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n        },\n      },\n    },\n  ],\n}\n\nexport default class Example extends React.Component {\n  private container: HTMLDivElement\n\n  componentDidMount() {\n    const graph = new Graph({\n      container: this.container,\n      background: {\n        color: '#F2F7FA',\n      },\n    })\n\n    graph.fromJSON(data)\n    graph.centerContent()\n  }\n\n  refContainer = (container: HTMLDivElement) => {\n    this.container = container\n  }\n\n  render() {\n    return (\n      <div className=\"react-shape-app\">\n        <div className=\"app-content\" ref={this.refContainer} />\n      </div>\n    )\n  }\n}\n"},28880:function(e,a){a.Z="import React from 'react'\nimport { Graph, Node, Snapline } from '@antv/x6'\nimport { register } from '@antv/x6-react-shape'\nimport { Dropdown } from 'antd'\nimport './index.less'\n\nconst CustomComponent = ({ node }: { node: Node }) => {\n  const label = node.prop('label')\n  return (\n    <Dropdown\n      menu={{\n        items: [\n          {\n            key: 'copy',\n            label: '',\n          },\n          {\n            key: 'paste',\n            label: '',\n          },\n          {\n            key: 'delete',\n            label: '',\n          },\n        ],\n      }}\n      trigger={['contextMenu']}\n    >\n      <div className=\"custom-react-node\">{label}</div>\n    </Dropdown>\n  )\n}\n\nregister({\n  shape: 'custom-react-node',\n  width: 100,\n  height: 40,\n  component: CustomComponent,\n})\n\nconst data = {\n  nodes: [\n    {\n      id: 'node1',\n      shape: 'custom-react-node',\n      x: 40,\n      y: 40,\n      label: 'hello',\n    },\n    {\n      id: 'node2',\n      shape: 'custom-react-node',\n      x: 160,\n      y: 180,\n      label: 'world',\n    },\n  ],\n  edges: [\n    {\n      shape: 'edge',\n      source: 'node1',\n      target: 'node2',\n      label: 'x6',\n      attrs: {\n        line: {\n          stroke: '#8f8f8f',\n          strokeWidth: 1,\n        },\n      },\n    },\n  ],\n}\n\nexport default class Example extends React.Component {\n  private container: HTMLDivElement\n\n  componentDidMount() {\n    const graph = new Graph({\n      container: this.container,\n      background: {\n        color: '#F2F7FA',\n      },\n    })\n\n    graph.use(\n      new Snapline({\n        enabled: true,\n      }),\n    )\n    graph.fromJSON(data)\n    graph.centerContent()\n  }\n\n  refContainer = (container: HTMLDivElement) => {\n    this.container = container\n  }\n\n  render() {\n    return (\n      <div className=\"use-plugin-app\">\n        <div className=\"app-content\" ref={this.refContainer} />\n      </div>\n    )\n  }\n}\n"}}]);