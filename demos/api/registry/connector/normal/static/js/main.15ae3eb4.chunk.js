(this["webpackJsonpapi.registry.connector.normal"] = this["webpackJsonpapi.registry.connector.normal"] || []).push([[0],{

/***/ 111:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Platform; });
var ua = navigator.userAgent;
var Platform;

(function (Platform) {
  Platform.IS_MAC = navigator.appVersion.indexOf('Mac') > 0;
  Platform.IS_IOS = ua.match(/(iPad|iPhone|iPod)/g) ? true : false;
  Platform.IS_WINDOWS = navigator.appVersion.indexOf('Win') > 0;
  Platform.IS_IE = ua.indexOf('MSIE') >= 0;
  Platform.IS_IE11 = !!ua.match(/Trident\/7\./);
  Platform.IS_EDGE = !!ua.match(/Edge\//);
  /**
   * A flag indicating whether the browser is Netscape (including Firefox).
   */

  Platform.IS_NETSCAPE = ua.indexOf('Mozilla/') >= 0 && ua.indexOf('MSIE') < 0 && ua.indexOf('Edge/') < 0;
  /**
   * A flag indicating whether the the this is running inside a Chrome App.
   */

  Platform.IS_CHROME_APP = window.chrome != null && window.chrome.app != null && window.chrome.app.runtime != null;
  Platform.IS_CHROME = ua.indexOf('Chrome/') >= 0 && ua.indexOf('Edge/') < 0;
  Platform.IS_OPERA = ua.indexOf('Opera/') >= 0 || ua.indexOf('OPR/') >= 0;
  Platform.IS_FIREFOX = ua.indexOf('Firefox/') >= 0;
  Platform.IS_SAFARI = ua.indexOf('AppleWebKit/') >= 0 && ua.indexOf('Chrome/') < 0 && ua.indexOf('Edge/') < 0;
  /**
   * A flag indicating whether this device supports touchstart/-move/-end
   * events (Apple iOS, Android, Chromebook and Chrome Browser on touch-enabled
   * devices).
   */

  Platform.SUPPORT_TOUCH = 'ontouchstart' in document.documentElement;
  /**
   * A flag indicating whether this device supports Microsoft pointer events.
   */

  Platform.SUPPORT_POINTER = window.PointerEvent != null && !Platform.IS_MAC;
  Platform.SUPPORT_PASSIVE = false;

  try {
    var options = Object.defineProperty({}, 'passive', {
      get: function get() {
        Platform.SUPPORT_PASSIVE = true;
      }
    });
    var div = document.createElement('div');

    if (div.addEventListener) {
      div.addEventListener('click', function () {}, options);
    }
  } catch (err) {}
  /**
   * A flag indicating whether foreignObject support is not available. This
   * is the case for Opera, older SVG-based browsers and all versions of IE.
   */


  Platform.NO_FOREIGNOBJECT = !document.createElementNS || "".concat(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')) !== '[object SVGForeignObjectElement]' || ua.indexOf('Opera/') >= 0;
  Platform.SUPPORT_FOREIGNOBJECT = !Platform.NO_FOREIGNOBJECT;
})(Platform || (Platform = {}));

(function (Platform) {
  function getHMRStatus() {
    var mod = module;

    if (mod != null && mod.hot != null && mod.hot.status != null) {
      return mod.hot.status();
    }

    return 'unkonwn';
  }

  Platform.getHMRStatus = getHMRStatus;

  function isApplyingHMR() {
    return getHMRStatus() === 'apply';
  }

  Platform.isApplyingHMR = isApplyingHMR;
})(Platform || (Platform = {}));
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(110)(module)))

/***/ }),

/***/ 184:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(234);


/***/ }),

/***/ 190:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 194:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "host", function() { return host; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCodeSandboxParams", function() { return getCodeSandboxParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStackblitzPrefillConfig", function() { return getStackblitzPrefillConfig; });

    const host = 'https://github.com/antvis/X6/tree/master//home/runner/work/X6/X6/examples/x6-example-sites/packages/api/registry/connector/normal'

    function getCodeSandboxParams () {
      return {"files":{"package.json":{"isBinary":false,"content":"{\"dependencies\":{\"@antv/x6\":\"latest\",\"antd\":\"^4.4.2\",\"react\":\"^16.13.1\",\"react-dom\":\"^16.13.1\",\"react-scripts\":\"^3.4.1\"},\"devDependencies\":{\"@types/react\":\"^16.9.19\",\"@types/react-dom\":\"^16.9.5\",\"typescript\":\"^4.0.2\"},\"scripts\":{\"start\":\"react-scripts start\",\"build\":\"react-scripts build\",\"test\":\"react-scripts test\",\"eject\":\"react-scripts eject\"},\"eslintConfig\":{\"extends\":\"react-app\"},\"browserslist\":{\"production\":[\">0.2%\",\"not dead\",\"not op_mini all\"],\"development\":[\"last 1 chrome version\",\"last 1 firefox version\",\"last 1 safari version\"]}}"},".gitignore":{"content":"# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.\n\n# dependencies\n/node_modules\nreact-app-env.d.ts\n/.pnp\n.pnp.js\n\n# testing\n/coverage\n\n# production\n/build\n\n# misc\n.DS_Store\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n","isBinary":false},"public/index.html":{"content":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n    />\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <title></title>\n  </head>\n\n  <body>\n    <noscript>\n      You need to enable JavaScript to run this app.\n    </noscript>\n    <div id=\"root\"></div>\n  </body>\n</html>\n","isBinary":false},"src/app.css":{"content":".app {\n  font-family: sans-serif;\n  padding: 0;\n  display: flex;\n  padding: 16px 8px;\n}\n\n.app-content {\n  flex: 1;\n  height: 320px;\n  margin-left: 8px;\n  margin-right: 8px;\n  box-shadow: 0 0 10px 1px #e9e9e9;\n}\n","isBinary":false},"src/app.tsx":{"content":"import React from 'react'\nimport { Graph } from '@antv/x6'\nimport './app.css'\n\nexport default class Example extends React.Component {\n  private container: HTMLDivElement\n\n  componentDidMount() {\n    const graph = new Graph({\n      container: this.container,\n      grid: true,\n    })\n\n    const rect1 = graph.addNode({\n      x: 30,\n      y: 30,\n      width: 100,\n      height: 40,\n      label: 'hello',\n    })\n\n    const rect2 = graph.addNode({\n      x: 300,\n      y: 240,\n      width: 100,\n      height: 40,\n      label: 'world',\n    })\n\n    graph.addEdge({\n      source: rect1,\n      target: rect2,\n      vertices: [\n        { x: 100, y: 200 },\n        { x: 300, y: 120 },\n      ],\n      connector: {\n        name: 'normal',\n      },\n    })\n  }\n\n  refContainer = (container: HTMLDivElement) => {\n    this.container = container\n  }\n\n  render() {\n    return (\n      <div className=\"app\">\n        <div className=\"app-content\" ref={this.refContainer} />\n      </div>\n    )\n  }\n}\n","isBinary":false},"src/index.css":{"content":"body {\n  margin: 0;\n  padding: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\ncode {\n  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',\n    monospace;\n}\n","isBinary":false},"src/index.tsx":{"content":"import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './app'\n\nReactDOM.render(<App />, document.getElementById('root'))","isBinary":false},"tsconfig.json":{"content":"{\n  \"compilerOptions\": {\n    \"allowJs\": true,\n    \"strict\": true,\n    \"isolatedModules\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"strictPropertyInitialization\": false,\n    \"noEmit\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"sourceMap\": true,\n    \"declaration\": true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"noImplicitAny\": true,\n    \"noEmitOnError\": true,\n    \"noUnusedLocals\": true,\n    \"strictNullChecks\": true,\n    \"resolveJsonModule\": true,\n    \"experimentalDecorators\": true,\n    \"jsx\": \"react\",\n    \"target\": \"es5\",\n    \"lib\": [\n      \"dom\",\n      \"es2015\"\n    ]\n  },\n  \"include\": [\n    \"src\"\n  ]\n}\n","isBinary":false}}}
    }

    function getStackblitzPrefillConfig () {
      return {"title":"api/registry/connector/normal","description":"","template":"create-react-app","dependencies":{"@antv/x6":"latest","antd":"^4.4.2","react":"^16.13.1","react-dom":"^16.13.1","react-scripts":"^3.4.1"},"files":{"package.json":"{\"dependencies\":{\"@antv/x6\":\"latest\",\"antd\":\"^4.4.2\",\"react\":\"^16.13.1\",\"react-dom\":\"^16.13.1\",\"react-scripts\":\"^3.4.1\"},\"devDependencies\":{\"@types/react\":\"^16.9.19\",\"@types/react-dom\":\"^16.9.5\",\"typescript\":\"^4.0.2\"},\"scripts\":{\"start\":\"react-scripts start\",\"build\":\"react-scripts build\",\"test\":\"react-scripts test\",\"eject\":\"react-scripts eject\"},\"eslintConfig\":{\"extends\":\"react-app\"},\"browserslist\":{\"production\":[\">0.2%\",\"not dead\",\"not op_mini all\"],\"development\":[\"last 1 chrome version\",\"last 1 firefox version\",\"last 1 safari version\"]}}",".gitignore":"# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.\n\n# dependencies\n/node_modules\nreact-app-env.d.ts\n/.pnp\n.pnp.js\n\n# testing\n/coverage\n\n# production\n/build\n\n# misc\n.DS_Store\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n","public/index.html":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n    />\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <title></title>\n  </head>\n\n  <body>\n    <noscript>\n      You need to enable JavaScript to run this app.\n    </noscript>\n    <div id=\"root\"></div>\n  </body>\n</html>\n","src/app.css":".app {\n  font-family: sans-serif;\n  padding: 0;\n  display: flex;\n  padding: 16px 8px;\n}\n\n.app-content {\n  flex: 1;\n  height: 320px;\n  margin-left: 8px;\n  margin-right: 8px;\n  box-shadow: 0 0 10px 1px #e9e9e9;\n}\n","src/app.tsx":"import React from 'react'\nimport { Graph } from '@antv/x6'\nimport './app.css'\n\nexport default class Example extends React.Component {\n  private container: HTMLDivElement\n\n  componentDidMount() {\n    const graph = new Graph({\n      container: this.container,\n      grid: true,\n    })\n\n    const rect1 = graph.addNode({\n      x: 30,\n      y: 30,\n      width: 100,\n      height: 40,\n      label: 'hello',\n    })\n\n    const rect2 = graph.addNode({\n      x: 300,\n      y: 240,\n      width: 100,\n      height: 40,\n      label: 'world',\n    })\n\n    graph.addEdge({\n      source: rect1,\n      target: rect2,\n      vertices: [\n        { x: 100, y: 200 },\n        { x: 300, y: 120 },\n      ],\n      connector: {\n        name: 'normal',\n      },\n    })\n  }\n\n  refContainer = (container: HTMLDivElement) => {\n    this.container = container\n  }\n\n  render() {\n    return (\n      <div className=\"app\">\n        <div className=\"app-content\" ref={this.refContainer} />\n      </div>\n    )\n  }\n}\n","src/index.css":"body {\n  margin: 0;\n  padding: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\ncode {\n  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',\n    monospace;\n}\n","src/index.tsx":"import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './app'\n\nReactDOM.render(<App />, document.getElementById('root'))","tsconfig.json":"{\n  \"compilerOptions\": {\n    \"allowJs\": true,\n    \"strict\": true,\n    \"isolatedModules\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"strictPropertyInitialization\": false,\n    \"noEmit\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"sourceMap\": true,\n    \"declaration\": true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"noImplicitAny\": true,\n    \"noEmitOnError\": true,\n    \"noUnusedLocals\": true,\n    \"strictNullChecks\": true,\n    \"resolveJsonModule\": true,\n    \"experimentalDecorators\": true,\n    \"jsx\": \"react\",\n    \"target\": \"es5\",\n    \"lib\": [\n      \"dom\",\n      \"es2015\"\n    ]\n  },\n  \"include\": [\n    \"src\"\n  ]\n}\n"}}
    }
  

/***/ }),

/***/ 195:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 211:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 234:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/util/array/array.js
var array_namespaceObject = {};
__webpack_require__.r(array_namespaceObject);
__webpack_require__.d(array_namespaceObject, "isArray", function() { return isArray["a" /* default */]; });
__webpack_require__.d(array_namespaceObject, "isArrayLike", function() { return isArrayLike["a" /* default */]; });
__webpack_require__.d(array_namespaceObject, "toArray", function() { return toArray["a" /* default */]; });
__webpack_require__.d(array_namespaceObject, "uniq", function() { return uniq["a" /* default */]; });
__webpack_require__.d(array_namespaceObject, "union", function() { return union["a" /* default */]; });
__webpack_require__.d(array_namespaceObject, "sortedIndex", function() { return sortedIndex["a" /* default */]; });
__webpack_require__.d(array_namespaceObject, "sortedIndexBy", function() { return sortedIndexBy["a" /* default */]; });
__webpack_require__.d(array_namespaceObject, "sortBy", function() { return sortBy["a" /* default */]; });
__webpack_require__.d(array_namespaceObject, "groupBy", function() { return groupBy["a" /* default */]; });
__webpack_require__.d(array_namespaceObject, "difference", function() { return difference["a" /* default */]; });
__webpack_require__.d(array_namespaceObject, "without", function() { return without["a" /* default */]; });
__webpack_require__.d(array_namespaceObject, "slice", function() { return slice; });
__webpack_require__.d(array_namespaceObject, "indexOf", function() { return indexOf; });
__webpack_require__.d(array_namespaceObject, "includes", function() { return includes; });
__webpack_require__.d(array_namespaceObject, "lastIndexOf", function() { return lastIndexOf; });
__webpack_require__.d(array_namespaceObject, "map", function() { return array_map; });
__webpack_require__.d(array_namespaceObject, "some", function() { return some; });
__webpack_require__.d(array_namespaceObject, "every", function() { return every; });
__webpack_require__.d(array_namespaceObject, "filter", function() { return array_filter; });
__webpack_require__.d(array_namespaceObject, "forEach", function() { return forEach; });
__webpack_require__.d(array_namespaceObject, "reduce", function() { return reduce; });
__webpack_require__.d(array_namespaceObject, "reduceRight", function() { return reduceRight; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/util/object/object.js
var object_namespaceObject = {};
__webpack_require__.r(object_namespaceObject);
__webpack_require__.d(object_namespaceObject, "has", function() { return has["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "pick", function() { return pick["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "forIn", function() { return forIn["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "merge", function() { return lodash_es_merge["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "extend", function() { return assignIn["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "isEqual", function() { return isEqual["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "isEmpty", function() { return isEmpty["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "isObject", function() { return isObject["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "isPlainObject", function() { return isPlainObject["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "clone", function() { return lodash_es_clone["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "cloneDeep", function() { return cloneDeep["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "defaults", function() { return lodash_es_defaults["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "defaultsDeep", function() { return defaultsDeep["a" /* default */]; });
__webpack_require__.d(object_namespaceObject, "applyMixins", function() { return applyMixins; });
__webpack_require__.d(object_namespaceObject, "inherit", function() { return inherit_inherit; });
__webpack_require__.d(object_namespaceObject, "createClass", function() { return inherit_createClass; });
__webpack_require__.d(object_namespaceObject, "ensure", function() { return object_ensure; });
__webpack_require__.d(object_namespaceObject, "getValue", function() { return getValue; });
__webpack_require__.d(object_namespaceObject, "getNumber", function() { return getNumber; });
__webpack_require__.d(object_namespaceObject, "getBoolean", function() { return getBoolean; });
__webpack_require__.d(object_namespaceObject, "getByPath", function() { return object_getByPath; });
__webpack_require__.d(object_namespaceObject, "setByPath", function() { return object_setByPath; });
__webpack_require__.d(object_namespaceObject, "unsetByPath", function() { return unsetByPath; });
__webpack_require__.d(object_namespaceObject, "flatten", function() { return flatten; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/util/string/string.js
var string_namespaceObject = {};
__webpack_require__.r(string_namespaceObject);
__webpack_require__.d(string_namespaceObject, "isString", function() { return isString["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "toString", function() { return lodash_es_toString["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "escape", function() { return lodash_es_escape["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "unescape", function() { return lodash_es_unescape["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "startsWith", function() { return startsWith["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "endsWith", function() { return endsWith["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "split", function() { return split["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "repeat", function() { return repeat["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "pad", function() { return lodash_es_pad["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "padEnd", function() { return padEnd["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "padStart", function() { return padStart["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "truncate", function() { return truncate["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "template", function() { return lodash_es_template["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "uniqueId", function() { return uniqueId["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "eval", function() { return exec; });
__webpack_require__.d(string_namespaceObject, "camelCase", function() { return camelCase["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "kebabCase", function() { return lodash_es_kebabCase["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "startCase", function() { return startCase["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "snakeCase", function() { return snakeCase["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "lowerCase", function() { return lowerCase["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "upperCase", function() { return upperCase["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "lowerFirst", function() { return lowerFirst["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "upperFirst", function() { return upperFirst["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "capitalize", function() { return capitalize["a" /* default */]; });
__webpack_require__.d(string_namespaceObject, "pascalCase", function() { return pascalCase; });
__webpack_require__.d(string_namespaceObject, "constantCase", function() { return constantCase; });
__webpack_require__.d(string_namespaceObject, "dotCase", function() { return dotCase; });
__webpack_require__.d(string_namespaceObject, "pathCase", function() { return pathCase; });
__webpack_require__.d(string_namespaceObject, "sentenceCase", function() { return sentenceCase; });
__webpack_require__.d(string_namespaceObject, "titleCase", function() { return titleCase; });
__webpack_require__.d(string_namespaceObject, "hashcode", function() { return hashcode; });
__webpack_require__.d(string_namespaceObject, "uuid", function() { return uuid; });
__webpack_require__.d(string_namespaceObject, "sanitizeHTML", function() { return sanitizeHTML; });
__webpack_require__.d(string_namespaceObject, "getSpellingSuggestion", function() { return suggestion_getSpellingSuggestion; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/util/number/number.js
var number_namespaceObject = {};
__webpack_require__.r(number_namespaceObject);
__webpack_require__.d(number_namespaceObject, "isNumber", function() { return isNumber["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "isFinite", function() { return lodash_es_isFinite["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "isNaN", function() { return lodash_es_isNaN["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "isInteger", function() { return isInteger["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "isSafeInteger", function() { return isSafeInteger["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "clamp", function() { return clamp["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "inRange", function() { return inRange["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "toFinite", function() { return toFinite["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "toNumber", function() { return toNumber["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "toInteger", function() { return toInteger["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "toSafeInteger", function() { return toSafeInteger["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "parseInt", function() { return lodash_es_parseInt["a" /* default */]; });
__webpack_require__.d(number_namespaceObject, "isNumeric", function() { return isNumeric; });
__webpack_require__.d(number_namespaceObject, "mod", function() { return mod; });
__webpack_require__.d(number_namespaceObject, "random", function() { return number_random; });
__webpack_require__.d(number_namespaceObject, "isPercentage", function() { return number_isPercentage; });
__webpack_require__.d(number_namespaceObject, "normalizePercentage", function() { return normalizePercentage; });
__webpack_require__.d(number_namespaceObject, "parseCssNumeric", function() { return parseCssNumeric; });
__webpack_require__.d(number_namespaceObject, "normalizeSides", function() { return normalizeSides; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/util/function/main.js
var main_namespaceObject = {};
__webpack_require__.r(main_namespaceObject);
__webpack_require__.d(main_namespaceObject, "isFunction", function() { return isFunction["a" /* default */]; });
__webpack_require__.d(main_namespaceObject, "once", function() { return once["a" /* default */]; });
__webpack_require__.d(main_namespaceObject, "noop", function() { return noop["a" /* default */]; });
__webpack_require__.d(main_namespaceObject, "debounce", function() { return debounce["a" /* default */]; });
__webpack_require__.d(main_namespaceObject, "defer", function() { return defer["a" /* default */]; });
__webpack_require__.d(main_namespaceObject, "apply", function() { return apply; });
__webpack_require__.d(main_namespaceObject, "call", function() { return function_call; });
__webpack_require__.d(main_namespaceObject, "cacher", function() { return cacher; });
__webpack_require__.d(main_namespaceObject, "isAsyncLike", function() { return isAsyncLike; });
__webpack_require__.d(main_namespaceObject, "isAsync", function() { return isAsync; });
__webpack_require__.d(main_namespaceObject, "toAsyncBoolean", function() { return toAsyncBoolean; });
__webpack_require__.d(main_namespaceObject, "toDeferredBoolean", function() { return toDeferredBoolean; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/util/text/main.js
var text_main_namespaceObject = {};
__webpack_require__.r(text_main_namespaceObject);
__webpack_require__.d(text_main_namespaceObject, "annotate", function() { return annotate; });
__webpack_require__.d(text_main_namespaceObject, "findAnnotationsAtIndex", function() { return findAnnotationsAtIndex; });
__webpack_require__.d(text_main_namespaceObject, "findAnnotationsBetweenIndexes", function() { return findAnnotationsBetweenIndexes; });
__webpack_require__.d(text_main_namespaceObject, "shiftAnnotations", function() { return shiftAnnotations; });
__webpack_require__.d(text_main_namespaceObject, "sanitize", function() { return sanitize_sanitize; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/util/dom/main.js
var dom_main_namespaceObject = {};
__webpack_require__.r(dom_main_namespaceObject);
__webpack_require__.d(dom_main_namespaceObject, "requestAnimationFrame", function() { return af_requestAnimationFrame; });
__webpack_require__.d(dom_main_namespaceObject, "cancelAnimationFrame", function() { return af_cancelAnimationFrame; });
__webpack_require__.d(dom_main_namespaceObject, "getAttribute", function() { return attr_getAttribute; });
__webpack_require__.d(dom_main_namespaceObject, "removeAttribute", function() { return attr_removeAttribute; });
__webpack_require__.d(dom_main_namespaceObject, "setAttribute", function() { return attr_setAttribute; });
__webpack_require__.d(dom_main_namespaceObject, "setAttributes", function() { return attr_setAttributes; });
__webpack_require__.d(dom_main_namespaceObject, "attr", function() { return attr_attr; });
__webpack_require__.d(dom_main_namespaceObject, "qualifyAttr", function() { return qualifyAttr; });
__webpack_require__.d(dom_main_namespaceObject, "styleToObject", function() { return styleToObject; });
__webpack_require__.d(dom_main_namespaceObject, "mergeAttrs", function() { return mergeAttrs; });
__webpack_require__.d(dom_main_namespaceObject, "uniqueId", function() { return elem_uniqueId; });
__webpack_require__.d(dom_main_namespaceObject, "ensureId", function() { return ensureId; });
__webpack_require__.d(dom_main_namespaceObject, "isSVGGraphicsElement", function() { return isSVGGraphicsElement; });
__webpack_require__.d(dom_main_namespaceObject, "ns", function() { return elem_ns; });
__webpack_require__.d(dom_main_namespaceObject, "svgVersion", function() { return svgVersion; });
__webpack_require__.d(dom_main_namespaceObject, "createElement", function() { return elem_createElement; });
__webpack_require__.d(dom_main_namespaceObject, "createElementNS", function() { return createElementNS; });
__webpack_require__.d(dom_main_namespaceObject, "createSvgElement", function() { return createSvgElement; });
__webpack_require__.d(dom_main_namespaceObject, "createSvgDocument", function() { return createSvgDocument; });
__webpack_require__.d(dom_main_namespaceObject, "parseXML", function() { return parseXML; });
__webpack_require__.d(dom_main_namespaceObject, "tagName", function() { return elem_tagName; });
__webpack_require__.d(dom_main_namespaceObject, "index", function() { return elem_index; });
__webpack_require__.d(dom_main_namespaceObject, "find", function() { return elem_find; });
__webpack_require__.d(dom_main_namespaceObject, "findOne", function() { return elem_findOne; });
__webpack_require__.d(dom_main_namespaceObject, "findParentByClass", function() { return elem_findParentByClass; });
__webpack_require__.d(dom_main_namespaceObject, "contains", function() { return elem_contains; });
__webpack_require__.d(dom_main_namespaceObject, "remove", function() { return elem_remove; });
__webpack_require__.d(dom_main_namespaceObject, "empty", function() { return elem_empty; });
__webpack_require__.d(dom_main_namespaceObject, "append", function() { return elem_append; });
__webpack_require__.d(dom_main_namespaceObject, "prepend", function() { return elem_prepend; });
__webpack_require__.d(dom_main_namespaceObject, "before", function() { return elem_before; });
__webpack_require__.d(dom_main_namespaceObject, "appendTo", function() { return elem_appendTo; });
__webpack_require__.d(dom_main_namespaceObject, "isHTMLElement", function() { return isHTMLElement; });
__webpack_require__.d(dom_main_namespaceObject, "getClass", function() { return getClass; });
__webpack_require__.d(dom_main_namespaceObject, "hasClass", function() { return class_hasClass; });
__webpack_require__.d(dom_main_namespaceObject, "addClass", function() { return class_addClass; });
__webpack_require__.d(dom_main_namespaceObject, "removeClass", function() { return class_removeClass; });
__webpack_require__.d(dom_main_namespaceObject, "toggleClass", function() { return class_toggleClass; });
__webpack_require__.d(dom_main_namespaceObject, "setPrefixedStyle", function() { return setPrefixedStyle; });
__webpack_require__.d(dom_main_namespaceObject, "getComputedStyle", function() { return getComputedStyle; });
__webpack_require__.d(dom_main_namespaceObject, "hasScrollbars", function() { return hasScrollbars; });
__webpack_require__.d(dom_main_namespaceObject, "getVendorPrefixedName", function() { return getVendorPrefixedName; });
__webpack_require__.d(dom_main_namespaceObject, "clearSelection", function() { return clearSelection; });
__webpack_require__.d(dom_main_namespaceObject, "text", function() { return text_text; });
__webpack_require__.d(dom_main_namespaceObject, "breakText", function() { return breakText; });
__webpack_require__.d(dom_main_namespaceObject, "KAPPA", function() { return KAPPA; });
__webpack_require__.d(dom_main_namespaceObject, "sample", function() { return path_sample; });
__webpack_require__.d(dom_main_namespaceObject, "lineToPathData", function() { return lineToPathData; });
__webpack_require__.d(dom_main_namespaceObject, "polygonToPathData", function() { return polygonToPathData; });
__webpack_require__.d(dom_main_namespaceObject, "polylineToPathData", function() { return polylineToPathData; });
__webpack_require__.d(dom_main_namespaceObject, "getPointsFromSvgElement", function() { return getPointsFromSvgElement; });
__webpack_require__.d(dom_main_namespaceObject, "circleToPathData", function() { return circleToPathData; });
__webpack_require__.d(dom_main_namespaceObject, "ellipseToPathData", function() { return ellipseToPathData; });
__webpack_require__.d(dom_main_namespaceObject, "rectangleToPathData", function() { return rectangleToPathData; });
__webpack_require__.d(dom_main_namespaceObject, "rectToPathData", function() { return rectToPathData; });
__webpack_require__.d(dom_main_namespaceObject, "toPath", function() { return toPath; });
__webpack_require__.d(dom_main_namespaceObject, "toPathData", function() { return toPathData; });
__webpack_require__.d(dom_main_namespaceObject, "createSlicePathData", function() { return createSlicePathData; });
__webpack_require__.d(dom_main_namespaceObject, "bbox", function() { return geom_bbox; });
__webpack_require__.d(dom_main_namespaceObject, "getBBox", function() { return geom_getBBox; });
__webpack_require__.d(dom_main_namespaceObject, "getTransformToElement", function() { return geom_getTransformToElement; });
__webpack_require__.d(dom_main_namespaceObject, "toLocalPoint", function() { return geom_toLocalPoint; });
__webpack_require__.d(dom_main_namespaceObject, "toGeometryShape", function() { return geom_toGeometryShape; });
__webpack_require__.d(dom_main_namespaceObject, "getIntersection", function() { return getIntersection; });
__webpack_require__.d(dom_main_namespaceObject, "animateAlongPath", function() { return geom_animateAlongPath; });
__webpack_require__.d(dom_main_namespaceObject, "getBoundingOffsetRect", function() { return getBoundingOffsetRect; });
__webpack_require__.d(dom_main_namespaceObject, "createSVGPoint", function() { return createSVGPoint; });
__webpack_require__.d(dom_main_namespaceObject, "createSVGMatrix", function() { return createSVGMatrix; });
__webpack_require__.d(dom_main_namespaceObject, "createSVGTransform", function() { return createSVGTransform; });
__webpack_require__.d(dom_main_namespaceObject, "transformStringToMatrix", function() { return transformStringToMatrix; });
__webpack_require__.d(dom_main_namespaceObject, "matrixToTransformString", function() { return matrixToTransformString; });
__webpack_require__.d(dom_main_namespaceObject, "parseTransformString", function() { return parseTransformString; });
__webpack_require__.d(dom_main_namespaceObject, "decomposeMatrix", function() { return decomposeMatrix; });
__webpack_require__.d(dom_main_namespaceObject, "matrixToScale", function() { return matrixToScale; });
__webpack_require__.d(dom_main_namespaceObject, "matrixToRotation", function() { return matrixToRotation; });
__webpack_require__.d(dom_main_namespaceObject, "matrixToTranslation", function() { return matrixToTranslation; });
__webpack_require__.d(dom_main_namespaceObject, "transformPoint", function() { return transformPoint; });
__webpack_require__.d(dom_main_namespaceObject, "transformLine", function() { return transformLine; });
__webpack_require__.d(dom_main_namespaceObject, "transformPolyline", function() { return transformPolyline; });
__webpack_require__.d(dom_main_namespaceObject, "transformRectangle", function() { return transformRectangle; });
__webpack_require__.d(dom_main_namespaceObject, "transform", function() { return transform_transform; });
__webpack_require__.d(dom_main_namespaceObject, "translate", function() { return transform_translate; });
__webpack_require__.d(dom_main_namespaceObject, "rotate", function() { return transform_rotate; });
__webpack_require__.d(dom_main_namespaceObject, "scale", function() { return transform_scale; });
__webpack_require__.d(dom_main_namespaceObject, "translateAndAutoOrient", function() { return transform_translateAndAutoOrient; });
__webpack_require__.d(dom_main_namespaceObject, "isVector", function() { return vector_isVector; });
__webpack_require__.d(dom_main_namespaceObject, "createVector", function() { return vector_createVector; });
__webpack_require__.d(dom_main_namespaceObject, "createVectors", function() { return vector_createVectors; });
__webpack_require__.d(dom_main_namespaceObject, "toHTMLElement", function() { return vector_toHTMLElement; });
__webpack_require__.d(dom_main_namespaceObject, "toHTMLElements", function() { return vector_toHTMLElements; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/marker/main.js
var marker_main_namespaceObject = {};
__webpack_require__.r(marker_main_namespaceObject);
__webpack_require__.d(marker_main_namespaceObject, "block", function() { return block; });
__webpack_require__.d(marker_main_namespaceObject, "classic", function() { return classic; });
__webpack_require__.d(marker_main_namespaceObject, "diamond", function() { return diamond_diamond; });
__webpack_require__.d(marker_main_namespaceObject, "path", function() { return path_path; });
__webpack_require__.d(marker_main_namespaceObject, "cross", function() { return cross_cross; });
__webpack_require__.d(marker_main_namespaceObject, "async", function() { return async_async; });
__webpack_require__.d(marker_main_namespaceObject, "circle", function() { return circle; });
__webpack_require__.d(marker_main_namespaceObject, "circlePlus", function() { return circle_circlePlus; });
__webpack_require__.d(marker_main_namespaceObject, "ellipse", function() { return ellipse_ellipse; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/attr/main.js
var attr_main_namespaceObject = {};
__webpack_require__.r(attr_main_namespaceObject);
__webpack_require__.d(attr_main_namespaceObject, "ref", function() { return ref_ref; });
__webpack_require__.d(attr_main_namespaceObject, "refX", function() { return refX; });
__webpack_require__.d(attr_main_namespaceObject, "refY", function() { return refY; });
__webpack_require__.d(attr_main_namespaceObject, "refDx", function() { return refDx; });
__webpack_require__.d(attr_main_namespaceObject, "refDy", function() { return refDy; });
__webpack_require__.d(attr_main_namespaceObject, "refWidth", function() { return refWidth; });
__webpack_require__.d(attr_main_namespaceObject, "refHeight", function() { return refHeight; });
__webpack_require__.d(attr_main_namespaceObject, "refRx", function() { return refRx; });
__webpack_require__.d(attr_main_namespaceObject, "refRy", function() { return refRy; });
__webpack_require__.d(attr_main_namespaceObject, "refRInscribed", function() { return refRInscribed; });
__webpack_require__.d(attr_main_namespaceObject, "refRCircumscribed", function() { return refRCircumscribed; });
__webpack_require__.d(attr_main_namespaceObject, "refCx", function() { return refCx; });
__webpack_require__.d(attr_main_namespaceObject, "refCy", function() { return refCy; });
__webpack_require__.d(attr_main_namespaceObject, "refDResetOffset", function() { return refDResetOffset; });
__webpack_require__.d(attr_main_namespaceObject, "refDKeepOffset", function() { return refDKeepOffset; });
__webpack_require__.d(attr_main_namespaceObject, "refPointsResetOffset", function() { return refPointsResetOffset; });
__webpack_require__.d(attr_main_namespaceObject, "refPointsKeepOffset", function() { return refPointsKeepOffset; });
__webpack_require__.d(attr_main_namespaceObject, "refR", function() { return refR; });
__webpack_require__.d(attr_main_namespaceObject, "refD", function() { return refD; });
__webpack_require__.d(attr_main_namespaceObject, "refPoints", function() { return refPoints; });
__webpack_require__.d(attr_main_namespaceObject, "refX2", function() { return refX2; });
__webpack_require__.d(attr_main_namespaceObject, "refY2", function() { return refY2; });
__webpack_require__.d(attr_main_namespaceObject, "refWidth2", function() { return refWidth2; });
__webpack_require__.d(attr_main_namespaceObject, "refHeight2", function() { return refHeight2; });
__webpack_require__.d(attr_main_namespaceObject, "fill", function() { return fill; });
__webpack_require__.d(attr_main_namespaceObject, "stroke", function() { return stroke; });
__webpack_require__.d(attr_main_namespaceObject, "text", function() { return attr_text_text; });
__webpack_require__.d(attr_main_namespaceObject, "textWrap", function() { return text_textWrap; });
__webpack_require__.d(attr_main_namespaceObject, "lineHeight", function() { return text_lineHeight; });
__webpack_require__.d(attr_main_namespaceObject, "textVerticalAnchor", function() { return textVerticalAnchor; });
__webpack_require__.d(attr_main_namespaceObject, "textPath", function() { return text_textPath; });
__webpack_require__.d(attr_main_namespaceObject, "annotations", function() { return text_annotations; });
__webpack_require__.d(attr_main_namespaceObject, "eol", function() { return text_eol; });
__webpack_require__.d(attr_main_namespaceObject, "displayEmpty", function() { return displayEmpty; });
__webpack_require__.d(attr_main_namespaceObject, "title", function() { return title_title; });
__webpack_require__.d(attr_main_namespaceObject, "xAlign", function() { return xAlign; });
__webpack_require__.d(attr_main_namespaceObject, "yAlign", function() { return yAlign; });
__webpack_require__.d(attr_main_namespaceObject, "resetOffset", function() { return resetOffset; });
__webpack_require__.d(attr_main_namespaceObject, "style", function() { return style_style; });
__webpack_require__.d(attr_main_namespaceObject, "html", function() { return html_html; });
__webpack_require__.d(attr_main_namespaceObject, "filter", function() { return filter_filter; });
__webpack_require__.d(attr_main_namespaceObject, "port", function() { return port_port; });
__webpack_require__.d(attr_main_namespaceObject, "sourceMarker", function() { return sourceMarker; });
__webpack_require__.d(attr_main_namespaceObject, "targetMarker", function() { return targetMarker; });
__webpack_require__.d(attr_main_namespaceObject, "vertexMarker", function() { return vertexMarker; });
__webpack_require__.d(attr_main_namespaceObject, "connection", function() { return connection; });
__webpack_require__.d(attr_main_namespaceObject, "atConnectionLengthKeepGradient", function() { return atConnectionLengthKeepGradient; });
__webpack_require__.d(attr_main_namespaceObject, "atConnectionLengthIgnoreGradient", function() { return atConnectionLengthIgnoreGradient; });
__webpack_require__.d(attr_main_namespaceObject, "atConnectionRatioKeepGradient", function() { return atConnectionRatioKeepGradient; });
__webpack_require__.d(attr_main_namespaceObject, "atConnectionRatioIgnoreGradient", function() { return atConnectionRatioIgnoreGradient; });
__webpack_require__.d(attr_main_namespaceObject, "atConnectionLength", function() { return atConnectionLength; });
__webpack_require__.d(attr_main_namespaceObject, "atConnectionRatio", function() { return atConnectionRatio; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/grid/main.js
var grid_main_namespaceObject = {};
__webpack_require__.r(grid_main_namespaceObject);
__webpack_require__.d(grid_main_namespaceObject, "dot", function() { return dot; });
__webpack_require__.d(grid_main_namespaceObject, "fixedDot", function() { return fixedDot; });
__webpack_require__.d(grid_main_namespaceObject, "mesh", function() { return mesh; });
__webpack_require__.d(grid_main_namespaceObject, "doubleMesh", function() { return doubleMesh; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/filter/main.js
var filter_main_namespaceObject = {};
__webpack_require__.r(filter_main_namespaceObject);
__webpack_require__.d(filter_main_namespaceObject, "outline", function() { return outline; });
__webpack_require__.d(filter_main_namespaceObject, "highlight", function() { return highlight_highlight; });
__webpack_require__.d(filter_main_namespaceObject, "blur", function() { return blur_blur; });
__webpack_require__.d(filter_main_namespaceObject, "dropShadow", function() { return dropShadow; });
__webpack_require__.d(filter_main_namespaceObject, "grayScale", function() { return grayScale; });
__webpack_require__.d(filter_main_namespaceObject, "sepia", function() { return sepia; });
__webpack_require__.d(filter_main_namespaceObject, "saturate", function() { return saturate; });
__webpack_require__.d(filter_main_namespaceObject, "hueRotate", function() { return hueRotate; });
__webpack_require__.d(filter_main_namespaceObject, "invert", function() { return invert; });
__webpack_require__.d(filter_main_namespaceObject, "brightness", function() { return brightness; });
__webpack_require__.d(filter_main_namespaceObject, "contrast", function() { return contrast; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/background/main.js
var background_main_namespaceObject = {};
__webpack_require__.r(background_main_namespaceObject);
__webpack_require__.d(background_main_namespaceObject, "flipX", function() { return flipX; });
__webpack_require__.d(background_main_namespaceObject, "flipY", function() { return flipY; });
__webpack_require__.d(background_main_namespaceObject, "flipXY", function() { return flipXY; });
__webpack_require__.d(background_main_namespaceObject, "watermark", function() { return watermark_watermark; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/highlighter/main.js
var highlighter_main_namespaceObject = {};
__webpack_require__.r(highlighter_main_namespaceObject);
__webpack_require__.d(highlighter_main_namespaceObject, "className", function() { return class_className; });
__webpack_require__.d(highlighter_main_namespaceObject, "opacity", function() { return opacity_opacity; });
__webpack_require__.d(highlighter_main_namespaceObject, "stroke", function() { return stroke_stroke; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/port-layout/main.js
var port_layout_main_namespaceObject = {};
__webpack_require__.r(port_layout_main_namespaceObject);
__webpack_require__.d(port_layout_main_namespaceObject, "absolute", function() { return absolute_absolute; });
__webpack_require__.d(port_layout_main_namespaceObject, "ellipse", function() { return port_layout_ellipse_ellipse; });
__webpack_require__.d(port_layout_main_namespaceObject, "ellipseSpread", function() { return ellipseSpread; });
__webpack_require__.d(port_layout_main_namespaceObject, "line", function() { return line_line; });
__webpack_require__.d(port_layout_main_namespaceObject, "left", function() { return line_left; });
__webpack_require__.d(port_layout_main_namespaceObject, "right", function() { return line_right; });
__webpack_require__.d(port_layout_main_namespaceObject, "top", function() { return line_top; });
__webpack_require__.d(port_layout_main_namespaceObject, "bottom", function() { return line_bottom; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/port-label-layout/main.js
var port_label_layout_main_namespaceObject = {};
__webpack_require__.r(port_label_layout_main_namespaceObject);
__webpack_require__.d(port_label_layout_main_namespaceObject, "manual", function() { return side_manual; });
__webpack_require__.d(port_label_layout_main_namespaceObject, "left", function() { return side_left; });
__webpack_require__.d(port_label_layout_main_namespaceObject, "right", function() { return side_right; });
__webpack_require__.d(port_label_layout_main_namespaceObject, "top", function() { return side_top; });
__webpack_require__.d(port_label_layout_main_namespaceObject, "bottom", function() { return side_bottom; });
__webpack_require__.d(port_label_layout_main_namespaceObject, "outside", function() { return outside; });
__webpack_require__.d(port_label_layout_main_namespaceObject, "outsideOriented", function() { return outsideOriented; });
__webpack_require__.d(port_label_layout_main_namespaceObject, "inside", function() { return inside; });
__webpack_require__.d(port_label_layout_main_namespaceObject, "insideOriented", function() { return insideOriented; });
__webpack_require__.d(port_label_layout_main_namespaceObject, "radial", function() { return radial; });
__webpack_require__.d(port_label_layout_main_namespaceObject, "radialOriented", function() { return radialOriented; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/connection-strategy/main.js
var connection_strategy_main_namespaceObject = {};
__webpack_require__.r(connection_strategy_main_namespaceObject);
__webpack_require__.d(connection_strategy_main_namespaceObject, "noop", function() { return noop_noop; });
__webpack_require__.d(connection_strategy_main_namespaceObject, "pinRelative", function() { return pinRelative; });
__webpack_require__.d(connection_strategy_main_namespaceObject, "pinAbsolute", function() { return pinAbsolute; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/node-anchor/main.js
var node_anchor_main_namespaceObject = {};
__webpack_require__.r(node_anchor_main_namespaceObject);
__webpack_require__.d(node_anchor_main_namespaceObject, "center", function() { return bbox_center; });
__webpack_require__.d(node_anchor_main_namespaceObject, "top", function() { return bbox_top; });
__webpack_require__.d(node_anchor_main_namespaceObject, "bottom", function() { return bbox_bottom; });
__webpack_require__.d(node_anchor_main_namespaceObject, "left", function() { return bbox_left; });
__webpack_require__.d(node_anchor_main_namespaceObject, "right", function() { return bbox_right; });
__webpack_require__.d(node_anchor_main_namespaceObject, "topLeft", function() { return bbox_topLeft; });
__webpack_require__.d(node_anchor_main_namespaceObject, "topRight", function() { return topRight; });
__webpack_require__.d(node_anchor_main_namespaceObject, "bottomLeft", function() { return bottomLeft; });
__webpack_require__.d(node_anchor_main_namespaceObject, "bottomRight", function() { return bbox_bottomRight; });
__webpack_require__.d(node_anchor_main_namespaceObject, "orth", function() { return orth_orth; });
__webpack_require__.d(node_anchor_main_namespaceObject, "nodeCenter", function() { return node_center_nodeCenter; });
__webpack_require__.d(node_anchor_main_namespaceObject, "midSide", function() { return midSide; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/edge-anchor/main.js
var edge_anchor_main_namespaceObject = {};
__webpack_require__.r(edge_anchor_main_namespaceObject);
__webpack_require__.d(edge_anchor_main_namespaceObject, "ratio", function() { return ratio_ratio; });
__webpack_require__.d(edge_anchor_main_namespaceObject, "length", function() { return length_length; });
__webpack_require__.d(edge_anchor_main_namespaceObject, "orth", function() { return edge_anchor_orth_orth; });
__webpack_require__.d(edge_anchor_main_namespaceObject, "closest", function() { return closest_closest; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/connection-point/main.js
var connection_point_main_namespaceObject = {};
__webpack_require__.r(connection_point_main_namespaceObject);
__webpack_require__.d(connection_point_main_namespaceObject, "bbox", function() { return bbox_bbox; });
__webpack_require__.d(connection_point_main_namespaceObject, "rect", function() { return rect_rect; });
__webpack_require__.d(connection_point_main_namespaceObject, "boundary", function() { return boundary_boundary; });
__webpack_require__.d(connection_point_main_namespaceObject, "anchor", function() { return anchor_anchor; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/router/main.js
var router_main_namespaceObject = {};
__webpack_require__.r(router_main_namespaceObject);
__webpack_require__.d(router_main_namespaceObject, "normal", function() { return normal_normal; });
__webpack_require__.d(router_main_namespaceObject, "oneSide", function() { return oneside_oneSide; });
__webpack_require__.d(router_main_namespaceObject, "orth", function() { return router_orth_orth; });
__webpack_require__.d(router_main_namespaceObject, "metro", function() { return metro_metro; });
__webpack_require__.d(router_main_namespaceObject, "manhattan", function() { return manhattan_manhattan; });
__webpack_require__.d(router_main_namespaceObject, "er", function() { return er_er; });

// NAMESPACE OBJECT: /home/runner/work/X6/X6/packages/x6/es/registry/connector/main.js
var connector_main_namespaceObject = {};
__webpack_require__.r(connector_main_namespaceObject);
__webpack_require__.d(connector_main_namespaceObject, "normal", function() { return connector_normal_normal; });
__webpack_require__.d(connector_main_namespaceObject, "rounded", function() { return rounded_rounded; });
__webpack_require__.d(connector_main_namespaceObject, "smooth", function() { return smooth_smooth; });
__webpack_require__.d(connector_main_namespaceObject, "jumpover", function() { return jumpover_jumpover; });

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/react/index.js
var react = __webpack_require__(0);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/react-dom/index.js
var react_dom = __webpack_require__(34);
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__(1);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__(2);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js + 1 modules
var inherits = __webpack_require__(3);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js + 1 modules
var createSuper = __webpack_require__(4);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/jquery/dist/jquery.js
var jquery = __webpack_require__(21);
var jquery_default = /*#__PURE__*/__webpack_require__.n(jquery);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/jquery-mousewheel/jquery.mousewheel.js
var jquery_mousewheel = __webpack_require__(189);

// EXTERNAL MODULE: /home/runner/work/X6/X6/packages/x6/es/util/platform/index.js
var platform = __webpack_require__(111);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/polyfill/index.js




if (platform["a" /* Platform */].SUPPORT_PASSIVE) {
  jquery_default.a.event.special.touchstart = {
    setup: function setup(data, ns, handle) {
      this.addEventListener('touchstart', handle, {
        passive: true
      });
    }
  };
  var polyfill_hook = jquery_default.a.event.special.mousewheel;

  if (polyfill_hook) {
    var polyfill_setup = polyfill_hook.setup;

    polyfill_hook.setup = function () {
      var _this = this;

      var addEventListener = this.addEventListener;

      this.addEventListener = function (name, handler) {
        addEventListener.call(_this, name, handler, {
          passive: true
        });
      };

      polyfill_setup.call(this);
      this.addEventListener = addEventListener;
    };
  }
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/lang/lang.js

var isWindow = function isWindow(value) {
  return value && value === value.window;
};
var isNumeric = function isNumeric(value) {
  return !Array.isArray(value) && value - parseFloat(value) + 1 >= 0;
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/lang/index.js


// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isArray.js
var isArray = __webpack_require__(14);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isArrayLike.js
var isArrayLike = __webpack_require__(24);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/toArray.js + 2 modules
var toArray = __webpack_require__(278);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/uniq.js
var uniq = __webpack_require__(236);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/union.js
var union = __webpack_require__(237);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/sortedIndex.js + 1 modules
var sortedIndex = __webpack_require__(284);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/sortedIndexBy.js
var sortedIndexBy = __webpack_require__(238);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/sortBy.js + 5 modules
var sortBy = __webpack_require__(274);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/groupBy.js + 3 modules
var groupBy = __webpack_require__(276);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/difference.js
var difference = __webpack_require__(239);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/without.js
var without = __webpack_require__(240);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/array/array.js

var proto = Array.prototype;
function slice(arr, start, end) {
  return arr ? proto.slice.call(arr, start, end) : [];
}
function indexOf(arr, item) {
  return arr ? proto.indexOf.call(arr, item) : -1;
}
function includes(arr, item) {
  return arr ? indexOf(arr, item) >= 0 : false;
}
function lastIndexOf(arr, item) {
  return arr ? proto.lastIndexOf.call(arr, item) : -1;
}
function array_map(arr, iterator, thisArg) {
  return arr ? proto.map.call(arr, iterator, thisArg) : [];
}
function some(arr, iterator, thisArg) {
  return arr ? proto.some.call(arr, iterator, thisArg) : false;
}
function every(arr, iterator, thisArg) {
  return arr ? proto.every.call(arr, iterator, thisArg) : false;
}
function array_filter(arr, iterator, thisArg) {
  return arr ? proto.filter.call(arr, iterator, thisArg) : [];
}
function forEach(arr, iterator, thisArg) {
  arr && proto.forEach.call(arr, iterator, thisArg);
}
function reduce(arr, iterator, initialValue) {
  return arr ? proto.reduce.call(arr, iterator, initialValue) : initialValue;
}
function reduceRight(arr, iterator, initialValue) {
  return arr ? proto.reduceRight.call(arr, iterator, initialValue) : initialValue;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/array/index.js


// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/has.js + 1 modules
var has = __webpack_require__(285);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/pick.js + 5 modules
var pick = __webpack_require__(275);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/forIn.js + 1 modules
var forIn = __webpack_require__(286);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/merge.js
var lodash_es_merge = __webpack_require__(241);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/assignIn.js
var assignIn = __webpack_require__(242);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isEqual.js
var isEqual = __webpack_require__(243);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isEmpty.js
var isEmpty = __webpack_require__(244);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isObject.js
var isObject = __webpack_require__(13);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isPlainObject.js
var isPlainObject = __webpack_require__(126);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/clone.js
var lodash_es_clone = __webpack_require__(245);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/cloneDeep.js
var cloneDeep = __webpack_require__(246);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/defaults.js
var lodash_es_defaults = __webpack_require__(247);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/defaultsDeep.js + 2 modules
var defaultsDeep = __webpack_require__(279);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/object/mixins.js
/**
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 */
function applyMixins(derivedCtor) {
  for (var _len = arguments.length, baseCtors = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    baseCtors[_key - 1] = arguments[_key];
  }

  baseCtors.forEach(function (baseCtor) {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
      if (name !== 'constructor') {
        Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
      }
    });
  });
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/object/inherit.js


var extendStatics = Object.setPrototypeOf || {
  __proto__: []
} instanceof Array && function (d, b) {
  d.__proto__ = b;
} || function (d, b) {
  for (var p in b) {
    if (b.hasOwnProperty(p)) {
      d[p] = b[p];
    }
  }
};
/**
 * @see https://github.com/microsoft/TypeScript/blob/5c85febb0ce9d6088cbe9b09cb42f73f9ee8ea05/src/compiler/transformers/es2015.ts#L4309
 */


function inherit_inherit(cls, base) {
  extendStatics(cls, base);

  function tmp() {
    this.constructor = cls;
  }

  cls.prototype = base === null ? Object.create(base) : (tmp.prototype = base.prototype, new tmp());
}

var inherit_A = function A() {
  Object(classCallCheck["a" /* default */])(this, A);
};

var isNativeClass = /^\s*class\s+/.test("".concat(inherit_A)) || /^\s*class\s*\{/.test("".concat( /*#__PURE__*/function () {
  function _class() {
    Object(classCallCheck["a" /* default */])(this, _class);
  }

  return _class;
}()));
/**
 * Extends class with specified class name.
 */

function inherit_createClass(className, base) {
  // tslint:disable-next-line
  var cls = new Function('base', "\n      return ".concat(isNativeClass, "\n        ? class ").concat(className, " extends base { }\n        : function ").concat(className, "() { return base.apply(this, arguments) }\n    "))(base);

  if (!isNativeClass) {
    inherit_inherit(cls, base);
  }

  return cls;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/object/object.js



function object_ensure(value, defaultValue) {
  return value != null ? value : defaultValue;
}
function getValue(obj, key, defaultValue) {
  var value = obj != null ? obj[key] : null;
  return defaultValue !== undefined ? object_ensure(value, defaultValue) : value;
}
function getNumber(obj, key, defaultValue) {
  var value = obj != null ? obj[key] : null;

  if (value == null) {
    return defaultValue;
  }

  value = +value;

  if (isNaN(value) || !isFinite(value)) {
    return defaultValue;
  }

  return value;
}
function getBoolean(obj, key, defaultValue) {
  var value = obj != null ? obj[key] : null;

  if (value == null) {
    return defaultValue;
  }

  return !!value;
}
function object_getByPath(obj, path) {
  var delimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';
  var ret;
  var keys = Array.isArray(path) ? path : path.split(delimiter);

  if (keys.length) {
    ret = obj;

    while (keys.length) {
      var key = keys.shift();

      if (Object(ret) === ret && key && key in ret) {
        ret = ret[key];
      } else {
        return undefined;
      }
    }
  }

  return ret;
}
function object_setByPath(obj, path, value) {
  var delimiter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';
  var keys = Array.isArray(path) ? path : path.split(delimiter);
  var lastKey = keys.pop();

  if (lastKey) {
    var diver = obj;
    keys.forEach(function (key) {
      if (diver[key] == null) {
        diver[key] = {};
      }

      diver = diver[key];
    });
    diver[lastKey] = value;
  }

  return obj;
}
function unsetByPath(obj, path) {
  var delimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';
  var keys = Array.isArray(path) ? path.slice() : path.split(delimiter);
  var propertyToRemove = keys.pop();

  if (propertyToRemove) {
    if (keys.length > 0) {
      var parent = object_getByPath(obj, keys);

      if (parent) {
        delete parent[propertyToRemove];
      }
    } else {
      delete obj[propertyToRemove];
    }
  }

  return obj;
}
function flatten(obj) {
  var delim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';
  var stop = arguments.length > 2 ? arguments[2] : undefined;
  var ret = {};
  Object.keys(obj).forEach(function (key) {
    var val = obj[key];
    var deep = typeof val === 'object' || Array.isArray(val);

    if (deep && stop && stop(val)) {
      deep = false;
    }

    if (deep) {
      var flatObject = flatten(val, delim, stop);
      Object.keys(flatObject).forEach(function (flatKey) {
        ret[key + delim + flatKey] = flatObject[flatKey];
      });
    } else {
      ret[key] = val;
    }
  });

  for (var key in obj) {
    if (!obj.hasOwnProperty(key)) continue;
  }

  return ret;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/object/index.js


// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isString.js
var isString = __webpack_require__(157);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/toString.js
var lodash_es_toString = __webpack_require__(10);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/escape.js + 1 modules
var lodash_es_escape = __webpack_require__(182);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/unescape.js + 1 modules
var lodash_es_unescape = __webpack_require__(287);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/startsWith.js
var startsWith = __webpack_require__(248);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/endsWith.js
var endsWith = __webpack_require__(249);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/split.js
var split = __webpack_require__(250);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/repeat.js
var repeat = __webpack_require__(251);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/pad.js
var lodash_es_pad = __webpack_require__(252);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/padEnd.js
var padEnd = __webpack_require__(253);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/padStart.js
var padStart = __webpack_require__(254);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/truncate.js
var truncate = __webpack_require__(255);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/template.js + 9 modules
var lodash_es_template = __webpack_require__(272);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/uniqueId.js
var uniqueId = __webpack_require__(256);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/string/eval.js
function exec(exp) {
  var result = null;

  try {
    result = window.eval(exp);
  } catch (e) {}

  return result;
}
// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/camelCase.js
var camelCase = __webpack_require__(257);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/kebabCase.js
var lodash_es_kebabCase = __webpack_require__(258);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/startCase.js
var startCase = __webpack_require__(259);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/snakeCase.js
var snakeCase = __webpack_require__(260);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/lowerCase.js
var lowerCase = __webpack_require__(261);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/upperCase.js
var upperCase = __webpack_require__(262);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/lowerFirst.js
var lowerFirst = __webpack_require__(263);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/upperFirst.js
var upperFirst = __webpack_require__(127);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/capitalize.js
var capitalize = __webpack_require__(160);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/string/format.js

 // @see: https://medium.com/@robertsavian/javascript-case-converters-using-lodash-4f2f964091cc

function pascalCase(str) {
  return Object(startCase["a" /* default */])(Object(camelCase["a" /* default */])(str)).replace(/ /g, '');
}
function constantCase(str) {
  return Object(upperCase["a" /* default */])(str).replace(/ /g, '_');
}
function dotCase(str) {
  return Object(lowerCase["a" /* default */])(str).replace(/ /g, '.');
}
function pathCase(str) {
  return Object(lowerCase["a" /* default */])(str).replace(/ /g, '/');
}
function sentenceCase(str) {
  return Object(upperFirst["a" /* default */])(Object(lowerCase["a" /* default */])(str));
}
function titleCase(str) {
  return Object(startCase["a" /* default */])(Object(camelCase["a" /* default */])(str));
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/string/hashcode.js
/**
 * Return a simple hash code from a string.
 * Source from: https://github.com/sindresorhus/fnv1a/blob/master/index.js#L25
 */
function hashcode(str) {
  var hash = 2166136261;
  var isUnicoded = false;
  var string = str;

  for (var i = 0, ii = string.length; i < ii; i += 1) {
    var characterCode = string.charCodeAt(i); // Non-ASCII characters trigger the Unicode escape logic

    if (characterCode > 0x7f && !isUnicoded) {
      string = unescape(encodeURIComponent(string));
      characterCode = string.charCodeAt(i);
      isUnicoded = true;
    }

    hash ^= characterCode;
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
  }

  return hash >>> 0;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/string/uuid.js
function uuid() {
  // credit: http://stackoverflow.com/posts/2117523/revisions
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0;
    var v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/string/html.js

function sanitizeHTML(html) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // If documentContext (second parameter) is not specified or given as
  // `null` or `undefined`, a new document is used. Inline events will not
  // execute when the HTML is parsed; this includes, for example, sending
  // GET requests for images.
  // If keepScripts (last parameter) is `false`, scripts are not executed.
  var nodes = jquery_default.a.parseHTML(html, null, false);
  nodes.forEach(function (node) {
    var elem = node;

    if (elem) {
      var attrs = elem.attributes;

      if (attrs) {
        for (var i = 0, ii = attrs.length; i < ii; i += 1) {
          var attr = attrs.item(i);

          if (attr) {
            var val = attr.value.toLowerCase();
            var name = attr.name.toLowerCase(); // Removes attribute name starts with "on" (e.g. onload,
            // onerror...).
            // Removes attribute value starts with "javascript:" pseudo
            // protocol (e.g. `href="javascript:alert(1)"`).

            if (name.startsWith('on') || val.startsWith('javascript:') || // ref: https://lgtm.com/rules/1510852698359/
            val.startsWith('data:') || val.startsWith('vbscript:')) {
              elem.removeAttribute(name);
            }
          }
        }
      }
    }
  });

  if (options.raw) {
    return nodes;
  }

  return jquery_default()('<div/>').append(nodes).html();
}
// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js
var createForOfIteratorHelper = __webpack_require__(161);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/string/suggestion.js

// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts

/**
 * Given a name and a list of names that are not equal to the name, return a
 * spelling suggestion if there is one that is close enough. Names less than
 * length 3 only check for case-insensitive equality, not Levenshtein distance.
 *
 * - If there is a candidate that's the same except for case, return that.
 * - If there is a candidate that's within one edit of the name, return that.
 * - Otherwise, return the candidate with the smallest Levenshtein distance,
 *     except for candidates:
 *       * With no name
 *       * Whose length differs from the target name by more than 0.34 of the
 *         length of the name.
 *       * Whose levenshtein distance is more than 0.4 of the length of the
 *         name (0.4 allows 1 substitution/transposition for every 5 characters,
 *         and 1 insertion/deletion at 3 characters)
 */
function suggestion_getSpellingSuggestion(name, candidates, getName) {
  var maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34)); // If the best result isn't better than this, don't bother.

  var bestDistance = Math.floor(name.length * 0.4) + 1;
  var bestCandidate;
  var justCheckExactMatches = false;
  var nameLowerCase = name.toLowerCase();

  var _iterator = Object(createForOfIteratorHelper["a" /* default */])(candidates),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var candidate = _step.value;
      var candidateName = getName(candidate);

      if (candidateName !== undefined && Math.abs(candidateName.length - nameLowerCase.length) <= maximumLengthDifference) {
        var candidateNameLowerCase = candidateName.toLowerCase();

        if (candidateNameLowerCase === nameLowerCase) {
          if (candidateName === name) {
            continue;
          }

          return candidate;
        }

        if (justCheckExactMatches) {
          continue;
        }

        if (candidateName.length < 3) {
          // Don't bother, user would have noticed a
          // 2-character name having an extra character.
          continue;
        } // Only care about a result better than the best so far.


        var distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);

        if (distance === undefined) {
          continue;
        }

        if (distance < 3) {
          justCheckExactMatches = true;
          bestCandidate = candidate;
        } else {
          // Debug.assert(distance < bestDistance)
          bestDistance = distance;
          bestCandidate = candidate;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return bestCandidate;
}

function levenshteinWithMax(s1, s2, max) {
  var previous = new Array(s2.length + 1); // tslint:disable-line

  var current = new Array(s2.length + 1); // tslint:disable-line

  /** Represents any value > max. We don't care about the particular value. */

  var big = max + 1;

  for (var i = 0; i <= s2.length; i += 1) {
    previous[i] = i;
  }

  for (var _i = 1; _i <= s1.length; _i += 1) {
    var c1 = s1.charCodeAt(_i - 1);
    var minJ = _i > max ? _i - max : 1;
    var maxJ = s2.length > max + _i ? max + _i : s2.length;
    current[0] = _i;
    /** Smallest value of the matrix in the ith column. */

    var colMin = _i;

    for (var j = 1; j < minJ; j += 1) {
      current[j] = big;
    }

    for (var _j = minJ; _j <= maxJ; _j += 1) {
      var dist = c1 === s2.charCodeAt(_j - 1) ? previous[_j - 1] : Math.min(
      /*delete*/
      previous[_j] + 1,
      /*insert*/
      current[_j - 1] + 1,
      /*substitute*/
      previous[_j - 1] + 2);
      current[_j] = dist;
      colMin = Math.min(colMin, dist);
    }

    for (var _j2 = maxJ + 1; _j2 <= s2.length; _j2 += 1) {
      current[_j2] = big;
    }

    if (colMin > max) {
      // Give up -- everything in this column is > max
      // and it can't get better in future columns.
      return undefined;
    }

    var temp = previous;
    previous = current;
    current = temp;
  }

  var res = previous[s2.length];
  return res > max ? undefined : res;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/string/string.js







// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/string/index.js


// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isNumber.js
var isNumber = __webpack_require__(162);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isFinite.js
var lodash_es_isFinite = __webpack_require__(264);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isNaN.js
var lodash_es_isNaN = __webpack_require__(265);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isInteger.js
var isInteger = __webpack_require__(163);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isSafeInteger.js
var isSafeInteger = __webpack_require__(266);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/clamp.js
var clamp = __webpack_require__(267);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/inRange.js + 1 modules
var inRange = __webpack_require__(288);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/toFinite.js
var toFinite = __webpack_require__(106);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/toNumber.js
var toNumber = __webpack_require__(47);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/toInteger.js
var toInteger = __webpack_require__(20);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/toSafeInteger.js
var toSafeInteger = __webpack_require__(268);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/parseInt.js
var lodash_es_parseInt = __webpack_require__(269);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/number/number.js


/**
 * Returns the remainder of division of `n` by `m`. You should use this
 * instead of the built-in operation as the built-in operation does not
 * properly handle negative numbers.
 */

function mod(n, m) {
  return (n % m + m) % m;
}
function number_random(lower, upper) {
  if (upper == null) {
    upper = lower == null ? 1 : lower; // tslint:disable-line

    lower = 0; // tslint:disable-line
  } else {
    if (upper < lower) {
      var tmp = lower;
      lower = upper; // tslint:disable-line

      upper = tmp; // tslint:disable-line
    }
  }

  return Math.floor(Math.random() * (upper - lower + 1) + lower);
}
function number_isPercentage(val) {
  return typeof val === 'string' && val.slice(-1) === '%';
}
function normalizePercentage(num, ref) {
  if (num == null) {
    return 0;
  }

  var raw;

  if (typeof num === 'string') {
    raw = parseFloat(num);

    if (number_isPercentage(num)) {
      raw /= 100;

      if (isFinite(raw)) {
        return raw * ref;
      }
    }
  } else {
    raw = num;
  }

  if (!isFinite(raw)) {
    return 0;
  }

  if (raw > 0 && raw < 1) {
    return raw * ref;
  }

  return raw;
}
function parseCssNumeric(val, units) {
  function getUnit(regexp) {
    var matches = new RegExp("(?:\\d+(?:\\.\\d+)*)(".concat(regexp, ")$")).exec(val);

    if (!matches) {
      return null;
    }

    return matches[1];
  }

  var number = parseFloat(val);

  if (Number.isNaN(number)) {
    return null;
  } // determine the unit


  var regexp;

  if (units == null) {
    // accept any unit, as well as no unit
    regexp = '[A-Za-z]*';
  } else if (Array.isArray(units)) {
    if (units.length === 0) {
      return null;
    }

    regexp = units.join('|');
  } else if (typeof units === 'string') {
    regexp = units;
  }

  var unit = getUnit(regexp);

  if (unit === null) {
    return null;
  }

  return {
    unit: unit,
    value: number
  };
}
function normalizeSides(box) {
  if (typeof box === 'object') {
    var left = 0;
    var top = 0;
    var right = 0;
    var bottom = 0;

    if (box.vertical != null && isFinite(box.vertical)) {
      top = bottom = box.vertical;
    }

    if (box.horizontal != null && isFinite(box.horizontal)) {
      right = left = box.horizontal;
    }

    if (box.left != null && isFinite(box.left)) left = box.left;
    if (box.top != null && isFinite(box.top)) top = box.top;
    if (box.right != null && isFinite(box.right)) right = box.right;
    if (box.bottom != null && isFinite(box.bottom)) bottom = box.bottom;
    return {
      top: top,
      right: right,
      bottom: bottom,
      left: left
    };
  }

  var val = 0;

  if (box != null && isFinite(box)) {
    val = box;
  }

  return {
    top: val,
    right: val,
    bottom: val,
    left: val
  };
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/number/index.js


// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/isFunction.js
var isFunction = __webpack_require__(82);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/once.js + 1 modules
var once = __webpack_require__(289);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/noop.js
var noop = __webpack_require__(159);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/debounce.js + 1 modules
var debounce = __webpack_require__(290);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/lodash-es/defer.js + 1 modules
var defer = __webpack_require__(291);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/function/function.js

function apply(fn, ctx, args) {
  if (args) {
    switch (args.length) {
      case 0:
        return fn.call(ctx);

      case 1:
        return fn.call(ctx, args[0]);

      case 2:
        return fn.call(ctx, args[0], args[1]);

      case 3:
        return fn.call(ctx, args[0], args[1], args[2]);

      case 4:
        return fn.call(ctx, args[0], args[1], args[2], args[3]);

      case 5:
        return fn.call(ctx, args[0], args[1], args[2], args[3], args[4]);

      case 6:
        return fn.call(ctx, args[0], args[1], args[2], args[3], args[4], args[5]);

      default:
        return fn.apply(ctx, args);
    }
  }

  return fn.call(ctx);
}
function function_call(fn, ctx) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  return apply(fn, ctx, args);
}

function repush(array, item) {
  for (var i = 0, ii = array.length; i < ii; i += 1) {
    if (array[i] === item) {
      return array.push(array.splice(i, 1)[0]);
    }
  }
}

function cacher(fn, ctx, postProcessor) {
  var keys = [];
  var cache = {};

  var f = function f() {
    var hasCache = false;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var key = args.join("\u2400");

    if (key in cache) {
      hasCache = true;
      repush(keys, key);
    } else {
      if (keys.length >= 1000) {
        delete cache[keys.shift()];
      }

      keys.push(key);
      cache[key] = apply(fn, ctx || null, args);
    }

    return postProcessor ? postProcessor(cache[key], hasCache) : cache[key];
  };

  return f;
}
// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules
var toConsumableArray = __webpack_require__(5);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/function/async.js

function isAsyncLike(obj) {
  return typeof obj === 'object' && obj.then && typeof obj.then === 'function';
}
function isAsync(obj) {
  return obj != null && (obj instanceof Promise || isAsyncLike(obj));
}
function toAsyncBoolean() {
  var results = [];

  for (var _len = arguments.length, inputs = new Array(_len), _key = 0; _key < _len; _key++) {
    inputs[_key] = arguments[_key];
  }

  inputs.forEach(function (arg) {
    if (Array.isArray(arg)) {
      results.push.apply(results, Object(toConsumableArray["a" /* default */])(arg));
    } else {
      results.push(arg);
    }
  });
  var hasAsync = results.some(function (res) {
    return isAsync(res);
  });

  if (hasAsync) {
    var deferres = results.map(function (res) {
      return isAsync(res) ? res : Promise.resolve(res !== false);
    });
    return Promise.all(deferres).then(function (arr) {
      return arr.reduce(function (memo, item) {
        return item !== false && memo;
      }, true);
    });
  }

  return results.every(function (res) {
    return res !== false;
  });
}
function toDeferredBoolean() {
  for (var _len2 = arguments.length, inputs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    inputs[_key2] = arguments[_key2];
  }

  var ret = toAsyncBoolean(inputs);
  return typeof ret === 'boolean' ? Promise.resolve(ret) : ret;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/function/main.js


// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/function/index.js


// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/class.js
var rclass = /[\t\r\n\f]/g;
var rnotwhite = /\S+/g;

var fillSpaces = function fillSpaces(str) {
  return " ".concat(str, " ");
};

function getClass(elem) {
  return elem && elem.getAttribute && elem.getAttribute('class') || '';
}
function class_hasClass(elem, selector) {
  if (elem == null || selector == null) {
    return false;
  }

  var classNames = fillSpaces(getClass(elem));
  var className = fillSpaces(selector);
  return elem.nodeType === 1 ? classNames.replace(rclass, ' ').includes(className) : false;
}
function class_addClass(elem, selector) {
  if (elem == null || selector == null) {
    return;
  }

  if (typeof selector === 'function') {
    return class_addClass(elem, selector(getClass(elem)));
  }

  if (typeof selector === 'string' && elem.nodeType === 1) {
    var classes = selector.match(rnotwhite) || [];
    var oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
    var newValue = classes.reduce(function (memo, cls) {
      if (memo.indexOf(fillSpaces(cls)) < 0) {
        return "".concat(memo).concat(cls, " ");
      }

      return memo;
    }, oldValue);
    newValue = newValue.trim();

    if (oldValue !== newValue) {
      elem.setAttribute('class', newValue);
    }
  }
}
function class_removeClass(elem, selector) {
  if (elem == null) {
    return;
  }

  if (typeof selector === 'function') {
    return class_removeClass(elem, selector(getClass(elem)));
  }

  if ((!selector || typeof selector === 'string') && elem.nodeType === 1) {
    var classes = (selector || '').match(rnotwhite) || [];
    var oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
    var newValue = classes.reduce(function (memo, cls) {
      var className = fillSpaces(cls);

      if (memo.indexOf(className) > -1) {
        return memo.replace(className, ' ');
      }

      return memo;
    }, oldValue);
    newValue = selector ? newValue.trim() : '';

    if (oldValue !== newValue) {
      elem.setAttribute('class', newValue);
    }
  }
}
function class_toggleClass(elem, selector, stateVal) {
  if (elem == null || selector == null) {
    return;
  }

  if (stateVal != null && typeof selector === 'string') {
    stateVal ? class_addClass(elem, selector) : class_removeClass(elem, selector);
    return;
  }

  if (typeof selector === 'function') {
    return class_toggleClass(elem, selector(getClass(elem), stateVal), stateVal);
  }

  if (typeof selector === 'string') {
    var metches = selector.match(rnotwhite) || [];
    metches.forEach(function (cls) {
      class_hasClass(elem, cls) ? class_removeClass(elem, cls) : class_addClass(elem, cls);
    });
  }
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/elem.js

var idCounter = 0;
function elem_uniqueId() {
  idCounter += 1;
  return "v".concat(idCounter);
}
function ensureId(elem) {
  if (elem.id == null || elem.id === '') {
    elem.id = elem_uniqueId();
  }

  return elem.id;
}
/**
 * Returns true if object is an instance of SVGGraphicsElement.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement
 */

function isSVGGraphicsElement(elem) {
  if (elem == null) {
    return false;
  }

  return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement;
}
var elem_ns = {
  svg: 'http://www.w3.org/2000/svg',
  xmlns: 'http://www.w3.org/2000/xmlns/',
  xml: 'http://www.w3.org/XML/1998/namespace',
  xlink: 'http://www.w3.org/1999/xlink',
  xhtml: 'http://www.w3.org/1999/xhtml'
};
var svgVersion = '1.1';
function elem_createElement(tagName) {
  var doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return doc.createElement(tagName);
}
function createElementNS(tagName) {
  var namespaceURI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : elem_ns.xhtml;
  var doc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
  return doc.createElementNS(namespaceURI, tagName);
}
function createSvgElement(tagName) {
  var doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return createElementNS(tagName, elem_ns.svg, doc);
}
function createSvgDocument(content) {
  if (content) {
    var xml = "<svg xmlns=\"".concat(elem_ns.svg, "\" xmlns:xlink=\"").concat(elem_ns.xlink, "\" version=\"").concat(svgVersion, "\">").concat(content, "</svg>");

    var _parseXML = parseXML(xml, {
      async: false
    }),
        documentElement = _parseXML.documentElement;

    return documentElement;
  }

  var svg = document.createElementNS(elem_ns.svg, 'svg');
  svg.setAttributeNS(elem_ns.xmlns, 'xmlns:xlink', elem_ns.xlink);
  svg.setAttribute('version', svgVersion);
  return svg;
}
function parseXML(data) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var xml;

  try {
    var parser = new DOMParser();

    if (options.async != null) {
      var tmp = parser;
      tmp.async = options.async;
    }

    xml = parser.parseFromString(data, 'text/xml');
  } catch (error) {
    xml = undefined;
  }

  if (!xml || xml.getElementsByTagName('parsererror').length) {
    throw new Error("Invalid XML: ".concat(data));
  }

  return xml;
}
function elem_tagName(node) {
  var lowercase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var nodeName = node.nodeName;
  return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();
}
function elem_index(elem) {
  var index = 0;
  var node = elem.previousSibling;

  while (node) {
    if (node.nodeType === 1) {
      index += 1;
    }

    node = node.previousSibling;
  }

  return index;
}
function elem_find(elem, selector) {
  return elem.querySelectorAll(selector);
}
function elem_findOne(elem, selector) {
  return elem.querySelector(selector);
}
function elem_findParentByClass(elem, className, terminator) {
  var ownerSVGElement = elem.ownerSVGElement;
  var node = elem.parentNode;

  while (node && node !== terminator && node !== ownerSVGElement) {
    if (class_hasClass(node, className)) {
      return node;
    }

    node = node.parentNode;
  }

  return null;
}
function elem_contains(parent, child) {
  var bup = child && child.parentNode;
  return parent === bup || !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16);
}
function elem_remove(elem) {
  if (elem.parentNode) {
    elem.parentNode.removeChild(elem);
  }
}
function elem_empty(elem) {
  while (elem.firstChild) {
    elem.removeChild(elem.firstChild);
  }
}
function elem_append(elem, elems) {
  var arr = Array.isArray(elems) ? elems : [elems];
  arr.forEach(function (child) {
    if (child != null) {
      elem.appendChild(child);
    }
  });
}
function elem_prepend(elem, elems) {
  var child = elem.firstChild;
  return child ? elem_before(child, elems) : elem_append(elem, elems);
}
function elem_before(elem, elems) {
  var parent = elem.parentNode;

  if (parent) {
    var arr = Array.isArray(elems) ? elems : [elems];
    arr.forEach(function (child) {
      if (child != null) {
        parent.insertBefore(child, elem);
      }
    });
  }
}
function elem_appendTo(elem, target) {
  if (target != null) {
    target.appendChild(elem);
  }
} // Determines whether a node is an HTML node

function isHTMLElement(elem) {
  try {
    // Using W3 DOM2 (works for FF, Opera and Chrome)
    return elem instanceof HTMLElement;
  } catch (e) {
    // Browsers not supporting W3 DOM2 don't have HTMLElement and
    // an exception is thrown and we end up here. Testing some
    // properties that all elements have (works on IE7)
    return typeof elem === 'object' && elem.nodeType === 1 && typeof elem.style === 'object' && typeof elem.ownerDocument === 'object';
  }
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/attr.js

function attr_getAttribute(elem, name) {
  return elem.getAttribute(name);
}
function attr_removeAttribute(elem, name) {
  var qualified = qualifyAttr(name);

  if (qualified.ns) {
    if (elem.hasAttributeNS(qualified.ns, qualified.local)) {
      elem.removeAttributeNS(qualified.ns, qualified.local);
    }
  } else if (elem.hasAttribute(name)) {
    elem.removeAttribute(name);
  }
}
function attr_setAttribute(elem, name, value) {
  if (value == null) {
    return attr_removeAttribute(elem, name);
  }

  var qualified = qualifyAttr(name);

  if (qualified.ns && typeof value === 'string') {
    elem.setAttributeNS(qualified.ns, name, value);
  } else if (name === 'id') {
    elem.id = "".concat(value);
  } else {
    elem.setAttribute(name, "".concat(value));
  }
}
function attr_setAttributes(elem, attrs) {
  Object.keys(attrs).forEach(function (name) {
    attr_setAttribute(elem, name, attrs[name]);
  });
}
function attr_attr(elem, name, value) {
  if (name == null) {
    var attrs = elem.attributes;
    var ret = {};

    for (var i = 0; i < attrs.length; i += 1) {
      ret[attrs[i].name] = attrs[i].value;
    }

    return ret;
  }

  if (typeof name === 'string' && value === undefined) {
    return elem.getAttribute(name);
  }

  if (typeof name === 'object') {
    attr_setAttributes(elem, name);
  } else {
    attr_setAttribute(elem, name, value);
  }
}
function qualifyAttr(name) {
  if (name.indexOf(':') !== -1) {
    var combinedKey = name.split(':');
    return {
      ns: elem_ns[combinedKey[0]],
      local: combinedKey[1]
    };
  }

  return {
    ns: null,
    local: name
  };
}
function styleToObject(styleString) {
  var ret = {};
  var styles = styleString.split(';');
  styles.forEach(function (item) {
    var section = item.trim();

    if (section) {
      var pair = section.split('=');

      if (pair.length) {
        ret[pair[0].trim()] = pair[1] ? pair[1].trim() : '';
      }
    }
  });
  return ret;
}
function mergeAttrs(target, source) {
  Object.keys(source).forEach(function (attr) {
    if (attr === 'class') {
      target[attr] = target[attr] ? "".concat(target[attr], " ").concat(source[attr]) : source[attr];
    } else if (attr === 'style') {
      var to = typeof target[attr] === 'object';
      var so = typeof source[attr] === 'object';
      var tt;
      var ss;

      if (to && so) {
        tt = target[attr];
        ss = source[attr];
      } else if (to) {
        tt = target[attr];
        ss = styleToObject(source[attr]);
      } else if (so) {
        tt = styleToObject(target[attr]);
        ss = source[attr];
      } else {
        tt = styleToObject(target[attr]);
        ss = styleToObject(source[attr]);
      }

      target[attr] = mergeAttrs(tt, ss);
    } else {
      target[attr] = source[attr];
    }
  });
  return target;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/text/annotate.js


function annotate(t, annotations) {
  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var offset = opt.offset || 0;
  var compacted = [];
  var ret = [];
  var curr;
  var prev;
  var batch = null;

  for (var i = 0; i < t.length; i += 1) {
    curr = ret[i] = t[i];

    for (var j = 0, jj = annotations.length; j < jj; j += 1) {
      var annotation = annotations[j];
      var start = annotation.start + offset;
      var end = annotation.end + offset;

      if (i >= start && i < end) {
        if (typeof curr === 'string') {
          curr = ret[i] = {
            t: t[i],
            attrs: annotation.attrs
          };
        } else {
          curr.attrs = mergeAttrs(mergeAttrs({}, curr.attrs), annotation.attrs);
        }

        if (opt.includeAnnotationIndices) {
          if (curr.annotations == null) {
            curr.annotations = [];
          }

          curr.annotations.push(j);
        }
      }
    }

    prev = ret[i - 1];

    if (!prev) {
      batch = curr;
    } else if (object_namespaceObject.isObject(curr) && object_namespaceObject.isObject(prev)) {
      batch = batch; // Both previous item and the current one are annotations.
      // If the attributes didn't change, merge the text.

      if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {
        batch.t += curr.t;
      } else {
        compacted.push(batch);
        batch = curr;
      }
    } else if (object_namespaceObject.isObject(curr)) {
      // Previous item was a string, current item is an annotation.
      batch = batch;
      compacted.push(batch);
      batch = curr;
    } else if (object_namespaceObject.isObject(prev)) {
      // Previous item was an annotation, current item is a string.
      batch = batch;
      compacted.push(batch);
      batch = curr;
    } else {
      // Both previous and current item are strings.
      batch = (batch || '') + curr;
    }
  }

  if (batch != null) {
    compacted.push(batch);
  }

  return compacted;
}
function findAnnotationsAtIndex(annotations, index) {
  return annotations ? annotations.filter(function (a) {
    return a.start < index && index <= a.end;
  }) : [];
}
function findAnnotationsBetweenIndexes(annotations, start, end) {
  return annotations ? annotations.filter(function (a) {
    return start >= a.start && start < a.end || end > a.start && end <= a.end || a.start >= start && a.end < end;
  }) : [];
}
function shiftAnnotations(annotations, index, offset) {
  if (annotations) {
    annotations.forEach(function (a) {
      if (a.start < index && a.end >= index) {
        a.end += offset;
      } else if (a.start >= index) {
        a.start += offset;
        a.end += offset;
      }
    });
  }

  return annotations;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/text/sanitize.js
/**
 * Replaces all spaces with the Unicode No-break space.
 * ref: http://www.fileformat.info/info/unicode/char/a0/index.htm
 *
 * IE would otherwise collapse all spaces into one. This is useful
 * e.g. in tests when you want to compare the actual DOM text content
 * without having to add the unicode character in the place of all spaces.
 */
function sanitize_sanitize(text) {
  return text.replace(/ /g, "\xA0");
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/text/main.js


// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/text/index.js


// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/json/index.js
/**
 * The namespace for JSON-specific functions.
 */
var JSONExt;

(function (JSONExt) {
  /**
   * A shared frozen empty JSONObject
   */
  JSONExt.emptyObject = Object.freeze({});
  /**
   * A shared frozen empty JSONArray
   */

  JSONExt.emptyArray = Object.freeze([]);
  /**
   * Test whether a JSON value is a primitive.
   *
   * @param value - The JSON value of interest.
   *
   * @returns `true` if the value is a primitive,`false` otherwise.
   */

  function isPrimitive(value) {
    return value === null || value === undefined || typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string';
  }

  JSONExt.isPrimitive = isPrimitive;

  function isArray(value) {
    return Array.isArray(value);
  }

  JSONExt.isArray = isArray;

  function isObject(value) {
    return !isPrimitive(value) && !isArray(value);
  }

  JSONExt.isObject = isObject;
  /**
   * Compare two JSON values for deep equality.
   *
   * @param first - The first JSON value of interest.
   *
   * @param second - The second JSON value of interest.
   *
   * @returns `true` if the values are equivalent, `false` otherwise.
   */

  function deepEqual(first, second) {
    // Check referential and primitive equality first.
    if (first === second) {
      return true;
    } // If one is a primitive, the `===` check ruled out the other.


    if (isPrimitive(first) || isPrimitive(second)) {
      return false;
    } // Test whether they are arrays.


    var a1 = isArray(first);
    var a2 = isArray(second); // Bail if the types are different.

    if (a1 !== a2) {
      return false;
    } // If they are both arrays, compare them.


    if (a1 && a2) {
      return deepArrayEqual(first, second);
    } // At this point, they must both be objects.


    return deepObjectEqual(first, second);
  }

  JSONExt.deepEqual = deepEqual;
  /**
   * Create a deep copy of a JSON value.
   *
   * @param value - The JSON value to copy.
   *
   * @returns A deep copy of the given JSON value.
   */

  function deepCopy(value) {
    // Do nothing for primitive values.
    if (isPrimitive(value)) {
      return value;
    } // Deep copy an array.


    if (isArray(value)) {
      return deepArrayCopy(value);
    } // Deep copy an object.


    return deepObjectCopy(value);
  }

  JSONExt.deepCopy = deepCopy;
  /**
   * Compare two JSON arrays for deep equality.
   */

  function deepArrayEqual(first, second) {
    // Check referential equality first.
    if (first === second) {
      return true;
    } // Test the arrays for equal length.


    if (first.length !== second.length) {
      return false;
    } // Compare the values for equality.


    for (var i = 0, n = first.length; i < n; i += 1) {
      if (!deepEqual(first[i], second[i])) {
        return false;
      }
    } // At this point, the arrays are equal.


    return true;
  }
  /**
   * Compare two JSON objects for deep equality.
   */


  function deepObjectEqual(first, second) {
    // Check referential equality first.
    if (first === second) {
      return true;
    } // Check for the first object's keys in the second object.


    for (var key in first) {
      if (!(key in second)) {
        return false;
      }
    } // Check for the second object's keys in the first object.


    for (var _key in second) {
      if (!(_key in first)) {
        return false;
      }
    } // Compare the values for equality.


    for (var _key2 in first) {
      if (!deepEqual(first[_key2], second[_key2])) {
        return false;
      }
    } // At this point, the objects are equal.


    return true;
  }
  /**
   * Create a deep copy of a JSON array.
   */


  function deepArrayCopy(value) {
    var result = new Array(value.length); // tslint:disable-line

    for (var i = 0, n = value.length; i < n; i += 1) {
      result[i] = deepCopy(value[i]);
    }

    return result;
  }
  /**
   * Create a deep copy of a JSON object.
   */


  function deepObjectCopy(value) {
    var result = {};

    for (var key in value) {
      result[key] = deepCopy(value[key]);
    }

    return result;
  }
})(JSONExt || (JSONExt = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/color/index.js
var Color;

(function (Color) {
  function isValid(color) {
    return color != null && color !== 'none';
  }

  Color.isValid = isValid;

  function random() {
    var letters = '0123456789ABCDEF';
    var color = '#';

    for (var i = 0; i < 6; i += 1) {
      color += letters[Math.floor(Math.random() * 16)];
    }

    return color;
  }

  Color.random = random;

  function invert(hex, bw) {
    if (hex.indexOf('#') === 0) {
      hex = hex.slice(1); // tslint:disable-line
    } // convert 3-digit hex to 6-digits.


    if (hex.length === 3) {
      // tslint:disable-next-line
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }

    if (hex.length !== 6) {
      throw new Error('Invalid hex color.');
    }

    var r = parseInt(hex.slice(0, 2), 16);
    var g = parseInt(hex.slice(2, 4), 16);
    var b = parseInt(hex.slice(4, 6), 16);

    if (bw) {
      // http://stackoverflow.com/a/3943023/112731
      return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? '#000000' : '#FFFFFF';
    } // invert color components


    var rr = (255 - r).toString(16);
    var gg = (255 - g).toString(16);
    var bb = (255 - b).toString(16); // pad each with zeros and return

    return "#".concat(pad(rr)).concat(pad(gg)).concat(pad(bb));
  }

  Color.invert = invert;

  function pad(str) {
    var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    var zeros = '';

    if (str.length < len) {
      for (var i = 0; i < len; i += 1) {
        zeros += '0';
      }
    }

    return (zeros + str).slice(-len);
  }
})(Color || (Color = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/datauri/index.js
var DataUri;

(function (DataUri) {
  function isDataUrl(url) {
    var prefix = 'data:';
    return url.substr(0, prefix.length) === prefix;
  }

  DataUri.isDataUrl = isDataUrl;
  /**
   * Converts an image at `url` to base64-encoded data uri.
   * The mime type of the image is inferred from the `url` file extension.
   */

  function imageToDataUri(url, callback) {
    // No need to convert to data uri if it is already in data uri.
    if (!url || isDataUrl(url)) {
      // Keep the async nature of the function.
      setTimeout(function () {
        return callback(null, url);
      });
      return;
    }

    var onError = function onError() {
      callback(new Error("Failed to load image: ".concat(url)));
    };

    var onLoad = window.FileReader ? // chrome, IE10+
    function (xhr) {
      if (xhr.status === 200) {
        var reader = new FileReader();

        reader.onload = function (evt) {
          var dataUri = evt.target.result;
          callback(null, dataUri);
        };

        reader.onerror = onError;
        reader.readAsDataURL(xhr.response);
      } else {
        onError();
      }
    } : function (xhr) {
      var toString = function toString(u8a) {
        var CHUNK_SZ = 0x8000;
        var c = [];

        for (var i = 0; i < u8a.length; i += CHUNK_SZ) {
          c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));
        }

        return c.join('');
      };

      if (xhr.status === 200) {
        var suffix = url.split('.').pop() || 'png';

        if (suffix === 'svg') {
          suffix = 'svg+xml';
        }

        var meta = "data:image/".concat(suffix, ";base64,");
        var bytes = new Uint8Array(xhr.response);
        var base64 = meta + btoa(toString(bytes));
        callback(null, base64);
      } else {
        onError();
      }
    };
    var xhr = new XMLHttpRequest();
    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';
    xhr.open('GET', url, true);
    xhr.addEventListener('error', onError);
    xhr.addEventListener('load', function () {
      return onLoad(xhr);
    });
    xhr.send();
  }

  DataUri.imageToDataUri = imageToDataUri;

  function dataUriToBlob(dataUrl) {
    var uri = dataUrl.replace(/\s/g, '');
    uri = decodeURIComponent(uri);
    var index = uri.indexOf(',');
    var dataType = uri.slice(0, index); // e.g. 'data:image/jpeg;base64'

    var mime = dataType.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'

    var data = uri.slice(index + 1);
    var decodedString;

    if (dataType.indexOf('base64') >= 0) {
      // data may be encoded in base64
      decodedString = atob(data);
    } else {
      // convert the decoded string to UTF-8
      decodedString = unescape(encodeURIComponent(data));
    } // write the bytes of the string to a typed array


    var ia = new Uint8Array(decodedString.length);

    for (var i = 0; i < decodedString.length; i += 1) {
      ia[i] = decodedString.charCodeAt(i);
    }

    return new Blob([ia], {
      type: mime
    });
  }

  DataUri.dataUriToBlob = dataUriToBlob;

  function downloadBlob(blob, fileName) {
    if (window.navigator.msSaveBlob) {
      // requires IE 10+
      // pulls up a save dialog
      window.navigator.msSaveBlob(blob, fileName);
    } else {
      // other browsers
      // downloads directly in Chrome and Safari
      // presents a save/open dialog in Firefox
      // Firefox bug: `from` field in save dialog always shows `from:blob:`
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327
      var url = window.URL.createObjectURL(blob);
      var link = document.createElement('a');
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link); // mark the url for garbage collection

      window.URL.revokeObjectURL(url);
    }
  }

  DataUri.downloadBlob = downloadBlob;

  function downloadDataUri(dataUrl, fileName) {
    var blob = dataUriToBlob(dataUrl);
    downloadBlob(blob, fileName);
  }

  DataUri.downloadDataUri = downloadDataUri;

  function parseViewBox(svg) {
    var matches = svg.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);

    if (matches && matches[2]) {
      return matches[2].replace(/\s+/, ' ').split(' ');
    }

    return null;
  }

  function getNumber(str) {
    var ret = parseFloat(str);
    return isNaN(ret) ? null : ret;
  }

  function svgToDataUrl(svg) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var viewBox = null;

    var getNumberFromViewBox = function getNumberFromViewBox(index) {
      if (viewBox == null) {
        viewBox = parseViewBox(svg);
      }

      if (viewBox != null) {
        return getNumber(viewBox[index]);
      }

      return null;
    };

    var getNumberFromMatches = function getNumberFromMatches(reg) {
      var matches = svg.match(reg);

      if (matches && matches[2]) {
        return getNumber(matches[2]);
      }

      return null;
    };

    var w = options.width;

    if (w == null) {
      w = getNumberFromMatches(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    }

    if (w == null) {
      w = getNumberFromViewBox(2);
    }

    if (w == null) {
      throw new Error('Can not parse width from svg string');
    }

    var h = options.height;

    if (h == null) {
      h = getNumberFromMatches(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    }

    if (h == null) {
      h = getNumberFromViewBox(3);
    }

    if (h == null) {
      throw new Error('Can not parse height from svg string');
    }

    var decoded = encodeURIComponent(svg).replace(/'/g, '%27').replace(/"/g, '%22');
    var header = 'data:image/svg+xml';
    var dataUrl = "".concat(header, ",").concat(decoded);
    return dataUrl;
  }

  DataUri.svgToDataUrl = svgToDataUrl;
})(DataUri || (DataUri = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/af.js
var af_requestAnimationFrame = function () {
  var raf;
  var win = window;

  if (win != null) {
    raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame;

    if (raf != null) {
      raf = raf.bind(win);
    }
  }

  if (raf == null) {
    var lastTime = 0;

    raf = function raf(callback) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = setTimeout(function () {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  return raf;
}();
var af_cancelAnimationFrame = function () {
  var caf;
  var win = window;

  if (win != null) {
    caf = win.cancelAnimationFrame || win.webkitCancelAnimationFrame || win.webkitCancelRequestAnimationFrame || win.msCancelAnimationFrame || win.msCancelRequestAnimationFrame || win.oCancelAnimationFrame || win.oCancelRequestAnimationFrame || win.mozCancelAnimationFrame || win.mozCancelRequestAnimationFrame;

    if (caf) {
      caf = caf.bind(win);
    }
  }

  if (caf == null) {
    caf = clearTimeout;
  }

  return caf;
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/prefix.js
var hyphenPattern = /-(.)/g;

function camelize(str) {
  return str.replace(hyphenPattern, function (_, char) {
    return char.toUpperCase();
  });
}

var memoized = {};
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
var testStyle = document ? document.createElement('div').style : {};

function getWithPrefix(name) {
  for (var i = 0; i < prefixes.length; i += 1) {
    var prefixedName = prefixes[i] + name;

    if (prefixedName in testStyle) {
      return prefixedName;
    }
  }

  return null;
}

function getVendorPrefixedName(property) {
  var name = camelize(property);

  if (memoized[name] == null) {
    var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
    memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName);
  }

  return memoized[name];
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/style.js

function setPrefixedStyle(style, name, value) {
  var vendor = getVendorPrefixedName(name);

  if (vendor != null) {
    style[vendor] = value;
  }

  style[name] = value;
}
function getComputedStyle(elem, name) {
  // IE9+
  var computed = elem.ownerDocument && elem.ownerDocument.defaultView && elem.ownerDocument.defaultView.opener ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : window.getComputedStyle(elem, null);

  if (computed && name) {
    return computed.getPropertyValue(name) || computed[name];
  }

  return computed;
}
function hasScrollbars(container) {
  var style = getComputedStyle(container);
  return style != null && (style.overflow === 'scroll' || style.overflow === 'auto');
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/selection.js
var clearSelection = function () {
  var doc = document;

  if (doc.selection) {
    return function () {
      doc.selection.empty();
    };
  }

  if (window.getSelection) {
    return function () {
      var selection = window.getSelection();

      if (selection) {
        if (selection.empty) {
          selection.empty();
        } else if (selection.removeAllRanges) {
          selection.removeAllRanges();
        }
      }
    };
  }

  return function () {};
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/angle.js
var Angle;

(function (Angle) {
  function toDeg(rad) {
    return 180 * rad / Math.PI % 360;
  }

  Angle.toDeg = toDeg;

  Angle.toRad = function (deg) {
    var over360 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var d = over360 ? deg : deg % 360;
    return d * Math.PI / 180;
  };
  /**
   * Returns the angle in degrees and clamps its value between `0` and `360`.
   */


  function normalize(angle) {
    return angle % 360 + (angle < 0 ? 360 : 0);
  }

  Angle.normalize = normalize;
})(Angle || (Angle = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/util.js
function util_round(num, precision) {
  var f = Math.pow(10, precision || 0);
  return Math.round(num * f) / f;
}
function util_random(min, max) {
  var mmin;
  var mmax;

  if (max == null) {
    mmax = min == null ? 1 : min;
    mmin = 0;
  } else {
    mmax = max;
    mmin = min == null ? 0 : min;
  }

  if (mmax < mmin) {
    var temp = mmin;
    mmin = mmax;
    mmax = temp;
  }

  return Math.floor(Math.random() * (mmax - mmin + 1) + mmin);
}
function util_clamp(value, min, max) {
  if (isNaN(value)) {
    return NaN;
  }

  if (isNaN(min) || isNaN(max)) {
    return 0;
  }

  return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
}
function util_snapToGrid(value, gridSize) {
  return gridSize * Math.round(value / gridSize);
}
function util_containsPoint(rect, point) {
  return point != null && rect != null && point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height;
}
function squaredLength(p1, p2) {
  var dx = p1.x - p2.x;
  var dy = p1.y - p2.y;
  return dx * dx + dy * dy;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/geometry.js


var geometry_Geometry = /*#__PURE__*/function () {
  function Geometry() {
    Object(classCallCheck["a" /* default */])(this, Geometry);
  }

  Object(createClass["a" /* default */])(Geometry, [{
    key: "valueOf",
    value: function valueOf() {
      return this.toJSON();
    }
  }, {
    key: "toString",
    value: function toString() {
      return JSON.stringify(this.toJSON());
    }
  }]);

  return Geometry;
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/point.js







var point_Point = /*#__PURE__*/function (_Geometry) {
  Object(inherits["a" /* default */])(Point, _Geometry);

  var _super = Object(createSuper["a" /* default */])(Point);

  function Point(x, y) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Point);

    _this = _super.call(this);
    _this.x = x == null ? 0 : x;
    _this.y = y == null ? 0 : y;
    return _this;
  }

  Object(createClass["a" /* default */])(Point, [{
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.x = util_round(this.x, precision);
      this.y = util_round(this.y, precision);
      return this;
    }
  }, {
    key: "add",
    value: function add(x, y) {
      var p = Point.create(x, y);
      this.x += p.x;
      this.y += p.y;
      return this;
    }
  }, {
    key: "update",
    value: function update(x, y) {
      var p = Point.create(x, y);
      this.x = p.x;
      this.y = p.y;
      return this;
    }
  }, {
    key: "translate",
    value: function translate(dx, dy) {
      var t = Point.create(dx, dy);
      this.x += t.x;
      this.y += t.y;
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(angle, center) {
      var p = Point.rotate(this, angle, center);
      this.x = p.x;
      this.y = p.y;
      return this;
    }
  }, {
    key: "scale",
    value: function scale(sx, sy) {
      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();
      var ref = Point.create(origin);
      this.x = ref.x + sx * (this.x - ref.x);
      this.y = ref.y + sy * (this.y - ref.y);
      return this;
    }
    /**
     * Chooses the point closest to this point from among `points`.
     * If `points` is an empty array, `null` is returned.
     */

  }, {
    key: "closest",
    value: function closest(points) {
      var _this2 = this;

      if (points.length === 1) {
        return Point.create(points[0]);
      }

      var ret = null;
      var min = Infinity;
      points.forEach(function (p) {
        var dist = _this2.squaredDistance(p);

        if (dist < min) {
          ret = p;
          min = dist;
        }
      });
      return ret ? Point.create(ret) : null;
    }
  }, {
    key: "distance",
    value: function distance(p) {
      return Math.sqrt(this.squaredDistance(p));
    }
  }, {
    key: "squaredDistance",
    value: function squaredDistance(p) {
      var ref = Point.create(p);
      var dx = this.x - ref.x;
      var dy = this.y - ref.y;
      return dx * dx + dy * dy;
    }
  }, {
    key: "manhattanDistance",
    value: function manhattanDistance(p) {
      var ref = Point.create(p);
      return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);
    }
    /**
     * Returns the magnitude of the point vector.
     *
     * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
     */

  }, {
    key: "magnitude",
    value: function magnitude() {
      return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
    }
    /**
     * Returns the angle between vector from this point to `p` and the x axis.
     */

  }, {
    key: "theta",
    value: function theta() {
      var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Point();
      var ref = Point.create(p);
      var y = -(ref.y - this.y); // invert the y-axis.

      var x = ref.x - this.x;
      var rad = Math.atan2(y, x); // Correction for III. and IV. quadrant.

      if (rad < 0) {
        rad = 2 * Math.PI + rad;
      }

      return 180 * rad / Math.PI;
    }
    /**
     * Returns the angle between vector from this point to `p1` and the
     * vector from this point to `p2`.
     *
     * Ordering of points `p1` and `p2` is important!
     */

  }, {
    key: "angleBetween",
    value: function angleBetween(p1, p2) {
      if (this.equals(p1) || this.equals(p2)) {
        return NaN;
      }

      var angle = this.theta(p2) - this.theta(p1);

      if (angle < 0) {
        angle += 360;
      }

      return angle;
    }
    /**
     * Returns the angle between the vector from `0,0` to this point and the
     * vector from `0,0` to `p`. Returns `NaN` if `p` is at `0,0`.
     *
     * @returns the angle in degrees. `NaN` if `p` is at `0,0`.
     */

  }, {
    key: "vectorAngle",
    value: function vectorAngle(p) {
      var zero = new Point(0, 0);
      return zero.angleBetween(this, p);
    }
    /**
     * Converts rectangular to polar coordinates.
     */

  }, {
    key: "toPolar",
    value: function toPolar(origin) {
      this.update(Point.toPolar(this, origin));
      return this;
    }
    /**
     * Returns the change in angle from my previous position `-dx,-dy`
     * to my new position relative to `ref` point.
     */

  }, {
    key: "changeInAngle",
    value: function changeInAngle(dx, dy, ref) {
      // Revert the translation and measure the change in angle around x-axis.
      return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);
    }
  }, {
    key: "adhereToRect",
    value: function adhereToRect(rect) {
      if (!util_containsPoint(rect, this)) {
        this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);
        this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);
      }

      return this;
    }
    /**
     * Returns the bearing between me and the given point.
     */

  }, {
    key: "bearing",
    value: function bearing(p) {
      var ref = Point.create(p);
      var lat1 = Angle.toRad(this.y);
      var lat2 = Angle.toRad(ref.y);
      var lon1 = this.x;
      var lon2 = ref.x;
      var dLon = Angle.toRad(lon2 - lon1);
      var y = Math.sin(dLon) * Math.cos(lat2);
      var x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
      var brng = Angle.toDeg(Math.atan2(y, x));
      var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];
      var index = brng - 22.5;
      if (index < 0) index += 360;
      index = index / 45;
      return bearings[index];
    }
    /**
     * Returns the cross product of the vector from me to `p1`
     * and the vector from me to `p2`.
     *
     * The left-hand rule is used because the coordinate system is left-handed.
     */

  }, {
    key: "cross",
    value: function cross(p1, p2) {
      if (p1 != null && p2 != null) {
        var a = Point.create(p1);
        var b = Point.create(p2);
        return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);
      }

      return NaN;
    }
    /**
     * Returns the dot product of this point with given other point.
     */

  }, {
    key: "dot",
    value: function dot(p) {
      var ref = Point.create(p);
      return this.x * ref.x + this.y * ref.y;
    }
  }, {
    key: "diff",
    value: function diff(dx, dy) {
      if (typeof dx === 'number') {
        return new Point(this.x - dx, this.y - dy);
      }

      var p = Point.create(dx);
      return new Point(this.x - p.x, this.y - p.y);
    }
    /**
     * Returns an interpolation between me and point `p` for a
     * parametert in the closed interval `[0, 1]`.
     */

  }, {
    key: "lerp",
    value: function lerp(p, t) {
      var x = this.x;
      var y = this.y;
      var ref = Point.create(p);
      return new Point((1 - t) * x + t * ref.x, (1 - t) * y + t * ref.y);
    }
    /**
     * Normalize the point vector, scale the line segment between `(0, 0)`
     * and the point in order for it to have the given length. If length is
     * not specified, it is considered to be `1`; in that case, a unit vector
     * is computed.
     */

  }, {
    key: "normalize",
    value: function normalize() {
      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var scale = length / this.magnitude();
      return this.scale(scale, scale);
    }
    /**
     * Moves the point on a line that leads to another point `ref`
     * by a certain `distance`.
     */

  }, {
    key: "move",
    value: function move(ref, distance) {
      var p = Point.create(ref);
      var rad = Angle.toRad(p.theta(this));
      return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);
    }
    /**
     * Returns a point that is a reflection of the point with the
     * center of reflection at point `ref`.
     */

  }, {
    key: "reflection",
    value: function reflection(ref) {
      var p = Point.create(ref);
      return p.move(this, this.distance(p));
    }
  }, {
    key: "snapToGrid",
    value: function snapToGrid(gx, gy) {
      this.x = util_snapToGrid(this.x, gx);
      this.y = util_snapToGrid(this.y, gy == null ? gx : gy);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(p) {
      var ref = Point.create(p);
      return ref != null && ref.x === this.x && ref.y === this.y;
    }
  }, {
    key: "clone",
    value: function clone() {
      return Point.clone(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return Point.toJSON(this);
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return "".concat(this.x, " ").concat(this.y);
    }
  }]);

  return Point;
}(geometry_Geometry);

(function (Point) {
  function isPointLike(o) {
    return o != null && typeof o === 'object' && typeof o.x === 'number' && typeof o.y === 'number';
  }

  Point.isPointLike = isPointLike;

  function isPointData(o) {
    return o != null && Array.isArray(o) && o.length === 2 && typeof o[0] === 'number' && typeof o[1] === 'number';
  }

  Point.isPointData = isPointData;
})(point_Point || (point_Point = {}));

(function (Point) {
  function create(x, y) {
    if (x == null || typeof x === 'number') {
      return new Point(x, y);
    }

    return clone(x);
  }

  Point.create = create;

  function clone(p) {
    if (p instanceof Point) {
      return new Point(p.x, p.y);
    }

    if (Array.isArray(p)) {
      return new Point(p[0], p[1]);
    }

    return new Point(p.x, p.y);
  }

  Point.clone = clone;

  function toJSON(p) {
    if (p instanceof Point) {
      return {
        x: p.x,
        y: p.y
      };
    }

    if (Array.isArray(p)) {
      return {
        x: p[0],
        y: p[1]
      };
    }

    return {
      x: p.x,
      y: p.y
    };
  }

  Point.toJSON = toJSON;
  /**
   * Returns a new Point object from the given polar coordinates.
   * @see http://en.wikipedia.org/wiki/Polar_coordinate_system
   */

  function fromPolar(r, rad) {
    var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();
    var x = Math.abs(r * Math.cos(rad));
    var y = Math.abs(r * Math.sin(rad));
    var org = clone(origin);
    var deg = Angle.normalize(Angle.toDeg(rad));

    if (deg < 90) {
      y = -y;
    } else if (deg < 180) {
      x = -x;
      y = -y;
    } else if (deg < 270) {
      x = -x;
    }

    return new Point(org.x + x, org.y + y);
  }

  Point.fromPolar = fromPolar;

  function toPolar(point) {
    var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Point();
    var p = clone(point);
    var o = clone(origin);
    var dx = p.x - o.x;
    var dy = p.y - o.y;
    return new Point(Math.sqrt(dx * dx + dy * dy), // r
    Angle.toRad(o.theta(p)));
  }

  Point.toPolar = toPolar;

  function equals(p1, p2) {
    if (p1 === p2) {
      return true;
    }

    if (p1 != null && p2 != null) {
      return p1.x === p2.x && p1.y === p2.y;
    }

    return false;
  }

  Point.equals = equals;

  function equalPoints(p1, p2) {
    if (p1 == null && p2 != null || p1 != null && p2 == null || p1 != null && p2 != null && p1.length !== p2.length) {
      return false;
    }

    if (p1 != null && p2 != null) {
      for (var i = 0, ii = p1.length; i < ii; i += 1) {
        if (p1[i] === p2[i] || p1[i] != null && !equals(p1[i], p2[i])) {
          return false;
        }
      }
    }

    return true;
  }

  Point.equalPoints = equalPoints;
  /**
   * Create a point with random coordinates that fall within
   * the range `[x1, x2]` and `[y1, y2]`.
   */

  function random(x1, x2, y1, y2) {
    return new Point(util_random(x1, x2), util_random(y1, y2));
  }

  Point.random = random;

  function rotate(point, angle, center) {
    var rad = Angle.toRad(Angle.normalize(-angle));
    var sin = Math.sin(rad);
    var cos = Math.cos(rad);
    return rotateEx(point, cos, sin, center);
  }

  Point.rotate = rotate;

  function rotateEx(point, cos, sin) {
    var center = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Point();
    var source = clone(point);
    var origin = clone(center);
    var dx = source.x - origin.x;
    var dy = source.y - origin.y;
    var x1 = dx * cos - dy * sin;
    var y1 = dy * cos + dx * sin;
    return new Point(x1 + origin.x, y1 + origin.y);
  }

  Point.rotateEx = rotateEx;
})(point_Point || (point_Point = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/rectangle.js









var rectangle_Rectangle = /*#__PURE__*/function (_Geometry) {
  Object(inherits["a" /* default */])(Rectangle, _Geometry);

  var _super = Object(createSuper["a" /* default */])(Rectangle);

  function Rectangle(x, y, width, height) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Rectangle);

    _this = _super.call(this);
    _this.x = x == null ? 0 : x;
    _this.y = y == null ? 0 : y;
    _this.width = width == null ? 0 : width;
    _this.height = height == null ? 0 : height;
    return _this;
  }

  Object(createClass["a" /* default */])(Rectangle, [{
    key: "getOrigin",
    value: function getOrigin() {
      return this.origin;
    }
  }, {
    key: "getTopLeft",
    value: function getTopLeft() {
      return this.topLeft;
    }
  }, {
    key: "getTopCenter",
    value: function getTopCenter() {
      return this.topCenter;
    }
  }, {
    key: "getTopRight",
    value: function getTopRight() {
      return this.topRight;
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      return this.center;
    }
  }, {
    key: "getCenterX",
    value: function getCenterX() {
      return this.x + this.width / 2;
    }
  }, {
    key: "getCenterY",
    value: function getCenterY() {
      return this.y + this.height / 2;
    }
  }, {
    key: "getBottomLeft",
    value: function getBottomLeft() {
      return this.bottomLeft;
    }
  }, {
    key: "getBottomCenter",
    value: function getBottomCenter() {
      return this.bottomCenter;
    }
  }, {
    key: "getBottomRight",
    value: function getBottomRight() {
      return this.bottomRight;
    }
  }, {
    key: "getCorner",
    value: function getCorner() {
      return this.corner;
    }
  }, {
    key: "getRightMiddle",
    value: function getRightMiddle() {
      return this.rightMiddle;
    }
  }, {
    key: "getLeftMiddle",
    value: function getLeftMiddle() {
      return this.leftMiddle;
    }
  }, {
    key: "getTopLine",
    value: function getTopLine() {
      return this.topLine;
    }
  }, {
    key: "getRightLine",
    value: function getRightLine() {
      return this.rightLine;
    }
  }, {
    key: "getBottomLine",
    value: function getBottomLine() {
      return this.bottomLine;
    }
  }, {
    key: "getLeftLine",
    value: function getLeftLine() {
      return this.leftLine;
    }
    /**
     * Returns a rectangle that is the bounding box of the rectangle.
     *
     * If `angle` is specified, the bounding box calculation will take into
     * account the rotation of the rectangle by angle degrees around its center.
     */

  }, {
    key: "bbox",
    value: function bbox(angle) {
      if (!angle) {
        return this.clone();
      }

      var rad = Angle.toRad(angle);
      var st = Math.abs(Math.sin(rad));
      var ct = Math.abs(Math.cos(rad));
      var w = this.width * ct + this.height * st;
      var h = this.width * st + this.height * ct;
      return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.x = util_round(this.x, precision);
      this.y = util_round(this.y, precision);
      this.width = util_round(this.width, precision);
      this.height = util_round(this.height, precision);
      return this;
    }
  }, {
    key: "add",
    value: function add(x, y, width, height) {
      var rect = Rectangle.create(x, y, width, height);
      var minX = Math.min(this.x, rect.x);
      var minY = Math.min(this.y, rect.y);
      var maxX = Math.max(this.x + this.width, rect.x + rect.width);
      var maxY = Math.max(this.y + this.height, rect.y + rect.height);
      this.x = minX;
      this.y = minY;
      this.width = maxX - minX;
      this.height = maxY - minY;
      return this;
    }
  }, {
    key: "update",
    value: function update(x, y, width, height) {
      var rect = Rectangle.create(x, y, width, height);
      this.x = rect.x;
      this.y = rect.y;
      this.width = rect.width;
      this.height = rect.height;
      return this;
    }
  }, {
    key: "inflate",
    value: function inflate(dx, dy) {
      var w = dx;
      var h = dy != null ? dy : dx;
      this.x -= w;
      this.y -= h;
      this.width += 2 * w;
      this.height += 2 * h;
      return this;
    }
  }, {
    key: "snapToGrid",
    value: function snapToGrid(gx, gy) {
      var origin = this.origin.snapToGrid(gx, gy);
      var corner = this.corner.snapToGrid(gx, gy);
      this.x = origin.x;
      this.y = origin.y;
      this.width = corner.x - origin.x;
      this.height = corner.y - origin.y;
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      var p = point_Point.create(tx, ty);
      this.x += p.x;
      this.y += p.y;
      return this;
    }
    /**
     * Translates the rectangle by `rect.x` and `rect.y` and expand it
     * by `rect.width` and `rect.height`.
     */

  }, {
    key: "moveAndExpand",
    value: function moveAndExpand(rect) {
      var ref = Rectangle.clone(rect);
      this.x += ref.x || 0;
      this.y += ref.y || 0;
      this.width += ref.width || 0;
      this.height += ref.height || 0;
      return this;
    }
  }, {
    key: "scale",
    value: function scale(sx, sy) {
      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new point_Point();
      var pos = this.origin.scale(sx, sy, origin);
      this.x = pos.x;
      this.y = pos.y;
      this.width *= sx;
      this.height *= sy;
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(degree) {
      var center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getCenter();

      if (degree !== 0) {
        var rad = Angle.toRad(degree);
        var cos = Math.cos(rad);
        var sin = Math.sin(rad);
        var p1 = this.getOrigin();
        var p2 = this.getTopRight();
        var p3 = this.getBottomRight();
        var p4 = this.getBottomLeft();
        p1 = point_Point.rotateEx(p1, cos, sin, center);
        p2 = point_Point.rotateEx(p2, cos, sin, center);
        p3 = point_Point.rotateEx(p3, cos, sin, center);
        p4 = point_Point.rotateEx(p4, cos, sin, center);
        var rect = new Rectangle(p1.x, p1.y, 0, 0);
        rect.add(p2.x, p2.y, 0, 0);
        rect.add(p3.x, p3.y, 0, 0);
        rect.add(p4.x, p4.y, 0, 0);
        this.update(rect);
      }

      return this;
    }
  }, {
    key: "rotate90",
    value: function rotate90() {
      var t = (this.width - this.height) / 2;
      this.x += t;
      this.y -= t;
      var tmp = this.width;
      this.width = this.height;
      this.height = tmp;
      return this;
    }
  }, {
    key: "maxRectScaleToFit",
    value: function maxRectScaleToFit(limitRectangle) {
      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.center;
      var rect = Rectangle.clone(limitRectangle);
      var ox = origin.x;
      var oy = origin.y;
      var sx1;
      var sx2;
      var sx3;
      var sx4;
      var sy1;
      var sy2;
      var sy3;
      var sy4; // Find the maximal possible scale for all corners, so when the scale
      // is applied the point is still inside the rectangle.

      sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity; // Top Left

      var p1 = rect.topLeft;

      if (p1.x < ox) {
        sx1 = (this.x - ox) / (p1.x - ox);
      }

      if (p1.y < oy) {
        sy1 = (this.y - oy) / (p1.y - oy);
      } // Bottom Right


      var p2 = rect.bottomRight;

      if (p2.x > ox) {
        sx2 = (this.x + this.width - ox) / (p2.x - ox);
      }

      if (p2.y > oy) {
        sy2 = (this.y + this.height - oy) / (p2.y - oy);
      } // Top Right


      var p3 = rect.topRight;

      if (p3.x > ox) {
        sx3 = (this.x + this.width - ox) / (p3.x - ox);
      }

      if (p3.y < oy) {
        sy3 = (this.y - oy) / (p3.y - oy);
      } // Bottom Left


      var p4 = rect.bottomLeft;

      if (p4.x < ox) {
        sx4 = (this.x - ox) / (p4.x - ox);
      }

      if (p4.y > oy) {
        sy4 = (this.y + this.height - oy) / (p4.y - oy);
      }

      return {
        sx: Math.min(sx1, sx2, sx3, sx4),
        sy: Math.min(sy1, sy2, sy3, sy4)
      };
    }
  }, {
    key: "maxRectUniformScaleToFit",
    value: function maxRectUniformScaleToFit(limitRectangle) {
      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.center;
      var scale = this.maxRectScaleToFit(limitRectangle, origin);
      return Math.min(scale.sx, scale.sy);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(x, y) {
      return util_containsPoint(this, point_Point.create(x, y));
    }
  }, {
    key: "containsRect",
    value: function containsRect(x, y, width, height) {
      var b = Rectangle.create(x, y, width, height);
      var x1 = this.x;
      var y1 = this.y;
      var w1 = this.width;
      var h1 = this.height;
      var x2 = b.x;
      var y2 = b.y;
      var w2 = b.width;
      var h2 = b.height;
      return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;
    }
  }, {
    key: "intersectionWithLine",
    value: function intersectionWithLine(line) {
      var rectLines = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];
      var points = [];
      var dedupeArr = [];
      rectLines.forEach(function (l) {
        var p = line.intersectionWithLine(l);

        if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {
          points.push(p);
          dedupeArr.push(p.toString());
        }
      });
      return points.length > 0 ? points : null;
    }
    /**
     * Returns the point on the boundary of the rectangle that is the
     * intersection of the rectangle with a line starting in the center
     * of the rectangle ending in the point `p`.
     *
     * If angle is specified, the intersection will take into account the
     * rotation of the rectangle by angle degrees around its center.
     */

  }, {
    key: "intersectionWithLineFromCenterToPoint",
    value: function intersectionWithLineFromCenterToPoint(p, angle) {
      var ref = point_Point.clone(p);
      var center = this.center;
      var result;

      if (angle) {
        ref.rotate(angle, center);
      }

      var sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];
      var connector = new line_Line(center, p);

      for (var i = sides.length - 1; i >= 0; i -= 1) {
        var intersection = sides[i].intersectionWithLine(connector);

        if (intersection !== null) {
          result = intersection;
          break;
        }
      }

      if (result && angle) {
        result.rotate(-angle, center);
      }

      return result;
    }
    /**
     * Normalize the rectangle, i.e. make it so that it has non-negative
     * width and height.
     *
     * If width is less than `0`, the function swaps left and right corners
     * and if height is less than `0`, the top and bottom corners are swapped.
     */

  }, {
    key: "normalize",
    value: function normalize() {
      var newx = this.x;
      var newy = this.y;
      var newwidth = this.width;
      var newheight = this.height;

      if (this.width < 0) {
        newx = this.x + this.width;
        newwidth = -this.width;
      }

      if (this.height < 0) {
        newy = this.y + this.height;
        newheight = -this.height;
      }

      this.x = newx;
      this.y = newy;
      this.width = newwidth;
      this.height = newheight;
      return this;
    }
  }, {
    key: "intersect",
    value: function intersect(x, y, width, height) {
      var ref = Rectangle.create(x, y, width, height); // no intersection

      if (!this.isIntersectWith(ref)) {
        return null;
      }

      var myOrigin = this.origin;
      var myCorner = this.corner;
      var rOrigin = ref.origin;
      var rCorner = ref.corner;
      var xx = Math.max(myOrigin.x, rOrigin.x);
      var yy = Math.max(myOrigin.y, rOrigin.y);
      return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);
    }
  }, {
    key: "isIntersectWith",
    value: function isIntersectWith(x, y, width, height) {
      var ref = Rectangle.create(x, y, width, height);
      var myOrigin = this.origin;
      var myCorner = this.corner;
      var rOrigin = ref.origin;
      var rCorner = ref.corner;

      if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) {
        return false;
      }

      return true;
    }
    /**
     * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
     */

  }, {
    key: "union",
    value: function union(rect) {
      var ref = Rectangle.clone(rect);
      var myOrigin = this.origin;
      var myCorner = this.corner;
      var rOrigin = ref.origin;
      var rCorner = ref.corner;
      var originX = Math.min(myOrigin.x, rOrigin.x);
      var originY = Math.min(myOrigin.y, rOrigin.y);
      var cornerX = Math.max(myCorner.x, rCorner.x);
      var cornerY = Math.max(myCorner.y, rCorner.y);
      return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);
    }
  }, {
    key: "sideNearestToPoint",
    value: function sideNearestToPoint(p) {
      var ref = point_Point.clone(p);
      var distLeft = ref.x - this.x;
      var distRight = this.x + this.width - ref.x;
      var distTop = ref.y - this.y;
      var distBottom = this.y + this.height - ref.y;
      var closest = distLeft;
      var side = 'left';

      if (distRight < closest) {
        closest = distRight;
        side = 'right';
      }

      if (distTop < closest) {
        closest = distTop;
        side = 'top';
      }

      if (distBottom < closest) {
        side = 'bottom';
      }

      return side;
    }
  }, {
    key: "pointNearestToPoint",
    value: function pointNearestToPoint(p) {
      var ref = point_Point.clone(p);

      if (this.containsPoint(ref)) {
        var side = this.sideNearestToPoint(ref);

        switch (side) {
          case 'right':
            return new point_Point(this.x + this.width, ref.y);

          case 'left':
            return new point_Point(this.x, ref.y);

          case 'bottom':
            return new point_Point(ref.x, this.y + this.height);

          case 'top':
            return new point_Point(ref.x, this.y);
        }
      }

      return ref.adhereToRect(this);
    }
  }, {
    key: "equals",
    value: function equals(rect) {
      return rect != null && rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Rectangle(this.x, this.y, this.width, this.height);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return "".concat(this.x, " ").concat(this.y, " ").concat(this.width, " ").concat(this.height);
    }
  }, {
    key: "origin",
    get: function get() {
      return new point_Point(this.x, this.y);
    }
  }, {
    key: "topLeft",
    get: function get() {
      return new point_Point(this.x, this.y);
    }
  }, {
    key: "topCenter",
    get: function get() {
      return new point_Point(this.x + this.width / 2, this.y);
    }
  }, {
    key: "topRight",
    get: function get() {
      return new point_Point(this.x + this.width, this.y);
    }
  }, {
    key: "center",
    get: function get() {
      return new point_Point(this.x + this.width / 2, this.y + this.height / 2);
    }
  }, {
    key: "bottomLeft",
    get: function get() {
      return new point_Point(this.x, this.y + this.height);
    }
  }, {
    key: "bottomCenter",
    get: function get() {
      return new point_Point(this.x + this.width / 2, this.y + this.height);
    }
  }, {
    key: "bottomRight",
    get: function get() {
      return new point_Point(this.x + this.width, this.y + this.height);
    }
  }, {
    key: "corner",
    get: function get() {
      return new point_Point(this.x + this.width, this.y + this.height);
    }
  }, {
    key: "rightMiddle",
    get: function get() {
      return new point_Point(this.x + this.width, this.y + this.height / 2);
    }
  }, {
    key: "leftMiddle",
    get: function get() {
      return new point_Point(this.x, this.y + this.height / 2);
    }
  }, {
    key: "topLine",
    get: function get() {
      return new line_Line(this.topLeft, this.topRight);
    }
  }, {
    key: "rightLine",
    get: function get() {
      return new line_Line(this.topRight, this.bottomRight);
    }
  }, {
    key: "bottomLine",
    get: function get() {
      return new line_Line(this.bottomLeft, this.bottomRight);
    }
  }, {
    key: "leftLine",
    get: function get() {
      return new line_Line(this.topLeft, this.bottomLeft);
    }
  }]);

  return Rectangle;
}(geometry_Geometry);

(function (Rectangle) {
  function create(x, y, width, height) {
    if (x == null || typeof x === 'number') {
      return new Rectangle(x, y, width, height);
    }

    return clone(x);
  }

  Rectangle.create = create;

  function clone(rect) {
    if (rect instanceof Rectangle) {
      return rect.clone();
    }

    if (Array.isArray(rect)) {
      return new Rectangle(rect[0], rect[1], rect[2], rect[3]);
    }

    return new Rectangle(rect.x, rect.y, rect.width, rect.height);
  }

  Rectangle.clone = clone;

  function fromSize(size) {
    return new Rectangle(0, 0, size.width, size.height);
  }

  Rectangle.fromSize = fromSize;

  function fromPositionAndSize(pos, size) {
    return new Rectangle(pos.x, pos.y, size.width, size.height);
  }

  Rectangle.fromPositionAndSize = fromPositionAndSize;

  function fromEllipse(ellipse) {
    return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);
  }

  Rectangle.fromEllipse = fromEllipse;

  function isRectangleLike(o) {
    return o != null && typeof o === 'object' && typeof o.x === 'number' && typeof o.y === 'number' && typeof o.width === 'number' && typeof o.height === 'number';
  }

  Rectangle.isRectangleLike = isRectangleLike;
})(rectangle_Rectangle || (rectangle_Rectangle = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/line.js







var line_Line = /*#__PURE__*/function (_Geometry) {
  Object(inherits["a" /* default */])(Line, _Geometry);

  var _super = Object(createSuper["a" /* default */])(Line);

  function Line(x1, y1, x2, y2) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Line);

    _this = _super.call(this);

    if (typeof x1 === 'number' && typeof y1 === 'number') {
      _this.start = new point_Point(x1, y1);
      _this.end = new point_Point(x2, y2);
    } else {
      _this.start = point_Point.create(x1);
      _this.end = point_Point.create(y1);
    }

    return _this;
  }

  Object(createClass["a" /* default */])(Line, [{
    key: "getCenter",
    value: function getCenter() {
      return this.center;
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.start.round(precision);
      this.end.round(precision);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      if (typeof tx === 'number') {
        this.start.translate(tx, ty);
        this.end.translate(tx, ty);
      } else {
        this.start.translate(tx);
        this.end.translate(tx);
      }

      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(angle, origin) {
      this.start.rotate(angle, origin);
      this.end.rotate(angle, origin);
      return this;
    }
  }, {
    key: "scale",
    value: function scale(sx, sy, origin) {
      this.start.scale(sx, sy, origin);
      this.end.scale(sx, sy, origin);
      return this;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.squaredLength());
    }
  }, {
    key: "squaredLength",
    value: function squaredLength() {
      var dx = this.start.x - this.end.x;
      var dy = this.start.y - this.end.y;
      return dx * dx + dy * dy;
    }
  }, {
    key: "setLength",
    value: function setLength(length) {
      var total = this.length();

      if (!total) {
        return this;
      }

      var scale = length / total;
      return this.scale(scale, scale, this.start);
    }
    /**
     * Returns the vector (point) of the line with length equal to
     * length of the line.
     */

  }, {
    key: "vector",
    value: function vector() {
      return new point_Point(this.end.x - this.start.x, this.end.y - this.start.y);
    }
    /**
     * Returns the angle of incline of the line.
     *
     * The function returns `NaN` if the two endpoints of the line
     * both lie at the same coordinates.
     */

  }, {
    key: "angle",
    value: function angle() {
      var horizontal = new point_Point(this.start.x + 1, this.start.y);
      return this.start.angleBetween(this.end, horizontal);
    }
    /**
     * Returns a rectangle that is the bounding box of the line.
     */

  }, {
    key: "bbox",
    value: function bbox() {
      var left = Math.min(this.start.x, this.end.x);
      var top = Math.min(this.start.y, this.end.y);
      var right = Math.max(this.start.x, this.end.x);
      var bottom = Math.max(this.start.y, this.end.y);
      return new rectangle_Rectangle(left, top, right - left, bottom - top);
    }
    /**
     * Returns the bearing (cardinal direction) of the line.
     *
     * The return value is one of the following strings:
     * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
     *
     * The function returns 'N' if the two endpoints of the line are coincident.
     */

  }, {
    key: "bearing",
    value: function bearing() {
      return this.start.bearing(this.end);
    }
    /**
     * Returns the point on the line that lies closest to point.
     */

  }, {
    key: "closestPoint",
    value: function closestPoint(p) {
      return this.pointAt(this.closestPointNormalizedLength(p));
    }
    /**
     * Returns the length of the line up to the point that lies
     * closest to point.
     */

  }, {
    key: "closestPointLength",
    value: function closestPointLength(p) {
      return this.closestPointNormalizedLength(p) * this.length();
    }
    /**
     * Returns a line that is tangent to the line at the point that
     * lies closest to point.
     */

  }, {
    key: "closestPointTangent",
    value: function closestPointTangent(p) {
      return this.tangentAt(this.closestPointNormalizedLength(p));
    }
    /**
     * Returns the normalized length (distance from the start of the
     * line / total line length) of the line up to the point that lies
     * closest to point.
     */

  }, {
    key: "closestPointNormalizedLength",
    value: function closestPointNormalizedLength(p) {
      var product = this.vector().dot(new Line(this.start, p).vector());
      var normalized = Math.min(1, Math.max(0, product / this.squaredLength())); // normalized returns `NaN` if this line has zero length

      if (normalized !== normalized) {
        return 0;
      }

      return normalized;
    }
    /**
     * Returns a point on the line that lies `rate` (normalized length)
     * away from the beginning of the line.
     */

  }, {
    key: "pointAt",
    value: function pointAt(ratio) {
      var start = this.start;
      var end = this.end;

      if (ratio <= 0) {
        return start.clone();
      }

      if (ratio >= 1) {
        return end.clone();
      }

      return start.lerp(end, ratio);
    }
    /**
     * Returns a point on the line that lies length away from the
     * beginning of the line.
     */

  }, {
    key: "pointAtLength",
    value: function pointAtLength(length) {
      var start = this.start;
      var end = this.end;
      var fromStart = true;

      if (length < 0) {
        fromStart = false; // start calculation from end point

        length = -length; // tslint:disable-line
      }

      var total = this.length();

      if (length >= total) {
        return fromStart ? end.clone() : start.clone();
      }

      var rate = (fromStart ? length : total - length) / total;
      return this.pointAt(rate);
    }
    /**
     * Divides the line into two lines at the point that lies `rate`
     * (normalized length) away from the beginning of the line.
     */

  }, {
    key: "divideAt",
    value: function divideAt(ratio) {
      var dividerPoint = this.pointAt(ratio);
      return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];
    }
    /**
     * Divides the line into two lines at the point that lies length
     * away from the beginning of the line.
     */

  }, {
    key: "divideAtLength",
    value: function divideAtLength(length) {
      var dividerPoint = this.pointAtLength(length);
      return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      var start = this.start;
      var end = this.end; // cross product of 0 indicates that this line and
      // the vector to `p` are collinear.

      if (start.cross(p, end) !== 0) {
        return false;
      }

      var length = this.length();

      if (new Line(start, p).length() > length) {
        return false;
      }

      if (new Line(p, end).length() > length) {
        return false;
      }

      return true;
    }
  }, {
    key: "intersect",
    value: function intersect(shape, options) {
      var ret = shape.intersectionWithLine(this, options);

      if (ret) {
        return Array.isArray(ret) ? ret : [ret];
      }

      return null;
    }
    /**
     * Returns the intersection point of the line with another line.
     * Returns `null` if no intersection exists.
     */

  }, {
    key: "intersectionWithLine",
    value: function intersectionWithLine(line) {
      var pt1Dir = new point_Point(this.end.x - this.start.x, this.end.y - this.start.y);
      var pt2Dir = new point_Point(line.end.x - line.start.x, line.end.y - line.start.y);
      var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
      var deltaPt = new point_Point(line.start.x - this.start.x, line.start.y - this.start.y);
      var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
      var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;

      if (det === 0 || alpha * det < 0 || beta * det < 0) {
        return null;
      }

      if (det > 0) {
        if (alpha > det || beta > det) {
          return null;
        }
      } else {
        if (alpha < det || beta < det) {
          return null;
        }
      }

      return new point_Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det);
    }
  }, {
    key: "isDifferentiable",
    value: function isDifferentiable() {
      return !this.start.equals(this.end);
    }
    /**
     * Returns the perpendicular distance between the line and point.
     * The distance is positive if the point lies to the right of the
     * line, negative if the point lies to the left of the line, and
     * `0` if the point lies on the line.
     */

  }, {
    key: "pointOffset",
    value: function pointOffset(p) {
      var ref = point_Point.clone(p);
      var start = this.start;
      var end = this.end;
      var determinant = (end.x - start.x) * (ref.y - start.y) - (end.y - start.y) * (ref.x - start.x);
      return determinant / this.length();
    }
  }, {
    key: "pointSquaredDistance",
    value: function pointSquaredDistance(x, y) {
      var p = point_Point.create(x, y);
      return this.closestPoint(p).squaredDistance(p);
    }
  }, {
    key: "pointDistance",
    value: function pointDistance(x, y) {
      var p = point_Point.create(x, y);
      return this.closestPoint(p).distance(p);
    }
    /**
     * Returns a line tangent to the line at point that lies `rate`
     * (normalized length) away from the beginning of the line.
     */

  }, {
    key: "tangentAt",
    value: function tangentAt(ratio) {
      if (!this.isDifferentiable()) {
        return null;
      }

      var start = this.start;
      var end = this.end;
      var tangentStart = this.pointAt(ratio);
      var tangentLine = new Line(start, end);
      tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
      return tangentLine;
    }
    /**
     * Returns a line tangent to the line at point that lies `length`
     * away from the beginning of the line.
     */

  }, {
    key: "tangentAtLength",
    value: function tangentAtLength(length) {
      if (!this.isDifferentiable()) {
        return null;
      }

      var start = this.start;
      var end = this.end;
      var tangentStart = this.pointAtLength(length);
      var tangentLine = new Line(start, end);
      tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
      return tangentLine;
    }
  }, {
    key: "relativeCcw",
    value: function relativeCcw(x, y) {
      var ref = point_Point.create(x, y);
      var dx1 = ref.x - this.start.x;
      var dy1 = ref.y - this.start.y;
      var dx2 = this.end.x - this.start.x;
      var dy2 = this.end.y - this.start.y;
      var ccw = dx1 * dy2 - dy1 * dx2;

      if (ccw === 0) {
        ccw = dx1 * dx2 + dy1 * dy2;

        if (ccw > 0.0) {
          dx1 -= dx2;
          dy1 -= dy2;
          ccw = dx1 * dx2 + dy1 * dy2;

          if (ccw < 0.0) {
            ccw = 0.0;
          }
        }
      }

      return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;
    }
  }, {
    key: "equals",
    value: function equals(l) {
      return l != null && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Line(this.start, this.end);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        start: this.start.toJSON(),
        end: this.end.toJSON()
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return [this.start.serialize(), this.end.serialize()].join(' ');
    }
  }, {
    key: "center",
    get: function get() {
      return new point_Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
    }
  }]);

  return Line;
}(geometry_Geometry);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/ellipse.js







var ellipse_Ellipse = /*#__PURE__*/function (_Geometry) {
  Object(inherits["a" /* default */])(Ellipse, _Geometry);

  var _super = Object(createSuper["a" /* default */])(Ellipse);

  function Ellipse(x, y, a, b) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Ellipse);

    _this = _super.call(this);
    _this.x = x == null ? 0 : x;
    _this.y = y == null ? 0 : y;
    _this.a = a == null ? 0 : a;
    _this.b = b == null ? 0 : b;
    return _this;
  }

  Object(createClass["a" /* default */])(Ellipse, [{
    key: "bbox",

    /**
     * Returns a rectangle that is the bounding box of the ellipse.
     */
    value: function bbox() {
      return rectangle_Rectangle.fromEllipse(this);
    }
    /**
     * Returns a point that is the center of the ellipse.
     */

  }, {
    key: "getCenter",
    value: function getCenter() {
      return this.center;
    }
  }, {
    key: "inflate",
    value: function inflate(dx, dy) {
      var w = dx;
      var h = dy != null ? dy : dx;
      this.a += 2 * w;
      this.b += 2 * h;
      return this;
    }
    /**
     * Returns `true` if the point `p` is inside the ellipse (inclusive).
     * Returns `false` otherwise.
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      return this.normalizedDistance(p) <= 1;
    }
    /**
     * Returns a normalized distance from the ellipse center to point `p`.
     * Returns `n < 1` for points inside the ellipse, `n = 1` for points
     * lying on the ellipse boundary and `n > 1` for points outside the ellipse.
     */

  }, {
    key: "normalizedDistance",
    value: function normalizedDistance(p) {
      var ref = point_Point.clone(p);
      var dx = ref.x - this.x;
      var dy = ref.y - this.y;
      var a = this.a;
      var b = this.b;
      return dx * dx / (a * a) + dy * dy / (b * b);
    }
    /**
     * Returns an array of the intersection points of the ellipse and the line.
     * Returns `null` if no intersection exists.
     */

  }, {
    key: "intersectionWithLine",
    value: function intersectionWithLine(line) {
      var intersections = [];
      var rx = this.a;
      var ry = this.b;
      var a1 = line.start;
      var a2 = line.end;
      var dir = line.vector();
      var diff = a1.diff(new point_Point(this.x, this.y));
      var mDir = new point_Point(dir.x / (rx * rx), dir.y / (ry * ry));
      var mDiff = new point_Point(diff.x / (rx * rx), diff.y / (ry * ry));
      var a = dir.dot(mDir);
      var b = dir.dot(mDiff);
      var c = diff.dot(mDiff) - 1.0;
      var d = b * b - a * c;

      if (d < 0) {
        return null;
      }

      if (d > 0) {
        var root = Math.sqrt(d);
        var ta = (-b - root) / a;
        var tb = (-b + root) / a;

        if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {
          // outside
          return null;
        }

        if (0 <= ta && ta <= 1) {
          intersections.push(a1.lerp(a2, ta));
        }

        if (0 <= tb && tb <= 1) {
          intersections.push(a1.lerp(a2, tb));
        }
      } else {
        var t = -b / a;

        if (0 <= t && t <= 1) {
          intersections.push(a1.lerp(a2, t));
        } else {
          // outside
          return null;
        }
      }

      return intersections;
    }
    /**
     * Returns the point on the boundary of the ellipse that is the
     * intersection of the ellipse with a line starting in the center
     * of the ellipse ending in the point `p`.
     *
     * If angle is specified, the intersection will take into account
     * the rotation of the ellipse by angle degrees around its center.
     */

  }, {
    key: "intersectionWithLineFromCenterToPoint",
    value: function intersectionWithLineFromCenterToPoint(p) {
      var angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var ref = point_Point.clone(p);

      if (angle) {
        ref.rotate(angle, this.getCenter());
      }

      var dx = ref.x - this.x;
      var dy = ref.y - this.y;
      var result;

      if (dx === 0) {
        result = this.bbox().pointNearestToPoint(p);

        if (angle) {
          return result.rotate(-angle, this.getCenter());
        }

        return result;
      }

      var m = dy / dx;
      var mSquared = m * m;
      var aSquared = this.a * this.a;
      var bSquared = this.b * this.b;
      var x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));
      x = dx < 0 ? -x : x;
      var y = m * x;
      result = new point_Point(this.x + x, this.y + y);
      if (angle) return result.rotate(-angle, this.getCenter());
      return result;
    }
  }, {
    key: "tangentTheta",
    value: function tangentTheta(p) {
      var ref = point_Point.clone(p);
      var x0 = ref.x;
      var y0 = ref.y;
      var a = this.a;
      var b = this.b;
      var center = this.bbox().center;
      var cx = center.x;
      var cy = center.y;
      var refPointDelta = 30;
      var q1 = x0 > center.x + a / 2;
      var q3 = x0 < center.x - a / 2;
      var x;
      var y;

      if (q1 || q3) {
        y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;
        x = a * a / (x0 - cx) - a * a * (y0 - cy) * (y - cy) / (b * b * (x0 - cx)) + cx;
      } else {
        x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;
        y = b * b / (y0 - cy) - b * b * (x0 - cx) * (x - cx) / (a * a * (y0 - cy)) + cy;
      }

      return new point_Point(x, y).theta(ref);
    }
  }, {
    key: "scale",
    value: function scale(sx, sy) {
      this.a *= sx;
      this.b *= sy;
      return this;
    }
  }, {
    key: "translate",
    value: function translate(dx, dy) {
      var p = point_Point.create(dx, dy);
      this.x += p.x;
      this.y += p.y;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(ellipse) {
      return ellipse != null && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Ellipse(this.x, this.y, this.a, this.b);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        x: this.x,
        y: this.y,
        a: this.a,
        b: this.b
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return "".concat(this.x, " ").concat(this.y, " ").concat(this.a, " ").concat(this.b);
    }
  }, {
    key: "center",
    get: function get() {
      return new point_Point(this.x, this.y);
    }
  }]);

  return Ellipse;
}(geometry_Geometry);

(function (Ellipse) {
  function create(x, y, a, b) {
    if (x == null || typeof x === 'number') {
      return new Ellipse(x, y, a, b);
    }

    return parse(x);
  }

  Ellipse.create = create;

  function parse(e) {
    if (e instanceof Ellipse) {
      return e.clone();
    }

    if (Array.isArray(e)) {
      return new Ellipse(e[0], e[1], e[2], e[3]);
    }

    return new Ellipse(e.x, e.y, e.a, e.b);
  }

  Ellipse.parse = parse;

  function fromRect(rect) {
    var center = rect.center;
    return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);
  }

  Ellipse.fromRect = fromRect;
})(ellipse_Ellipse || (ellipse_Ellipse = {}));
// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js + 1 modules
var possibleConstructorReturn = __webpack_require__(97);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/polyline.js









var polyline_Polyline = /*#__PURE__*/function (_Geometry) {
  Object(inherits["a" /* default */])(Polyline, _Geometry);

  var _super = Object(createSuper["a" /* default */])(Polyline);

  function Polyline(points) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Polyline);

    _this = _super.call(this);

    if (points != null) {
      if (typeof points === 'string') {
        return Object(possibleConstructorReturn["a" /* default */])(_this, Polyline.parse(points));
      }

      _this.points = points.map(function (p) {
        return point_Point.create(p);
      });
    } else {
      _this.points = [];
    }

    return _this;
  }

  Object(createClass["a" /* default */])(Polyline, [{
    key: "scale",
    value: function scale(sx, sy) {
      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new point_Point();
      this.points.forEach(function (p) {
        return p.scale(sx, sy, origin);
      });
      return this;
    }
  }, {
    key: "translate",
    value: function translate(dx, dy) {
      var t = point_Point.create(dx, dy);
      this.points.forEach(function (p) {
        return p.translate(t.x, t.y);
      });
      return this;
    }
  }, {
    key: "bbox",
    value: function bbox() {
      if (this.points.length === 0) {
        return new rectangle_Rectangle();
      }

      var x1 = Infinity;
      var x2 = -Infinity;
      var y1 = Infinity;
      var y2 = -Infinity;
      var points = this.points;

      for (var i = 0, ii = points.length; i < ii; i += 1) {
        var point = points[i];
        var x = point.x;
        var y = point.y;
        if (x < x1) x1 = x;
        if (x > x2) x2 = x;
        if (y < y1) y1 = y;
        if (y > y2) y2 = y;
      }

      return new rectangle_Rectangle(x1, y1, x2 - x1, y2 - y1);
    }
  }, {
    key: "closestPoint",
    value: function closestPoint(p) {
      var cpLength = this.closestPointLength(p);
      return this.pointAtLength(cpLength);
    }
  }, {
    key: "closestPointLength",
    value: function closestPointLength(p) {
      var points = this.points;
      var count = points.length;

      if (count === 0 || count === 1) {
        return 0;
      }

      var length = 0;
      var cpLength = 0;
      var minSqrDistance = Infinity;

      for (var i = 0, ii = count - 1; i < ii; i += 1) {
        var line = new line_Line(points[i], points[i + 1]);
        var lineLength = line.length();
        var cpNormalizedLength = line.closestPointNormalizedLength(p);
        var cp = line.pointAt(cpNormalizedLength);
        var sqrDistance = cp.squaredDistance(p);

        if (sqrDistance < minSqrDistance) {
          minSqrDistance = sqrDistance;
          cpLength = length + cpNormalizedLength * lineLength;
        }

        length += lineLength;
      }

      return cpLength;
    }
  }, {
    key: "closestPointNormalizedLength",
    value: function closestPointNormalizedLength(p) {
      var cpLength = this.closestPointLength(p);

      if (cpLength === 0) {
        return 0;
      }

      var length = this.length();

      if (length === 0) {
        return 0;
      }

      return cpLength / length;
    }
  }, {
    key: "closestPointTangent",
    value: function closestPointTangent(p) {
      var cpLength = this.closestPointLength(p);
      return this.tangentAtLength(cpLength);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      if (this.points.length === 0) {
        return false;
      }

      var ref = point_Point.clone(p);
      var x = ref.x;
      var y = ref.y;
      var points = this.points;
      var count = points.length;
      var startIndex = count - 1;
      var intersectionCount = 0;

      for (var endIndex = 0; endIndex < count; endIndex += 1) {
        var start = points[startIndex];
        var end = points[endIndex];

        if (ref.equals(start)) {
          return true;
        }

        var segment = new line_Line(start, end);

        if (segment.containsPoint(p)) {
          return true;
        } // do we have an intersection?


        if (y <= start.y && y > end.y || y > start.y && y <= end.y) {
          // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`
          // (when `y === start.y === end.y`)
          // this conditional branch IS entered when `segment` touches `ray` at only one point
          // (e.g. when `y === start.y !== end.y`)
          // since this branch is entered again for the following segment, the two touches cancel out
          var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;

          if (xDifference >= 0) {
            // segment lies at least partially to the right of `p`
            var rayEnd = new point_Point(x + xDifference, y); // right

            var ray = new line_Line(p, rayEnd);

            if (segment.intersectionWithLine(ray)) {
              // an intersection was detected to the right of `p`
              intersectionCount += 1;
            }
          } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)

        } // move to check the next polyline segment


        startIndex = endIndex;
      } // returns `true` for odd numbers of intersections (even-odd algorithm)


      return intersectionCount % 2 === 1;
    }
  }, {
    key: "intersectionWithLine",
    value: function intersectionWithLine(line) {
      var intersections = [];

      for (var i = 0, n = this.points.length - 1; i < n; i += 1) {
        var a = this.points[i];
        var b = this.points[i + 1];
        var int = line.intersectionWithLine(new line_Line(a, b));

        if (int) {
          intersections.push(int);
        }
      }

      return intersections.length > 0 ? intersections : null;
    }
  }, {
    key: "isDifferentiable",
    value: function isDifferentiable() {
      for (var i = 0, ii = this.points.length - 1; i < ii; i += 1) {
        var a = this.points[i];
        var b = this.points[i + 1];
        var line = new line_Line(a, b);

        if (line.isDifferentiable()) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "length",
    value: function length() {
      var len = 0;

      for (var i = 0, ii = this.points.length - 1; i < ii; i += 1) {
        var a = this.points[i];
        var b = this.points[i + 1];
        len += a.distance(b);
      }

      return len;
    }
  }, {
    key: "pointAt",
    value: function pointAt(ratio) {
      var points = this.points;
      var count = points.length;

      if (count === 0) {
        return null;
      }

      if (count === 1) {
        return points[0].clone();
      }

      if (ratio <= 0) {
        return points[0].clone();
      }

      if (ratio >= 1) {
        return points[count - 1].clone();
      }

      var total = this.length();
      var length = total * ratio;
      return this.pointAtLength(length);
    }
  }, {
    key: "pointAtLength",
    value: function pointAtLength(length) {
      var points = this.points;
      var count = points.length;

      if (count === 0) {
        return null;
      }

      if (count === 1) {
        return points[0].clone();
      }

      var fromStart = true;

      if (length < 0) {
        fromStart = false;
        length = -length; // tslint:disable-line
      }

      var tmp = 0;

      for (var i = 0, ii = count - 1; i < ii; i += 1) {
        var index = fromStart ? i : ii - 1 - i;
        var a = points[index];
        var b = points[index + 1];
        var l = new line_Line(a, b);
        var d = a.distance(b);

        if (length <= tmp + d) {
          return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));
        }

        tmp += d;
      }

      var lastPoint = fromStart ? points[count - 1] : points[0];
      return lastPoint.clone();
    }
  }, {
    key: "tangentAt",
    value: function tangentAt(ratio) {
      var points = this.points;
      var count = points.length;

      if (count === 0 || count === 1) {
        return null;
      }

      if (ratio < 0) {
        ratio = 0; // tslint:disable-line
      }

      if (ratio > 1) {
        ratio = 1; // tslint:disable-line
      }

      var total = this.length();
      var length = total * ratio;
      return this.tangentAtLength(length);
    }
  }, {
    key: "tangentAtLength",
    value: function tangentAtLength(length) {
      var points = this.points;
      var count = points.length;

      if (count === 0 || count === 1) {
        return null;
      }

      var fromStart = true;

      if (length < 0) {
        fromStart = false;
        length = -length; // tslint:disable-line
      }

      var lastValidLine;
      var tmp = 0;

      for (var i = 0, ii = count - 1; i < ii; i += 1) {
        var index = fromStart ? i : ii - 1 - i;
        var a = points[index];
        var b = points[index + 1];
        var l = new line_Line(a, b);
        var d = a.distance(b);

        if (l.isDifferentiable()) {
          // has a tangent line (line length is not 0)
          if (length <= tmp + d) {
            return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));
          }

          lastValidLine = l;
        }

        tmp += d;
      }

      if (lastValidLine) {
        var ratio = fromStart ? 1 : 0;
        return lastValidLine.tangentAt(ratio);
      }

      return null;
    }
  }, {
    key: "simplify",
    value: function simplify() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var points = this.points; // we need at least 3 points

      if (points.length < 3) {
        return this;
      }

      var threshold = options.threshold || 0; // start at the beginning of the polyline and go forward

      var currentIndex = 0; // we need at least one intermediate point (3 points) in every iteration
      // as soon as that stops being true, we know we reached the end of the polyline

      while (points[currentIndex + 2]) {
        var firstIndex = currentIndex;
        var middleIndex = currentIndex + 1;
        var lastIndex = currentIndex + 2;
        var firstPoint = points[firstIndex];
        var middlePoint = points[middleIndex];
        var lastPoint = points[lastIndex];
        var chord = new line_Line(firstPoint, lastPoint); // = connection between first and last point

        var closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point

        var closestPointDistance = closestPoint.distance(middlePoint);

        if (closestPointDistance <= threshold) {
          // middle point is close enough to the chord = simplify
          // 1) remove middle point:
          points.splice(middleIndex, 1); // 2) in next iteration, investigate the newly-created triplet of points
          //    - do not change `currentIndex`
          //    = (first point stays, point after removed point becomes middle point)
        } else {
          // middle point is far from the chord
          // 1) preserve middle point
          // 2) in next iteration, move `currentIndex` by one step:
          currentIndex += 1; //    = (point after first point becomes first point)
        }
      } // `points` array was modified in-place


      return this;
    }
  }, {
    key: "toHull",
    value: function toHull() {
      var points = this.points;
      var count = points.length;

      if (count === 0) {
        return new Polyline();
      } // Step 1: find the starting point -- point with
      // the lowest y (if equality, highest x).


      var startPoint = points[0];

      for (var i = 1; i < count; i += 1) {
        if (points[i].y < startPoint.y) {
          startPoint = points[i];
        } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {
          startPoint = points[i];
        }
      } // Step 2: sort the list of points by angle between line
      // from start point to current point and the x-axis (theta).
      // Step 2a: create the point records = [point, originalIndex, angle]


      var sortedRecords = [];

      for (var _i = 0; _i < count; _i += 1) {
        var angle = startPoint.theta(points[_i]);

        if (angle === 0) {
          // Give highest angle to start point.
          // The start point will end up at end of sorted list.
          // The start point will end up at beginning of hull points list.
          angle = 360;
        }

        sortedRecords.push([points[_i], _i, angle]);
      } // Step 2b: sort the list in place


      sortedRecords.sort(function (record1, record2) {
        var ret = record1[2] - record2[2];

        if (ret === 0) {
          ret = record2[1] - record1[1];
        }

        return ret;
      }); // Step 2c: duplicate start record from the top of
      // the stack to the bottom of the stack.

      if (sortedRecords.length > 2) {
        var _startPoint = sortedRecords[sortedRecords.length - 1];
        sortedRecords.unshift(_startPoint);
      } // Step 3
      // ------
      // Step 3a: go through sorted points in order and find those with
      // right turns, and we want to get our results in clockwise order.
      // Dictionary of points with left turns - cannot be on the hull.


      var insidePoints = {}; // Stack of records with right turns - hull point candidates.

      var hullRecords = [];

      var getKey = function getKey(record) {
        return "".concat(record[0].toString(), "@").concat(record[1]);
      };

      while (sortedRecords.length !== 0) {
        var currentRecord = sortedRecords.pop();
        var currentPoint = currentRecord[0]; // Check if point has already been discarded.

        if (insidePoints[getKey(currentRecord)]) {
          continue;
        }

        var correctTurnFound = false;

        while (!correctTurnFound) {
          if (hullRecords.length < 2) {
            // Not enough points for comparison, just add current point.
            hullRecords.push(currentRecord);
            correctTurnFound = true;
          } else {
            var lastHullRecord = hullRecords.pop();
            var lastHullPoint = lastHullRecord[0];
            var secondLastHullRecord = hullRecords.pop();
            var secondLastHullPoint = secondLastHullRecord[0];
            var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);

            if (crossProduct < 0) {
              // Found a right turn.
              hullRecords.push(secondLastHullRecord);
              hullRecords.push(lastHullRecord);
              hullRecords.push(currentRecord);
              correctTurnFound = true;
            } else if (crossProduct === 0) {
              // the three points are collinear
              // three options:
              // there may be a 180 or 0 degree angle at lastHullPoint
              // or two of the three points are coincident
              // we have to take rounding errors into account
              var THRESHOLD = 1e-10;
              var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);

              if (Math.abs(angleBetween - 180) < THRESHOLD) {
                // rouding around 180 to 180
                // if the cross product is 0 because the angle is 180 degrees
                // discard last hull point (add to insidePoints)
                // insidePoints.unshift(lastHullPoint);
                insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)

                hullRecords.push(secondLastHullRecord); // do not do anything with current point
                // correct turn not found
              } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {
                // if the cross product is 0 because two points are the same
                // discard last hull point (add to insidePoints)
                // insidePoints.unshift(lastHullPoint);
                insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)

                hullRecords.push(secondLastHullRecord); // do not do anything with current point
                // correct turn not found
              } else if (Math.abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {
                // rounding around 0 and 360 to 0
                // if the cross product is 0 because the angle is 0 degrees
                // remove last hull point from hull BUT do not discard it
                // reenter second-to-last hull point (will be last at next iter)
                hullRecords.push(secondLastHullRecord); // put last hull point back into the sorted point records list

                sortedRecords.push(lastHullRecord); // we are switching the order of the 0deg and 180deg points
                // correct turn not found
              }
            } else {
              // found a left turn
              // discard last hull point (add to insidePoints)
              // insidePoints.unshift(lastHullPoint);
              insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter of loop)

              hullRecords.push(secondLastHullRecord); // do not do anything with current point
              // correct turn not found
            }
          }
        }
      } // At this point, hullPointRecords contains the output points in clockwise order
      // the points start with lowest-y,highest-x startPoint, and end at the same point
      // Step 3b: remove duplicated startPointRecord from the end of the array


      if (hullRecords.length > 2) {
        hullRecords.pop();
      } // Step 4: find the lowest originalIndex record and put it at the beginning of hull


      var lowestHullIndex; // the lowest originalIndex on the hull

      var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex

      for (var _i2 = 0, n = hullRecords.length; _i2 < n; _i2 += 1) {
        var currentHullIndex = hullRecords[_i2][1];

        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {
          lowestHullIndex = currentHullIndex;
          indexOfLowestHullIndexRecord = _i2;
        }
      }

      var hullPointRecordsReordered = [];

      if (indexOfLowestHullIndexRecord > 0) {
        var newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);
        var newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);
        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);
      } else {
        hullPointRecordsReordered = hullRecords;
      }

      var hullPoints = [];

      for (var _i3 = 0, _n = hullPointRecordsReordered.length; _i3 < _n; _i3 += 1) {
        hullPoints.push(hullPointRecordsReordered[_i3][0]);
      }

      return new Polyline(hullPoints);
    }
  }, {
    key: "equals",
    value: function equals(p) {
      var _this2 = this;

      if (p == null) {
        return false;
      }

      if (p.points.length !== this.points.length) {
        return false;
      }

      return p.points.every(function (a, i) {
        return a.equals(_this2.points[i]);
      });
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Polyline(this.points.map(function (p) {
        return p.clone();
      }));
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.points.map(function (p) {
        return p.toJSON();
      });
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return this.points.map(function (p) {
        return "".concat(p.x, ", ").concat(p.y);
      }).join(' ');
    }
  }, {
    key: "start",
    get: function get() {
      if (this.points.length === 0) {
        return null;
      }

      return this.points[0];
    }
  }, {
    key: "end",
    get: function get() {
      if (this.points.length === 0) {
        return null;
      }

      return this.points[this.points.length - 1];
    }
  }]);

  return Polyline;
}(geometry_Geometry);

(function (Polyline) {
  function parse(svgString) {
    var str = svgString.trim();

    if (str === '') {
      return new Polyline();
    }

    var points = [];
    var coords = str.split(/\s*,\s*|\s+/);

    for (var i = 0, ii = coords.length; i < ii; i += 2) {
      points.push({
        x: +coords[i],
        y: +coords[i + 1]
      });
    }

    return new Polyline(points);
  }

  Polyline.parse = parse;
})(polyline_Polyline || (polyline_Polyline = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/curve.js









var curve_Curve = /*#__PURE__*/function (_Geometry) {
  Object(inherits["a" /* default */])(Curve, _Geometry);

  var _super = Object(createSuper["a" /* default */])(Curve);

  function Curve(start, controlPoint1, controlPoint2, end) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Curve);

    _this = _super.call(this);
    _this.PRECISION = 3;
    _this.start = point_Point.create(start);
    _this.controlPoint1 = point_Point.create(controlPoint1);
    _this.controlPoint2 = point_Point.create(controlPoint2);
    _this.end = point_Point.create(end);
    return _this;
  }

  Object(createClass["a" /* default */])(Curve, [{
    key: "bbox",
    value: function bbox() {
      var start = this.start;
      var controlPoint1 = this.controlPoint1;
      var controlPoint2 = this.controlPoint2;
      var end = this.end;
      var x0 = start.x;
      var y0 = start.y;
      var x1 = controlPoint1.x;
      var y1 = controlPoint1.y;
      var x2 = controlPoint2.x;
      var y2 = controlPoint2.y;
      var x3 = end.x;
      var y3 = end.y;
      var points = []; // local extremes

      var tvalues = []; // t values of local extremes

      var bounds = [[], []];
      var a;
      var b;
      var c;
      var t;
      var t1;
      var t2;
      var b2ac;
      var sqrtb2ac;

      for (var i = 0; i < 2; i += 1) {
        if (i === 0) {
          b = 6 * x0 - 12 * x1 + 6 * x2;
          a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
          c = 3 * x1 - 3 * x0;
        } else {
          b = 6 * y0 - 12 * y1 + 6 * y2;
          a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
          c = 3 * y1 - 3 * y0;
        }

        if (Math.abs(a) < 1e-12) {
          if (Math.abs(b) < 1e-12) {
            continue;
          }

          t = -c / b;
          if (0 < t && t < 1) tvalues.push(t);
          continue;
        }

        b2ac = b * b - 4 * c * a;
        sqrtb2ac = Math.sqrt(b2ac);
        if (b2ac < 0) continue;
        t1 = (-b + sqrtb2ac) / (2 * a);
        if (0 < t1 && t1 < 1) tvalues.push(t1);
        t2 = (-b - sqrtb2ac) / (2 * a);
        if (0 < t2 && t2 < 1) tvalues.push(t2);
      }

      var x;
      var y;
      var mt;
      var j = tvalues.length;
      var jlen = j;

      while (j) {
        j -= 1;
        t = tvalues[j];
        mt = 1 - t;
        x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
        bounds[0][j] = x;
        y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
        bounds[1][j] = y;
        points[j] = {
          X: x,
          Y: y
        };
      }

      tvalues[jlen] = 0;
      tvalues[jlen + 1] = 1;
      points[jlen] = {
        X: x0,
        Y: y0
      };
      points[jlen + 1] = {
        X: x3,
        Y: y3
      };
      bounds[0][jlen] = x0;
      bounds[1][jlen] = y0;
      bounds[0][jlen + 1] = x3;
      bounds[1][jlen + 1] = y3;
      tvalues.length = jlen + 2;
      bounds[0].length = jlen + 2;
      bounds[1].length = jlen + 2;
      points.length = jlen + 2;
      var left = Math.min.apply(null, bounds[0]);
      var top = Math.min.apply(null, bounds[1]);
      var right = Math.max.apply(null, bounds[0]);
      var bottom = Math.max.apply(null, bounds[1]);
      return new rectangle_Rectangle(left, top, right - left, bottom - top);
    }
  }, {
    key: "closestPoint",
    value: function closestPoint(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.pointAtT(this.closestPointT(p, options));
    }
  }, {
    key: "closestPointLength",
    value: function closestPointLength(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var opts = this.getOptions(options);
      return this.lengthAtT(this.closestPointT(p, opts), opts);
    }
  }, {
    key: "closestPointNormalizedLength",
    value: function closestPointNormalizedLength(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var opts = this.getOptions(options);
      var cpLength = this.closestPointLength(p, opts);

      if (!cpLength) {
        return 0;
      }

      var length = this.length(opts);

      if (length === 0) {
        return 0;
      }

      return cpLength / length;
    }
  }, {
    key: "closestPointT",
    value: function closestPointT(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var precision = this.getPrecision(options);
      var subdivisions = this.getDivisions(options);
      var precisionRatio = Math.pow(10, -precision);
      var investigatedSubdivision = null;
      var investigatedSubdivisionStartT = 0;
      var investigatedSubdivisionEndT = 0;
      var distFromStart = 0;
      var distFromEnd = 0;
      var chordLength = 0;
      var minSumDist = null;
      var count = subdivisions.length;
      var piece = count > 0 ? 1 / count : 0;
      subdivisions.forEach(function (division, i) {
        var startDist = division.start.distance(p);
        var endDist = division.end.distance(p);
        var sumDist = startDist + endDist;

        if (minSumDist == null || sumDist < minSumDist) {
          investigatedSubdivision = division;
          investigatedSubdivisionStartT = i * piece;
          investigatedSubdivisionEndT = (i + 1) * piece;
          distFromStart = startDist;
          distFromEnd = endDist;
          minSumDist = sumDist;
          chordLength = division.endpointDistance();
        }
      }); // Recursively divide investigated subdivision, until distance between
      // baselinePoint and closest path endpoint is within `10^(-precision)`,
      // then return the closest endpoint of that final subdivision.

      while (true) {
        // check if we have reached at least one required observed precision
        // - calculated as: the difference in distances from point to start and end divided by the distance
        // - note that this function is not monotonic = it doesn't converge stably but has "teeth"
        // - the function decreases while one of the endpoints is fixed but "jumps" whenever we switch
        // - this criterion works well for points lying far away from the curve
        var startPrecisionRatio = distFromStart ? Math.abs(distFromStart - distFromEnd) / distFromStart : 0;
        var endPrecisionRatio = distFromEnd != null ? Math.abs(distFromStart - distFromEnd) / distFromEnd : 0;
        var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio; // check if we have reached at least one required minimal distance
        // - calculated as: the subdivision chord length multiplied by precisionRatio
        // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions
        // - this is a backup criterion that works well for points lying "almost at" the curve

        var hasMiniStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;
        var hasMiniEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;
        var hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;

        if (hasRequiredPrecision || hasMiniDistance) {
          return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;
        } // otherwise, set up for next iteration


        var divided = investigatedSubdivision.divide(0.5);
        piece /= 2;
        var startDist1 = divided[0].start.distance(p);
        var endDist1 = divided[0].end.distance(p);
        var sumDist1 = startDist1 + endDist1;
        var startDist2 = divided[1].start.distance(p);
        var endDist2 = divided[1].end.distance(p);
        var sumDist2 = startDist2 + endDist2;

        if (sumDist1 <= sumDist2) {
          investigatedSubdivision = divided[0];
          investigatedSubdivisionEndT -= piece;
          distFromStart = startDist1;
          distFromEnd = endDist1;
        } else {
          investigatedSubdivision = divided[1];
          investigatedSubdivisionStartT += piece;
          distFromStart = startDist2;
          distFromEnd = endDist2;
        }
      }
    }
  }, {
    key: "closestPointTangent",
    value: function closestPointTangent(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.tangentAtT(this.closestPointT(p, options));
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var polyline = this.toPolyline(options);
      return polyline.containsPoint(p);
    }
  }, {
    key: "divideAt",
    value: function divideAt(ratio) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (ratio <= 0) {
        return this.divideAtT(0);
      }

      if (ratio >= 1) {
        return this.divideAtT(1);
      }

      var t = this.tAt(ratio, options);
      return this.divideAtT(t);
    }
  }, {
    key: "divideAtLength",
    value: function divideAtLength(length) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var t = this.tAtLength(length, options);
      return this.divideAtT(t);
    }
  }, {
    key: "divide",
    value: function divide(t) {
      return this.divideAtT(t);
    }
  }, {
    key: "divideAtT",
    value: function divideAtT(t) {
      var start = this.start;
      var controlPoint1 = this.controlPoint1;
      var controlPoint2 = this.controlPoint2;
      var end = this.end;

      if (t <= 0) {
        return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];
      }

      if (t >= 1) {
        return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];
      }

      var dividerPoints = this.getSkeletonPoints(t);
      var startControl1 = dividerPoints.startControlPoint1;
      var startControl2 = dividerPoints.startControlPoint2;
      var divider = dividerPoints.divider;
      var dividerControl1 = dividerPoints.dividerControlPoint1;
      var dividerControl2 = dividerPoints.dividerControlPoint2;
      return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];
    }
  }, {
    key: "endpointDistance",
    value: function endpointDistance() {
      return this.start.distance(this.end);
    }
  }, {
    key: "getSkeletonPoints",
    value: function getSkeletonPoints(t) {
      var start = this.start;
      var control1 = this.controlPoint1;
      var control2 = this.controlPoint2;
      var end = this.end; // shortcuts for `t` values that are out of range

      if (t <= 0) {
        return {
          startControlPoint1: start.clone(),
          startControlPoint2: start.clone(),
          divider: start.clone(),
          dividerControlPoint1: control1.clone(),
          dividerControlPoint2: control2.clone()
        };
      }

      if (t >= 1) {
        return {
          startControlPoint1: control1.clone(),
          startControlPoint2: control2.clone(),
          divider: end.clone(),
          dividerControlPoint1: end.clone(),
          dividerControlPoint2: end.clone()
        };
      }

      var midpoint1 = new line_Line(start, control1).pointAt(t);
      var midpoint2 = new line_Line(control1, control2).pointAt(t);
      var midpoint3 = new line_Line(control2, end).pointAt(t);
      var subControl1 = new line_Line(midpoint1, midpoint2).pointAt(t);
      var subControl2 = new line_Line(midpoint2, midpoint3).pointAt(t);
      var divideLine = new line_Line(subControl1, subControl2).pointAt(t);
      return {
        startControlPoint1: midpoint1,
        startControlPoint2: subControl1,
        divider: divideLine,
        dividerControlPoint1: subControl2,
        dividerControlPoint2: midpoint3
      };
    }
  }, {
    key: "getSubdivisions",
    value: function getSubdivisions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var precision = this.getPrecision(options);
      var subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];

      if (precision === 0) {
        return subdivisions;
      }

      var previousLength = this.endpointDistance();
      var precisionRatio = Math.pow(10, -precision); // Recursively divide curve at `t = 0.5`, until the difference between
      // observed length at subsequent iterations is lower than precision.

      var iteration = 0;

      var _loop = function _loop() {
        iteration += 1;
        var divisions = [];
        subdivisions.forEach(function (c) {
          // dividing at t = 0.5 (not at middle length!)
          var divided = c.divide(0.5);
          divisions.push(divided[0], divided[1]);
        }); // measure new length

        var length = divisions.reduce(function (memo, c) {
          return memo + c.endpointDistance();
        }, 0); // check if we have reached required observed precision
        // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1
        // not a problem for further iterations because cubic curves cannot have more than two local extrema
        // (i.e. cubic curves cannot intersect the baseline more than once)
        // therefore two subsequent iterations cannot produce sampling with equal length

        var ratio = length !== 0 ? (length - previousLength) / length : 0;

        if (iteration > 1 && ratio < precisionRatio) {
          return {
            v: divisions
          };
        }

        subdivisions = divisions;
        previousLength = length;
      };

      while (true) {
        var _ret = _loop();

        if (typeof _ret === "object") return _ret.v;
      }
    }
  }, {
    key: "length",
    value: function length() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var divisions = this.getDivisions(options);
      return divisions.reduce(function (memo, c) {
        return memo + c.endpointDistance();
      }, 0);
    }
  }, {
    key: "lengthAtT",
    value: function lengthAtT(t) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (t <= 0) {
        return 0;
      }

      var precision = options.precision === undefined ? this.PRECISION : options.precision;
      var subCurve = this.divide(t)[0];
      return subCurve.length({
        precision: precision
      });
    }
  }, {
    key: "pointAt",
    value: function pointAt(ratio) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (ratio <= 0) {
        return this.start.clone();
      }

      if (ratio >= 1) {
        return this.end.clone();
      }

      var t = this.tAt(ratio, options);
      return this.pointAtT(t);
    }
  }, {
    key: "pointAtLength",
    value: function pointAtLength(length) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var t = this.tAtLength(length, options);
      return this.pointAtT(t);
    }
  }, {
    key: "pointAtT",
    value: function pointAtT(t) {
      if (t <= 0) {
        return this.start.clone();
      }

      if (t >= 1) {
        return this.end.clone();
      }

      return this.getSkeletonPoints(t).divider;
    }
  }, {
    key: "isDifferentiable",
    value: function isDifferentiable() {
      var start = this.start;
      var control1 = this.controlPoint1;
      var control2 = this.controlPoint2;
      var end = this.end;
      return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
    }
  }, {
    key: "tangentAt",
    value: function tangentAt(ratio) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!this.isDifferentiable()) return null;

      if (ratio < 0) {
        ratio = 0; // tslint:disable-line
      } else if (ratio > 1) {
        ratio = 1; // tslint:disable-line
      }

      var t = this.tAt(ratio, options);
      return this.tangentAtT(t);
    }
  }, {
    key: "tangentAtLength",
    value: function tangentAtLength(length) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this.isDifferentiable()) {
        return null;
      }

      var t = this.tAtLength(length, options);
      return this.tangentAtT(t);
    }
  }, {
    key: "tangentAtT",
    value: function tangentAtT(t) {
      if (!this.isDifferentiable()) {
        return null;
      }

      if (t < 0) {
        t = 0; // tslint:disable-line
      }

      if (t > 1) {
        t = 1; // tslint:disable-line
      }

      var skeletonPoints = this.getSkeletonPoints(t);
      var p1 = skeletonPoints.startControlPoint2;
      var p2 = skeletonPoints.dividerControlPoint1;
      var tangentStart = skeletonPoints.divider;
      var tangentLine = new line_Line(p1, p2); // move so that tangent line starts at the point requested

      tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);
      return tangentLine;
    }
  }, {
    key: "getPrecision",
    value: function getPrecision() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return options.precision == null ? this.PRECISION : options.precision;
    }
  }, {
    key: "getDivisions",
    value: function getDivisions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.subdivisions != null) {
        return options.subdivisions;
      }

      var precision = this.getPrecision(options);
      return this.getSubdivisions({
        precision: precision
      });
    }
  }, {
    key: "getOptions",
    value: function getOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var precision = this.getPrecision(options);
      var subdivisions = this.getDivisions(options);
      return {
        precision: precision,
        subdivisions: subdivisions
      };
    }
  }, {
    key: "tAt",
    value: function tAt(ratio) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (ratio <= 0) {
        return 0;
      }

      if (ratio >= 1) {
        return 1;
      }

      var opts = this.getOptions(options);
      var total = this.length(opts);
      var length = total * ratio;
      return this.tAtLength(length, opts);
    }
  }, {
    key: "tAtLength",
    value: function tAtLength(length) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var fromStart = true;

      if (length < 0) {
        fromStart = false;
        length = -length; // tslint:disable-line
      }

      var precision = this.getPrecision(options);
      var subdivisions = this.getDivisions(options);
      var opts = {
        precision: precision,
        subdivisions: subdivisions
      };
      var investigatedSubdivision = null;
      var investigatedSubdivisionStartT;
      var investigatedSubdivisionEndT;
      var baselinePointDistFromStart = 0;
      var baselinePointDistFromEnd = 0;
      var memo = 0;
      var count = subdivisions.length;
      var piece = count > 0 ? 1 / count : 0;

      for (var i = 0; i < count; i += 1) {
        var index = fromStart ? i : count - 1 - i;
        var division = subdivisions[i];
        var dist = division.endpointDistance();

        if (length <= memo + dist) {
          investigatedSubdivision = division;
          investigatedSubdivisionStartT = index * piece;
          investigatedSubdivisionEndT = (index + 1) * piece;
          baselinePointDistFromStart = fromStart ? length - memo : dist + memo - length;
          baselinePointDistFromEnd = fromStart ? dist + memo - length : length - memo;
          break;
        }

        memo += dist;
      }

      if (investigatedSubdivision == null) {
        return fromStart ? 1 : 0;
      } // note that precision affects what length is recorded
      // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)
      // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1


      var total = this.length(opts);
      var precisionRatio = Math.pow(10, -precision); // recursively divide investigated subdivision:
      // until distance between baselinePoint and closest path endpoint is within 10^(-precision)
      // then return the closest endpoint of that final subdivision

      while (true) {
        var ratio = void 0;
        ratio = total !== 0 ? baselinePointDistFromStart / total : 0;

        if (ratio < precisionRatio) {
          return investigatedSubdivisionStartT;
        }

        ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;

        if (ratio < precisionRatio) {
          return investigatedSubdivisionEndT;
        } // otherwise, set up for next iteration


        var newBaselinePointDistFromStart = void 0;
        var newBaselinePointDistFromEnd = void 0;
        var divided = investigatedSubdivision.divide(0.5);
        piece /= 2;
        var baseline1Length = divided[0].endpointDistance();
        var baseline2Length = divided[1].endpointDistance();

        if (baselinePointDistFromStart <= baseline1Length) {
          investigatedSubdivision = divided[0];
          investigatedSubdivisionEndT -= piece;
          newBaselinePointDistFromStart = baselinePointDistFromStart;
          newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;
        } else {
          investigatedSubdivision = divided[1];
          investigatedSubdivisionStartT += piece;
          newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;
          newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;
        }

        baselinePointDistFromStart = newBaselinePointDistFromStart;
        baselinePointDistFromEnd = newBaselinePointDistFromEnd;
      }
    }
  }, {
    key: "toPoints",
    value: function toPoints() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var subdivisions = this.getDivisions(options);
      var points = [subdivisions[0].start.clone()];
      subdivisions.forEach(function (c) {
        return points.push(c.end.clone());
      });
      return points;
    }
  }, {
    key: "toPolyline",
    value: function toPolyline() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new polyline_Polyline(this.toPoints(options));
    }
  }, {
    key: "scale",
    value: function scale(sx, sy, origin) {
      this.start.scale(sx, sy, origin);
      this.controlPoint1.scale(sx, sy, origin);
      this.controlPoint2.scale(sx, sy, origin);
      this.end.scale(sx, sy, origin);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      if (typeof tx === 'number') {
        this.start.translate(tx, ty);
        this.controlPoint1.translate(tx, ty);
        this.controlPoint2.translate(tx, ty);
        this.end.translate(tx, ty);
      } else {
        this.start.translate(tx);
        this.controlPoint1.translate(tx);
        this.controlPoint2.translate(tx);
        this.end.translate(tx);
      }

      return this;
    }
  }, {
    key: "equals",
    value: function equals(c) {
      return c != null && this.start.equals(c.start) && this.controlPoint1.equals(c.controlPoint1) && this.controlPoint2.equals(c.controlPoint2) && this.end.equals(c.end);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        start: this.start.toJSON(),
        controlPoint1: this.controlPoint1.toJSON(),
        controlPoint2: this.controlPoint2.toJSON(),
        end: this.end.toJSON()
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return [this.start.serialize(), this.controlPoint1.serialize(), this.controlPoint2.serialize(), this.end.serialize()].join(' ');
    }
  }]);

  return Curve;
}(geometry_Geometry);

(function (Curve) {
  function getFirstControlPoints(rhs) {
    var n = rhs.length;
    var x = []; // `x` is a solution vector.

    var tmp = [];
    var b = 2.0;
    x[0] = rhs[0] / b; // Decomposition and forward substitution.

    for (var i = 1; i < n; i += 1) {
      tmp[i] = 1 / b;
      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];
      x[i] = (rhs[i] - x[i - 1]) / b;
    }

    for (var _i = 1; _i < n; _i += 1) {
      // Backsubstitution.
      x[n - _i - 1] -= tmp[n - _i] * x[n - _i];
    }

    return x;
  }

  function getCurveControlPoints(points) {
    var knots = points.map(function (p) {
      return point_Point.clone(p);
    });
    var firstControlPoints = [];
    var secondControlPoints = [];
    var n = knots.length - 1; // Special case: Bezier curve should be a straight line.

    if (n === 1) {
      // 3P1 = 2P0 + P3
      firstControlPoints[0] = new point_Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3); // P2 = 2P1  P0

      secondControlPoints[0] = new point_Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
      return [firstControlPoints, secondControlPoints];
    } // Calculate first Bezier control points.
    // Right hand side vector.


    var rhs = []; // Set right hand side X values.

    for (var i = 1; i < n - 1; i += 1) {
      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
    }

    rhs[0] = knots[0].x + 2 * knots[1].x;
    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0; // Get first control points X-values.

    var x = getFirstControlPoints(rhs); // Set right hand side Y values.

    for (var _i2 = 1; _i2 < n - 1; _i2 += 1) {
      rhs[_i2] = 4 * knots[_i2].y + 2 * knots[_i2 + 1].y;
    }

    rhs[0] = knots[0].y + 2 * knots[1].y;
    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0; // Get first control points Y-values.

    var y = getFirstControlPoints(rhs); // Fill output arrays.

    for (var _i3 = 0; _i3 < n; _i3 += 1) {
      // First control point.
      firstControlPoints.push(new point_Point(x[_i3], y[_i3])); // Second control point.

      if (_i3 < n - 1) {
        secondControlPoints.push(new point_Point(2 * knots[_i3 + 1].x - x[_i3 + 1], 2 * knots[_i3 + 1].y - y[_i3 + 1]));
      } else {
        secondControlPoints.push(new point_Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
      }
    }

    return [firstControlPoints, secondControlPoints];
  }

  function throughPoints(points) {
    if (points == null || Array.isArray(points) && points.length < 2) {
      throw new Error('At least 2 points are required');
    }

    var controlPoints = getCurveControlPoints(points);
    var curves = [];

    for (var i = 0, ii = controlPoints[0].length; i < ii; i += 1) {
      var controlPoint1 = new point_Point(controlPoints[0][i].x, controlPoints[0][i].y);
      var controlPoint2 = new point_Point(controlPoints[1][i].x, controlPoints[1][i].y);
      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));
    }

    return curves;
  }

  Curve.throughPoints = throughPoints;
})(curve_Curve || (curve_Curve = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/path/segment.js





var segment_Segment = /*#__PURE__*/function (_Geometry) {
  Object(inherits["a" /* default */])(Segment, _Geometry);

  var _super = Object(createSuper["a" /* default */])(Segment);

  function Segment() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Segment);

    _this = _super.apply(this, arguments);
    _this.isVisible = true;
    _this.isSegment = true;
    _this.isSubpathStart = false;
    return _this;
  }

  Object(createClass["a" /* default */])(Segment, [{
    key: "closestPointT",
    value: function closestPointT(p, options) {
      if (this.closestPointNormalizedLength) {
        return this.closestPointNormalizedLength(p);
      }

      throw new Error('Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.');
    }
  }, {
    key: "lengthAtT",
    value: function lengthAtT(t, options) {
      if (t <= 0) {
        return 0;
      }

      var length = this.length();

      if (t >= 1) {
        return length;
      }

      return length * t;
    }
  }, {
    key: "divideAtT",
    value: function divideAtT(t) {
      if (this.divideAt) {
        return this.divideAt(t);
      }

      throw new Error('Neither `divideAtT` nor `divideAt` method is implemented.');
    }
  }, {
    key: "pointAtT",
    value: function pointAtT(t) {
      if (this.pointAt) {
        return this.pointAt(t);
      }

      throw new Error('Neither `pointAtT` nor `pointAt` method is implemented.');
    }
  }, {
    key: "tangentAtT",
    value: function tangentAtT(t) {
      if (this.tangentAt) {
        return this.tangentAt(t);
      }

      throw new Error('Neither `tangentAtT` nor `tangentAt` method is implemented.');
    }
  }, {
    key: "end",
    get: function get() {
      return this.endPoint;
    }
  }, {
    key: "start",
    get: function get() {
      if (this.previousSegment == null) {
        throw new Error('Missing previous segment. (This segment cannot be the ' + 'first segment of a path, or segment has not yet been ' + 'added to a path.)');
      }

      return this.previousSegment.end;
    }
  }]);

  return Segment;
}(geometry_Geometry);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/path/lineto.js







var lineto_LineTo = /*#__PURE__*/function (_Segment) {
  Object(inherits["a" /* default */])(LineTo, _Segment);

  var _super = Object(createSuper["a" /* default */])(LineTo);

  function LineTo(x, y) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, LineTo);

    _this = _super.call(this);

    if (x instanceof line_Line) {
      _this.endPoint = x.end.clone();
    } else {
      _this.endPoint = point_Point.create(x, y);
    }

    return _this;
  }

  Object(createClass["a" /* default */])(LineTo, [{
    key: "bbox",
    value: function bbox() {
      return this.line.bbox();
    }
  }, {
    key: "closestPoint",
    value: function closestPoint(p) {
      return this.line.closestPoint(p);
    }
  }, {
    key: "closestPointLength",
    value: function closestPointLength(p) {
      return this.line.closestPointLength(p);
    }
  }, {
    key: "closestPointNormalizedLength",
    value: function closestPointNormalizedLength(p) {
      return this.line.closestPointNormalizedLength(p);
    }
  }, {
    key: "closestPointTangent",
    value: function closestPointTangent(p) {
      return this.line.closestPointTangent(p);
    }
  }, {
    key: "length",
    value: function length() {
      return this.line.length();
    }
  }, {
    key: "divideAt",
    value: function divideAt(ratio) {
      var divided = this.line.divideAt(ratio);
      return [new LineTo(divided[0]), new LineTo(divided[1])];
    }
  }, {
    key: "divideAtLength",
    value: function divideAtLength(length) {
      var divided = this.line.divideAtLength(length);
      return [new LineTo(divided[0]), new LineTo(divided[1])];
    }
  }, {
    key: "getSubdivisions",
    value: function getSubdivisions() {
      return [];
    }
  }, {
    key: "pointAt",
    value: function pointAt(ratio) {
      return this.line.pointAt(ratio);
    }
  }, {
    key: "pointAtLength",
    value: function pointAtLength(length) {
      return this.line.pointAtLength(length);
    }
  }, {
    key: "tangentAt",
    value: function tangentAt(ratio) {
      return this.line.tangentAt(ratio);
    }
  }, {
    key: "tangentAtLength",
    value: function tangentAtLength(length) {
      return this.line.tangentAtLength(length);
    }
  }, {
    key: "isDifferentiable",
    value: function isDifferentiable() {
      if (this.previousSegment == null) {
        return false;
      }

      return !this.start.equals(this.end);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new LineTo(this.end);
    }
  }, {
    key: "scale",
    value: function scale(sx, sy, origin) {
      this.end.scale(sx, sy, origin);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      if (typeof tx === 'number') {
        this.end.translate(tx, ty);
      } else {
        this.end.translate(tx);
      }

      return this;
    }
  }, {
    key: "equals",
    value: function equals(s) {
      return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: this.type,
        start: this.start.toJSON(),
        end: this.end.toJSON()
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var end = this.end;
      return "".concat(this.type, " ").concat(end.x, " ").concat(end.y);
    }
  }, {
    key: "type",
    get: function get() {
      return 'L';
    }
  }, {
    key: "line",
    get: function get() {
      return new line_Line(this.start, this.end);
    }
  }]);

  return LineTo;
}(segment_Segment);

(function (LineTo) {
  function create() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var len = args.length;
    var arg0 = args[0]; // line provided

    if (arg0 instanceof line_Line) {
      return new LineTo(arg0);
    } // points provided


    if (point_Point.isPointLike(arg0)) {
      if (len === 1) {
        return new LineTo(arg0);
      } // poly-line segment


      return args.map(function (arg) {
        return new LineTo(arg);
      });
    } // coordinates provided


    if (len === 2) {
      return new LineTo(+args[0], +args[1]);
    } // poly-line segment


    var segments = [];

    for (var i = 0; i < len; i += 2) {
      var x = +args[i];
      var y = +args[i + 1];
      segments.push(new LineTo(x, y));
    }

    return segments;
  }

  LineTo.create = create;
})(lineto_LineTo || (lineto_LineTo = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/path/close.js







var close_Close = /*#__PURE__*/function (_Segment) {
  Object(inherits["a" /* default */])(Close, _Segment);

  var _super = Object(createSuper["a" /* default */])(Close);

  function Close() {
    Object(classCallCheck["a" /* default */])(this, Close);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Close, [{
    key: "bbox",
    value: function bbox() {
      return this.line.bbox();
    }
  }, {
    key: "closestPoint",
    value: function closestPoint(p) {
      return this.line.closestPoint(p);
    }
  }, {
    key: "closestPointLength",
    value: function closestPointLength(p) {
      return this.line.closestPointLength(p);
    }
  }, {
    key: "closestPointNormalizedLength",
    value: function closestPointNormalizedLength(p) {
      return this.line.closestPointNormalizedLength(p);
    }
  }, {
    key: "closestPointTangent",
    value: function closestPointTangent(p) {
      return this.line.closestPointTangent(p);
    }
  }, {
    key: "length",
    value: function length() {
      return this.line.length();
    }
  }, {
    key: "divideAt",
    value: function divideAt(ratio) {
      var divided = this.line.divideAt(ratio);
      return [// do not actually cut into the segment, first divided part can stay as Z
      divided[1].isDifferentiable() ? new lineto_LineTo(divided[0]) : this.clone(), new lineto_LineTo(divided[1])];
    }
  }, {
    key: "divideAtLength",
    value: function divideAtLength(length) {
      var divided = this.line.divideAtLength(length);
      return [divided[1].isDifferentiable() ? new lineto_LineTo(divided[0]) : this.clone(), new lineto_LineTo(divided[1])];
    }
  }, {
    key: "getSubdivisions",
    value: function getSubdivisions() {
      return [];
    }
  }, {
    key: "pointAt",
    value: function pointAt(ratio) {
      return this.line.pointAt(ratio);
    }
  }, {
    key: "pointAtLength",
    value: function pointAtLength(length) {
      return this.line.pointAtLength(length);
    }
  }, {
    key: "tangentAt",
    value: function tangentAt(ratio) {
      return this.line.tangentAt(ratio);
    }
  }, {
    key: "tangentAtLength",
    value: function tangentAtLength(length) {
      return this.line.tangentAtLength(length);
    }
  }, {
    key: "isDifferentiable",
    value: function isDifferentiable() {
      if (!this.previousSegment || !this.subpathStartSegment) {
        return false;
      }

      return !this.start.equals(this.end);
    }
  }, {
    key: "scale",
    value: function scale() {
      return this;
    }
  }, {
    key: "translate",
    value: function translate() {
      return this;
    }
  }, {
    key: "equals",
    value: function equals(s) {
      return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Close();
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: this.type,
        start: this.start.toJSON(),
        end: this.end.toJSON()
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return this.type;
    }
  }, {
    key: "end",
    get: function get() {
      if (!this.subpathStartSegment) {
        throw new Error('Missing subpath start segment. (This segment needs a subpath ' + 'start segment (e.g. MoveTo), or segment has not yet been added' + ' to a path.)');
      }

      return this.subpathStartSegment.end;
    }
  }, {
    key: "type",
    get: function get() {
      return 'Z';
    }
  }, {
    key: "line",
    get: function get() {
      return new line_Line(this.start, this.end);
    }
  }]);

  return Close;
}(segment_Segment);

(function (Close) {
  function create() {
    return new Close();
  }

  Close.create = create;
})(close_Close || (close_Close = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/path/moveto.js









var moveto_MoveTo = /*#__PURE__*/function (_Segment) {
  Object(inherits["a" /* default */])(MoveTo, _Segment);

  var _super = Object(createSuper["a" /* default */])(MoveTo);

  function MoveTo(x, y) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, MoveTo);

    _this = _super.call(this);
    _this.isVisible = false;
    _this.isSubpathStart = true;

    if (x instanceof line_Line || x instanceof curve_Curve) {
      _this.endPoint = x.end.clone();
    } else {
      _this.endPoint = point_Point.create(x, y);
    }

    return _this;
  }

  Object(createClass["a" /* default */])(MoveTo, [{
    key: "bbox",
    value: function bbox() {
      return null;
    }
  }, {
    key: "closestPoint",
    value: function closestPoint() {
      return this.end.clone();
    }
  }, {
    key: "closestPointLength",
    value: function closestPointLength() {
      return 0;
    }
  }, {
    key: "closestPointNormalizedLength",
    value: function closestPointNormalizedLength() {
      return 0;
    }
  }, {
    key: "closestPointT",
    value: function closestPointT() {
      return 1;
    }
  }, {
    key: "closestPointTangent",
    value: function closestPointTangent() {
      return null;
    }
  }, {
    key: "length",
    value: function length() {
      return 0;
    }
  }, {
    key: "lengthAtT",
    value: function lengthAtT() {
      return 0;
    }
  }, {
    key: "divideAt",
    value: function divideAt() {
      return [this.clone(), this.clone()];
    }
  }, {
    key: "divideAtLength",
    value: function divideAtLength() {
      return [this.clone(), this.clone()];
    }
  }, {
    key: "getSubdivisions",
    value: function getSubdivisions() {
      return [];
    }
  }, {
    key: "pointAt",
    value: function pointAt() {
      return this.end.clone();
    }
  }, {
    key: "pointAtLength",
    value: function pointAtLength() {
      return this.end.clone();
    }
  }, {
    key: "pointAtT",
    value: function pointAtT() {
      return this.end.clone();
    }
  }, {
    key: "tangentAt",
    value: function tangentAt() {
      return null;
    }
  }, {
    key: "tangentAtLength",
    value: function tangentAtLength() {
      return null;
    }
  }, {
    key: "tangentAtT",
    value: function tangentAtT() {
      return null;
    }
  }, {
    key: "isDifferentiable",
    value: function isDifferentiable() {
      return false;
    }
  }, {
    key: "scale",
    value: function scale(sx, sy, origin) {
      this.end.scale(sx, sy, origin);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      if (typeof tx === 'number') {
        this.end.translate(tx, ty);
      } else {
        this.end.translate(tx);
      }

      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new MoveTo(this.end);
    }
  }, {
    key: "equals",
    value: function equals(s) {
      return this.type === s.type && this.end.equals(s.end);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: this.type,
        end: this.end.toJSON()
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var end = this.end;
      return "".concat(this.type, " ").concat(end.x, " ").concat(end.y);
    }
  }, {
    key: "start",
    get: function get() {
      throw new Error('Illegal access. Moveto segments should not need a start property.');
    }
  }, {
    key: "type",
    get: function get() {
      return 'M';
    }
  }]);

  return MoveTo;
}(segment_Segment);

(function (MoveTo) {
  function create() {
    var len = arguments.length;
    var arg0 = arguments.length <= 0 ? undefined : arguments[0]; // line provided

    if (arg0 instanceof line_Line) {
      return new MoveTo(arg0);
    } // curve provided


    if (arg0 instanceof curve_Curve) {
      return new MoveTo(arg0);
    } // points provided


    if (point_Point.isPointLike(arg0)) {
      if (len === 1) {
        return new MoveTo(arg0);
      } // this is a moveto-with-subsequent-poly-line segment


      var _segments = []; // points come one by one

      for (var i = 0; i < len; i += 1) {
        if (i === 0) {
          _segments.push(new MoveTo(i < 0 || arguments.length <= i ? undefined : arguments[i]));
        } else {
          _segments.push(new lineto_LineTo(i < 0 || arguments.length <= i ? undefined : arguments[i]));
        }
      }

      return _segments;
    } // coordinates provided


    if (len === 2) {
      return new MoveTo(+(arguments.length <= 0 ? undefined : arguments[0]), +(arguments.length <= 1 ? undefined : arguments[1]));
    } // this is a moveto-with-subsequent-poly-line segment


    var segments = [];

    for (var _i = 0; _i < len; _i += 2) {
      var x = +(_i < 0 || arguments.length <= _i ? undefined : arguments[_i]);
      var y = +(_i + 1 < 0 || arguments.length <= _i + 1 ? undefined : arguments[_i + 1]);

      if (_i === 0) {
        segments.push(new MoveTo(x, y));
      } else {
        segments.push(new lineto_LineTo(x, y));
      }
    }

    return segments;
  }

  MoveTo.create = create;
})(moveto_MoveTo || (moveto_MoveTo = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/path/curveto.js







var curveto_CurveTo = /*#__PURE__*/function (_Segment) {
  Object(inherits["a" /* default */])(CurveTo, _Segment);

  var _super = Object(createSuper["a" /* default */])(CurveTo);

  function CurveTo(arg0, arg1, arg2, arg3, arg4, arg5) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, CurveTo);

    _this = _super.call(this);

    if (arg0 instanceof curve_Curve) {
      _this.controlPoint1 = arg0.controlPoint1.clone();
      _this.controlPoint2 = arg0.controlPoint2.clone();
      _this.endPoint = arg0.end.clone();
    } else if (typeof arg0 === 'number') {
      _this.controlPoint1 = new point_Point(arg0, arg1);
      _this.controlPoint2 = new point_Point(arg2, arg3);
      _this.endPoint = new point_Point(arg4, arg5);
    } else {
      _this.controlPoint1 = point_Point.create(arg0);
      _this.controlPoint2 = point_Point.create(arg1);
      _this.endPoint = point_Point.create(arg2);
    }

    return _this;
  }

  Object(createClass["a" /* default */])(CurveTo, [{
    key: "bbox",
    value: function bbox() {
      return this.curve.bbox();
    }
  }, {
    key: "closestPoint",
    value: function closestPoint(p) {
      return this.curve.closestPoint(p);
    }
  }, {
    key: "closestPointLength",
    value: function closestPointLength(p) {
      return this.curve.closestPointLength(p);
    }
  }, {
    key: "closestPointNormalizedLength",
    value: function closestPointNormalizedLength(p) {
      return this.curve.closestPointNormalizedLength(p);
    }
  }, {
    key: "closestPointTangent",
    value: function closestPointTangent(p) {
      return this.curve.closestPointTangent(p);
    }
  }, {
    key: "length",
    value: function length() {
      return this.curve.length();
    }
  }, {
    key: "divideAt",
    value: function divideAt(ratio) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // TODO: fix options
      var divided = this.curve.divideAt(ratio, options);
      return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
  }, {
    key: "divideAtLength",
    value: function divideAtLength(length) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // TODO: fix options
      var divided = this.curve.divideAtLength(length, options);
      return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
  }, {
    key: "divideAtT",
    value: function divideAtT(t) {
      var divided = this.curve.divideAtT(t);
      return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
  }, {
    key: "getSubdivisions",
    value: function getSubdivisions() {
      return [];
    }
  }, {
    key: "pointAt",
    value: function pointAt(ratio) {
      return this.curve.pointAt(ratio);
    }
  }, {
    key: "pointAtLength",
    value: function pointAtLength(length) {
      return this.curve.pointAtLength(length);
    }
  }, {
    key: "tangentAt",
    value: function tangentAt(ratio) {
      return this.curve.tangentAt(ratio);
    }
  }, {
    key: "tangentAtLength",
    value: function tangentAtLength(length) {
      return this.curve.tangentAtLength(length);
    }
  }, {
    key: "isDifferentiable",
    value: function isDifferentiable() {
      if (!this.previousSegment) {
        return false;
      }

      var start = this.start;
      var control1 = this.controlPoint1;
      var control2 = this.controlPoint2;
      var end = this.end;
      return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
    }
  }, {
    key: "scale",
    value: function scale(sx, sy, origin) {
      this.controlPoint1.scale(sx, sy, origin);
      this.controlPoint2.scale(sx, sy, origin);
      this.end.scale(sx, sy, origin);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      if (typeof tx === 'number') {
        this.controlPoint1.translate(tx, ty);
        this.controlPoint2.translate(tx, ty);
        this.end.translate(tx, ty);
      } else {
        this.controlPoint1.translate(tx);
        this.controlPoint2.translate(tx);
        this.end.translate(tx);
      }

      return this;
    }
  }, {
    key: "equals",
    value: function equals(s) {
      return this.start.equals(s.start) && this.end.equals(s.end) && this.controlPoint1.equals(s.controlPoint1) && this.controlPoint2.equals(s.controlPoint2);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new CurveTo(this.controlPoint1, this.controlPoint2, this.end);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: this.type,
        start: this.start.toJSON(),
        controlPoint1: this.controlPoint1.toJSON(),
        controlPoint2: this.controlPoint2.toJSON(),
        end: this.end.toJSON()
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      var c1 = this.controlPoint1;
      var c2 = this.controlPoint2;
      var end = this.end;
      return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ');
    }
  }, {
    key: "end",
    get: function get() {
      return this.endPoint;
    }
  }, {
    key: "type",
    get: function get() {
      return 'C';
    }
  }, {
    key: "curve",
    get: function get() {
      return new curve_Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
    }
  }]);

  return CurveTo;
}(segment_Segment);

(function (CurveTo) {
  function create() {
    var len = arguments.length;
    var arg0 = arguments.length <= 0 ? undefined : arguments[0]; // curve provided

    if (arg0 instanceof curve_Curve) {
      return new CurveTo(arg0);
    } // points provided


    if (point_Point.isPointLike(arg0)) {
      if (len === 3) {
        return new CurveTo(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);
      } // this is a poly-bezier segment


      var _segments = [];

      for (var i = 0; i < len; i += 3) {
        _segments.push(new CurveTo(i < 0 || arguments.length <= i ? undefined : arguments[i], i + 1 < 0 || arguments.length <= i + 1 ? undefined : arguments[i + 1], i + 2 < 0 || arguments.length <= i + 2 ? undefined : arguments[i + 2]));
      }

      return _segments;
    } // coordinates provided


    if (len === 6) {
      return new CurveTo(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2], arguments.length <= 3 ? undefined : arguments[3], arguments.length <= 4 ? undefined : arguments[4], arguments.length <= 5 ? undefined : arguments[5]);
    } // this is a poly-bezier segment


    var segments = [];

    for (var _i = 0; _i < len; _i += 6) {
      segments.push(new CurveTo(_i < 0 || arguments.length <= _i ? undefined : arguments[_i], _i + 1 < 0 || arguments.length <= _i + 1 ? undefined : arguments[_i + 1], _i + 2 < 0 || arguments.length <= _i + 2 ? undefined : arguments[_i + 2], _i + 3 < 0 || arguments.length <= _i + 3 ? undefined : arguments[_i + 3], _i + 4 < 0 || arguments.length <= _i + 4 ? undefined : arguments[_i + 4], _i + 5 < 0 || arguments.length <= _i + 5 ? undefined : arguments[_i + 5]));
    }

    return segments;
  }

  CurveTo.create = create;
})(curveto_CurveTo || (curveto_CurveTo = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/path/normalize.js

var spaces = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', // tslint:disable-line
'ig');
var pathValues = new RegExp( // tslint:disable-next-line
'(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');

function normalize_rotate(x, y, rad) {
  var X = x * Math.cos(rad) - y * Math.sin(rad);
  var Y = x * Math.sin(rad) + y * Math.cos(rad);
  return {
    x: X,
    y: Y
  };
}

function q2c(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;

  var _23 = 2 / 3;

  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
}

function a2c(x1, y1, rx, ry, angle, largeArcFlag, sweepFlag, x2, y2, recursive) {
  // for more information of where this math came from visit:
  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  var _120 = Math.PI * 120 / 180;

  var rad = Math.PI / 180 * (+angle || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;

  if (!recursive) {
    xy = normalize_rotate(x1, y1, -rad);
    x1 = xy.x; // tslint:disable-line

    y1 = xy.y; // tslint:disable-line

    xy = normalize_rotate(x2, y2, -rad);
    x2 = xy.x; // tslint:disable-line

    y2 = xy.y; // tslint:disable-line

    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);

    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx; // tslint:disable-line

      ry = h * ry; // tslint:disable-line
    }

    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (largeArcFlag === sweepFlag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(+((y1 - cy) / ry).toFixed(9));
    f2 = Math.asin(+((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;

    if (f1 < 0) {
      f1 = Math.PI * 2 + f1;
    }

    if (f2 < 0) {
      f2 = Math.PI * 2 + f2;
    }

    if (sweepFlag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }

    if (!sweepFlag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }

  var df = f2 - f1;

  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweepFlag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2); // tslint:disable-line

    y2 = cy + ry * Math.sin(f2); // tslint:disable-line

    res = a2c(x2, y2, rx, ry, angle, 0, sweepFlag, x2old, y2old, [f2, f2old, cx, cy]);
  }

  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * (rx * t);
  var hy = 4 / 3 * (ry * t);
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];

  if (recursive) {
    return [m2, m3, m4].concat(res);
  }

  {
    res = [m2, m3, m4].concat(res).join().split(',');
    var newres = [];
    var ii = res.length;

    for (var i = 0; i < ii; i += 1) {
      newres[i] = i % 2 ? normalize_rotate(+res[i - 1], +res[i], rad).y : normalize_rotate(+res[i], +res[i + 1], rad).x;
    }

    return newres;
  }
}

function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }

  var paramCounts = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0
  };
  var data = [];
  pathString.replace(pathCommand, function (a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(pathValues, function (a, b) {
      if (b) {
        params.push(+b);
      }

      return a;
    });

    if (name === 'm' && params.length > 2) {
      data.push([b].concat(Object(toConsumableArray["a" /* default */])(params.splice(0, 2))));
      name = 'l';
      b = b === 'm' ? 'l' : 'L'; // tslint:disable-line
    }

    var count = paramCounts[name];

    while (params.length >= count) {
      data.push([b].concat(Object(toConsumableArray["a" /* default */])(params.splice(0, count))));

      if (!count) {
        break;
      }
    }

    return a;
  });
  return data;
}

function toAbsolute(pathString) {
  var pathArray = parsePathString(pathString); // if invalid string, return 'M 0 0'

  if (!pathArray || !pathArray.length) {
    return [['M', 0, 0]];
  }

  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;

  for (var i = 0, ii = pathArray.length; i < ii; i += 1) {
    var r = [];
    res.push(r);
    var pa = pathArray[i];
    var action = pa[0];

    if (action !== action.toUpperCase()) {
      r[0] = action.toUpperCase();
      var jj = void 0;
      var j = void 0;

      switch (r[0]) {
        case 'A':
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;

        case 'V':
          r[1] = +pa[1] + y;
          break;

        case 'H':
          r[1] = +pa[1] + x;
          break;

        case 'M':
          mx = +pa[1] + x;
          my = +pa[2] + y;

          for (j = 1, jj = pa.length; j < jj; j += 1) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }

          break;

        default:
          for (j = 1, jj = pa.length; j < jj; j += 1) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }

          break;
      }
    } else {
      for (var _j = 0, _jj = pa.length; _j < _jj; _j += 1) {
        r[_j] = pa[_j];
      }
    }

    switch (r[0]) {
      case 'Z':
        x = +mx;
        y = +my;
        break;

      case 'H':
        x = r[1];
        break;

      case 'V':
        y = r[1];
        break;

      case 'M':
        mx = r[r.length - 2];
        my = r[r.length - 1];
        x = r[r.length - 2];
        y = r[r.length - 1];
        break;

      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
        break;
    }
  }

  return res;
}

function normalize(path) {
  var pathArray = toAbsolute(path);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };

  function processPath(path, d, pcom) {
    var nx;
    var ny;

    if (!path) {
      return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
    }

    if (!(path[0] in {
      T: 1,
      Q: 1
    })) {
      d.qx = null;
      d.qy = null;
    }

    switch (path[0]) {
      case 'M':
        d.X = path[1];
        d.Y = path[2];
        break;

      case 'A':
        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {
          // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters
          // "If either rx or ry is 0, then this arc is treated as a
          // straight line segment (a "lineto") joining the endpoints."
          return ['L', path[6], path[7]];
        }

        return ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));

      case 'S':
        if (pcom === 'C' || pcom === 'S') {
          // In 'S' case we have to take into account, if the previous command is C/S.
          nx = d.x * 2 - d.bx; // And reflect the previous

          ny = d.y * 2 - d.by; // command's control point relative to the current point.
        } else {
          // or some else or nothing
          nx = d.x;
          ny = d.y;
        }

        return ['C', nx, ny].concat(path.slice(1));

      case 'T':
        if (pcom === 'Q' || pcom === 'T') {
          // In 'T' case we have to take into account, if the previous command is Q/T.
          d.qx = d.x * 2 - d.qx; // And make a reflection similar

          d.qy = d.y * 2 - d.qy; // to case 'S'.
        } else {
          // or something else or nothing
          d.qx = d.x;
          d.qy = d.y;
        }

        return ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));

      case 'Q':
        d.qx = path[1];
        d.qy = path[2];
        return ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));

      case 'H':
        return ['L'].concat(path[1], d.y);

      case 'V':
        return ['L'].concat(d.x, path[1]);

      case 'L':
        break;

      case 'Z':
        break;
    }

    return path;
  }

  function fixArc(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      var pi = pp[i];

      while (pi.length) {
        // if created multiple 'C's, their original seg is saved
        commands[i] = 'A';
        i += 1; // tslint:disable-line

        pp.splice(i, 0, ['C'].concat(pi.splice(0, 6)));
      }

      pp.splice(i, 1);
      ii = pathArray.length;
    }
  }

  var commands = []; // path commands of original path p

  var prevCommand = ''; // holder for previous path command of original path

  var ii = pathArray.length;

  for (var i = 0; i < ii; i += 1) {
    var command = ''; // temporary holder for original path command

    if (pathArray[i]) {
      command = pathArray[i][0]; // save current path command
    }

    if (command !== 'C') {
      // C is not saved yet, because it may be result of conversion
      commands[i] = command; // Save current path command

      if (i > 0) {
        prevCommand = commands[i - 1]; // Get previous path command pcom
      }
    } // Previous path command is inputted to processPath


    pathArray[i] = processPath(pathArray[i], attrs, prevCommand);

    if (commands[i] !== 'A' && command === 'C') {
      commands[i] = 'C'; // 'A' is the only command
    } // which may produce multiple 'C's
    // so we have to make sure that 'C' is also 'C' in original path


    fixArc(pathArray, i); // fixArc adds also the right amount of 'A's to pcoms

    var seg = pathArray[i];
    var seglen = seg.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
  } // make sure normalized path data string starts with an M segment


  if (!pathArray[0][0] || pathArray[0][0] !== 'M') {
    pathArray.unshift(['M', 0, 0]);
  }

  return pathArray;
}
/**
 * Converts provided SVG path data string into a normalized path data string.
 *
 * The normalization uses a restricted subset of path commands; all segments
 * are translated into lineto, curveto, moveto, and closepath segments.
 *
 * Relative path commands are changed into their absolute counterparts,
 * and chaining of coordinates is disallowed.
 *
 * The function will always return a valid path data string; if an input
 * string cannot be normalized, 'M 0 0' is returned.
 */


function normalizePathData(pathData) {
  return normalize(pathData).join(',').split(',').join(' ');
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/path/path.js
















var path_Path = /*#__PURE__*/function (_Geometry) {
  Object(inherits["a" /* default */])(Path, _Geometry);

  var _super = Object(createSuper["a" /* default */])(Path);

  function Path(args) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Path);

    _this = _super.call(this);
    _this.PRECISION = 3;
    _this.segments = [];

    if (Array.isArray(args)) {
      if (args[0] instanceof line_Line || args[0] instanceof curve_Curve) {
        var previousObj = null;
        var arr = args;
        arr.forEach(function (o, i) {
          if (i === 0) {
            _this.appendSegment(Path.createSegment('M', o.start));
          }

          if (previousObj != null && !previousObj.end.equals(o.start)) {
            _this.appendSegment(Path.createSegment('M', o.start));
          }

          if (o instanceof line_Line) {
            _this.appendSegment(Path.createSegment('L', o.end));
          } else if (o instanceof curve_Curve) {
            _this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));
          }

          previousObj = o;
        });
      } else {
        var _arr = args;

        _arr.forEach(function (s) {
          if (s.isSegment) {
            _this.appendSegment(s);
          }
        });
      }
    } else if (args != null) {
      if (args instanceof line_Line) {
        _this.appendSegment(Path.createSegment('M', args.start));

        _this.appendSegment(Path.createSegment('L', args.end));
      } else if (args instanceof curve_Curve) {
        _this.appendSegment(Path.createSegment('M', args.start));

        _this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));
      } else if (args instanceof polyline_Polyline) {
        if (args.points && args.points.length) {
          args.points.forEach(function (point, index) {
            var segment = index === 0 ? Path.createSegment('M', point) : Path.createSegment('L', point);

            _this.appendSegment(segment);
          });
        }
      } else if (args.isSegment) {
        _this.appendSegment(args);
      }
    }

    return _this;
  }

  Object(createClass["a" /* default */])(Path, [{
    key: "moveTo",
    value: function moveTo() {
      var _MoveTo$create;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.appendSegment((_MoveTo$create = moveto_MoveTo.create).call.apply(_MoveTo$create, [null].concat(args)));
    }
  }, {
    key: "lineTo",
    value: function lineTo() {
      var _LineTo$create;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this.appendSegment((_LineTo$create = lineto_LineTo.create).call.apply(_LineTo$create, [null].concat(args)));
    }
  }, {
    key: "curveTo",
    value: function curveTo() {
      var _CurveTo$create;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this.appendSegment((_CurveTo$create = curveto_CurveTo.create).call.apply(_CurveTo$create, [null].concat(args)));
    }
  }, {
    key: "close",
    value: function close() {
      return this.appendSegment(close_Close.create());
    }
  }, {
    key: "bbox",
    value: function bbox() {
      var segments = this.segments;
      var count = segments.length;

      if (count === 0) {
        return null;
      }

      var bbox;

      for (var i = 0; i < count; i += 1) {
        var segment = segments[i];

        if (segment.isVisible) {
          var segmentBBox = segment.bbox();

          if (segmentBBox != null) {
            bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;
          }
        }
      }

      if (bbox != null) {
        return bbox;
      } // if the path has only invisible elements, return end point of last segment


      var lastSegment = segments[count - 1];
      return new rectangle_Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);
    }
  }, {
    key: "appendSegment",
    value: function appendSegment(seg) {
      var count = this.segments.length;
      var previousSegment = count !== 0 ? this.segments[count - 1] : null;
      var currentSegment;
      var nextSegment = null;

      if (Array.isArray(seg)) {
        for (var i = 0, ii = seg.length; i < ii; i += 1) {
          var segment = seg[i];
          currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
          this.segments.push(currentSegment);
          previousSegment = currentSegment;
        }
      } else {
        if (seg != null && seg.isSegment) {
          currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
          this.segments.push(currentSegment);
        }
      }

      return this;
    }
  }, {
    key: "insertSegment",
    value: function insertSegment(index, seg) {
      var count = this.segments.length;

      if (index < 0) {
        index = count + index + 1; // tslint:disable-line
      }

      if (index > count || index < 0) {
        throw new Error('Index out of range.');
      }

      var currentSegment;
      var previousSegment = null;
      var nextSegment = null;

      if (count !== 0) {
        if (index >= 1) {
          previousSegment = this.segments[index - 1];
          nextSegment = previousSegment.nextSegment;
        } else {
          previousSegment = null;
          nextSegment = this.segments[0];
        }
      }

      if (!Array.isArray(seg)) {
        currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
        this.segments.splice(index, 0, currentSegment);
      } else {
        for (var i = 0, ii = seg.length; i < ii; i += 1) {
          var segment = seg[i];
          currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
          this.segments.splice(index + i, 0, currentSegment);
          previousSegment = currentSegment;
        }
      }

      return this;
    }
  }, {
    key: "removeSegment",
    value: function removeSegment(index) {
      var idx = this.fixIndex(index);
      var removedSegment = this.segments.splice(idx, 1)[0];
      var previousSegment = removedSegment.previousSegment;
      var nextSegment = removedSegment.nextSegment; // link the previous and next segments together (if present)

      if (previousSegment) {
        previousSegment.nextSegment = nextSegment;
      }

      if (nextSegment) {
        nextSegment.previousSegment = previousSegment;
      }

      if (removedSegment.isSubpathStart && nextSegment) {
        this.updateSubpathStartSegment(nextSegment);
      }

      return removedSegment;
    }
  }, {
    key: "replaceSegment",
    value: function replaceSegment(index, seg) {
      var idx = this.fixIndex(index);
      var currentSegment;
      var replacedSegment = this.segments[idx];
      var previousSegment = replacedSegment.previousSegment;
      var nextSegment = replacedSegment.nextSegment;
      var updateSubpathStart = replacedSegment.isSubpathStart;

      if (!Array.isArray(seg)) {
        currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
        this.segments.splice(idx, 1, currentSegment);

        if (updateSubpathStart && currentSegment.isSubpathStart) {
          // already updated by `prepareSegment`
          updateSubpathStart = false;
        }
      } else {
        this.segments.splice(index, 1);

        for (var i = 0, ii = seg.length; i < ii; i += 1) {
          var segment = seg[i];
          currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
          this.segments.splice(index + i, 0, currentSegment);
          previousSegment = currentSegment;

          if (updateSubpathStart && currentSegment.isSubpathStart) {
            updateSubpathStart = false;
          }
        }
      }

      if (updateSubpathStart && nextSegment) {
        this.updateSubpathStartSegment(nextSegment);
      }
    }
  }, {
    key: "getSegment",
    value: function getSegment(index) {
      var idx = this.fixIndex(index);
      return this.segments[idx];
    }
  }, {
    key: "fixIndex",
    value: function fixIndex(index) {
      var length = this.segments.length;

      if (length === 0) {
        throw new Error('Path has no segments.');
      }

      var i = index;

      while (i < 0) {
        i = length + i;
      }

      if (i >= length || i < 0) {
        throw new Error('Index out of range.');
      }

      return i;
    }
  }, {
    key: "segmentAt",
    value: function segmentAt(ratio) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var index = this.segmentIndexAt(ratio, options);

      if (!index) {
        return null;
      }

      return this.getSegment(index);
    }
  }, {
    key: "segmentAtLength",
    value: function segmentAtLength(length) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var index = this.segmentIndexAtLength(length, options);
      if (!index) return null;
      return this.getSegment(index);
    }
  }, {
    key: "segmentIndexAt",
    value: function segmentIndexAt(ratio) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.segments.length === 0) {
        return null;
      }

      var rate = util_clamp(ratio, 0, 1);
      var opt = this.getOptions(options);
      var len = this.length(opt);
      var length = len * rate;
      return this.segmentIndexAtLength(length, opt);
    }
  }, {
    key: "segmentIndexAtLength",
    value: function segmentIndexAtLength(length) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var count = this.segments.length;

      if (count === 0) {
        return null;
      }

      var fromStart = true;

      if (length < 0) {
        fromStart = false;
        length = -length; // tslint:disable-line
      }

      var precision = this.getPrecision(options);
      var segmentSubdivisions = this.getSubdivisions(options);
      var memo = 0;
      var lastVisibleIndex = null;

      for (var i = 0; i < count; i += 1) {
        var index = fromStart ? i : count - 1 - i;
        var segment = this.segments[index];
        var subdivisions = segmentSubdivisions[index];
        var len = segment.length({
          precision: precision,
          subdivisions: subdivisions
        });

        if (segment.isVisible) {
          if (length <= memo + len) {
            return index;
          }

          lastVisibleIndex = index;
        }

        memo += len;
      } // If length requested is higher than the length of the path, return
      // last visible segment index. If no visible segment, return null.


      return lastVisibleIndex;
    }
  }, {
    key: "getSegmentSubdivisions",
    value: function getSegmentSubdivisions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var precision = this.getPrecision(options);
      var segmentSubdivisions = [];

      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
        var segment = this.segments[i];
        var subdivisions = segment.getSubdivisions({
          precision: precision
        });
        segmentSubdivisions.push(subdivisions);
      }

      return segmentSubdivisions;
    }
  }, {
    key: "updateSubpathStartSegment",
    value: function updateSubpathStartSegment(segment) {
      var previous = segment.previousSegment;
      var current = segment;

      while (current && !current.isSubpathStart) {
        // assign previous segment's subpath start segment to this segment
        if (previous != null) {
          current.subpathStartSegment = previous.subpathStartSegment;
        } else {
          current.subpathStartSegment = null;
        }

        previous = current;
        current = current.nextSegment;
      }
    }
  }, {
    key: "prepareSegment",
    value: function prepareSegment(segment, previousSegment, nextSegment) {
      segment.previousSegment = previousSegment;
      segment.nextSegment = nextSegment;

      if (previousSegment != null) {
        previousSegment.nextSegment = segment;
      }

      if (nextSegment != null) {
        nextSegment.previousSegment = segment;
      }

      var updateSubpathStart = segment;

      if (segment.isSubpathStart) {
        // move to
        segment.subpathStartSegment = segment;
        updateSubpathStart = nextSegment;
      } // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments


      if (updateSubpathStart != null) {
        this.updateSubpathStartSegment(updateSubpathStart);
      }

      return segment;
    }
  }, {
    key: "closestPoint",
    value: function closestPoint(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var t = this.closestPointT(p, options);

      if (!t) {
        return null;
      }

      return this.pointAtT(t);
    }
  }, {
    key: "closestPointLength",
    value: function closestPointLength(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var opts = this.getOptions(options);
      var t = this.closestPointT(p, opts);

      if (!t) {
        return 0;
      }

      return this.lengthAtT(t, opts);
    }
  }, {
    key: "closestPointNormalizedLength",
    value: function closestPointNormalizedLength(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var opts = this.getOptions(options);
      var cpLength = this.closestPointLength(p, opts);

      if (cpLength === 0) {
        return 0;
      }

      var length = this.length(opts);

      if (length === 0) {
        return 0;
      }

      return cpLength / length;
    }
  }, {
    key: "closestPointT",
    value: function closestPointT(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.segments.length === 0) {
        return null;
      }

      var precision = this.getPrecision(options);
      var segmentSubdivisions = this.getSubdivisions(options);
      var closestPointT;
      var minSquaredDistance = Infinity;

      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
        var segment = this.segments[i];
        var subdivisions = segmentSubdivisions[i];

        if (segment.isVisible) {
          var segmentClosestPointT = segment.closestPointT(p, {
            precision: precision,
            subdivisions: subdivisions
          });
          var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
          var squaredDistance = squaredLength(segmentClosestPoint, p);

          if (squaredDistance < minSquaredDistance) {
            closestPointT = {
              segmentIndex: i,
              value: segmentClosestPointT
            };
            minSquaredDistance = squaredDistance;
          }
        }
      }

      if (closestPointT) {
        return closestPointT;
      }

      return {
        segmentIndex: this.segments.length - 1,
        value: 1
      };
    }
  }, {
    key: "closestPointTangent",
    value: function closestPointTangent(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.segments.length === 0) {
        return null;
      }

      var precision = this.getPrecision(options);
      var segmentSubdivisions = this.getSubdivisions(options);
      var closestPointTangent;
      var minSquaredDistance = Infinity;

      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
        var segment = this.segments[i];
        var subdivisions = segmentSubdivisions[i];

        if (segment.isDifferentiable()) {
          var segmentClosestPointT = segment.closestPointT(p, {
            precision: precision,
            subdivisions: subdivisions
          });
          var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
          var squaredDistance = squaredLength(segmentClosestPoint, p);

          if (squaredDistance < minSquaredDistance) {
            closestPointTangent = segment.tangentAtT(segmentClosestPointT);
            minSquaredDistance = squaredDistance;
          }
        }
      }

      if (closestPointTangent) {
        return closestPointTangent;
      }

      return null;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var polylines = this.toPolylines(options);

      if (!polylines) {
        return false;
      }

      var numIntersections = 0;

      for (var i = 0, ii = polylines.length; i < ii; i += 1) {
        var polyline = polylines[i];

        if (polyline.containsPoint(p)) {
          numIntersections += 1;
        }
      } // returns `true` for odd numbers of intersections (even-odd algorithm)


      return numIntersections % 2 === 1;
    }
  }, {
    key: "pointAt",
    value: function pointAt(ratio) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.segments.length === 0) {
        return null;
      }

      if (ratio <= 0) {
        return this.start.clone();
      }

      if (ratio >= 1) {
        return this.end.clone();
      }

      var opts = this.getOptions(options);
      var pathLength = this.length(opts);
      var length = pathLength * ratio;
      return this.pointAtLength(length, opts);
    }
  }, {
    key: "pointAtLength",
    value: function pointAtLength(length) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.segments.length === 0) {
        return null;
      }

      if (length === 0) {
        return this.start.clone();
      }

      var fromStart = true;

      if (length < 0) {
        fromStart = false;
        length = -length; // tslint:disable-line
      }

      var precision = this.getPrecision(options);
      var segmentSubdivisions = this.getSubdivisions(options);
      var lastVisibleSegment;
      var memo = 0;

      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
        var index = fromStart ? i : ii - 1 - i;
        var segment = this.segments[index];
        var subdivisions = segmentSubdivisions[index];
        var d = segment.length({
          precision: precision,
          subdivisions: subdivisions
        });

        if (segment.isVisible) {
          if (length <= memo + d) {
            return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {
              precision: precision,
              subdivisions: subdivisions
            });
          }

          lastVisibleSegment = segment;
        }

        memo += d;
      } // if length requested is higher than the length of the path,
      // return last visible segment endpoint


      if (lastVisibleSegment) {
        return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;
      } // if no visible segment, return last segment end point


      var lastSegment = this.segments[this.segments.length - 1];
      return lastSegment.end.clone();
    }
  }, {
    key: "pointAtT",
    value: function pointAtT(t) {
      var segments = this.segments;
      var numSegments = segments.length;
      if (numSegments === 0) return null; // if segments is an empty array

      var segmentIndex = t.segmentIndex;
      if (segmentIndex < 0) return segments[0].pointAtT(0);

      if (segmentIndex >= numSegments) {
        return segments[numSegments - 1].pointAtT(1);
      }

      var tValue = util_clamp(t.value, 0, 1);
      return segments[segmentIndex].pointAtT(tValue);
    }
  }, {
    key: "divideAt",
    value: function divideAt(ratio) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.segments.length === 0) {
        return null;
      }

      var rate = util_clamp(ratio, 0, 1);
      var opts = this.getOptions(options);
      var len = this.length(opts);
      var length = len * rate;
      return this.divideAtLength(length, opts);
    }
  }, {
    key: "divideAtLength",
    value: function divideAtLength(length) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.segments.length === 0) {
        return null;
      }

      var fromStart = true;

      if (length < 0) {
        fromStart = false;
        length = -length; // tslint:disable-line
      }

      var precision = this.getPrecision(options);
      var segmentSubdivisions = this.getSubdivisions(options);
      var memo = 0;
      var divided;
      var dividedSegmentIndex;
      var lastValidSegment;
      var lastValidSegmentIndex;
      var t;

      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
        var _index = fromStart ? i : ii - 1 - i;

        var segment = this.getSegment(_index);
        var subdivisions = segmentSubdivisions[_index];
        var opts = {
          precision: precision,
          subdivisions: subdivisions
        };
        var len = segment.length(opts);

        if (segment.isDifferentiable()) {
          lastValidSegment = segment;
          lastValidSegmentIndex = _index;

          if (length <= memo + len) {
            dividedSegmentIndex = _index;
            divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);
            break;
          }
        }

        memo += len;
      }

      if (!lastValidSegment) {
        return null;
      }

      if (!divided) {
        dividedSegmentIndex = lastValidSegmentIndex;
        t = fromStart ? 1 : 0;
        divided = lastValidSegment.divideAtT(t);
      } // create a copy of this path and replace the identified segment with its two divided parts:


      var pathCopy = this.clone();
      var index = dividedSegmentIndex;
      pathCopy.replaceSegment(index, divided);
      var divisionStartIndex = index;
      var divisionMidIndex = index + 1;
      var divisionEndIndex = index + 2; // do not insert the part if it looks like a point

      if (!divided[0].isDifferentiable()) {
        pathCopy.removeSegment(divisionStartIndex);
        divisionMidIndex -= 1;
        divisionEndIndex -= 1;
      } // insert a Moveto segment to ensure secondPath will be valid:


      var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;
      pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));
      divisionEndIndex += 1; // do not insert the part if it looks like a point

      if (!divided[1].isDifferentiable()) {
        pathCopy.removeSegment(divisionEndIndex - 1);
        divisionEndIndex -= 1;
      } // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:


      var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;

      for (var _i = divisionEndIndex, _ii = pathCopy.segments.length; _i < _ii; _i += 1) {
        var originalSegment = this.getSegment(_i - secondPathSegmentIndexConversion);

        var _segment = pathCopy.getSegment(_i);

        if (_segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(_segment.subpathStartSegment.end)) {
          // pathCopy segment's subpathStartSegment is different from original segment's one
          // convert this Closepath segment to a Lineto and replace it in pathCopy
          var convertedSegment = Path.createSegment('L', originalSegment.end);
          pathCopy.replaceSegment(_i, convertedSegment);
        }
      } // distribute pathCopy segments into two paths and return those:


      var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));
      var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));
      return [firstPath, secondPath];
    }
  }, {
    key: "intersectionWithLine",
    value: function intersectionWithLine(line) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var polylines = this.toPolylines(options);

      if (polylines == null) {
        return null;
      }

      var intersections = null;

      for (var i = 0, ii = polylines.length; i < ii; i += 1) {
        var polyline = polylines[i];
        var intersection = line.intersect(polyline);

        if (intersection) {
          if (intersections == null) {
            intersections = [];
          }

          if (Array.isArray(intersection)) {
            var _intersections;

            (_intersections = intersections).push.apply(_intersections, Object(toConsumableArray["a" /* default */])(intersection));
          } else {
            intersections.push(intersection);
          }
        }
      }

      return intersections;
    }
  }, {
    key: "isDifferentiable",
    value: function isDifferentiable() {
      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
        var segment = this.segments[i];

        if (segment.isDifferentiable()) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "isValid",
    value: function isValid() {
      var segments = this.segments;
      var isValid = segments.length === 0 || segments[0].type === 'M';
      return isValid;
    }
  }, {
    key: "length",
    value: function length() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.segments.length === 0) {
        return 0;
      }

      var segmentSubdivisions = this.getSubdivisions(options);
      var length = 0;

      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
        var segment = this.segments[i];
        var subdivisions = segmentSubdivisions[i];
        length += segment.length({
          subdivisions: subdivisions
        });
      }

      return length;
    }
  }, {
    key: "lengthAtT",
    value: function lengthAtT(t) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var count = this.segments.length;

      if (count === 0) {
        return 0;
      }

      var segmentIndex = t.segmentIndex;

      if (segmentIndex < 0) {
        return 0;
      }

      var tValue = util_clamp(t.value, 0, 1);

      if (segmentIndex >= count) {
        segmentIndex = count - 1;
        tValue = 1;
      }

      var precision = this.getPrecision(options);
      var segmentSubdivisions = this.getSubdivisions(options);
      var length = 0;

      for (var i = 0; i < segmentIndex; i += 1) {
        var _segment2 = this.segments[i];
        var _subdivisions = segmentSubdivisions[i];
        length += _segment2.length({
          precision: precision,
          subdivisions: _subdivisions
        });
      }

      var segment = this.segments[segmentIndex];
      var subdivisions = segmentSubdivisions[segmentIndex];
      length += segment.lengthAtT(tValue, {
        precision: precision,
        subdivisions: subdivisions
      });
      return length;
    }
  }, {
    key: "tangentAt",
    value: function tangentAt(ratio) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.segments.length === 0) {
        return null;
      }

      var rate = util_clamp(ratio, 0, 1);
      var opts = this.getOptions(options);
      var len = this.length(opts);
      var length = len * rate;
      return this.tangentAtLength(length, opts);
    }
  }, {
    key: "tangentAtLength",
    value: function tangentAtLength(length) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.segments.length === 0) {
        return null;
      }

      var fromStart = true;

      if (length < 0) {
        fromStart = false;
        length = -length; // tslint:disable-line
      }

      var precision = this.getPrecision(options);
      var segmentSubdivisions = this.getSubdivisions(options);
      var lastValidSegment;
      var memo = 0;

      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {
        var index = fromStart ? i : ii - 1 - i;
        var segment = this.segments[index];
        var subdivisions = segmentSubdivisions[index];
        var len = segment.length({
          precision: precision,
          subdivisions: subdivisions
        });

        if (segment.isDifferentiable()) {
          if (length <= memo + len) {
            return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {
              precision: precision,
              subdivisions: subdivisions
            });
          }

          lastValidSegment = segment;
        }

        memo += len;
      } // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment


      if (lastValidSegment) {
        var t = fromStart ? 1 : 0;
        return lastValidSegment.tangentAtT(t);
      } // if no valid segment, return null


      return null;
    }
  }, {
    key: "tangentAtT",
    value: function tangentAtT(t) {
      var count = this.segments.length;

      if (count === 0) {
        return null;
      }

      var segmentIndex = t.segmentIndex;

      if (segmentIndex < 0) {
        return this.segments[0].tangentAtT(0);
      }

      if (segmentIndex >= count) {
        return this.segments[count - 1].tangentAtT(1);
      }

      var tValue = util_clamp(t.value, 0, 1);
      return this.segments[segmentIndex].tangentAtT(tValue);
    }
  }, {
    key: "getPrecision",
    value: function getPrecision() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return options.precision == null ? this.PRECISION : options.precision;
    }
  }, {
    key: "getSubdivisions",
    value: function getSubdivisions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.segmentSubdivisions == null) {
        var precision = this.getPrecision(options);
        return this.getSegmentSubdivisions({
          precision: precision
        });
      }

      return options.segmentSubdivisions;
    }
  }, {
    key: "getOptions",
    value: function getOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var precision = this.getPrecision(options);
      var segmentSubdivisions = this.getSubdivisions(options);
      return {
        precision: precision,
        segmentSubdivisions: segmentSubdivisions
      };
    }
  }, {
    key: "toPoints",
    value: function toPoints() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var segments = this.segments;
      var count = segments.length;

      if (count === 0) {
        return null;
      }

      var segmentSubdivisions = this.getSubdivisions(options);
      var points = [];
      var partialPoints = [];

      for (var i = 0; i < count; i += 1) {
        var segment = segments[i];

        if (segment.isVisible) {
          var divisions = segmentSubdivisions[i];

          if (divisions.length > 0) {
            divisions.forEach(function (c) {
              return partialPoints.push(c.start);
            });
          } else {
            partialPoints.push(segment.start);
          }
        } else if (partialPoints.length > 0) {
          partialPoints.push(segments[i - 1].end);
          points.push(partialPoints);
          partialPoints = [];
        }
      }

      if (partialPoints.length > 0) {
        partialPoints.push(this.end);
        points.push(partialPoints);
      }

      return points;
    }
  }, {
    key: "toPolylines",
    value: function toPolylines() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var points = this.toPoints(options);

      if (!points) {
        return null;
      }

      return points.map(function (arr) {
        return new polyline_Polyline(arr);
      });
    }
  }, {
    key: "scale",
    value: function scale(sx, sy, origin) {
      this.segments.forEach(function (s) {
        return s.scale(sx, sy, origin);
      });
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      if (typeof tx === 'number') {
        this.segments.forEach(function (s) {
          return s.translate(tx, ty);
        });
      } else {
        this.segments.forEach(function (s) {
          return s.translate(tx);
        });
      }

      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var path = new Path();
      this.segments.forEach(function (s) {
        return path.appendSegment(s.clone());
      });
      return path;
    }
  }, {
    key: "equals",
    value: function equals(p) {
      if (p == null) {
        return false;
      }

      var segments = this.segments;
      var otherSegments = p.segments;
      var count = segments.length;

      if (otherSegments.length !== count) {
        return false;
      }

      for (var i = 0; i < count; i += 1) {
        var a = segments[i];
        var b = otherSegments[i];

        if (a.type !== b.type || !a.equals(b)) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.segments.map(function (s) {
        return s.toJSON();
      });
    }
  }, {
    key: "serialize",
    value: function serialize() {
      if (!this.isValid()) {
        throw new Error('Invalid path segments.');
      }

      return this.segments.map(function (s) {
        return s.serialize();
      }).join(' ');
    }
  }, {
    key: "start",
    get: function get() {
      var segments = this.segments;
      var count = segments.length;

      if (count === 0) {
        return null;
      }

      for (var i = 0; i < count; i += 1) {
        var segment = segments[i];

        if (segment.isVisible) {
          return segment.start;
        }
      } // if no visible segment, return last segment end point


      return segments[count - 1].end;
    }
  }, {
    key: "end",
    get: function get() {
      var segments = this.segments;
      var count = segments.length;

      if (count === 0) {
        return null;
      }

      for (var i = count - 1; i >= 0; i -= 1) {
        var segment = segments[i];

        if (segment.isVisible) {
          return segment.end;
        }
      } // if no visible segment, return last segment end point


      return segments[count - 1].end;
    }
  }]);

  return Path;
}(geometry_Geometry);

(function (Path) {
  var regexSupportedData = new RegExp("^[\\s\\dLMCZz,.]*$");

  function isSupported(data) {
    if (typeof data !== 'string') {
      return false;
    }

    return regexSupportedData.test(data);
  }

  Path.isSupported = isSupported;
  Path.normalize = normalizePathData;

  function parse(pathData) {
    if (!pathData) {
      return new Path();
    }

    var path = new Path();
    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g;
    var commands = pathData.match(commandRe);

    if (commands != null) {
      for (var i = 0, ii = commands.length; i < ii; i += 1) {
        var command = commands[i];
        var argRe = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g; // args = [type, coordinate1, coordinate2...]

        var args = command.match(argRe);

        if (args != null) {
          var type = args[0];
          var coords = args.slice(1).map(function (a) {
            return +a;
          });
          var segment = createSegment.call.apply(createSegment, [null, type].concat(Object(toConsumableArray["a" /* default */])(coords)));
          path.appendSegment(segment);
        }
      }
    }

    return path;
  }

  Path.parse = parse;

  function createSegment(type) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    if (type === 'M') {
      var _MoveTo$create2;

      return (_MoveTo$create2 = moveto_MoveTo.create).call.apply(_MoveTo$create2, [null].concat(args));
    }

    if (type === 'L') {
      var _LineTo$create2;

      return (_LineTo$create2 = lineto_LineTo.create).call.apply(_LineTo$create2, [null].concat(args));
    }

    if (type === 'C') {
      var _CurveTo$create2;

      return (_CurveTo$create2 = curveto_CurveTo.create).call.apply(_CurveTo$create2, [null].concat(args));
    }

    if (type === 'z' || type === 'Z') {
      return close_Close.create();
    }

    throw new Error("Invalid path segment type \"".concat(type, "\""));
  }

  Path.createSegment = createSegment;
})(path_Path || (path_Path = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/path/index.js


// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/geometry/index.js








// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/vectorizer.js




var vectorizer_Vectorizer = /*#__PURE__*/function () {
  function Vectorizer(elem, attrs, children) {
    Object(classCallCheck["a" /* default */])(this, Vectorizer);

    if (!elem) {
      throw new TypeError('Invalid element to create vectorizer');
    }

    var node;

    if (Vectorizer.isVector(elem)) {
      node = elem.node;
    } else if (typeof elem === 'string') {
      if (elem.toLowerCase() === 'svg') {
        node = createSvgDocument();
      } else if (elem[0] === '<') {
        var svgDoc = createSvgDocument(elem); // only import the first child

        node = document.importNode(svgDoc.firstChild, true);
      } else {
        node = document.createElementNS(elem_ns.svg, elem);
      }
    } else {
      node = elem;
    }

    this.node = node;

    if (attrs) {
      this.setAttributes(attrs);
    }

    if (children) {
      this.append(children);
    }
  }

  Object(createClass["a" /* default */])(Vectorizer, [{
    key: "getTransformToElement",

    /**
     * Returns an SVGMatrix that specifies the transformation necessary
     * to convert this coordinate system into `target` coordinate system.
     */
    value: function getTransformToElement(target) {
      var ref = Vectorizer.toHTMLElement(target);
      return geom_getTransformToElement(this.node, ref);
    }
  }, {
    key: "transform",
    value: function transform(matrix, options) {
      if (matrix == null) {
        return transform_transform(this.node);
      }

      transform_transform(this.node, matrix, options);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx) {
      var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (tx == null) {
        return transform_translate(this.node);
      }

      transform_translate(this.node, tx, ty, options);
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(angle, cx, cy) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (angle == null) {
        return transform_rotate(this.node);
      }

      transform_rotate(this.node, angle, cx, cy, options);
      return this;
    }
  }, {
    key: "scale",
    value: function scale(sx, sy) {
      if (sx == null) {
        return transform_scale(this.node);
      }

      transform_scale(this.node, sx, sy);
      return this;
    }
  }, {
    key: "removeAttribute",
    value: function removeAttribute(name) {
      attr_removeAttribute(this.node, name);
      return this;
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      return attr_getAttribute(this.node, name);
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(name, value) {
      attr_setAttribute(this.node, name, value);
      return this;
    }
  }, {
    key: "setAttributes",
    value: function setAttributes(attrs) {
      attr_setAttributes(this.node, attrs);
      return this;
    }
  }, {
    key: "attr",
    value: function attr(name, value) {
      if (name == null) {
        return attr_attr(this.node);
      }

      if (typeof name === 'string' && value === undefined) {
        return attr_attr(this.node, name);
      }

      if (typeof name === 'object') {
        attr_attr(this.node, name);
      } else {
        attr_attr(this.node, name, value);
      }

      return this;
    }
  }, {
    key: "svg",
    value: function svg() {
      return this.node instanceof SVGSVGElement ? this : Vectorizer.createVector(this.node.ownerSVGElement);
    }
  }, {
    key: "defs",
    value: function defs() {
      var context = this.svg() || this;
      var defsNode = context.node.getElementsByTagName('defs')[0];

      if (defsNode) {
        return Vectorizer.createVector(defsNode);
      }

      return Vectorizer.createVector('defs').appendTo(context);
    }
  }, {
    key: "text",
    value: function text(content) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      text_text(this.node, content, options);
      return this;
    }
  }, {
    key: "tagName",
    value: function tagName() {
      return elem_tagName(this.node);
    }
  }, {
    key: "clone",
    value: function clone() {
      return Vectorizer.createVector(this.node.cloneNode(true));
    }
  }, {
    key: "remove",
    value: function remove() {
      elem_remove(this.node);
      return this;
    }
  }, {
    key: "empty",
    value: function empty() {
      elem_empty(this.node);
      return this;
    }
  }, {
    key: "append",
    value: function append(elems) {
      elem_append(this.node, Vectorizer.toHTMLElements(elems));
      return this;
    }
  }, {
    key: "prepend",
    value: function prepend(elems) {
      elem_prepend(this.node, Vectorizer.toHTMLElements(elems));
      return this;
    }
  }, {
    key: "before",
    value: function before(elems) {
      elem_before(this.node, Vectorizer.toHTMLElements(elems));
      return this;
    }
  }, {
    key: "appendTo",
    value: function appendTo(target) {
      elem_appendTo(this.node, Vectorizer.toHTMLElement(target));
      return this;
    }
  }, {
    key: "findOne",
    value: function findOne(selector) {
      var found = elem_findOne(this.node, selector);
      return found ? Vectorizer.createVector(found) : undefined;
    }
  }, {
    key: "find",
    value: function find(selector) {
      var vels = [];
      var nodes = elem_find(this.node, selector);

      if (nodes) {
        for (var i = 0, ii = nodes.length; i < ii; i += 1) {
          vels.push(Vectorizer.createVector(nodes[i]));
        }
      }

      return vels;
    }
  }, {
    key: "findParentByClass",
    value: function findParentByClass(className, terminator) {
      var node = elem_findParentByClass(this.node, className, terminator);
      return node ? Vectorizer.createVector(node) : null;
    }
  }, {
    key: "contains",
    value: function contains(child) {
      return elem_contains(this.node, child instanceof Vectorizer ? child.node : child);
    }
  }, {
    key: "children",
    value: function children() {
      var children = this.node.childNodes;
      var vels = [];

      for (var i = 0; i < children.length; i += 1) {
        var currentChild = children[i];

        if (currentChild.nodeType === 1) {
          vels.push(Vectorizer.createVector(children[i]));
        }
      }

      return vels;
    }
  }, {
    key: "index",
    value: function index() {
      return elem_index(this.node);
    }
  }, {
    key: "hasClass",
    value: function hasClass(className) {
      return class_hasClass(this.node, className);
    }
  }, {
    key: "addClass",
    value: function addClass(className) {
      class_addClass(this.node, className);
      return this;
    }
  }, {
    key: "removeClass",
    value: function removeClass(className) {
      class_removeClass(this.node, className);
      return this;
    }
  }, {
    key: "toggleClass",
    value: function toggleClass(className, stateVal) {
      class_toggleClass(this.node, className, stateVal);
      return this;
    }
  }, {
    key: "toLocalPoint",
    value: function toLocalPoint(x, y) {
      return geom_toLocalPoint(this.node, x, y);
    }
  }, {
    key: "toGeometryShape",
    value: function toGeometryShape() {
      return geom_toGeometryShape(this.node);
    }
  }, {
    key: "translateCenterToPoint",
    value: function translateCenterToPoint(p) {
      var bbox = this.getBBox({
        target: this.svg()
      });
      var center = bbox.getCenter();
      this.translate(p.x - center.x, p.y - center.y);
      return this;
    }
  }, {
    key: "translateAndAutoOrient",
    value: function translateAndAutoOrient(position, reference, target) {
      transform_translateAndAutoOrient(this.node, position, reference, target);
      return this;
    }
  }, {
    key: "animateAlongPath",
    value: function animateAlongPath(attrs, path) {
      geom_animateAlongPath(this.node, attrs, path);
      return this;
    }
    /**
     * Normalize this element's d attribute. SVGPathElements without
     * a path data attribute obtain a value of 'M 0 0'.
     */

  }, {
    key: "normalizePath",
    value: function normalizePath() {
      var tagName = this.tagName();

      if (tagName === 'path') {
        this.attr('d', path_Path.normalize(this.attr('d')));
      }

      return this;
    }
    /**
     * Returns the bounding box of the element after transformations are applied.
     * If `withoutTransformations` is `true`, transformations of the element
     * will not be considered when computing the bounding box. If `target` is
     * specified, bounding box will be computed relatively to the target element.
     */

  }, {
    key: "bbox",
    value: function bbox(withoutTransformations, target) {
      return geom_bbox(this.node, withoutTransformations, target);
    }
  }, {
    key: "getBBox",
    value: function getBBox() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return geom_getBBox(this.node, {
        recursive: options.recursive,
        target: Vectorizer.toHTMLElement(options.target)
      });
    }
    /**
     * Samples the underlying SVG element (it currently works only on
     * paths - where it is most useful anyway). Returns an array of objects
     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
     * objects represent a point on the path. This basically creates a discrete
     * representation of the path (which is possible a curve). The sampling
     * interval defines the accuracy of the sampling. In other words, we travel
     * from the beginning of the path to the end by interval distance (on the
     * path, not between the resulting points) and collect the discrete points
     * on the path. This is very useful in many situations. For example, SVG
     * does not provide a built-in mechanism to find intersections between two
     * paths. Using sampling, we can just generate bunch of points for each of
     * the path and find the closest ones from each set.
     */

  }, {
    key: "sample",
    value: function sample() {
      var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (this.node instanceof SVGPathElement) {
        return path_sample(this.node, interval);
      }

      return [];
    }
  }, {
    key: "convertToPath",
    value: function convertToPath() {
      return Vectorizer.createVector(toPath(this.node));
    }
  }, {
    key: "convertToPathData",
    value: function convertToPathData() {
      return toPathData(this.node);
    }
  }, {
    key: "id",
    get: function get() {
      return this.node.id;
    },
    set: function set(id) {
      this.node.id = id;
    }
  }]);

  return Vectorizer;
}();

(function (Vectorizer) {
  function isVector(o) {
    return o instanceof Vectorizer;
  }

  Vectorizer.isVector = isVector;

  function createVector(elem, attrs, children) {
    return new Vectorizer(elem, attrs, children);
  }

  Vectorizer.createVector = createVector;

  function createVectors(markup) {
    if (markup[0] === '<') {
      var svgDoc = createSvgDocument(markup);
      var vels = [];

      for (var i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {
        var childNode = svgDoc.childNodes[i];
        vels.push(createVector(document.importNode(childNode, true)));
      }

      return vels;
    }

    return [createVector(markup)];
  }

  Vectorizer.createVectors = createVectors;

  function toHTMLElement(elem) {
    if (elem != null) {
      if (isVector(elem)) {
        return elem.node;
      }

      return elem.nodeName && elem || elem[0];
    }

    return null;
  }

  Vectorizer.toHTMLElement = toHTMLElement;

  function toHTMLElements(elems) {
    if (Array.isArray(elems)) {
      return elems.map(function (elem) {
        return toHTMLElement(elem);
      });
    }

    return [toHTMLElement(elems)];
  }

  Vectorizer.toHTMLElements = toHTMLElements;
})(vectorizer_Vectorizer || (vectorizer_Vectorizer = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/text.js







function createTextPathNode(attrs, elem) {
  var vel = vectorizer_Vectorizer.createVector(elem);
  var textPath = vectorizer_Vectorizer.createVector('textPath');
  var d = attrs.d;

  if (d && attrs['xlink:href'] === undefined) {
    var path = vectorizer_Vectorizer.createVector('path').attr('d', d).appendTo(vel.defs());
    textPath.attr('xlink:href', "#".concat(path.id));
  }

  if (typeof attrs === 'object') {
    textPath.attr(attrs);
  }

  return textPath.node;
}

function annotateTextLine(lineNode, lineAnnotations, options) {
  var eol = options.eol;
  var baseSize = options.baseSize;
  var lineHeight = options.lineHeight;
  var maxFontSize = 0;
  var tspanNode;
  var fontMetrics = {};
  var lastJ = lineAnnotations.length - 1;

  for (var j = 0; j <= lastJ; j += 1) {
    var annotation = lineAnnotations[j];
    var fontSize = null;

    if (typeof annotation === 'object') {
      var annotationAttrs = annotation.attrs;
      var vTSpan = vectorizer_Vectorizer.createVector('tspan', annotationAttrs);
      tspanNode = vTSpan.node;
      var t = annotation.t;

      if (eol && j === lastJ) {
        t += eol;
      }

      tspanNode.textContent = t; // Per annotation className

      var annotationClass = annotationAttrs['class'];

      if (annotationClass) {
        vTSpan.addClass(annotationClass);
      } // set the list of indices of all the applied annotations
      // in the `annotations` attribute. This list is a comma
      // separated list of indices.


      if (options.includeAnnotationIndices) {
        vTSpan.attr('annotations', annotation.annotations.join(','));
      } // Check for max font size


      fontSize = parseFloat(annotationAttrs['font-size']);
      if (fontSize === undefined) fontSize = baseSize;
      if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;
    } else {
      if (eol && j === lastJ) {
        annotation += eol;
      }

      tspanNode = document.createTextNode(annotation || ' ');

      if (baseSize && baseSize > maxFontSize) {
        maxFontSize = baseSize;
      }
    }

    lineNode.appendChild(tspanNode);
  }

  if (maxFontSize) {
    fontMetrics.maxFontSize = maxFontSize;
  }

  if (lineHeight) {
    fontMetrics.lineHeight = lineHeight;
  } else if (maxFontSize) {
    fontMetrics.lineHeight = maxFontSize * 1.2;
  }

  return fontMetrics;
}

var emRegex = /em$/;

function emToPx(em, fontSize) {
  var numerical = parseFloat(em);

  if (emRegex.test(em)) {
    return numerical * fontSize;
  }

  return numerical;
}

function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {
  if (!Array.isArray(linesMetrics)) {
    return 0;
  }

  var n = linesMetrics.length;
  if (!n) return 0;
  var lineMetrics = linesMetrics[0];
  var flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
  var rLineHeights = 0;
  var lineHeightPx = emToPx(lineHeight, baseSizePx);

  for (var i = 1; i < n; i += 1) {
    lineMetrics = linesMetrics[i];
    var iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
    rLineHeights += iLineHeight;
  }

  var llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
  var dy;

  switch (alignment) {
    case 'middle':
      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
      break;

    case 'bottom':
      dy = -(0.25 * llMaxFont) - rLineHeights;
      break;

    default:
    case 'top':
      dy = 0.8 * flMaxFont;
      break;
  }

  return dy;
}

function text_text(elem, content) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  content = text_main_namespaceObject.sanitize(content); // tslint:disable-line

  var eol = options.eol;
  var textPath = options.textPath;
  var verticalAnchor = options.textVerticalAnchor;
  var namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top'; // Horizontal shift applied to all the lines but the first.

  var x = options.x;

  if (x === undefined) {
    x = elem.getAttribute('x') || 0;
  } // Annotations


  var iai = options.includeAnnotationIndices;
  var annotations = options.annotations;

  if (annotations && !Array.isArray(annotations)) {
    annotations = [annotations];
  } // Shift all the <tspan> but first by one line (`1em`)


  var defaultLineHeight = options.lineHeight;
  var autoLineHeight = defaultLineHeight === 'auto';
  var lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';
  elem_empty(elem);
  attr_attr(elem, {
    // Preserve spaces, do not consecutive spaces to get collapsed to one.
    'xml:space': 'preserve',
    // An empty text gets rendered into the DOM in webkit-based browsers.
    // In order to unify this behaviour across all browsers
    // we rather hide the text element when it's empty.
    display: content || options.displayEmpty ? null : 'none'
  }); // Set default font-size if none

  var fontSize = parseFloat(attr_attr(elem, 'font-size'));

  if (!fontSize) {
    fontSize = 16;

    if (namedVerticalAnchor || annotations) {
      attr_attr(elem, 'font-size', "".concat(fontSize));
    }
  }

  var containerNode;

  if (textPath) {
    // Now all the `<tspan>`s will be inside the `<textPath>`.
    if (typeof textPath === 'string') {
      textPath = {
        d: textPath
      };
    }

    containerNode = createTextPathNode(textPath, elem);
  } else {
    containerNode = document.createDocumentFragment();
  }

  var dy;
  var offset = 0;
  var annotatedY;
  var lines = content.split('\n');
  var linesMetrics = [];
  var lastI = lines.length - 1;

  for (var i = 0; i <= lastI; i += 1) {
    dy = lineHeight;
    var lineClassName = 'v-line';
    var lineNode = createSvgElement('tspan');
    var lineMetrics = void 0;
    var line = lines[i];

    if (line) {
      if (annotations) {
        // Find the *compacted* annotations for this line.
        var lineAnnotations = text_main_namespaceObject.annotate(line, annotations, {
          offset: -offset,
          includeAnnotationIndices: iai
        });
        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
          eol: i !== lastI && eol,
          baseSize: fontSize,
          lineHeight: autoLineHeight ? null : lineHeight,
          includeAnnotationIndices: iai
        }); // Get the line height based on the biggest font size
        // in the annotations for this line.

        var iLineHeight = lineMetrics.lineHeight;

        if (iLineHeight && autoLineHeight && i !== 0) {
          dy = iLineHeight;
        }

        if (i === 0) {
          annotatedY = lineMetrics.maxFontSize * 0.8;
        }
      } else {
        if (eol && i !== lastI) {
          line += eol;
        }

        lineNode.textContent = line;
      }
    } else {
      // Make sure the textContent is never empty. If it is, add a dummy
      // character and make it invisible, making the following lines correctly
      // relatively positioned. `dy=1em` won't work with empty lines otherwise.
      lineNode.textContent = '-';
      lineClassName += ' v-empty-line';
      var lineNodeStyle = lineNode.style;
      lineNodeStyle.fillOpacity = 0;
      lineNodeStyle.strokeOpacity = 0;

      if (annotations) {
        lineMetrics = {};
      }
    }

    if (lineMetrics) {
      linesMetrics.push(lineMetrics);
    }

    if (i > 0) {
      lineNode.setAttribute('dy', dy);
    } // Firefox requires 'x' to be set on the first line


    if (i > 0 || textPath) {
      lineNode.setAttribute('x', x);
    }

    lineNode.className.baseVal = lineClassName;
    containerNode.appendChild(lineNode);
    offset += line.length + 1; // + 1 = newline character.
  } // Y Alignment calculation


  if (namedVerticalAnchor) {
    if (annotations) {
      dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);
    } else if (verticalAnchor === 'top') {
      // A shortcut for top alignment. It does not depend on font-size nor line-height
      dy = '0.8em';
    } else {
      var rh; // remaining height

      if (lastI > 0) {
        rh = parseFloat(lineHeight) || 1;
        rh *= lastI;
        if (!emRegex.test(lineHeight)) rh /= fontSize;
      } else {
        // Single-line text
        rh = 0;
      }

      switch (verticalAnchor) {
        case 'middle':
          dy = "".concat(0.3 - rh / 2, "em");
          break;

        case 'bottom':
          dy = "".concat(-rh - 0.3, "em");
          break;
      }
    }
  } else {
    if (verticalAnchor === 0) {
      dy = '0em';
    } else if (verticalAnchor) {
      dy = verticalAnchor;
    } else {
      // No vertical anchor is defined
      dy = 0; // Backwards compatibility - we change the `y` attribute instead of `dy`.

      if (elem.getAttribute('y') == null) {
        elem.setAttribute('y', "".concat(annotatedY || '0.8em'));
      }
    }
  }

  var firstLine = containerNode.firstChild;
  firstLine.setAttribute('dy', dy);
  elem.appendChild(containerNode);
}
function breakText(text, size) {
  var styles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var width = size.width;
  var height = size.height;
  var svgDocument = options.svgDocument || createSvgElement('svg');
  var textSpan = createSvgElement('tspan');
  var textElement = createSvgElement('text');
  attr_attr(textElement, styles);
  elem_append(textElement, textSpan);
  var textNode = document.createTextNode(''); // Prevent flickering

  textElement.style.opacity = '0'; // Prevent FF from throwing an uncaught exception when `getBBox()`
  // called on element that is not in the render tree (is not measurable).
  // <tspan>.getComputedTextLength() returns always 0 in this case.
  // Note that the `textElement` resp. `textSpan` can become hidden
  // when it's appended to the DOM and a `display: none` CSS stylesheet
  // rule gets applied.

  textElement.style.display = 'block';
  textSpan.style.display = 'block';
  textSpan.appendChild(textNode);
  svgDocument.appendChild(textElement);

  if (!options.svgDocument) {
    document.body.appendChild(svgDocument);
  }

  var eol = options.eol || '\n';
  var separator = options.separator || ' ';
  var hyphen = options.hyphen ? new RegExp(options.hyphen) : /[^\w\d]/;
  var words = text.split(separator);
  var full = [];
  var lines = [];
  var p;
  var h;
  var lineHeight;

  for (var i = 0, l = 0, len = words.length; i < len; i += 1) {
    var word = words[i];

    if (!word) {
      continue;
    }

    if (eol && word.indexOf(eol) >= 0) {
      // word contains end-of-line character
      if (word.length > 1) {
        // separate word and continue cycle
        var eolWords = word.split(eol);

        for (var j = 0, jl = eolWords.length - 1; j < jl; j += 1) {
          eolWords.splice(2 * j + 1, 0, eol);
        }

        words.splice.apply(words, [i, 1].concat(Object(toConsumableArray["a" /* default */])(eolWords.filter(function (word) {
          return word !== '';
        }))));
        i -= 1;
        len = words.length;
      } else {
        // creates a new line
        l += 1;
        lines[l] = '';
      }

      continue;
    }

    textNode.data = lines[l] ? "".concat(lines[l], " ").concat(word) : word;

    if (textSpan.getComputedTextLength() <= width) {
      // the current line fits
      lines[l] = textNode.data;

      if (p || h) {
        // We were partitioning. Put rest of the word onto next line
        full[l] = true;
        l += 1; // cancel partitioning and splitting by hyphens

        p = 0;
        h = 0;
      }
    } else {
      if (!lines[l] || p) {
        var partition = !!p;
        p = word.length - 1;

        if (partition || !p) {
          // word has only one character.
          if (!p) {
            if (!lines[l]) {
              // we won't fit this text within our rect
              lines = [];
              break;
            } // partitioning didn't help on the non-empty line
            // try again, but this time start with a new line
            // cancel partitions created


            words.splice(i, 2, word + words[i + 1]); // adjust word length

            len -= 1;
            full[l] = true;
            l += 1;
            i -= 1;
            continue;
          } // move last letter to the beginning of the next word


          words[i] = word.substring(0, p);
          words[i + 1] = word.substring(p) + words[i + 1];
        } else {
          if (h) {
            // cancel splitting and put the words together again
            words.splice(i, 2, words[i] + words[i + 1]);
            h = 0;
          } else {
            var hyphenIndex = word.search(hyphen);

            if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {
              h = hyphenIndex + 1;
              p = 0;
            } // We initiate partitioning or splitting
            // split the long word into two words


            words.splice(i, 1, word.substring(0, h || p), word.substring(h || p)); // adjust words length

            len += 1;
          }

          if (l && !full[l - 1]) {
            // if the previous line is not full, try to fit max part of
            // the current word there
            l -= 1;
          }
        }

        i -= 1;
        continue;
      }

      l += 1;
      i -= 1;
    } // if size.height is defined we have to check whether the height of the entire
    // text exceeds the rect height


    if (height !== undefined) {
      if (lineHeight === undefined) {
        var heightValue = void 0; // use the same defaults as in V.prototype.text

        if (styles.lineHeight === 'auto') {
          heightValue = {
            value: 1.5,
            unit: 'em'
          };
        } else {
          heightValue = number_namespaceObject.parseCssNumeric(styles.lineHeight, ['em']) || {
            value: 1,
            unit: 'em'
          };
        }

        lineHeight = heightValue.value;

        if (heightValue.unit === 'em') {
          lineHeight *= textElement.getBBox().height;
        }
      }

      if (lineHeight * lines.length > height) {
        // remove overflowing lines
        var lastL = Math.floor(height / lineHeight) - 1;
        lines.splice(lastL + 1); // add ellipsis

        var ellipsis = options.ellipsis;
        if (!ellipsis || lastL < 0) break;
        if (typeof ellipsis !== 'string') ellipsis = "\u2026";
        var lastLine = lines[lastL];
        if (!lastLine) break;
        var k = lastLine.length;
        var lastLineWithOmission = void 0;
        var lastChar = void 0;
        var separatorChar = void 0;

        do {
          lastChar = lastLine[k];
          lastLineWithOmission = lastLine.substring(0, k);

          if (!lastChar) {
            separatorChar = typeof separator === 'string' ? separator : ' ';
            lastLineWithOmission += separatorChar;
          } else if (lastChar.match(separator)) {
            lastLineWithOmission += lastChar;
          }

          lastLineWithOmission += ellipsis;
          textNode.data = lastLineWithOmission;

          if (textSpan.getComputedTextLength() <= width) {
            lines[lastL] = lastLineWithOmission;
            break;
          }

          k -= 1;
        } while (k >= 0);

        break;
      }
    }
  }

  if (options.svgDocument) {
    // svg document was provided, remove the text element only
    svgDocument.removeChild(textElement);
  } else {
    // clean svg document
    document.body.removeChild(svgDocument);
  }

  return lines.join(eol);
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/path.js


var KAPPA = 0.551784;

function getNumbericAttribute(elem, attr) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
  var v = elem.getAttribute(attr);

  if (v == null) {
    return defaultValue;
  }

  var n = parseFloat(v);
  return isNaN(n) ? defaultValue : n;
}

function path_sample(elem) {
  var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var length = elem.getTotalLength();
  var samples = [];
  var distance = 0;
  var sample;

  while (distance < length) {
    sample = elem.getPointAtLength(distance);
    samples.push({
      distance: distance,
      x: sample.x,
      y: sample.y
    });
    distance += interval;
  }

  return samples;
}
function lineToPathData(line) {
  return ['M', getNumbericAttribute(line, 'x1'), getNumbericAttribute(line, 'y1'), 'L', getNumbericAttribute(line, 'x2'), getNumbericAttribute(line, 'y2')].join(' ');
}
function polygonToPathData(polygon) {
  var points = getPointsFromSvgElement(polygon);

  if (points.length === 0) {
    return null;
  }

  return "".concat(svgPointsToPath(points), " Z");
}
function polylineToPathData(polyline) {
  var points = getPointsFromSvgElement(polyline);

  if (points.length === 0) {
    return null;
  }

  return svgPointsToPath(points);
}

function svgPointsToPath(points) {
  var arr = points.map(function (p) {
    return "".concat(p.x, " ").concat(p.y);
  });
  return "M ".concat(arr.join(' L'));
}

function getPointsFromSvgElement(elem) {
  var points = [];
  var nodePoints = elem.points;

  if (nodePoints) {
    for (var i = 0, ii = nodePoints.numberOfItems; i < ii; i += 1) {
      points.push(nodePoints.getItem(i));
    }
  }

  return points;
}
function circleToPathData(circle) {
  var cx = getNumbericAttribute(circle, 'cx', 0);
  var cy = getNumbericAttribute(circle, 'cy', 0);
  var r = getNumbericAttribute(circle, 'r');
  var cd = r * KAPPA; // Control distance.

  return ['M', cx, cy - r, 'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, 'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, 'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, 'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, 'Z'].join(' ');
}
function ellipseToPathData(ellipse) {
  var cx = getNumbericAttribute(ellipse, 'cx', 0);
  var cy = getNumbericAttribute(ellipse, 'cy', 0);
  var rx = getNumbericAttribute(ellipse, 'rx');
  var ry = getNumbericAttribute(ellipse, 'ry') || rx;
  var cdx = rx * KAPPA; // Control distance x.

  var cdy = ry * KAPPA; // Control distance y.

  var d = ['M', cx, cy - ry, 'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, 'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, 'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, 'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, 'Z'].join(' ');
  return d;
}
function rectangleToPathData(rect) {
  return rectToPathData({
    x: getNumbericAttribute(rect, 'x', 0),
    y: getNumbericAttribute(rect, 'y', 0),
    width: getNumbericAttribute(rect, 'width', 0),
    height: getNumbericAttribute(rect, 'height', 0),
    rx: getNumbericAttribute(rect, 'rx', 0),
    ry: getNumbericAttribute(rect, 'ry', 0)
  });
}
function rectToPathData(r) {
  var d;
  var x = r.x;
  var y = r.y;
  var width = r.width;
  var height = r.height;
  var topRx = Math.min(r.rx || r['top-rx'] || 0, width / 2);
  var bottomRx = Math.min(r.rx || r['bottom-rx'] || 0, width / 2);
  var topRy = Math.min(r.ry || r['top-ry'] || 0, height / 2);
  var bottomRy = Math.min(r.ry || r['bottom-ry'] || 0, height / 2);

  if (topRx || bottomRx || topRy || bottomRy) {
    d = ['M', x, y + topRy, 'v', height - topRy - bottomRy, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy, 'h', width - 2 * bottomRx, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy, 'v', -(height - bottomRy - topRy), 'a', topRx, topRy, 0, 0, 0, -topRx, -topRy, 'h', -(width - 2 * topRx), 'a', topRx, topRy, 0, 0, 0, -topRx, topRy, 'Z'];
  } else {
    d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];
  }

  return d.join(' ');
}
function toPath(elem) {
  var path = createSvgElement('path');
  attr_attr(path, attr_attr(elem));
  var d = toPathData(elem);

  if (d) {
    path.setAttribute('d', d);
  }

  return path;
}
function toPathData(elem) {
  var tagName = elem.tagName.toLowerCase();

  switch (tagName) {
    case 'path':
      return elem.getAttribute('d');

    case 'line':
      return lineToPathData(elem);

    case 'polygon':
      return polygonToPathData(elem);

    case 'polyline':
      return polylineToPathData(elem);

    case 'ellipse':
      return ellipseToPathData(elem);

    case 'circle':
      return circleToPathData(elem);

    case 'rect':
      return rectangleToPathData(elem);
  }

  throw new Error("\"".concat(tagName, "\" cannot be converted to svg path element."));
} // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js

function createSlicePathData(innerRadius, outerRadius, startAngle, endAngle) {
  var svgArcMax = 2 * Math.PI - 1e-6;
  var r0 = innerRadius;
  var r1 = outerRadius;
  var a0 = startAngle;
  var a1 = endAngle;

  if (a1 < a0) {
    var tmp = a0;
    a0 = a1;
    a1 = tmp;
  }

  var da = a1 - a0;
  var df = da < Math.PI ? '0' : '1';
  var c0 = Math.cos(a0);
  var s0 = Math.sin(a0);
  var c1 = Math.cos(a1);
  var s1 = Math.sin(a1);
  return da >= svgArcMax ? r0 ? // tslint:disable-next-line
  'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'M0,' + r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + -r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0 + 'Z' : // tslint:disable-next-line
  'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'Z' : r0 ? // tslint:disable-next-line
  'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L' + r0 * c1 + ',' + r0 * s1 + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0 + 'Z' : // tslint:disable-next-line
  'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L0,0' + 'Z';
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/matrix.js


var matrix_svgDocument = createSvgElement('svg');
var transformRegex = /(\w+)\(([^,)]+),?([^)]+)?\)/gi;
var transformSeparatorRegex = /[ ,]+/;
var transformationListRegex = /^(\w+)\((.*)\)/;
/**
 * Returns a SVG point object initialized with the `x` and `y` coordinates.
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint
 */

function createSVGPoint(x, y) {
  var p = matrix_svgDocument.createSVGPoint();
  p.x = x;
  p.y = y;
  return p;
}
/**
 * Returns the SVG transformation matrix initialized with the given matrix.
 *
 * The given matrix is an object of the form:
 * {
 *   a: number
 *   b: number
 *   c: number
 *   d: number
 *   e: number
 *   f: number
 * }
 *
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
 */

function createSVGMatrix(matrix) {
  var mat = matrix_svgDocument.createSVGMatrix();

  if (matrix != null) {
    var source = matrix;
    var target = mat;

    for (var key in source) {
      target[key] = source[key];
    }
  }

  return mat;
}
/**
 * Returns a SVG transform object.
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform
 */

function createSVGTransform(matrix) {
  if (matrix != null) {
    if (!(matrix instanceof DOMMatrix)) {
      matrix = createSVGMatrix(matrix); // tslint:disable-line
    }

    return matrix_svgDocument.createSVGTransformFromMatrix(matrix);
  }

  return matrix_svgDocument.createSVGTransform();
}
/**
 * Returns the SVG transformation matrix built from the `transformString`.
 *
 * E.g. 'translate(10,10) scale(2,2)' will result in matrix:
 * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`
 */

function transformStringToMatrix(transform) {
  var mat = createSVGMatrix();
  var matches = transform != null && transform.match(transformRegex);

  if (!matches) {
    return mat;
  }

  for (var i = 0, n = matches.length; i < n; i += 1) {
    var transformationString = matches[i];
    var transformationMatch = transformationString.match(transformationListRegex);

    if (transformationMatch) {
      var sx = void 0;
      var sy = void 0;
      var tx = void 0;
      var ty = void 0;
      var angle = void 0;
      var ctm = createSVGMatrix();
      var args = transformationMatch[2].split(transformSeparatorRegex);

      switch (transformationMatch[1].toLowerCase()) {
        case 'scale':
          sx = parseFloat(args[0]);
          sy = args[1] === undefined ? sx : parseFloat(args[1]);
          ctm = ctm.scaleNonUniform(sx, sy);
          break;

        case 'translate':
          tx = parseFloat(args[0]);
          ty = parseFloat(args[1]);
          ctm = ctm.translate(tx, ty);
          break;

        case 'rotate':
          angle = parseFloat(args[0]);
          tx = parseFloat(args[1]) || 0;
          ty = parseFloat(args[2]) || 0;

          if (tx !== 0 || ty !== 0) {
            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);
          } else {
            ctm = ctm.rotate(angle);
          }

          break;

        case 'skewx':
          angle = parseFloat(args[0]);
          ctm = ctm.skewX(angle);
          break;

        case 'skewy':
          angle = parseFloat(args[0]);
          ctm = ctm.skewY(angle);
          break;

        case 'matrix':
          ctm.a = parseFloat(args[0]);
          ctm.b = parseFloat(args[1]);
          ctm.c = parseFloat(args[2]);
          ctm.d = parseFloat(args[3]);
          ctm.e = parseFloat(args[4]);
          ctm.f = parseFloat(args[5]);
          break;

        default:
          continue;
      }

      mat = mat.multiply(ctm);
    }
  }

  return mat;
}
function matrixToTransformString(matrix) {
  var m = matrix || {};
  var a = m.a != null ? m.a : 1;
  var b = m.b != null ? m.b : 0;
  var c = m.c != null ? m.c : 0;
  var d = m.d != null ? m.d : 1;
  var e = m.e != null ? m.e : 0;
  var f = m.f != null ? m.f : 0;
  return "matrix(".concat(a, ",").concat(b, ",").concat(c, ",").concat(d, ",").concat(e, ",").concat(f, ")");
}
function parseTransformString(transform) {
  var translation;
  var rotation;
  var scale;

  if (transform) {
    var separator = transformSeparatorRegex; // Allow reading transform string with a single matrix

    if (transform.trim().indexOf('matrix') >= 0) {
      var matrix = transformStringToMatrix(transform);
      var decomposedMatrix = decomposeMatrix(matrix);
      translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];
      rotation = [decomposedMatrix.rotation];
      scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];
      var transformations = [];

      if (translation[0] !== 0 || translation[1] !== 0) {
        transformations.push("translate(".concat(translation.join(','), ")"));
      }

      if (scale[0] !== 1 || scale[1] !== 1) {
        transformations.push("scale(".concat(scale.join(','), ")"));
      }

      if (rotation[0] !== 0) {
        transformations.push("rotate(".concat(rotation[0], ")"));
      }

      transform = transformations.join(' '); // tslint:disable-line
    } else {
      var translateMatch = transform.match(/translate\((.*?)\)/);

      if (translateMatch) {
        translation = translateMatch[1].split(separator);
      }

      var rotateMatch = transform.match(/rotate\((.*?)\)/);

      if (rotateMatch) {
        rotation = rotateMatch[1].split(separator);
      }

      var scaleMatch = transform.match(/scale\((.*?)\)/);

      if (scaleMatch) {
        scale = scaleMatch[1].split(separator);
      }
    }
  }

  var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;
  return {
    raw: transform || '',
    translation: {
      tx: translation && translation[0] ? parseInt(translation[0], 10) : 0,
      ty: translation && translation[1] ? parseInt(translation[1], 10) : 0
    },
    rotation: {
      angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,
      cx: rotation && rotation[1] ? parseInt(rotation[1], 10) : undefined,
      cy: rotation && rotation[2] ? parseInt(rotation[2], 10) : undefined
    },
    scale: {
      sx: sx,
      sy: scale && scale[1] ? parseFloat(scale[1]) : sx
    }
  };
}

function deltaTransformPoint(matrix, point) {
  var dx = point.x * matrix.a + point.y * matrix.c + 0;
  var dy = point.x * matrix.b + point.y * matrix.d + 0;
  return {
    x: dx,
    y: dy
  };
}
/**
 * Decomposes the SVG transformation matrix into separate transformations.
 *
 * Returns an object of the form:
 * {
 *   translateX: number
 *   translateY: number
 *   scaleX: number
 *   scaleY: number
 *   skewX: number
 *   skewY: number
 *   rotation: number
 * }
 *
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
 */


function decomposeMatrix(matrix) {
  // @see https://gist.github.com/2052247
  var px = deltaTransformPoint(matrix, {
    x: 0,
    y: 1
  });
  var py = deltaTransformPoint(matrix, {
    x: 1,
    y: 0
  });
  var skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;
  var skewY = 180 / Math.PI * Math.atan2(py.y, py.x);
  return {
    skewX: skewX,
    skewY: skewY,
    translateX: matrix.e,
    translateY: matrix.f,
    scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
    scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
    rotation: skewX
  };
}
function matrixToScale(matrix) {
  var a;
  var b;
  var c;
  var d;

  if (matrix) {
    a = matrix.a == null ? 1 : matrix.a;
    d = matrix.d == null ? 1 : matrix.d;
    b = matrix.b;
    c = matrix.c;
  } else {
    a = d = 1;
  }

  return {
    sx: b ? Math.sqrt(a * a + b * b) : a,
    sy: c ? Math.sqrt(c * c + d * d) : d
  };
}
function matrixToRotation(matrix) {
  var p = {
    x: 0,
    y: 1
  };

  if (matrix) {
    p = deltaTransformPoint(matrix, p);
  }

  return {
    angle: Angle.normalize(Angle.toDeg(Math.atan2(p.y, p.x)) - 90)
  };
}
function matrixToTranslation(matrix) {
  return {
    tx: matrix && matrix.e || 0,
    ty: matrix && matrix.f || 0
  };
}
/**
 * Transforms point by an SVG transformation represented by `matrix`.
 */

function transformPoint(point, matrix) {
  var ret = createSVGPoint(point.x, point.y).matrixTransform(matrix);
  return new point_Point(ret.x, ret.y);
}
/**
 * Transforms line by an SVG transformation represented by `matrix`.
 */

function transformLine(line, matrix) {
  return new line_Line(transformPoint(line.start, matrix), transformPoint(line.end, matrix));
}
/**
 * Transforms polyline by an SVG transformation represented by `matrix`.
 */

function transformPolyline(polyline, matrix) {
  var points = polyline instanceof polyline_Polyline ? polyline.points : polyline;

  if (!Array.isArray(points)) {
    points = [];
  }

  return new polyline_Polyline(points.map(function (p) {
    return transformPoint(p, matrix);
  }));
}
function transformRectangle(rect, matrix) {
  var p = matrix_svgDocument.createSVGPoint();
  p.x = rect.x;
  p.y = rect.y;
  var corner1 = p.matrixTransform(matrix);
  p.x = rect.x + rect.width;
  p.y = rect.y;
  var corner2 = p.matrixTransform(matrix);
  p.x = rect.x + rect.width;
  p.y = rect.y + rect.height;
  var corner3 = p.matrixTransform(matrix);
  p.x = rect.x;
  p.y = rect.y + rect.height;
  var corner4 = p.matrixTransform(matrix);
  var minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);
  var maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);
  var minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);
  var maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);
  return new rectangle_Rectangle(minX, minY, maxX - minX, maxY - minY);
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/geom.js






/**
 * Returns the bounding box of the element after transformations are
 * applied. If `withoutTransformations` is `true`, transformations of
 * the element will not be considered when computing the bounding box.
 * If `target` is specified, bounding box will be computed relatively
 * to the `target` element.
 */

function geom_bbox(elem, withoutTransformations, target) {
  var box;
  var ownerSVGElement = elem.ownerSVGElement; // If the element is not in the live DOM, it does not have a bounding
  // box defined and so fall back to 'zero' dimension element.

  if (!ownerSVGElement) {
    return new rectangle_Rectangle(0, 0, 0, 0);
  }

  try {
    box = elem.getBBox();
  } catch (e) {
    // Fallback for IE.
    box = {
      x: elem.clientLeft,
      y: elem.clientTop,
      width: elem.clientWidth,
      height: elem.clientHeight
    };
  }

  if (withoutTransformations) {
    return rectangle_Rectangle.create(box);
  }

  var matrix = geom_getTransformToElement(elem, target || ownerSVGElement);
  return transformRectangle(box, matrix);
}
/**
 * Returns the bounding box of the element after transformations are
 * applied. Unlike `bbox()`, this function fixes a browser implementation
 * bug to return the correct bounding box if this elemenent is a group of
 * svg elements (if `options.recursive` is specified).
 */

function geom_getBBox(elem) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var outputBBox;
  var ownerSVGElement = elem.ownerSVGElement; // If the element is not in the live DOM, it does not have a bounding box
  // defined and so fall back to 'zero' dimension element.
  // If the element is not an SVGGraphicsElement, we could not measure the
  // bounding box either

  if (!ownerSVGElement || !isSVGGraphicsElement(elem)) {
    if (isHTMLElement(elem)) {
      // If the element is a HTMLElement, return the position relative to the body
      var _getBoundingOffsetRec = getBoundingOffsetRect(elem),
          left = _getBoundingOffsetRec.left,
          top = _getBoundingOffsetRec.top,
          width = _getBoundingOffsetRec.width,
          height = _getBoundingOffsetRec.height;

      return new rectangle_Rectangle(left, top, width, height);
    }

    return new rectangle_Rectangle(0, 0, 0, 0);
  }

  var target = options.target;
  var recursive = options.recursive;

  if (!recursive) {
    try {
      outputBBox = elem.getBBox();
    } catch (e) {
      outputBBox = {
        x: elem.clientLeft,
        y: elem.clientTop,
        width: elem.clientWidth,
        height: elem.clientHeight
      };
    }

    if (!target) {
      return rectangle_Rectangle.create(outputBBox);
    } // transform like target


    var matrix = geom_getTransformToElement(elem, target);
    return transformRectangle(outputBBox, matrix);
  } // recursive


  {
    var children = elem.childNodes;
    var n = children.length;

    if (n === 0) {
      return geom_getBBox(elem, {
        target: target
      });
    }

    if (!target) {
      target = elem; // tslint:disable-line
    }

    for (var i = 0; i < n; i += 1) {
      var child = children[i];
      var childBBox = void 0;

      if (child.childNodes.length === 0) {
        childBBox = geom_getBBox(child, {
          target: target
        });
      } else {
        // if child is a group element, enter it with a recursive call
        childBBox = geom_getBBox(child, {
          target: target,
          recursive: true
        });
      }

      if (!outputBBox) {
        outputBBox = childBBox;
      } else {
        outputBBox = outputBBox.union(childBBox);
      }
    }

    return outputBBox;
  }
}
/**
 * Returns an DOMMatrix that specifies the transformation necessary
 * to convert `elem` coordinate system into `target` coordinate system.
 */

function geom_getTransformToElement(elem, target) {
  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {
    var targetCTM = target.getScreenCTM();
    var nodeCTM = elem.getScreenCTM();

    if (targetCTM && nodeCTM) {
      return targetCTM.inverse().multiply(nodeCTM);
    }
  } // Could not get actual transformation matrix


  return createSVGMatrix();
}
/**
 * Converts a global point with coordinates `x` and `y` into the
 * coordinate space of the element.
 */

function geom_toLocalPoint(elem, x, y) {
  var svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
  var p = svg.createSVGPoint();
  p.x = x;
  p.y = y;

  try {
    var ctm = svg.getScreenCTM();
    var globalPoint = p.matrixTransform(ctm.inverse());
    var globalToLocalMatrix = geom_getTransformToElement(elem, svg).inverse();
    return globalPoint.matrixTransform(globalToLocalMatrix);
  } catch (e) {
    return p;
  }
}
/**
 * Convert the SVGElement to an equivalent geometric shape. The element's
 * transformations are not taken into account.
 *
 * SVGRectElement      => Rectangle
 *
 * SVGLineElement      => Line
 *
 * SVGCircleElement    => Ellipse
 *
 * SVGEllipseElement   => Ellipse
 *
 * SVGPolygonElement   => Polyline
 *
 * SVGPolylineElement  => Polyline
 *
 * SVGPathElement      => Path
 *
 * others              => Rectangle
 */

function geom_toGeometryShape(elem) {
  var attr = function attr(name) {
    var s = elem.getAttribute(name);
    var v = s ? parseFloat(s) : 0;
    return isNaN(v) ? 0 : v;
  };

  switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {
    case 'rect':
      return new rectangle_Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));

    case 'circle':
      return new ellipse_Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'));

    case 'ellipse':
      return new ellipse_Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'));

    case 'polyline':
      {
        var points = getPointsFromSvgElement(elem);
        return new polyline_Polyline(points);
      }

    case 'polygon':
      {
        var _points = getPointsFromSvgElement(elem);

        if (_points.length > 1) {
          _points.push(_points[0]);
        }

        return new polyline_Polyline(_points);
      }

    case 'path':
      {
        var d = elem.getAttribute('d');

        if (!path_Path.isSupported(d)) {
          d = path_Path.normalize(d);
        }

        return path_Path.parse(d);
      }

    case 'line':
      return new line_Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'));
  } // Anything else is a rectangle


  return geom_getBBox(elem);
}
function getIntersection(elem, ref, target) {
  var svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
  target = target || svg; // tslint:disable-line

  var bbox = geom_getBBox(target);
  var center = bbox.getCenter();

  if (!bbox.intersectionWithLineFromCenterToPoint(ref)) {
    return undefined;
  }

  var spot;
  var tagName = elem.tagName.toLowerCase(); // Little speed up optimization for `<rect>` element. We do not do convert
  // to path element and sampling but directly calculate the intersection
  // through a transformed geometrical rectangle.

  if (tagName === 'rect') {
    var gRect = new rectangle_Rectangle(parseFloat(elem.getAttribute('x') || '0'), parseFloat(elem.getAttribute('y') || '0'), parseFloat(elem.getAttribute('width') || '0'), parseFloat(elem.getAttribute('height') || '0')); // Get the rect transformation matrix with regards to the SVG document.

    var rectMatrix = geom_getTransformToElement(elem, target);
    var rectMatrixComponents = decomposeMatrix(rectMatrix); // Rotate the rectangle back so that we can use
    // `intersectionWithLineFromCenterToPoint()`.

    var reseted = svg.createSVGTransform();
    reseted.setRotate(-rectMatrixComponents.rotation, center.x, center.y);
    var rect = transformRectangle(gRect, reseted.matrix.multiply(rectMatrix));
    spot = rectangle_Rectangle.create(rect).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);
  } else if (tagName === 'path' || tagName === 'polygon' || tagName === 'polyline' || tagName === 'circle' || tagName === 'ellipse') {
    var pathNode = tagName === 'path' ? elem : toPath(elem);
    var samples = path_sample(pathNode);
    var minDistance = Infinity;
    var closestSamples = [];

    for (var i = 0, ii = samples.length; i < ii; i += 1) {
      var _sample = samples[i]; // Convert the sample point in the local coordinate system
      // to the global coordinate system.

      var gp = createSVGPoint(_sample.x, _sample.y);
      gp = gp.matrixTransform(geom_getTransformToElement(elem, target));
      var ggp = point_Point.create(gp);
      var centerDistance = ggp.distance(center); // Penalize a higher distance to the reference point by 10%.
      // This gives better results. This is due to
      // inaccuracies introduced by rounding errors and getPointAtLength() returns.

      var refDistance = ggp.distance(ref) * 1.1;
      var distance = centerDistance + refDistance;

      if (distance < minDistance) {
        minDistance = distance;
        closestSamples = [{
          sample: _sample,
          refDistance: refDistance
        }];
      } else if (distance < minDistance + 1) {
        closestSamples.push({
          sample: _sample,
          refDistance: refDistance
        });
      }
    }

    closestSamples.sort(function (a, b) {
      return a.refDistance - b.refDistance;
    });

    if (closestSamples[0]) {
      spot = point_Point.create(closestSamples[0].sample);
    }
  }

  return spot;
}
/**
 * Animate the element along the path SVG element (or Vectorizer object).
 * `attrs` contain Animation Timing attributes describing the animation.
 */

function geom_animateAlongPath(elem, attrs, path) {
  var id = ensureId(path);
  var animate = createSvgElement('animateMotion');
  var mpath = createSvgElement('mpath');
  attr_attr(animate, attrs);
  attr_attr(mpath, {
    'xlink:href': "#".concat(id)
  });
  animate.appendChild(mpath);
  elem.appendChild(animate);

  try {
    var ani = animate;
    ani.beginElement();
  } catch (e) {
    // Fallback for IE 9.
    // Run the animation programmatically
    if (document.documentElement.getAttribute('smiling') === 'fake') {
      /* global getTargets:true, Animator:true, animators:true id2anim:true */
      // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)
      var animation = animate;
      animation.animators = [];
      var win = window;
      var animationID = animation.getAttribute('id');

      if (animationID) {
        win.id2anim[animationID] = animation;
      }

      var targets = win.getTargets(animation);

      for (var i = 0, ii = targets.length; i < ii; i += 1) {
        var target = targets[i];
        var animator = new win.Animator(animation, target, i);
        win.animators.push(animator);
        animation.animators[i] = animator;
        animator.register();
      }
    }
  }
}
function getBoundingOffsetRect(elem) {
  var left = 0;
  var top = 0;
  var width = 0;
  var height = 0;

  if (elem) {
    var current = elem;

    while (current) {
      left += current.offsetLeft;
      top += current.offsetTop;
      current = current.offsetParent;

      if (current) {
        left += parseInt(getComputedStyle(current, 'borderLeft'), 10);
        top += parseInt(getComputedStyle(current, 'borderTop'), 10);
      }
    }

    width = elem.offsetWidth;
    height = elem.offsetHeight;
  }

  return {
    left: left,
    top: top,
    width: width,
    height: height
  };
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/transform.js




function transform_transform(elem, matrix) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (matrix == null) {
    return transformStringToMatrix(attr_attr(elem, 'transform'));
  }

  if (options.absolute) {
    elem.setAttribute('transform', matrixToTransformString(matrix));
    return;
  }

  var transformList = elem.transform;
  var svgTransform = createSVGTransform(matrix);
  transformList.baseVal.appendItem(svgTransform);
}
function transform_translate(elem, tx) {
  var ty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var transformAttr = attr_attr(elem, 'transform');
  var transform = parseTransformString(transformAttr);

  if (tx == null) {
    return transform.translation;
  }

  transformAttr = transform.raw;
  transformAttr = transformAttr.replace(/translate\([^)]*\)/g, '').trim();
  var newTx = options.absolute ? tx : transform.translation.tx + tx;
  var newTy = options.absolute ? ty : transform.translation.ty + ty;
  var newTranslate = "translate(".concat(newTx, ",").concat(newTy, ")"); // Note that `translate()` is always the first transformation. This is
  // usually the desired case.

  elem.setAttribute('transform', "".concat(newTranslate, " ").concat(transformAttr).trim());
}
function transform_rotate(elem, angle, cx, cy) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var transformAttr = attr_attr(elem, 'transform');
  var transform = parseTransformString(transformAttr);

  if (angle == null) {
    return transform.rotation;
  }

  transformAttr = transform.raw;
  transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, '').trim();
  angle %= 360; // tslint:disable-line

  var newAngle = options.absolute ? angle : transform.rotation.angle + angle;
  var newOrigin = cx != null && cy != null ? ",".concat(cx, ",").concat(cy) : '';
  var newRotate = "rotate(".concat(newAngle).concat(newOrigin, ")");
  elem.setAttribute('transform', "".concat(transformAttr, " ").concat(newRotate).trim());
}
function transform_scale(elem, sx, sy) {
  var transformAttr = attr_attr(elem, 'transform');
  var transform = parseTransformString(transformAttr);

  if (sx == null) {
    return transform.scale;
  }

  sy = sy == null ? sx : sy; //tslint:disable-line

  transformAttr = transform.raw;
  transformAttr = transformAttr.replace(/scale\([^)]*\)/g, '').trim();
  var newScale = "scale(".concat(sx, ",").concat(sy, ")");
  elem.setAttribute('transform', "".concat(transformAttr, " ").concat(newScale).trim());
}
function transform_translateAndAutoOrient(elem, position, reference, target) {
  var pos = point_Point.create(position);
  var ref = point_Point.create(reference);

  if (!target) {
    var svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
    target = svg; // tslint:disable-line
  } // Clean-up previously set transformations except the scale.
  // If we didn't clean up the previous transformations then they'd
  // add up with the old ones. Scale is an exception as it doesn't
  // add up, consider: `this.scale(2).scale(2).scale(2)`. The result
  // is that the element is scaled by the factor 2, not 8.


  var s = transform_scale(elem);
  elem.setAttribute('transform', '');
  var bbox = geom_getBBox(elem, {
    target: target
  }).scale(s.sx, s.sy); // 1. Translate to origin.

  var translateToOrigin = createSVGTransform();
  translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2); // 2. Rotate around origin.

  var rotateAroundOrigin = createSVGTransform();
  var angle = pos.angleBetween(ref, pos.clone().translate(1, 0));
  if (angle) rotateAroundOrigin.setRotate(angle, 0, 0); // 3. Translate to the `position` + the offset (half my width)
  //    towards the `reference` point.

  var translateFromOrigin = createSVGTransform();
  var finalPosition = pos.clone().move(ref, bbox.width / 2);
  translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y); // 4. Get the current transformation matrix of this node

  var ctm = geom_getTransformToElement(elem, target); // 5. Apply transformations and the scale

  var transform = createSVGTransform();
  transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));
  elem.setAttribute('transform', matrixToTransformString(transform.matrix));
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/core.js






 // svg
// ---






// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/vector.js

var vector_isVector = vectorizer_Vectorizer.isVector;
var vector_createVector = vectorizer_Vectorizer.createVector;
var vector_createVectors = vectorizer_Vectorizer.createVectors;
var vector_toHTMLElement = vectorizer_Vectorizer.toHTMLElement;
var vector_toHTMLElements = vectorizer_Vectorizer.toHTMLElements;
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/main.js


// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/dom/index.js



// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/unit/index.js

var millimeterSize;
var supportedUnits = {
  px: function px(val) {
    return val;
  },
  mm: function mm(val) {
    return millimeterSize * val;
  },
  cm: function cm(val) {
    return millimeterSize * val * 10;
  },
  in: function _in(val) {
    return millimeterSize * val * 25.4;
  },
  pt: function pt(val) {
    return millimeterSize * (25.4 * val / 72);
  },
  pc: function pc(val) {
    return millimeterSize * (25.4 * val / 6);
  }
};
var unit_Unit;

(function (Unit) {
  function measure(cssWidth, cssHeight, unit) {
    var $test = jquery_default()('<div/>').css({
      display: 'inline-block',
      position: 'absolute',
      left: -15000,
      top: -15000,
      width: cssWidth + (unit || ''),
      height: cssHeight + (unit || '')
    }).appendTo(document.body);
    var size = {
      width: $test.width() || 0,
      height: $test.height() || 0
    };
    $test.remove();
    return size;
  }

  Unit.measure = measure;

  function toPx(val, unit) {
    if (millimeterSize == null) {
      millimeterSize = measure("1", "1", 'mm').width;
    }

    var convert = unit ? supportedUnits[unit] : null;

    if (convert) {
      return convert(val);
    }

    return val;
  }

  Unit.toPx = toPx;
})(unit_Unit || (unit_Unit = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/util/index.js
















// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/events.js



var events_Events = /*#__PURE__*/function () {
  function Events() {
    Object(classCallCheck["a" /* default */])(this, Events);

    this.listeners = {};
  }

  Object(createClass["a" /* default */])(Events, [{
    key: "on",
    value: function on(name, handler, context) {
      if (handler == null) {
        return this;
      }

      if (!this.listeners[name]) {
        this.listeners[name] = [];
      }

      var cache = this.listeners[name];
      cache.push(handler, context);
      return this;
    }
  }, {
    key: "once",
    value: function once(name, handler, context) {
      var _this = this;

      var cb = function cb() {
        _this.off(name, cb);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return events_Private.call([handler, context], args);
      };

      return this.on(name, cb, this);
    }
  }, {
    key: "off",
    value: function off(name, handler, context) {
      // remove all events.
      if (!(name || handler || context)) {
        this.listeners = {};
        return this;
      }

      var listeners = this.listeners;
      var names = name ? [name] : Object.keys(listeners);
      names.forEach(function (n) {
        var cache = listeners[n];

        if (!cache) {
          return;
        } // remove all events with specified name.


        if (!(handler || context)) {
          delete listeners[n];
          return;
        }

        for (var i = cache.length - 2; i >= 0; i -= 2) {
          if (!(handler && cache[i] !== handler || context && cache[i + 1] !== context)) {
            cache.splice(i, 2);
          }
        }
      });
      return this;
    }
  }, {
    key: "trigger",
    value: function trigger(name) {
      var returned = true;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (name !== '*') {
        var _list = this.listeners[name];

        if (_list != null) {
          returned = events_Private.call(_list, args);
        }
      }

      var list = this.listeners['*'];

      if (list != null) {
        return main_namespaceObject.toAsyncBoolean([returned, events_Private.call(list, [name].concat(args))]);
      }

      return returned;
    }
  }, {
    key: "emit",
    value: function emit(name) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return this.trigger.apply(this, [name].concat(args));
    }
  }]);

  return Events;
}();
var events_Private;

(function (Private) {
  function call(list, args) {
    var results = [];

    for (var i = 0; i < list.length; i += 2) {
      var handler = list[i];
      var context = list[i + 1];
      var params = Array.isArray(args) ? args : [args];
      var ret = main_namespaceObject.apply(handler, context, params);
      results.push(ret);
    }

    return main_namespaceObject.toAsyncBoolean(results);
  }

  Private.call = call;
})(events_Private || (events_Private = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/disposable.js


// import { Platform } from '../util'
// import { DomEvent } from '../dom'
var disposable_Disposable = /*#__PURE__*/function () {
  function Disposable() {
    Object(classCallCheck["a" /* default */])(this, Disposable);
  }

  Object(createClass["a" /* default */])(Disposable, [{
    key: "dispose",
    value: function dispose() {
      this._disposed = true;
    }
  }, {
    key: "disposed",
    get: function get() {
      return this._disposed === true;
    }
  }]);

  return Disposable;
}();

(function (Disposable) {
  function dispose() {
    return function (target, methodName, descriptor) {
      var raw = descriptor.value;
      var proto = target.__proto__;

      descriptor.value = function () {
        if (this.disposed) {
          return;
        }

        raw.call(this);
        proto.dispose.call(this);
      };
    };
  }

  Disposable.dispose = dispose;
})(disposable_Disposable || (disposable_Disposable = {}));
/**
 * A disposable object which delegates to a callback function.
 */


var disposable_DisposableDelegate = /*#__PURE__*/function () {
  /**
   * Construct a new disposable delegate.
   *
   * @param callback - The callback function to invoke on dispose.
   */
  function DisposableDelegate(callback) {
    Object(classCallCheck["a" /* default */])(this, DisposableDelegate);

    this.callback = callback;
  }
  /**
   * Test whether the delegate has been disposed.
   */


  Object(createClass["a" /* default */])(DisposableDelegate, [{
    key: "dispose",

    /**
     * Dispose of the delegate and invoke the callback function.
     */
    value: function dispose() {
      if (!this.callback) {
        return;
      }

      var callback = this.callback;
      this.callback = null;
      callback();
    }
  }, {
    key: "disposed",
    get: function get() {
      return !this.callback;
    }
  }]);

  return DisposableDelegate;
}();
/**
 * An object which manages a collection of disposable items.
 */

var disposable_DisposableSet = /*#__PURE__*/function () {
  /**
   * Construct a new disposable set.
   */
  function DisposableSet() {
    Object(classCallCheck["a" /* default */])(this, DisposableSet);

    this.isDisposed = false; // tslint:disable-line:variable-name

    this.items = new Set();
  }
  /**
   * Test whether the set has been disposed.
   */


  Object(createClass["a" /* default */])(DisposableSet, [{
    key: "dispose",

    /**
     * Dispose of the set and the items it contains.
     *
     * #### Notes
     * Items are disposed in the order they are added to the set.
     */
    value: function dispose() {
      if (this.isDisposed) {
        return;
      }

      this.isDisposed = true;
      this.items.forEach(function (item) {
        item.dispose();
      });
      this.items.clear();
    }
    /**
     * Test whether the set contains a specific item.
     *
     * @param item - The item of interest.
     *
     * @returns `true` if the set contains the item, `false` otherwise.
     */

  }, {
    key: "contains",
    value: function contains(item) {
      return this.items.has(item);
    }
    /**
     * Add a disposable item to the set.
     *
     * @param item - The item to add to the set.
     *
     * #### Notes
     * If the item is already contained in the set, this is a no-op.
     */

  }, {
    key: "add",
    value: function add(item) {
      this.items.add(item);
    }
    /**
     * Remove a disposable item from the set.
     *
     * @param item - The item to remove from the set.
     *
     * #### Notes
     * If the item is not contained in the set, this is a no-op.
     */

  }, {
    key: "remove",
    value: function remove(item) {
      this.items.delete(item);
    }
    /**
     * Remove all items from the set.
     */

  }, {
    key: "clear",
    value: function clear() {
      this.items.clear();
    }
  }, {
    key: "disposed",
    get: function get() {
      return this.isDisposed;
    }
  }]);

  return DisposableSet;
}();

(function (DisposableSet) {
  /**
   * Create a disposable set from an iterable of items.
   *
   * @param items - The iterable or array-like object of interest.
   *
   * @returns A new disposable initialized with the given items.
   */
  function from(items) {
    var set = new DisposableSet();
    items.forEach(function (item) {
      set.add(item);
    });
    return set;
  }

  DisposableSet.from = from;
})(disposable_DisposableSet || (disposable_DisposableSet = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/basecoat.js






var basecoat_Basecoat = /*#__PURE__*/function (_Events) {
  Object(inherits["a" /* default */])(Basecoat, _Events);

  var _super = Object(createSuper["a" /* default */])(Basecoat);

  function Basecoat() {
    Object(classCallCheck["a" /* default */])(this, Basecoat);

    return _super.apply(this, arguments);
  }

  return Basecoat;
}(events_Events);

(function (Basecoat) {
  Basecoat.dispose = disposable_Disposable.dispose;
})(basecoat_Basecoat || (basecoat_Basecoat = {}));

object_namespaceObject.applyMixins(basecoat_Basecoat, disposable_Disposable);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/disablable.js





var disablable_Disablable = /*#__PURE__*/function (_Basecoat) {
  Object(inherits["a" /* default */])(Disablable, _Basecoat);

  var _super = Object(createSuper["a" /* default */])(Disablable);

  function Disablable() {
    Object(classCallCheck["a" /* default */])(this, Disablable);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Disablable, [{
    key: "enable",
    value: function enable() {
      delete this._disabled;
    }
  }, {
    key: "disable",
    value: function disable() {
      this._disabled = true;
    }
  }, {
    key: "disabled",
    get: function get() {
      return this._disabled === true;
    }
  }]);

  return Disablable;
}(basecoat_Basecoat);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/dictionary.js





var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};


var dictionary_Dictionary = /*#__PURE__*/function (_Disposable) {
  Object(inherits["a" /* default */])(Dictionary, _Disposable);

  var _super = Object(createSuper["a" /* default */])(Dictionary);

  function Dictionary() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Dictionary);

    _this = _super.call(this);

    _this.clear();

    return _this;
  }

  Object(createClass["a" /* default */])(Dictionary, [{
    key: "clear",
    value: function clear() {
      this.map = new WeakMap();
      this.arr = [];
    }
  }, {
    key: "has",
    value: function has(key) {
      return this.map.has(key);
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.map.get(key);
    }
  }, {
    key: "set",
    value: function set(key, value) {
      this.map.set(key, value);
      this.arr.push(key);
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      var index = this.arr.indexOf(key);

      if (index >= 0) {
        this.arr.splice(index, 1);
      }

      var ret = this.map.get(key);
      this.map.delete(key);
      return ret;
    }
  }, {
    key: "each",
    value: function each(iterator) {
      var _this2 = this;

      this.arr.forEach(function (key) {
        var value = _this2.map.get(key);

        iterator(value, key);
      });
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.clear();
    }
  }]);

  return Dictionary;
}(disposable_Disposable);

__decorate([disposable_Disposable.dispose()], dictionary_Dictionary.prototype, "dispose", null);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/algorithm/priorityqueue.js



/**
 * An implementation of the Priority Queue abstract data type.
 *
 * @see: http://en.wikipedia.org/wiki/Priority_queue
 *
 * It is like a normal stack or queue, but where each item has assigned a
 * priority (a number). Items with higher priority are served before items
 * with lower priority. This implementation uses binary heap as an internal
 * representation of the queue. The time complexity of all the methods is as
 * follows:
 *
 * - create: `O(n)`
 * - insert: `O(log n)`
 * - remove: `O(log n)`
 * - peek: `O(1)`
 * - isEmpty: `O(1)`
 * - peekPriority: `O(1)`
 */
var priorityqueue_PriorityQueue = /*#__PURE__*/function () {
  function PriorityQueue() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, PriorityQueue);

    this.comparator = options.comparator || PriorityQueue.defaultComparator;
    this.index = {};
    this.data = options.data || [];
    this.heapify();
  }
  /**
   * Returns `true` if the priority queue is empty, `false` otherwise.
   */


  Object(createClass["a" /* default */])(PriorityQueue, [{
    key: "isEmpty",
    value: function isEmpty() {
      return 0 === this.data.length;
    }
    /**
     * Inserts a value with priority to the queue. Optionally pass a unique
     * id of this item. Passing unique IDs for each item you insert allows
     * you to use the `updatePriority()` operation.
     * @param priority
     * @param value
     * @param id
     */

  }, {
    key: "insert",
    value: function insert(priority, value, id) {
      var item = {
        priority: priority,
        value: value
      };
      var index = this.data.length - 1;

      if (id) {
        item.id = id;
        this.index[id] = index;
      }

      this.data.push(item);
      this.bubbleUp(index);
      return this;
    }
    /**
     * Returns the value of an item with the highest priority.
     */

  }, {
    key: "peek",
    value: function peek() {
      return this.data[0] ? this.data[0].value : null;
    }
    /**
     * Returns the highest priority in the queue.
     */

  }, {
    key: "peekPriority",
    value: function peekPriority() {
      return this.data[0] ? this.data[0].priority : null;
    }
  }, {
    key: "updatePriority",
    value: function updatePriority(id, priority) {
      var index = this.index[id];

      if (typeof index === 'undefined') {
        throw new Error("Node with id '".concat(id, "' was not found in the heap."));
      }

      var data = this.data;
      var oldPriority = data[index].priority;
      var comp = this.comparator(priority, oldPriority);

      if (comp < 0) {
        data[index].priority = priority;
        this.bubbleUp(index);
      } else if (comp > 0) {
        data[index].priority = priority;
        this.bubbleDown(index);
      }
    }
    /**
     * Removes the item with the highest priority from the queue
     *
     * @returns The value of the removed item.
     */

  }, {
    key: "remove",
    value: function remove() {
      var data = this.data;
      var peek = data[0];
      var last = data.pop();
      delete this.index[data.length];

      if (data.length > 0) {
        data[0] = last;

        if (last.id) {
          this.index[last.id] = 0;
        }

        this.bubbleDown(0);
      }

      return peek ? peek.value : null;
    }
  }, {
    key: "heapify",
    value: function heapify() {
      for (var i = 0; i < this.data.length; i += 1) {
        this.bubbleUp(i);
      }
    }
  }, {
    key: "bubbleUp",
    value: function bubbleUp(index) {
      var data = this.data;
      var tmp;
      var parent;
      var current = index;

      while (current > 0) {
        parent = current - 1 >>> 1;

        if (this.comparator(data[current].priority, data[parent].priority) < 0) {
          tmp = data[parent];
          data[parent] = data[current];
          var id = data[current].id;

          if (id != null) {
            this.index[id] = parent;
          }

          data[current] = tmp;
          id = data[current].id;

          if (id != null) {
            this.index[id] = current;
          }

          current = parent;
        } else {
          break;
        }
      }
    }
  }, {
    key: "bubbleDown",
    value: function bubbleDown(index) {
      var data = this.data;
      var last = data.length - 1;
      var current = index;

      while (true) {
        var left = (current << 1) + 1;
        var right = left + 1;
        var minIndex = current;

        if (left <= last && this.comparator(data[left].priority, data[minIndex].priority) < 0) {
          minIndex = left;
        }

        if (right <= last && this.comparator(data[right].priority, data[minIndex].priority) < 0) {
          minIndex = right;
        }

        if (minIndex !== current) {
          var tmp = data[minIndex];
          data[minIndex] = data[current];
          var id = data[current].id;

          if (id != null) {
            this.index[id] = minIndex;
          }

          data[current] = tmp;
          id = data[current].id;

          if (id != null) {
            this.index[id] = current;
          }

          current = minIndex;
        } else {
          break;
        }
      }
    }
  }]);

  return PriorityQueue;
}();

(function (PriorityQueue) {
  PriorityQueue.defaultComparator = function (a, b) {
    return a - b;
  };
})(priorityqueue_PriorityQueue || (priorityqueue_PriorityQueue = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/algorithm/dijkstra.js

var dijkstra_Dijkstra;

(function (Dijkstra) {
  function run(adjacencyList, source) {
    var weight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (u, v) {
      return 1;
    };
    var dist = {};
    var previous = {};
    var scanned = {};
    var queue = new priorityqueue_PriorityQueue();
    dist[source] = 0;

    for (var v in adjacencyList) {
      if (v !== source) {
        dist[v] = Infinity;
      }

      queue.insert(dist[v], v, v);
    }

    while (!queue.isEmpty()) {
      var u = queue.remove();
      scanned[u] = true;
      var neighbours = adjacencyList[u] || [];

      for (var i = 0; i < neighbours.length; i += 1) {
        var _v = neighbours[i];

        if (!scanned[_v]) {
          var alt = dist[u] + weight(u, _v);

          if (alt < dist[_v]) {
            dist[_v] = alt;
            previous[_v] = u;
            queue.updatePriority(_v, alt);
          }
        }
      }
    }

    return previous;
  }

  Dijkstra.run = run;
})(dijkstra_Dijkstra || (dijkstra_Dijkstra = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/algorithm/index.js


// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/animation/timing.js
var Timing;

(function (Timing) {
  Timing.linear = function (t) {
    return t;
  };

  Timing.quad = function (t) {
    return t * t;
  };

  Timing.cubic = function (t) {
    return t * t * t;
  };

  Timing.inout = function (t) {
    if (t <= 0) {
      return 0;
    }

    if (t >= 1) {
      return 1;
    }

    var t2 = t * t;
    var t3 = t2 * t;
    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
  };

  Timing.exponential = function (t) {
    return Math.pow(2, 10 * (t - 1));
  };

  Timing.bounce = function (t) {
    for (var a = 0, b = 1; 1; a += b, b /= 2) {
      if (t >= (7 - 4 * a) / 11) {
        var q = (11 - 6 * a - 11 * t) / 4;
        return -q * q + b * b;
      }
    }
  };
})(Timing || (Timing = {}));

(function (Timing) {
  Timing.decorators = {
    reverse: function reverse(f) {
      return function (t) {
        return 1 - f(1 - t);
      };
    },
    reflect: function reflect(f) {
      return function (t) {
        return 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
      };
    },
    clamp: function clamp(f) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      return function (t) {
        var r = f(t);
        return r < n ? n : r > x ? x : r;
      };
    },
    back: function back() {
      var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.70158;
      return function (t) {
        return t * t * ((s + 1) * t - s);
      };
    },
    elastic: function elastic() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.5;
      return function (t) {
        return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);
      };
    }
  };
})(Timing || (Timing = {}));

(function (Timing) {
  // Slight acceleration from zero to full speed
  function easeInSine(t) {
    return -1 * Math.cos(t * (Math.PI / 2)) + 1;
  }

  Timing.easeInSine = easeInSine; // Slight deceleration at the end

  function easeOutSine(t) {
    return Math.sin(t * (Math.PI / 2));
  }

  Timing.easeOutSine = easeOutSine; // Slight acceleration at beginning and slight deceleration at end

  function easeInOutSine(t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
  }

  Timing.easeInOutSine = easeInOutSine; // Accelerating from zero velocity

  function easeInQuad(t) {
    return t * t;
  }

  Timing.easeInQuad = easeInQuad; // Decelerating to zero velocity

  function easeOutQuad(t) {
    return t * (2 - t);
  }

  Timing.easeOutQuad = easeOutQuad; // Acceleration until halfway, then deceleration

  function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }

  Timing.easeInOutQuad = easeInOutQuad; // Accelerating from zero velocity

  function easeInCubic(t) {
    return t * t * t;
  }

  Timing.easeInCubic = easeInCubic; // Decelerating to zero velocity

  function easeOutCubic(t) {
    var t1 = t - 1;
    return t1 * t1 * t1 + 1;
  }

  Timing.easeOutCubic = easeOutCubic; // Acceleration until halfway, then deceleration

  function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  }

  Timing.easeInOutCubic = easeInOutCubic; // Accelerating from zero velocity

  function easeInQuart(t) {
    return t * t * t * t;
  }

  Timing.easeInQuart = easeInQuart; // Decelerating to zero velocity

  function easeOutQuart(t) {
    var t1 = t - 1;
    return 1 - t1 * t1 * t1 * t1;
  }

  Timing.easeOutQuart = easeOutQuart; // Acceleration until halfway, then deceleration

  function easeInOutQuart(t) {
    var t1 = t - 1;
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * t1 * t1 * t1 * t1;
  }

  Timing.easeInOutQuart = easeInOutQuart; // Accelerating from zero velocity

  function easeInQuint(t) {
    return t * t * t * t * t;
  }

  Timing.easeInQuint = easeInQuint; // Decelerating to zero velocity

  function easeOutQuint(t) {
    var t1 = t - 1;
    return 1 + t1 * t1 * t1 * t1 * t1;
  }

  Timing.easeOutQuint = easeOutQuint; // Acceleration until halfway, then deceleration

  function easeInOutQuint(t) {
    var t1 = t - 1;
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * t1 * t1 * t1 * t1 * t1;
  }

  Timing.easeInOutQuint = easeInOutQuint; // Accelerate exponentially until finish

  function easeInExpo(t) {
    if (t === 0) {
      return 0;
    }

    return Math.pow(2, 10 * (t - 1));
  }

  Timing.easeInExpo = easeInExpo; // Initial exponential acceleration slowing to stop

  function easeOutExpo(t) {
    if (t === 1) {
      return 1;
    }

    return -Math.pow(2, -10 * t) + 1;
  }

  Timing.easeOutExpo = easeOutExpo; // Exponential acceleration and deceleration

  function easeInOutExpo(t) {
    if (t === 0 || t === 1) {
      return t;
    }

    var scaledTime = t * 2;
    var scaledTime1 = scaledTime - 1;

    if (scaledTime < 1) {
      return 0.5 * Math.pow(2, 10 * scaledTime1);
    }

    return 0.5 * (-Math.pow(2, -10 * scaledTime1) + 2);
  }

  Timing.easeInOutExpo = easeInOutExpo; // Increasing velocity until stop

  function easeInCirc(t) {
    var scaledTime = t / 1;
    return -1 * (Math.sqrt(1 - scaledTime * t) - 1);
  }

  Timing.easeInCirc = easeInCirc; // Start fast, decreasing velocity until stop

  function easeOutCirc(t) {
    var t1 = t - 1;
    return Math.sqrt(1 - t1 * t1);
  }

  Timing.easeOutCirc = easeOutCirc; // Fast increase in velocity, fast decrease in velocity

  function easeInOutCirc(t) {
    var scaledTime = t * 2;
    var scaledTime1 = scaledTime - 2;

    if (scaledTime < 1) {
      return -0.5 * (Math.sqrt(1 - scaledTime * scaledTime) - 1);
    }

    return 0.5 * (Math.sqrt(1 - scaledTime1 * scaledTime1) + 1);
  }

  Timing.easeInOutCirc = easeInOutCirc; // Slow movement backwards then fast snap to finish

  function easeInBack(t) {
    var magnitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.70158;
    return t * t * ((magnitude + 1) * t - magnitude);
  }

  Timing.easeInBack = easeInBack; // Fast snap to backwards point then slow resolve to finish

  function easeOutBack(t) {
    var magnitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.70158;
    var scaledTime = t / 1 - 1;
    return scaledTime * scaledTime * ((magnitude + 1) * scaledTime + magnitude) + 1;
  }

  Timing.easeOutBack = easeOutBack; // Slow movement backwards, fast snap to past finish, slow resolve to finish

  function easeInOutBack(t) {
    var magnitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.70158;
    var scaledTime = t * 2;
    var scaledTime2 = scaledTime - 2;
    var s = magnitude * 1.525;

    if (scaledTime < 1) {
      return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s);
    }

    return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2);
  }

  Timing.easeInOutBack = easeInOutBack; // Bounces slowly then quickly to finish

  function easeInElastic(t) {
    var magnitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.7;

    if (t === 0 || t === 1) {
      return t;
    }

    var scaledTime = t / 1;
    var scaledTime1 = scaledTime - 1;
    var p = 1 - magnitude;
    var s = p / (2 * Math.PI) * Math.asin(1);
    return -(Math.pow(2, 10 * scaledTime1) * Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));
  }

  Timing.easeInElastic = easeInElastic; // Fast acceleration, bounces to zero

  function easeOutElastic(t) {
    var magnitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.7;
    var p = 1 - magnitude;
    var scaledTime = t * 2;

    if (t === 0 || t === 1) {
      return t;
    }

    var s = p / (2 * Math.PI) * Math.asin(1);
    return Math.pow(2, -10 * scaledTime) * Math.sin((scaledTime - s) * (2 * Math.PI) / p) + 1;
  }

  Timing.easeOutElastic = easeOutElastic; // Slow start and end, two bounces sandwich a fast motion

  function easeInOutElastic(t) {
    var magnitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.65;
    var p = 1 - magnitude;

    if (t === 0 || t === 1) {
      return t;
    }

    var scaledTime = t * 2;
    var scaledTime1 = scaledTime - 1;
    var s = p / (2 * Math.PI) * Math.asin(1);

    if (scaledTime < 1) {
      return -0.5 * (Math.pow(2, 10 * scaledTime1) * Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));
    }

    return Math.pow(2, -10 * scaledTime1) * Math.sin((scaledTime1 - s) * (2 * Math.PI) / p) * 0.5 + 1;
  }

  Timing.easeInOutElastic = easeInOutElastic; // Bounce to completion

  function easeOutBounce(t) {
    var scaledTime = t / 1;

    if (scaledTime < 1 / 2.75) {
      return 7.5625 * scaledTime * scaledTime;
    }

    if (scaledTime < 2 / 2.75) {
      var scaledTime2 = scaledTime - 1.5 / 2.75;
      return 7.5625 * scaledTime2 * scaledTime2 + 0.75;
    }

    if (scaledTime < 2.5 / 2.75) {
      var _scaledTime = scaledTime - 2.25 / 2.75;

      return 7.5625 * _scaledTime * _scaledTime + 0.9375;
    }

    {
      var _scaledTime2 = scaledTime - 2.625 / 2.75;

      return 7.5625 * _scaledTime2 * _scaledTime2 + 0.984375;
    }
  }

  Timing.easeOutBounce = easeOutBounce; // Bounce increasing in velocity until completion

  function easeInBounce(t) {
    return 1 - easeOutBounce(1 - t);
  }

  Timing.easeInBounce = easeInBounce; // Bounce in and bounce out

  function easeInOutBounce(t) {
    if (t < 0.5) {
      return easeInBounce(t * 2) * 0.5;
    }

    return easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
  }

  Timing.easeInOutBounce = easeInOutBounce;
})(Timing || (Timing = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/animation/interp.js
var Interp;

(function (Interp) {
  Interp.number = function (a, b) {
    var d = b - a;
    return function (t) {
      return a + d * t;
    };
  };

  Interp.object = function (a, b) {
    var keys = Object.keys(a);
    return function (t) {
      var ret = {};

      for (var i = keys.length - 1; i !== -1; i -= 1) {
        var key = keys[i];
        ret[key] = a[key] + (b[key] - a[key]) * t;
      }

      return ret;
    };
  };

  Interp.unit = function (a, b) {
    var reg = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;
    var ma = reg.exec(a);
    var mb = reg.exec(b);
    var pb = mb ? mb[1] : '';
    var aa = ma ? +ma[1] : 0;
    var bb = mb ? +mb[1] : 0;
    var index = pb.indexOf('.');
    var precision = index > 0 ? pb[1].length - index - 1 : 0;
    var d = bb - aa;
    var u = ma ? ma[2] : '';
    return function (t) {
      return (aa + d * t).toFixed(precision) + u;
    };
  };

  Interp.color = function (a, b) {
    var ca = parseInt(a.slice(1), 16);
    var cb = parseInt(b.slice(1), 16);
    var ra = ca & 0x0000ff;
    var rd = (cb & 0x0000ff) - ra;
    var ga = ca & 0x00ff00;
    var gd = (cb & 0x00ff00) - ga;
    var ba = ca & 0xff0000;
    var bd = (cb & 0xff0000) - ba;
    return function (t) {
      var r = ra + rd * t & 0x000000ff;
      var g = ga + gd * t & 0x0000ff00;
      var b = ba + bd * t & 0x00ff0000;
      return "#".concat((1 << 24 | r | g | b).toString(16).slice(1));
    };
  };
})(Interp || (Interp = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/animation/index.js


// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/global/config.js
var Config = {
  prefixCls: 'x6',
  autoInsertCSS: true,
  useCSSSelector: true,
  trackable: true,
  trackInfo: {},

  /**
   * Turn on/off collect information of user client.
   *
   * In order to serve the users better, x6 will send the URL and version
   * information back to the AntV server:https://kcart.alipay.com/web/bi.do
   *
   * Except for URL and G2 version information, no other information will
   * be collected.
   *
   * @param enabled Specifies if seed client information to AntV server.
   */
  track: function track(enabled) {
    Config.trackable = enabled;
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/localstorage.js


var localstorage_LocalStorage;

(function (LocalStorage) {
  var prefix = "".concat(Config.prefixCls, ".storage");

  function insert(collection, doc, cb) {
    var id = doc.id || string_namespaceObject.uniqueId('doc-');
    var index = loadIndex(collection);
    index.keys.push(id);
    setItem(docKey(collection, id), doc);
    setItem(indexKey(collection), index);
    callback(cb, null, Object.assign(Object.assign({}, doc), {
      id: id
    }));
  }

  LocalStorage.insert = insert;

  function find(collection, query, cb) {
    var index = loadIndex(collection);
    var docs = [];

    if (query == null) {
      index.keys.forEach(function (id) {
        var doc = getItem(docKey(collection, id));

        if (!doc) {
          callback(cb, new Error("No document found for an ID '".concat(id, "' from index.")));
        } else {
          docs.push(doc);
        }
      });
      callback(cb, null, docs);
    } else if (query.id) {
      var doc = getItem(docKey(collection, query.id));
      callback(cb, null, doc ? [doc] : []);
    } else {
      callback(cb, null, []);
    }
  }

  LocalStorage.find = find;

  function remove(collection, query, cb) {
    var index = loadIndex(collection);

    if (query == null) {
      index.keys.forEach(function (id) {
        localStorage.removeItem(docKey(collection, id));
      });
      localStorage.removeItem(indexKey(collection));
      callback(cb, null);
    } else if (query.id) {
      var idx = index.keys.indexOf(query.id);

      if (idx >= 0) {
        index.keys.splice(idx, 1);
      }

      localStorage.removeItem(docKey(collection, query.id));
      setItem(indexKey(collection), index);
      callback(cb, null);
    }
  }

  LocalStorage.remove = remove; // util
  // ----

  function callback(cb, err, ret) {
    if (cb) {
      main_namespaceObject.defer(function () {
        cb(err, ret);
      });
    }
  }

  function setItem(key, item) {
    localStorage.setItem(key, JSON.stringify(item));
  }

  function getItem(key) {
    var item = localStorage.getItem(key);
    return item ? JSON.parse(item) : null;
  }

  function loadIndex(collection) {
    var index = getItem(indexKey(collection));

    if (index) {
      if (index.keys == null) {
        index.keys = [];
      }

      return index;
    }

    return {
      keys: []
    };
  }

  function docKey(collection, id) {
    return "".concat(prefix, ".").concat(collection, ".docs.").concat(id);
  }

  function indexKey(collection) {
    return "".concat(prefix, ".").concat(collection, ".index");
  }
})(localstorage_LocalStorage || (localstorage_LocalStorage = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/common/index.js








// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
var assertThisInitialized = __webpack_require__(11);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/registry.js



var registry_Registry = /*#__PURE__*/function () {
  function Registry(options) {
    Object(classCallCheck["a" /* default */])(this, Registry);

    this.options = Object.assign({}, options);
    this.data = this.options.data || {};
    this.register = this.register.bind(this);
    this.unregister = this.unregister.bind(this);
  }

  Object(createClass["a" /* default */])(Registry, [{
    key: "register",
    value: function register(name, options) {
      var _this = this;

      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (typeof name === 'object') {
        Object.keys(name).forEach(function (key) {
          _this.register(key, name[key], options);
        });
        return;
      }

      if (this.exist(name) && !force && !platform["a" /* Platform */].isApplyingHMR()) {
        this.onDuplicated(name);
      }

      var process = this.options.process;
      var entity = process ? main_namespaceObject.call(process, this, name, options) : options;
      this.data[name] = entity;
      return entity;
    }
  }, {
    key: "unregister",
    value: function unregister(name) {
      var entity = name ? this.data[name] : null;
      delete this.data[name];
      return entity;
    }
  }, {
    key: "get",
    value: function get(name) {
      return name ? this.data[name] : null;
    }
  }, {
    key: "exist",
    value: function exist(name) {
      return name ? this.data[name] != null : false;
    }
  }, {
    key: "onDuplicated",
    value: function onDuplicated(name) {
      try {
        // race
        if (this.options.onConflict) {
          main_namespaceObject.call(this.options.onConflict, this, name);
        }

        throw new Error("".concat(string_namespaceObject.upperFirst(this.options.type), " with name '").concat(name, "' already registered."));
      } catch (err) {
        throw err;
      }
    }
  }, {
    key: "onNotFound",
    value: function onNotFound(name, prefix) {
      throw new Error(this.getSpellingSuggestion(name, prefix));
    }
  }, {
    key: "getSpellingSuggestion",
    value: function getSpellingSuggestion(name, prefix) {
      var suggestion = this.getSpellingSuggestionForName(name);
      var prefixed = prefix ? "".concat(prefix, " ").concat(string_namespaceObject.lowerFirst(this.options.type)) : this.options.type;
      return (// tslint:disable-next-line
        "".concat(string_namespaceObject.upperFirst(prefixed), " with name '").concat(name, "' does not exist.") + (suggestion ? " Did you mean '".concat(suggestion, "'?") : '')
      );
    }
  }, {
    key: "getSpellingSuggestionForName",
    value: function getSpellingSuggestionForName(name) {
      return string_namespaceObject.getSpellingSuggestion(name, Object.keys(this.data), function (candidate) {
        return candidate;
      });
    }
  }, {
    key: "names",
    get: function get() {
      return Object.keys(this.data);
    }
  }]);

  return Registry;
}();

(function (Registry) {
  function create(options) {
    return new Registry(options);
  }

  Registry.create = create;
})(registry_Registry || (registry_Registry = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/raw.js
var raw_raw = {
  xlinkHref: 'xlink:href',
  xlinkShow: 'xlink:show',
  xlinkRole: 'xlink:role',
  xlinkType: 'xlink:type',
  xlinkArcrole: 'xlink:arcrole',
  xlinkTitle: 'xlink:title',
  xlinkActuate: 'xlink:actuate',
  xmlSpace: 'xml:space',
  xmlBase: 'xml:base',
  xmlLang: 'xml:lang',
  preserveAspectRatio: 'preserveAspectRatio',
  requiredExtension: 'requiredExtension',
  requiredFeatures: 'requiredFeatures',
  systemLanguage: 'systemLanguage',
  externalResourcesRequired: 'externalResourceRequired'
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/ref.js


var ref_ref = {// We do not set `ref` attribute directly on an element.
  // The attribute itself does not qualify for relative positioning.
}; // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width
// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box
// otherwise, `refX` is the left coordinate of the bounding box

var refX = {
  position: positionWrapper('x', 'width', 'origin')
};
var refY = {
  position: positionWrapper('y', 'height', 'origin')
}; // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom
// coordinate of the reference element.

var refDx = {
  position: positionWrapper('x', 'width', 'corner')
};
var refDy = {
  position: positionWrapper('y', 'height', 'corner')
}; // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to
// the reference element size
// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width
// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20

var refWidth = {
  set: setWrapper('width', 'width')
};
var refHeight = {
  set: setWrapper('height', 'height')
};
var refRx = {
  set: setWrapper('rx', 'width')
};
var refRy = {
  set: setWrapper('ry', 'height')
};
var refRInscribed = {
  set: function (attrName) {
    var widthFn = setWrapper(attrName, 'width');
    var heightFn = setWrapper(attrName, 'height');
    return function (value, options) {
      var refBBox = options.refBBox;
      var fn = refBBox.height > refBBox.width ? widthFn : heightFn;
      return main_namespaceObject.call(fn, this, value, options);
    };
  }('r')
};
var refRCircumscribed = {
  set: function set(val, _ref) {
    var refBBox = _ref.refBBox;
    var value = parseFloat(val);
    var percentage = number_namespaceObject.isPercentage(val);

    if (percentage) {
      value /= 100;
    }

    var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);
    var rValue;

    if (isFinite(value)) {
      if (percentage || value >= 0 && value <= 1) {
        rValue = value * diagonalLength;
      } else {
        rValue = Math.max(value + diagonalLength, 0);
      }
    }

    return {
      r: rValue
    };
  }
};
var refCx = {
  set: setWrapper('cx', 'width')
};
var refCy = {
  set: setWrapper('cy', 'height')
};
var refDResetOffset = {
  set: dWrapper({
    resetOffset: true
  })
};
var refDKeepOffset = {
  set: dWrapper({
    resetOffset: false
  })
};
var refPointsResetOffset = {
  set: pointsWrapper({
    resetOffset: true
  })
};
var refPointsKeepOffset = {
  set: pointsWrapper({
    resetOffset: false
  })
}; // aliases
// -------

var refR = refRInscribed;
var refD = refDResetOffset;
var refPoints = refPointsResetOffset; // Allows to combine both absolute and relative positioning
// refX: 50%, refX2: 20

var refX2 = refX;
var refY2 = refY;
var refWidth2 = refWidth;
var refHeight2 = refHeight; // utils
// -----

function positionWrapper(axis, dimension, origin) {
  return function (val, _ref2) {
    var refBBox = _ref2.refBBox;

    if (val == null) {
      return null;
    }

    var value = parseFloat(val);
    var percentage = number_namespaceObject.isPercentage(val);

    if (percentage) {
      value /= 100;
    }

    var delta;

    if (isFinite(value)) {
      var refOrigin = refBBox[origin];

      if (percentage || value > 0 && value < 1) {
        delta = refOrigin[axis] + refBBox[dimension] * value;
      } else {
        delta = refOrigin[axis] + value;
      }
    }

    var point = new point_Point();
    point[axis] = delta || 0;
    return point;
  };
}

function setWrapper(attrName, dimension) {
  return function (val, _ref3) {
    var refBBox = _ref3.refBBox;
    var value = parseFloat(val);
    var percentage = number_namespaceObject.isPercentage(val);

    if (percentage) {
      value /= 100;
    }

    var attrs = {};

    if (isFinite(value)) {
      var attrValue = percentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);
      attrs[attrName] = attrValue;
    }

    return attrs;
  };
}

function shapeWrapper(shapeConstructor, options) {
  var cacheName = 'x6-shape';
  var resetOffset = options && options.resetOffset;
  return function (value, _ref4) {
    var view = _ref4.view,
        elem = _ref4.elem,
        refBBox = _ref4.refBBox;
    var $elem = view.$(elem);
    var cache = $elem.data(cacheName);

    if (!cache || cache.value !== value) {
      // only recalculate if value has changed
      var cachedShape = shapeConstructor(value);
      cache = {
        value: value,
        shape: cachedShape,
        shapeBBox: cachedShape.bbox()
      };
      $elem.data(cacheName, cache);
    }

    var shape = cache.shape.clone();
    var shapeBBox = cache.shapeBBox.clone();
    var shapeOrigin = shapeBBox.getOrigin();
    var refOrigin = refBBox.getOrigin();
    shapeBBox.x = refOrigin.x;
    shapeBBox.y = refOrigin.y;
    var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin); // `maxRectScaleToFit` can give Infinity if width or height is 0

    var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;
    var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;
    shape.scale(sx, sy, shapeOrigin);

    if (resetOffset) {
      shape.translate(-shapeOrigin.x, -shapeOrigin.y);
    }

    return shape;
  };
} // `d` attribute for SVGPaths


function dWrapper(options) {
  function pathConstructor(value) {
    return path_Path.parse(path_Path.normalize(value));
  }

  var shape = shapeWrapper(pathConstructor, options);
  return function (value, args) {
    var path = shape(value, args);
    return {
      d: path.serialize()
    };
  };
} // `points` attribute for SVGPolylines and SVGPolygons


function pointsWrapper(options) {
  var shape = shapeWrapper(function (points) {
    return new polyline_Polyline(points);
  }, options);
  return function (value, args) {
    var polyline = shape(value, args);
    return {
      points: polyline.serialize()
    };
  };
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/fill.js

var fill = {
  qualify: object_namespaceObject.isPlainObject,
  set: function set(fill, _ref) {
    var view = _ref.view;
    return "url(#".concat(view.graph.defineGradient(fill), ")");
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/stroke.js

var stroke = {
  qualify: object_namespaceObject.isPlainObject,
  set: function set(stroke, _ref) {
    var view = _ref.view;
    return "url(#".concat(view.graph.defineGradient(stroke), ")");
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/text.js

var attr_text_text = {
  qualify: function qualify(text, _ref) {
    var attrs = _ref.attrs;
    return attrs.textWrap == null || !object_namespaceObject.isPlainObject(attrs.textWrap);
  },
  set: function set(text, _ref2) {
    var view = _ref2.view,
        elem = _ref2.elem,
        attrs = _ref2.attrs;
    var cacheName = 'x6-text';
    var $elem = view.$(elem);
    var cache = $elem.data(cacheName);
    var textAttrs = object_namespaceObject.pick(attrs, 'lineHeight', 'annotations', 'textPath', 'x', 'textVerticalAnchor', 'eol', 'displayEmpty', 'fontSize');
    textAttrs.fontSize = attrs['font-size'] || attrs['fontSize'];
    var fontSize = textAttrs.fontSize;
    var textHash = JSON.stringify([text, textAttrs]); // Updates the text only if there was a change in the string
    // or any of its attributes.

    if (cache == null || cache !== textHash) {
      if (fontSize) {
        elem.setAttribute('font-size', fontSize);
      } // Text Along Path Selector


      var _textPath = textAttrs.textPath;

      if (_textPath != null && typeof _textPath === 'object') {
        var selector = _textPath.selector;

        if (typeof selector === 'string') {
          var pathNode = view.find(selector)[0];

          if (pathNode instanceof SVGPathElement) {
            dom_main_namespaceObject.ensureId(pathNode);
            textAttrs.textPath = Object.assign({
              'xlink:href': "#".concat(pathNode.id)
            }, _textPath);
          }
        }
      }

      dom_main_namespaceObject.text(elem, "".concat(text), textAttrs);
      $elem.data(cacheName, textHash);
    }
  }
};
var text_textWrap = {
  qualify: object_namespaceObject.isPlainObject,
  set: function set(val, _ref3) {
    var view = _ref3.view,
        elem = _ref3.elem,
        attrs = _ref3.attrs,
        refBBox = _ref3.refBBox;
    var info = val; // option `width`

    var width = info.width || 0;

    if (number_namespaceObject.isPercentage(width)) {
      refBBox.width *= parseFloat(width) / 100;
    } else if (width <= 0) {
      refBBox.width += width;
    } else {
      refBBox.width = width;
    } // option `height`


    var height = info.height || 0;

    if (number_namespaceObject.isPercentage(height)) {
      refBBox.height *= parseFloat(height) / 100;
    } else if (height <= 0) {
      refBBox.height += height;
    } else {
      refBBox.height = height;
    } // option `text`


    var wrappedText;
    var txt = info.text;

    if (txt == null) {
      txt = attrs.text;
    }

    if (txt != null) {
      wrappedText = dom_main_namespaceObject.breakText("".concat(txt), refBBox, {
        'font-weight': attrs['font-weight'] || attrs.fontWeight,
        'font-size': attrs['font-size'] || attrs.fontSize,
        'font-family': attrs['font-family'] || attrs.fontFamily,
        lineHeight: attrs.lineHeight
      }, {
        svgDocument: view.graph.view.svg,
        ellipsis: info.ellipsis,
        hyphen: info.hyphen
      });
    } else {
      wrappedText = '';
    }

    main_namespaceObject.call(attr_text_text.set, this, wrappedText, {
      view: view,
      elem: elem,
      attrs: attrs,
      refBBox: refBBox,
      cell: view.cell
    });
  }
};

var isTextInUse = function isTextInUse(val, _ref4) {
  var attrs = _ref4.attrs;
  return attrs.text !== undefined;
};

var text_lineHeight = {
  qualify: isTextInUse
};
var textVerticalAnchor = {
  qualify: isTextInUse
};
var text_textPath = {
  qualify: isTextInUse
};
var text_annotations = {
  qualify: isTextInUse
};
var text_eol = {
  qualify: isTextInUse
};
var displayEmpty = {
  qualify: isTextInUse
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/title.js
var title_title = {
  qualify: function qualify(title, _ref) {
    var elem = _ref.elem;
    // HTMLElement title is specified via an attribute (i.e. not an element)
    return elem instanceof SVGElement;
  },
  set: function set(val, _ref2) {
    var view = _ref2.view,
        elem = _ref2.elem;
    var cacheName = 'x6-title';
    var title = "".concat(val);
    var $elem = view.$(elem);
    var cache = $elem.data(cacheName);

    if (cache == null || cache !== title) {
      $elem.data(cacheName, title); // Generally SVGTitleElement should be the first child
      // element of its parent.

      var firstChild = elem.firstChild;

      if (firstChild && firstChild.tagName.toUpperCase() === 'TITLE') {
        // Update an existing title
        var titleElem = firstChild;
        titleElem.textContent = title;
      } else {
        // Create a new title
        var titleNode = document.createElementNS(elem.namespaceURI, 'title');
        titleNode.textContent = title;
        elem.insertBefore(titleNode, firstChild);
      }
    }
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/align.js

 // `x-align` when set to `middle` causes centering of the subelement around its new x coordinate.
// `x-align` when set to `right` uses the x coordinate as referenced to the right of the bbox.

var xAlign = {
  offset: offsetWrapper('x', 'width', 'right')
}; // `y-align` when set to `middle` causes centering of the subelement around its new y coordinate.
// `y-align` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.

var yAlign = {
  offset: offsetWrapper('y', 'height', 'bottom')
};
var resetOffset = {
  offset: function offset(val, _ref) {
    var refBBox = _ref.refBBox;
    return val ? {
      x: -refBBox.x,
      y: -refBBox.y
    } : {
      x: 0,
      y: 0
    };
  }
};

function offsetWrapper(axis, dimension, corner) {
  return function (value, _ref2) {
    var refBBox = _ref2.refBBox;
    var point = new point_Point();
    var delta;

    if (value === 'middle') {
      delta = refBBox[dimension] / 2;
    } else if (value === corner) {
      delta = refBBox[dimension];
    } else if (typeof value === 'number' && isFinite(value)) {
      delta = value > -1 && value < 1 ? -refBBox[dimension] * value : -value;
    } else if (number_namespaceObject.isPercentage(value)) {
      delta = refBBox[dimension] * parseFloat(value) / 100;
    } else {
      delta = 0;
    }

    point[axis] = -(refBBox[axis] + delta);
    return point;
  };
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/style.js

var style_style = {
  qualify: object_namespaceObject.isPlainObject,
  set: function set(styles, _ref) {
    var view = _ref.view,
        elem = _ref.elem;
    view.$(elem).css(styles);
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/html.js
var html_html = {
  set: function set(html, _ref) {
    var view = _ref.view,
        elem = _ref.elem;
    view.$(elem).html("".concat(html));
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/filter.js

var filter_filter = {
  qualify: object_namespaceObject.isPlainObject,
  set: function set(filter, _ref) {
    var view = _ref.view;
    return "url(#".concat(view.graph.defineFilter(filter), ")");
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/port.js
var port_port = {
  set: function set(port) {
    if (port != null && typeof port === 'object' && port.id) {
      return port.id;
    }

    return port;
  }
};
// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(7);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/marker/util.js

function util_normalize(d, offset1, offset2) {
  var offsetX;
  var offsetY;

  if (typeof offset1 === 'object') {
    offsetX = offset1.x;
    offsetY = offset1.y;
  } else {
    offsetX = offset1;
    offsetY = offset2;
  }

  var path = path_Path.parse(path_Path.normalize(d));
  var bbox = path.bbox();

  if (bbox) {
    var ty = -bbox.height / 2 - bbox.y;
    var tx = -bbox.width / 2 - bbox.x;

    if (typeof offsetX === 'number') {
      tx -= offsetX;
    }

    if (typeof offsetY === 'number') {
      ty -= offsetY;
    }

    path.translate(tx, ty);
  }

  return path.serialize();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/marker/classic.js
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




var block = function block(_a) {
  var size = _a.size,
      width = _a.width,
      height = _a.height,
      offset = _a.offset,
      open = _a.open,
      attrs = __rest(_a, ["size", "width", "height", "offset", "open"]);

  return createClassicMarker({
    size: size,
    width: width,
    height: height,
    offset: offset
  }, open === true, true, undefined, attrs);
};
var classic = function classic(_a) {
  var size = _a.size,
      width = _a.width,
      height = _a.height,
      offset = _a.offset,
      factor = _a.factor,
      attrs = __rest(_a, ["size", "width", "height", "offset", "factor"]);

  return createClassicMarker({
    size: size,
    width: width,
    height: height,
    offset: offset
  }, false, false, factor, attrs);
};

function createClassicMarker(options, open, full) {
  var factor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3 / 4;
  var attrs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var size = options.size || 10;
  var width = options.width || size;
  var height = options.height || size;
  var path = new path_Path();
  var localAttrs = {};

  if (open) {
    path.moveTo(width, 0).lineTo(0, height / 2).lineTo(width, height);
    localAttrs.fill = 'none';
  } else {
    path.moveTo(0, height / 2);
    path.lineTo(width, 0);

    if (!full) {
      var f = number_namespaceObject.clamp(factor, 0, 1);
      path.lineTo(width * f, height / 2);
    }

    path.lineTo(width, height);
    path.close();
  }

  return Object.assign(Object.assign(Object.assign({}, localAttrs), attrs), {
    tagName: 'path',
    d: util_normalize(path.serialize(), {
      x: options.offset != null ? options.offset : -width / 2
    })
  });
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/marker/diamond.js
var diamond_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



var diamond_diamond = function diamond(_a) {
  var size = _a.size,
      width = _a.width,
      height = _a.height,
      offset = _a.offset,
      attrs = diamond_rest(_a, ["size", "width", "height", "offset"]);

  var s = size || 10;
  var w = width || s;
  var h = height || s;
  var path = new path_Path();
  path.moveTo(0, h / 2).lineTo(w / 2, 0).lineTo(w, h / 2).lineTo(w / 2, h).close();
  return Object.assign(Object.assign({}, attrs), {
    tagName: 'path',
    d: util_normalize(path.serialize(), offset == null ? -w / 2 : offset)
  });
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/marker/path.js
var path_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};


var path_path = function path(_a) {
  var d = _a.d,
      offsetX = _a.offsetX,
      offsetY = _a.offsetY,
      attrs = path_rest(_a, ["d", "offsetX", "offsetY"]);

  return Object.assign(Object.assign({}, attrs), {
    tagName: 'path',
    d: util_normalize(d, offsetX, offsetY)
  });
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/marker/cross.js
var cross_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



var cross_cross = function cross(_a) {
  var size = _a.size,
      width = _a.width,
      height = _a.height,
      offset = _a.offset,
      attrs = cross_rest(_a, ["size", "width", "height", "offset"]);

  var s = size || 10;
  var w = width || s;
  var h = height || s;
  var path = new path_Path();
  path.moveTo(0, 0).lineTo(w, h).moveTo(0, h).lineTo(w, 0);
  return Object.assign(Object.assign({}, attrs), {
    tagName: 'path',
    fill: 'none',
    d: util_normalize(path.serialize(), offset || -w / 2)
  });
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/marker/async.js
var async_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



var async_async = function async(_a) {
  var width = _a.width,
      height = _a.height,
      offset = _a.offset,
      open = _a.open,
      flip = _a.flip,
      attrs = async_rest(_a, ["width", "height", "offset", "open", "flip"]);

  var h = height || 6;
  var w = width || 10;
  var opened = open === true;
  var fliped = flip === true;
  var result = Object.assign(Object.assign({}, attrs), {
    tagName: 'path'
  });

  if (fliped) {
    h = -h;
  }

  var path = new path_Path();
  path.moveTo(0, h).lineTo(w, 0);

  if (!opened) {
    path.lineTo(w, h);
    path.close();
  } else {
    result.fill = 'none';
  }

  result.d = util_normalize(path.serialize(), {
    x: offset || -w / 2,
    y: h / 2
  });
  return result;
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/marker/circle.js
var circle_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



var circle = function circle(_a) {
  var r = _a.r,
      attrs = circle_rest(_a, ["r"]);

  var radius = r || 5;
  return Object.assign(Object.assign({
    cx: radius
  }, attrs), {
    tagName: 'circle',
    r: radius
  });
};
var circle_circlePlus = function circlePlus(_a) {
  var r = _a.r,
      attrs = circle_rest(_a, ["r"]);

  var radius = r || 5;
  var path = new path_Path();
  path.moveTo(radius, 0).lineTo(radius, radius * 2);
  path.moveTo(0, radius).lineTo(radius * 2, radius);
  return {
    children: [Object.assign(Object.assign({}, circle({
      r: radius
    })), {
      fill: 'none'
    }), Object.assign(Object.assign({}, attrs), {
      type: 'path',
      d: util_normalize(path.serialize(), -radius)
    })]
  };
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/marker/ellipse.js
var ellipse_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

var ellipse_ellipse = function ellipse(_a) {
  var rx = _a.rx,
      ry = _a.ry,
      attrs = ellipse_rest(_a, ["rx", "ry"]);

  var radiusX = rx || 5;
  var radiusy = ry || 5;
  return Object.assign(Object.assign({
    cx: radiusX
  }, attrs), {
    tagName: 'ellipse',
    rx: radiusX,
    ry: radiusy
  });
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/marker/main.js







// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/marker/index.js



var marker_Marker;

(function (Marker) {
  Marker.presets = marker_main_namespaceObject;
  Marker.registry = registry_Registry.create({
    type: 'marker'
  });
  Marker.registry.register(Marker.presets, true);
})(marker_Marker || (marker_Marker = {}));

(function (Marker) {
  Marker.normalize = util_normalize;
})(marker_Marker || (marker_Marker = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/marker.js


var marker_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




function marker_qualify(value) {
  return typeof value === 'string' || object_namespaceObject.isPlainObject(value);
}

var sourceMarker = {
  qualify: marker_qualify,
  set: function set(marker, _ref) {
    var view = _ref.view,
        attrs = _ref.attrs;
    return createMarker('marker-start', marker, view, attrs);
  }
};
var targetMarker = {
  qualify: marker_qualify,
  set: function set(marker, _ref2) {
    var view = _ref2.view,
        attrs = _ref2.attrs;
    return createMarker('marker-end', marker, view, attrs, {
      transform: 'rotate(180)'
    });
  }
};
var vertexMarker = {
  qualify: marker_qualify,
  set: function set(marker, _ref3) {
    var view = _ref3.view,
        attrs = _ref3.attrs;
    return createMarker('marker-mid', marker, view, attrs);
  }
};

function createMarker(key, marker, view, attrs) {
  var manual = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var def = typeof marker === 'string' ? {
    name: marker
  } : marker;

  var name = def.name,
      args = def.args,
      others = marker_rest(def, ["name", "args"]);

  var preset = others;

  if (name && typeof name === 'string') {
    var fn = marker_Marker.registry.get(name);

    if (fn) {
      preset = fn(Object.assign(Object.assign({}, others), args));
    } else {
      return marker_Marker.registry.onNotFound(name);
    }
  }

  var options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs)), manual), preset);
  return Object(defineProperty["a" /* default */])({}, key, "url(#".concat(view.graph.defineMarker(options), ")"));
}

function normalizeAttr(attr) {
  var result = {}; // The context 'fill' is disregared here. The usual case is to use the
  // marker with a connection(for which 'fill' attribute is set to 'none').

  var stroke = attr.stroke;

  if (typeof stroke === 'string') {
    result['stroke'] = stroke;
    result['fill'] = stroke;
  } // Again the context 'fill-opacity' is ignored.


  var strokeOpacity = attr.strokeOpacity;

  if (strokeOpacity == null) {
    strokeOpacity = attr['stroke-opacity'];
  }

  if (strokeOpacity == null) {
    strokeOpacity = attr.opacity;
  }

  if (strokeOpacity != null) {
    result['stroke-opacity'] = strokeOpacity;
    result['fill-opacity'] = strokeOpacity;
  }

  return result;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/connection.js
var isEdgeView = function isEdgeView(val, _ref) {
  var view = _ref.view;
  return view.cell.isEdge();
};

var connection = {
  qualify: isEdgeView,
  set: function set(val, args) {
    var view = args.view;
    var stubs = val.stubs || 0;
    var d;

    if (isFinite(stubs) && stubs !== 0) {
      var offset;

      if (stubs < 0) {
        var len = view.getConnectionLength() || 0;
        offset = (len + stubs) / 2;
      } else {
        offset = stubs;
      }

      var path = view.getConnection();

      if (path) {
        var sourceParts = path.divideAtLength(offset);
        var targetParts = path.divideAtLength(-offset);

        if (sourceParts && targetParts) {
          d = "".concat(sourceParts[0].serialize(), " ").concat(targetParts[1].serialize());
        }
      }
    }

    return {
      d: d || view.getConnectionPathData()
    };
  }
};
var atConnectionLengthKeepGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper('getTangentAtLength', {
    rotate: true
  })
};
var atConnectionLengthIgnoreGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper('getTangentAtLength', {
    rotate: false
  })
};
var atConnectionRatioKeepGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper('getTangentAtRatio', {
    rotate: true
  })
};
var atConnectionRatioIgnoreGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper('getTangentAtRatio', {
    rotate: false
  })
}; // aliases
// -------

var atConnectionLength = atConnectionLengthKeepGradient;
var atConnectionRatio = atConnectionRatioKeepGradient; // utils
// -----

function atConnectionWrapper(method, options) {
  var zeroVector = {
    x: 1,
    y: 0
  };
  return function (value, args) {
    var p;
    var angle;
    var view = args.view;
    var tangent = view[method](Number(value));

    if (tangent) {
      angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;
      p = tangent.start;
    } else {
      p = view.path.start;
      angle = 0;
    }

    if (angle === 0) {
      return {
        transform: "translate(".concat(p.x, ",").concat(p.y, "')")
      };
    }

    return {
      transform: "translate(".concat(p.x, ",").concat(p.y, "') rotate(").concat(angle, ")")
    };
  };
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/main.js












// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/attr/index.js




var attr_Attr;

(function (Attr) {
  function isValidDefinition(def, val, options) {
    if (def != null) {
      if (typeof def === 'string') {
        return true;
      }

      if (typeof def.qualify !== 'function' || main_namespaceObject.call(def.qualify, this, val, options)) {
        return true;
      }
    }

    return false;
  }

  Attr.isValidDefinition = isValidDefinition;
})(attr_Attr || (attr_Attr = {}));

(function (Attr) {
  Attr.presets = Object.assign(Object.assign({}, raw_raw), attr_main_namespaceObject);
  Attr.registry = registry_Registry.create({
    type: 'attribute definition'
  });
  Attr.registry.register(Attr.presets, true);
})(attr_Attr || (attr_Attr = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/grid/dot.js

var dot = {
  color: '#aaaaaa',
  thickness: 1,
  markup: 'rect',
  update: function update(elem, options) {
    var width = options.thickness * options.sx;
    var height = options.thickness * options.sy;
    dom_main_namespaceObject.attr(elem, {
      width: width,
      height: height,
      rx: width,
      ry: height,
      fill: options.color
    });
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/grid/fixed-dot.js

var fixedDot = {
  color: '#aaaaaa',
  thickness: 1,
  markup: 'rect',
  update: function update(elem, options) {
    var size = options.sx <= 1 ? options.thickness * options.sx : options.thickness;
    dom_main_namespaceObject.attr(elem, {
      width: size,
      height: size,
      rx: size,
      ry: size,
      fill: options.color
    });
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/grid/mesh.js

var mesh = {
  color: 'rgba(224,224,224,1)',
  thickness: 1,
  markup: 'path',
  update: function update(elem, options) {
    var d;
    var width = options.width;
    var height = options.height;
    var thickness = options.thickness;

    if (width - thickness >= 0 && height - thickness >= 0) {
      d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
    } else {
      d = 'M 0 0 0 0';
    }

    dom_main_namespaceObject.attr(elem, {
      d: d,
      stroke: options.color,
      'stroke-width': options.thickness
    });
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/grid/double-mesh.js

var doubleMesh = [{
  color: 'rgba(224,224,224,1)',
  thickness: 1,
  markup: 'path',
  update: function update(elem, options) {
    var d;
    var width = options.width;
    var height = options.height;
    var thickness = options.thickness;

    if (width - thickness >= 0 && height - thickness >= 0) {
      d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
    } else {
      d = 'M 0 0 0 0';
    }

    dom_main_namespaceObject.attr(elem, {
      d: d,
      stroke: options.color,
      'stroke-width': options.thickness
    });
  }
}, {
  color: 'rgba(224,224,224,0.2)',
  thickness: 3,
  factor: 4,
  markup: 'path',
  update: function update(elem, options) {
    var d;
    var factor = options.factor || 1;
    var width = options.width * factor;
    var height = options.height * factor;
    var thickness = options.thickness;

    if (width - thickness >= 0 && height - thickness >= 0) {
      d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
    } else {
      d = 'M 0 0 0 0';
    } // update wrapper size


    options.width = width;
    options.height = height;
    dom_main_namespaceObject.attr(elem, {
      d: d,
      stroke: options.color,
      'stroke-width': options.thickness
    });
  }
}];
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/grid/main.js




// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/grid/index.js





var grid_Grid = /*#__PURE__*/function () {
  function Grid() {
    Object(classCallCheck["a" /* default */])(this, Grid);

    this.patterns = {};
    this.root = dom_main_namespaceObject.createVector(dom_main_namespaceObject.createSvgDocument(), {
      width: '100%',
      height: '100%'
    }, [dom_main_namespaceObject.createSvgElement('defs')]).node;
  }

  Object(createClass["a" /* default */])(Grid, [{
    key: "add",
    value: function add(id, elem) {
      var firstChild = this.root.childNodes[0];

      if (firstChild) {
        firstChild.appendChild(elem);
      }

      this.patterns[id] = elem;
      dom_main_namespaceObject.createVector('rect', {
        width: '100%',
        height: '100%',
        fill: "url(#".concat(id, ")")
      }).appendTo(this.root);
    }
  }, {
    key: "get",
    value: function get(id) {
      return this.patterns[id];
    }
  }, {
    key: "has",
    value: function has(id) {
      return this.patterns[id] != null;
    }
  }]);

  return Grid;
}();

(function (Grid) {
  Grid.presets = grid_main_namespaceObject;
  Grid.registry = registry_Registry.create({
    type: 'grid'
  });
  Grid.registry.register(Grid.presets, true);
})(grid_Grid || (grid_Grid = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/util.js
function getString(value, defaultValue) {
  return value != null ? value : defaultValue;
}
function util_getNumber(num, defaultValue) {
  return num != null && isFinite(num) ? num : defaultValue;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/outline.js

function outline() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var color = getString(args.color, 'blue');
  var width = util_getNumber(args.width, 1);
  var margin = util_getNumber(args.margin, 2);
  var opacity = util_getNumber(args.opacity, 1);
  var innerRadius = margin;
  var outerRadius = margin + width;
  return "\n    <filter>\n      <feFlood flood-color=\"".concat(color, "\" flood-opacity=\"").concat(opacity, "\" result=\"colored\"/>\n      <feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"").concat(outerRadius, "\" />\n      <feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"").concat(innerRadius, "\" />\n      <feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/>\n      <feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/>\n      <feMerge>\n        <feMergeNode in=\"outline\"/>\n        <feMergeNode in=\"SourceGraphic\"/>\n      </feMerge>\n    </filter>\n  ").trim();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/highlight.js

function highlight_highlight() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var color = getString(args.color, 'red');
  var blur = util_getNumber(args.blur, 0);
  var width = util_getNumber(args.width, 1);
  var opacity = util_getNumber(args.opacity, 1);
  return "\n      <filter>\n        <feFlood flood-color=\"".concat(color, "\" flood-opacity=\"").concat(opacity, "\" result=\"colored\"/>\n        <feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"").concat(width, "\"/>\n        <feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/>\n        <feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"").concat(blur, "\"/>\n        <feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/>\n      </filter>\n    ").trim();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/blur.js

function blur_blur() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var x = util_getNumber(args.x, 2);
  var stdDeviation = args.y != null && isFinite(args.y) ? [x, args.y] : x;
  return "\n    <filter>\n      <feGaussianBlur stdDeviation=\"".concat(stdDeviation, "\"/>\n    </filter>\n  ").trim();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/drop-shadow.js

function dropShadow() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var dx = util_getNumber(args.dx, 0);
  var dy = util_getNumber(args.dy, 0);
  var color = getString(args.color, 'black');
  var blur = util_getNumber(args.blur, 4);
  var opacity = util_getNumber(args.opacity, 1);
  return 'SVGFEDropShadowElement' in window ? "<filter>\n         <feDropShadow stdDeviation=\"".concat(blur, "\" dx=\"").concat(dx, "\" dy=\"").concat(dy, "\" flood-color=\"").concat(color, "\" flood-opacity=\"").concat(opacity, "\" />\n       </filter>").trim() : "<filter>\n         <feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"".concat(blur, "\" />\n         <feOffset dx=\"").concat(dx, "\" dy=\"").concat(dy, "\" result=\"offsetblur\" />\n         <feFlood flood-color=\"").concat(color, "\" />\n         <feComposite in2=\"offsetblur\" operator=\"in\" />\n         <feComponentTransfer>\n           <feFuncA type=\"linear\" slope=\"").concat(opacity, "\" />\n         </feComponentTransfer>\n         <feMerge>\n           <feMergeNode/>\n           <feMergeNode in=\"SourceGraphic\"/>\n         </feMerge>\n       </filter>").trim();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/gray-scale.js

function grayScale() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var amount = util_getNumber(args.amount, 1);
  var a = 0.2126 + 0.7874 * (1 - amount);
  var b = 0.7152 - 0.7152 * (1 - amount);
  var c = 0.0722 - 0.0722 * (1 - amount);
  var d = 0.2126 - 0.2126 * (1 - amount);
  var e = 0.7152 + 0.2848 * (1 - amount);
  var f = 0.0722 - 0.0722 * (1 - amount);
  var g = 0.2126 - 0.2126 * (1 - amount);
  var h = 0.0722 + 0.9278 * (1 - amount);
  return "\n    <filter>\n      <feColorMatrix type=\"matrix\" values=\"".concat(a, " ").concat(b, " ").concat(c, " 0 0 ").concat(d, " ").concat(e, " ").concat(f, " 0 0 ").concat(g, " ").concat(b, " ").concat(h, " 0 0 0 0 0 1 0\"/>\n    </filter>\n  ").trim();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/sepia.js

function sepia() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var amount = util_getNumber(args.amount, 1);
  var a = 0.393 + 0.607 * (1 - amount);
  var b = 0.769 - 0.769 * (1 - amount);
  var c = 0.189 - 0.189 * (1 - amount);
  var d = 0.349 - 0.349 * (1 - amount);
  var e = 0.686 + 0.314 * (1 - amount);
  var f = 0.168 - 0.168 * (1 - amount);
  var g = 0.272 - 0.272 * (1 - amount);
  var h = 0.534 - 0.534 * (1 - amount);
  var i = 0.131 + 0.869 * (1 - amount);
  return "\n      <filter>\n        <feColorMatrix type=\"matrix\" values=\"".concat(a, " ").concat(b, " ").concat(c, " 0 0 ").concat(d, " ").concat(e, " ").concat(f, " 0 0 ").concat(g, " ").concat(h, " ").concat(i, " 0 0 0 0 0 1 0\"/>\n      </filter>\n    ").trim();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/saturate.js

function saturate() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var amount = util_getNumber(args.amount, 1);
  return "\n      <filter>\n        <feColorMatrix type=\"saturate\" values=\"".concat(1 - amount, "\"/>\n      </filter>\n    ").trim();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/hue-rotate.js

function hueRotate() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var angle = util_getNumber(args.angle, 0);
  return "\n      <filter>\n        <feColorMatrix type=\"hueRotate\" values=\"".concat(angle, "\"/>\n      </filter>\n    ").trim();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/invert.js

function invert() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var amount = util_getNumber(args.amount, 1);
  var amount2 = 1 - amount;
  return "\n      <filter>\n        <feComponentTransfer>\n          <feFuncR type=\"table\" tableValues=\"".concat(amount, " ").concat(amount2, "\"/>\n          <feFuncG type=\"table\" tableValues=\"").concat(amount, " ").concat(amount2, "\"/>\n          <feFuncB type=\"table\" tableValues=\"").concat(amount, " ").concat(amount2, "\"/>\n        </feComponentTransfer>\n      </filter>\n    ").trim();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/brightness.js

function brightness() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var amount = util_getNumber(args.amount, 1);
  return "\n    <filter>\n      <feComponentTransfer>\n        <feFuncR type=\"linear\" slope=\"".concat(amount, "\"/>\n        <feFuncG type=\"linear\" slope=\"").concat(amount, "\"/>\n        <feFuncB type=\"linear\" slope=\"").concat(amount, "\"/>\n      </feComponentTransfer>\n    </filter>\n  ").trim();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/contrast.js

function contrast() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var amount = util_getNumber(args.amount, 1);
  var amount2 = 0.5 - amount / 2;
  return "\n    <filter>\n     <feComponentTransfer>\n        <feFuncR type=\"linear\" slope=\"".concat(amount, "\" intercept=\"").concat(amount2, "\"/>\n        <feFuncG type=\"linear\" slope=\"").concat(amount, "\" intercept=\"").concat(amount2, "\"/>\n        <feFuncB type=\"linear\" slope=\"").concat(amount, "\" intercept=\"").concat(amount2, "\"/>\n      </feComponentTransfer>\n    </filter>\n  ").trim();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/main.js











// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/filter/index.js


var filter_Filter;

(function (Filter) {
  Filter.presets = filter_main_namespaceObject;
  Filter.registry = registry_Registry.create({
    type: 'filter'
  });
  Filter.registry.register(Filter.presets, true);
})(filter_Filter || (filter_Filter = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/background/flip-x.js
var flipX = function flipX(img) {
  // d b
  // d b
  var canvas = document.createElement('canvas');
  var width = img.width;
  var height = img.height;
  canvas.width = width * 2;
  canvas.height = height;
  var ctx = canvas.getContext('2d'); // left image

  ctx.drawImage(img, 0, 0, width, height); // flipped right image

  ctx.translate(2 * width, 0);
  ctx.scale(-1, 1);
  ctx.drawImage(img, 0, 0, width, height);
  return canvas;
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/background/flip-y.js
var flipY = function flipY(img) {
  // d d
  // q q
  var canvas = document.createElement('canvas');
  var width = img.width;
  var height = img.height;
  canvas.width = width;
  canvas.height = height * 2;
  var ctx = canvas.getContext('2d'); // top image

  ctx.drawImage(img, 0, 0, width, height); // flipped bottom image

  ctx.translate(0, 2 * height);
  ctx.scale(1, -1);
  ctx.drawImage(img, 0, 0, width, height);
  return canvas;
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/background/flip-xy.js
var flipXY = function flipXY(img) {
  // d b
  // q p
  var canvas = document.createElement('canvas');
  var width = img.width;
  var height = img.height;
  canvas.width = 2 * width;
  canvas.height = 2 * height;
  var ctx = canvas.getContext('2d'); // top-left image

  ctx.drawImage(img, 0, 0, width, height); // xy-flipped bottom-right image

  ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0, width, height); // x-flipped top-right image

  ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);
  ctx.drawImage(img, 0, 0, width, height); // y-flipped bottom-left image

  ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
  ctx.drawImage(img, 0, 0, width, height);
  return canvas;
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/background/watermark.js

var watermark_watermark = function watermark(img, options) {
  var width = img.width;
  var height = img.height;
  var canvas = document.createElement('canvas');
  canvas.width = width * 3;
  canvas.height = height * 3;
  var ctx = canvas.getContext('2d');
  var angle = options.angle != null ? -options.angle : -20;
  var radians = Angle.toRad(angle);
  var stepX = canvas.width / 4;
  var stepY = canvas.height / 4;

  for (var i = 0; i < 4; i += 1) {
    for (var j = 0; j < 4; j += 1) {
      if ((i + j) % 2 > 0) {
        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);
        ctx.rotate(radians);
        ctx.drawImage(img, -width / 2, -height / 2, width, height);
      }
    }
  }

  return canvas;
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/background/main.js




// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/background/index.js


var background_Background;

(function (Background) {
  Background.presets = background_main_namespaceObject;
  Background.registry = registry_Registry.create({
    type: 'background pattern'
  });
  Background.registry.register(Background.presets, true);
})(background_Background || (background_Background = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/global/util.js



var util_Util;

(function (Util) {
  Util.snapToGrid = util_snapToGrid;
  Util.normalizeMarker = util_normalize;

  function prefix(suffix) {
    return "".concat(Config.prefixCls, "-").concat(suffix);
  }

  Util.prefix = prefix;
})(util_Util || (util_Util = {}));

(function (Util) {
  function makeTree(parent, options, parentNode) {
    var _this = this;

    var collector = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var children = typeof options.children === 'function' ? options.children(parent) : parent[options.children || 'children'];

    if (!parentNode) {
      parentNode = options.createNode(parent); // tslint:disable-line

      collector.push(parentNode);
    }

    if (Array.isArray(children)) {
      children.forEach(function (child) {
        var node = options.createNode(child);
        var edge = options.createEdge(parentNode, node);
        collector.push(node, edge);

        _this.makeTree(child, options, node, collector);
      });
    }

    return collector;
  }

  Util.makeTree = makeTree;
})(util_Util || (util_Util = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/global/version.js
/* tslint:disable */

/**
 * Auto generated version file, do not modify it!
 */
var version = '0.10.62';

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/global/index.js



// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/highlighter/class.js


var defaultClassName = util_Util.prefix('highlighted');
var class_className = {
  highlight: function highlight(cellView, magnet, options) {
    var cls = options && options.className || defaultClassName;
    dom_main_namespaceObject.addClass(magnet, cls);
  },
  unhighlight: function unhighlight(cellView, magnet, options) {
    var cls = options && options.className || defaultClassName;
    dom_main_namespaceObject.removeClass(magnet, cls);
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/highlighter/opacity.js


var opacity_className = util_Util.prefix('highlight-opacity');
var opacity_opacity = {
  highlight: function highlight(cellView, magnet) {
    dom_main_namespaceObject.addClass(magnet, opacity_className);
  },
  unhighlight: function unhighlight(cellView, magnetEl) {
    dom_main_namespaceObject.removeClass(magnetEl, opacity_className);
  }
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/highlighter/stroke.js


var defaultOptions = {
  padding: 3,
  rx: 0,
  ry: 0,
  attrs: {
    'stroke-width': 3,
    stroke: '#FEB663'
  }
};
var stroke_stroke = {
  highlight: function highlight(cellView, magnet, options) {
    var id = stroke_Private.getHighlighterId(magnet, options);

    if (stroke_Private.hasCache(id)) {
      return;
    } // tslint:disable-next-line


    options = object_namespaceObject.defaultsDeep({}, options, defaultOptions);
    var magnetVel = dom_main_namespaceObject.createVector(magnet);
    var pathData;
    var magnetBBox;

    try {
      pathData = magnetVel.convertToPathData();
    } catch (error) {
      // Failed to get path data from magnet element.
      // Draw a rectangle around the entire cell view instead.
      magnetBBox = magnetVel.bbox(true
      /* without transforms */
      );
      pathData = dom_main_namespaceObject.rectToPathData(Object.assign(Object.assign({}, options), magnetBBox));
    }

    var path = dom_main_namespaceObject.createSvgElement('path');
    dom_main_namespaceObject.attr(path, Object.assign({
      d: pathData,
      'pointer-events': 'none',
      'vector-effect': 'non-scaling-stroke',
      fill: 'none'
    }, options.attrs)); // const highlightVel = v.create('path').attr()

    if (cellView.isEdgeElement(magnet)) {
      dom_main_namespaceObject.attr(path, 'd', cellView.getConnectionPathData());
    } else {
      var highlightMatrix = magnetVel.getTransformToElement(cellView.container); // Add padding to the highlight element.

      var padding = options.padding;

      if (padding) {
        if (magnetBBox == null) {
          magnetBBox = magnetVel.bbox(true);
        }

        var cx = magnetBBox.x + magnetBBox.width / 2;
        var cy = magnetBBox.y + magnetBBox.height / 2;
        magnetBBox = dom_main_namespaceObject.transformRectangle(magnetBBox, highlightMatrix);
        var width = Math.max(magnetBBox.width, 1);
        var height = Math.max(magnetBBox.height, 1);
        var sx = (width + padding) / width;
        var sy = (height + padding) / height;
        var paddingMatrix = dom_main_namespaceObject.createSVGMatrix({
          a: sx,
          b: 0,
          c: 0,
          d: sy,
          e: cx - sx * cx,
          f: cy - sy * cy
        });
        highlightMatrix = highlightMatrix.multiply(paddingMatrix);
      }

      dom_main_namespaceObject.transform(path, highlightMatrix);
    }

    dom_main_namespaceObject.addClass(path, util_Util.prefix('highlight-stroke'));
    var cell = cellView.cell;

    var removeHandler = function removeHandler() {
      return stroke_Private.removeHighlighter(id);
    };

    cell.on('removed', removeHandler);

    if (cell.model) {
      cell.model.on('reseted', removeHandler);
    }

    cellView.container.appendChild(path);
    stroke_Private.setCache(id, path);
  },
  unhighlight: function unhighlight(cellView, magnet, opt) {
    stroke_Private.removeHighlighter(stroke_Private.getHighlighterId(magnet, opt));
  }
};
var stroke_Private;

(function (Private) {
  function getHighlighterId(magnet, options) {
    dom_main_namespaceObject.ensureId(magnet);
    return magnet.id + JSON.stringify(options);
  }

  Private.getHighlighterId = getHighlighterId;
  var cache = {};

  function setCache(id, elem) {
    cache[id] = elem;
  }

  Private.setCache = setCache;

  function hasCache(id) {
    return cache[id] != null;
  }

  Private.hasCache = hasCache;

  function removeHighlighter(id) {
    var elem = cache[id];

    if (elem) {
      dom_main_namespaceObject.remove(elem);
      delete cache[id];
    }
  }

  Private.removeHighlighter = removeHighlighter;
})(stroke_Private || (stroke_Private = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/highlighter/main.js



// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/highlighter/index.js


var highlighter_Highlighter;

(function (Highlighter) {
  function check(name, highlighter) {
    if (typeof highlighter.highlight !== 'function') {
      throw new Error("Highlighter '".concat(name, "' is missing required `highlight()` method"));
    }

    if (typeof highlighter.unhighlight !== 'function') {
      throw new Error("Highlighter '".concat(name, "' is missing required `unhighlight()` method"));
    }
  }

  Highlighter.check = check;
})(highlighter_Highlighter || (highlighter_Highlighter = {}));

(function (Highlighter) {
  Highlighter.presets = highlighter_main_namespaceObject;
  Highlighter.registry = registry_Registry.create({
    type: 'highlighter'
  });
  Highlighter.registry.register(Highlighter.presets, true);
})(highlighter_Highlighter || (highlighter_Highlighter = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-layout/util.js


function normalizePoint(bbox) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new point_Point(number_namespaceObject.normalizePercentage(args.x, bbox.width), number_namespaceObject.normalizePercentage(args.y, bbox.height));
}
function toResult(point, angle, rawArgs) {
  return Object.assign({
    angle: angle,
    position: point.toJSON()
  }, rawArgs);
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-layout/absolute.js

var absolute_absolute = function absolute(portsPositionArgs, elemBBox) {
  return portsPositionArgs.map(function (_ref) {
    var x = _ref.x,
        y = _ref.y,
        angle = _ref.angle;
    return toResult(normalizePoint(elemBBox, {
      x: x,
      y: y
    }), angle || 0);
  });
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-layout/ellipse.js


var port_layout_ellipse_ellipse = function ellipse(portsPositionArgs, elemBBox, groupPositionArgs) {
  var startAngle = groupPositionArgs.start || 0;
  var stepAngle = groupPositionArgs.step || 20;
  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, function (index, count) {
    return (index + 0.5 - count / 2) * stepAngle;
  });
};
var ellipseSpread = function ellipseSpread(portsPositionArgs, elemBBox, groupPositionArgs) {
  var startAngle = groupPositionArgs.start || 0;
  var stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length;
  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, function (index) {
    return index * stepAngle;
  });
};

function ellipseLayout(portsPositionArgs, elemBBox, startAngle, stepFn) {
  var center = elemBBox.getCenter();
  var start = elemBBox.getTopCenter();
  var ratio = elemBBox.width / elemBBox.height;
  var ellipse = ellipse_Ellipse.fromRect(elemBBox);
  var count = portsPositionArgs.length;
  return portsPositionArgs.map(function (item, index) {
    var angle = startAngle + stepFn(index, count);
    var p = start.clone().rotate(-angle, center).scale(ratio, 1, center);
    var theta = item.compensateRotate ? -ellipse.tangentTheta(p) : 0;

    if (item.dx || item.dy) {
      p.translate(item.dx || 0, item.dy || 0);
    }

    if (item.dr) {
      p.move(center, item.dr);
    }

    return toResult(p.round(), theta, item);
  });
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-layout/line.js
var line_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



var line_line = function line(portsPositionArgs, elemBBox, groupPositionArgs) {
  var start = normalizePoint(elemBBox, groupPositionArgs.start || elemBBox.getOrigin());
  var end = normalizePoint(elemBBox, groupPositionArgs.end || elemBBox.getCorner());
  return lineLayout(portsPositionArgs, start, end, groupPositionArgs);
};
var line_left = function left(portsPositionArgs, elemBBox, groupPositionArgs) {
  return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getBottomLeft(), groupPositionArgs);
};
var line_right = function right(portsPositionArgs, elemBBox, groupPositionArgs) {
  return lineLayout(portsPositionArgs, elemBBox.getTopRight(), elemBBox.getBottomRight(), groupPositionArgs);
};
var line_top = function top(portsPositionArgs, elemBBox, groupPositionArgs) {
  return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getTopRight(), groupPositionArgs);
};
var line_bottom = function bottom(portsPositionArgs, elemBBox, groupPositionArgs) {
  return lineLayout(portsPositionArgs, elemBBox.getBottomLeft(), elemBBox.getBottomRight(), groupPositionArgs);
};

function lineLayout(portsPositionArgs, p1, p2, groupPositionArgs) {
  var line = new line_Line(p1, p2);
  var length = portsPositionArgs.length;
  return portsPositionArgs.map(function (_a, index) {
    var strict = _a.strict,
        offset = line_rest(_a, ["strict"]);

    var ratio = strict || groupPositionArgs.strict ? (index + 1) / (length + 1) : (index + 0.5) / length;
    var p = line.pointAt(ratio);

    if (offset.dx || offset.dy) {
      p.translate(offset.dx || 0, offset.dy || 0);
    }

    return toResult(p.round(), 0, offset);
  });
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-layout/main.js



// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-layout/index.js


var port_layout_PortLayout;

(function (PortLayout) {
  PortLayout.presets = port_layout_main_namespaceObject;
  PortLayout.registry = registry_Registry.create({
    type: 'port layout'
  });
  PortLayout.registry.register(PortLayout.presets, true);
})(port_layout_PortLayout || (port_layout_PortLayout = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-label-layout/util.js

var util_defaults = {
  position: {
    x: 0,
    y: 0
  },
  angle: 0,
  attrs: {
    '.': {
      y: '0',
      'text-anchor': 'start'
    }
  }
};
function util_toResult(preset, args) {
  var _ref = args || {},
      x = _ref.x,
      y = _ref.y,
      angle = _ref.angle,
      attrs = _ref.attrs;

  return object_namespaceObject.defaultsDeep({}, {
    angle: angle,
    attrs: attrs,
    position: {
      x: x,
      y: y
    }
  }, preset, util_defaults);
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-label-layout/side.js

var side_manual = function manual(portPosition, elemBBox, args) {
  return util_toResult({
    position: elemBBox.getTopLeft()
  }, args);
};
var side_left = function left(portPosition, elemBBox, args) {
  return util_toResult({
    position: {
      x: -15,
      y: 0
    },
    attrs: {
      '.': {
        y: '.3em',
        'text-anchor': 'end'
      }
    }
  }, args);
};
var side_right = function right(portPosition, elemBBox, args) {
  return util_toResult({
    position: {
      x: 15,
      y: 0
    },
    attrs: {
      '.': {
        y: '.3em',
        'text-anchor': 'start'
      }
    }
  }, args);
};
var side_top = function top(portPosition, elemBBox, args) {
  return util_toResult({
    position: {
      x: 0,
      y: -15
    },
    attrs: {
      '.': {
        'text-anchor': 'middle'
      }
    }
  }, args);
};
var side_bottom = function bottom(portPosition, elemBBox, args) {
  return util_toResult({
    position: {
      x: 0,
      y: 15
    },
    attrs: {
      '.': {
        y: '.6em',
        'text-anchor': 'middle'
      }
    }
  }, args);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-label-layout/inout.js

var outside = function outside(portPosition, elemBBox, args) {
  return outsideLayout(portPosition, elemBBox, false, args);
};
var outsideOriented = function outsideOriented(portPosition, elemBBox, args) {
  return outsideLayout(portPosition, elemBBox, true, args);
};
var inside = function inside(portPosition, elemBBox, args) {
  return insideLayout(portPosition, elemBBox, false, args);
};
var insideOriented = function insideOriented(portPosition, elemBBox, args) {
  return insideLayout(portPosition, elemBBox, true, args);
};

function outsideLayout(portPosition, elemBBox, autoOrient, args) {
  var offset = args.offset != null ? args.offset : 15;
  var angle = elemBBox.getCenter().theta(portPosition);
  var bboxAngles = getBBoxAngles(elemBBox);
  var y;
  var tx;
  var ty;
  var textAnchor;
  var orientAngle = 0;

  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
    y = '.3em';
    tx = offset;
    ty = 0;
    textAnchor = 'start';
  } else if (angle < bboxAngles[0]) {
    y = '0';
    tx = 0;
    ty = -offset;

    if (autoOrient) {
      orientAngle = -90;
      textAnchor = 'start';
    } else {
      textAnchor = 'middle';
    }
  } else if (angle < bboxAngles[3]) {
    y = '.3em';
    tx = -offset;
    ty = 0;
    textAnchor = 'end';
  } else {
    y = '.6em';
    tx = 0;
    ty = offset;

    if (autoOrient) {
      orientAngle = 90;
      textAnchor = 'start';
    } else {
      textAnchor = 'middle';
    }
  }

  return util_toResult({
    position: {
      x: Math.round(tx),
      y: Math.round(ty)
    },
    angle: orientAngle,
    attrs: {
      '.': {
        y: y,
        'text-anchor': textAnchor
      }
    }
  }, args);
}

function insideLayout(portPosition, elemBBox, autoOrient, args) {
  var offset = args.offset != null ? args.offset : 15;
  var angle = elemBBox.getCenter().theta(portPosition);
  var bboxAngles = getBBoxAngles(elemBBox);
  var y;
  var tx;
  var ty;
  var textAnchor;
  var orientAngle = 0;

  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
    y = '.3em';
    tx = -offset;
    ty = 0;
    textAnchor = 'end';
  } else if (angle < bboxAngles[0]) {
    y = '.6em';
    tx = 0;
    ty = offset;

    if (autoOrient) {
      orientAngle = 90;
      textAnchor = 'start';
    } else {
      textAnchor = 'middle';
    }
  } else if (angle < bboxAngles[3]) {
    y = '.3em';
    tx = offset;
    ty = 0;
    textAnchor = 'start';
  } else {
    y = '0em';
    tx = 0;
    ty = -offset;

    if (autoOrient) {
      orientAngle = -90;
      textAnchor = 'start';
    } else {
      textAnchor = 'middle';
    }
  }

  return util_toResult({
    position: {
      x: Math.round(tx),
      y: Math.round(ty)
    },
    angle: orientAngle,
    attrs: {
      '.': {
        y: y,
        'text-anchor': textAnchor
      }
    }
  }, args);
}

function getBBoxAngles(elemBBox) {
  var center = elemBBox.getCenter();
  var tl = center.theta(elemBBox.getTopLeft());
  var bl = center.theta(elemBBox.getBottomLeft());
  var br = center.theta(elemBBox.getBottomRight());
  var tr = center.theta(elemBBox.getTopRight());
  return [tl, tr, br, bl];
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-label-layout/radial.js


var radial = function radial(portPosition, elemBBox, args) {
  return radialLayout(portPosition.diff(elemBBox.getCenter()), false, args);
};
var radialOriented = function radialOriented(portPosition, elemBBox, args) {
  return radialLayout(portPosition.diff(elemBBox.getCenter()), true, args);
};

function radialLayout(portCenterOffset, autoOrient, args) {
  var offset = args.offset != null ? args.offset : 20;
  var origin = new point_Point(0, 0);
  var angle = -portCenterOffset.theta(origin);
  var pos = portCenterOffset.clone().move(origin, offset).diff(portCenterOffset).round();
  var y = '.3em';
  var textAnchor;
  var orientAngle = angle;

  if ((angle + 90) % 180 === 0) {
    textAnchor = autoOrient ? 'end' : 'middle';

    if (!autoOrient && angle === -270) {
      y = '0em';
    }
  } else if (angle > -270 && angle < -90) {
    textAnchor = 'start';
    orientAngle = angle - 180;
  } else {
    textAnchor = 'end';
  }

  return util_toResult({
    position: pos.round().toJSON(),
    angle: autoOrient ? orientAngle : 0,
    attrs: {
      '.': {
        y: y,
        'text-anchor': textAnchor
      }
    }
  }, args);
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-label-layout/main.js



// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/port-label-layout/index.js


var port_label_layout_PortLabelLayout;

(function (PortLabelLayout) {
  PortLabelLayout.presets = port_label_layout_main_namespaceObject;
  PortLabelLayout.registry = registry_Registry.create({
    type: 'port label layout'
  });
  PortLabelLayout.registry.register(PortLabelLayout.presets, true);
})(port_label_layout_PortLabelLayout || (port_label_layout_PortLabelLayout = {}));
// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js + 1 modules
var esm_get = __webpack_require__(8);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(6);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/view/view.js









var view_View = /*#__PURE__*/function (_Basecoat) {
  Object(inherits["a" /* default */])(View, _Basecoat);

  var _super = Object(createSuper["a" /* default */])(View);

  function View() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, View);

    _this = _super.call(this);
    _this.cid = view_Private.uniqueId();
    View.views[_this.cid] = Object(assertThisInitialized["a" /* default */])(_this);
    return _this;
  }

  Object(createClass["a" /* default */])(View, [{
    key: "confirmUpdate",
    value: function confirmUpdate(flag, options) {
      return 0;
    } // tslint:disable-next-line

  }, {
    key: "$",
    value: function $(elem) {
      return View.$(elem);
    }
  }, {
    key: "empty",
    value: function empty() {
      var elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.container;
      this.$(elem).empty();
      return this;
    }
  }, {
    key: "unmount",
    value: function unmount() {
      var elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.container;
      this.$(elem).remove();
      return this;
    }
  }, {
    key: "remove",
    value: function remove() {
      var elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.container;

      if (elem === this.container) {
        this.removeEventListeners(document);
        this.onRemove();
        delete View.views[this.cid];
      }

      this.unmount(elem);
      return this;
    }
  }, {
    key: "onRemove",
    value: function onRemove() {}
  }, {
    key: "addClass",
    value: function addClass(className) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;
      this.$(elem).addClass(Array.isArray(className) ? className.join(' ') : className);
      return this;
    }
  }, {
    key: "removeClass",
    value: function removeClass(className) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;
      this.$(elem).removeClass(Array.isArray(className) ? className.join(' ') : className);
      return this;
    }
  }, {
    key: "setStyle",
    value: function setStyle(style) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;
      this.$(elem).css(style);
      return this;
    }
  }, {
    key: "setAttrs",
    value: function setAttrs(attrs) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;

      if (attrs != null && elem != null) {
        if (elem instanceof SVGElement) {
          dom_main_namespaceObject.attr(elem, attrs);
        } else {
          this.$(elem).attr(attrs);
        }
      }

      return this;
    }
    /**
     * Returns the value of the specified attribute of `node`.
     *
     * If the node does not set a value for attribute, start recursing up
     * the DOM tree from node to lookup for attribute at the ancestors of
     * node. If the recursion reaches CellView's root node and attribute
     * is not found even there, return `null`.
     */

  }, {
    key: "findAttr",
    value: function findAttr(attrName) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;
      var current = elem;

      while (current && current.nodeType === 1) {
        var value = current.getAttribute(attrName);

        if (value != null) {
          return value;
        }

        if (current === this.container) {
          return null;
        }

        current = current.parentNode;
      }

      return null;
    }
  }, {
    key: "find",
    value: function find(selector) {
      var rootElem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;
      var selectors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.selectors;
      return View.find(selector, rootElem, selectors).elems;
    }
  }, {
    key: "findOne",
    value: function findOne(selector) {
      var rootElem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;
      var selectors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.selectors;
      var nodes = this.find(selector, rootElem, selectors);
      return nodes.length > 0 ? nodes[0] : null;
    }
  }, {
    key: "findByAttr",
    value: function findByAttr(attrName) {
      var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;
      var node = elem;

      while (node && node.getAttribute) {
        var val = node.getAttribute(attrName);

        if ((val != null || node === this.container) && val !== 'false') {
          return node;
        }

        node = node.parentNode;
      } // If the overall cell has set `magnet === false`, then returns
      // `null` to announce there is no magnet found for this cell.
      // This is especially useful to set on cells that have 'ports'.
      // In this case, only the ports have set `magnet === true` and the
      // overall element has `magnet === false`.


      return null;
    }
  }, {
    key: "getSelector",
    value: function getSelector(elem, prevSelector) {
      var selector;

      if (elem === this.container) {
        if (typeof prevSelector === 'string') {
          selector = "> ".concat(prevSelector);
        }

        return selector;
      }

      if (elem) {
        var nth = dom_main_namespaceObject.index(elem) + 1;
        selector = "".concat(elem.tagName.toLowerCase(), ":nth-child(").concat(nth, ")");

        if (prevSelector) {
          selector += " > ".concat(prevSelector);
        }

        selector = this.getSelector(elem.parentNode, selector);
      }

      return selector;
    }
  }, {
    key: "prefixClassName",
    value: function prefixClassName(className) {
      return util_Util.prefix(className);
    }
  }, {
    key: "delegateEvents",
    value: function delegateEvents(events, append) {
      var _this2 = this;

      if (events == null) {
        return this;
      }

      if (!append) {
        this.undelegateEvents();
      }

      var splitter = /^(\S+)\s*(.*)$/;
      Object.keys(events).forEach(function (key) {
        var match = key.match(splitter);

        if (match == null) {
          return;
        }

        var method = _this2.getEventHandler(events[key]);

        if (typeof method === 'function') {
          _this2.delegateEvent(match[1], match[2], method);
        }
      });
      return this;
    }
  }, {
    key: "undelegateEvents",
    value: function undelegateEvents() {
      this.$(this.container).off(this.getEventNamespace());
      return this;
    }
  }, {
    key: "delegateDocumentEvents",
    value: function delegateDocumentEvents(events, data) {
      this.addEventListeners(document, events, data);
      return this;
    }
  }, {
    key: "undelegateDocumentEvents",
    value: function undelegateDocumentEvents() {
      this.removeEventListeners(document);
      return this;
    }
  }, {
    key: "delegateEvent",
    value: function delegateEvent(eventName, selector, listener) {
      this.$(this.container).on(eventName + this.getEventNamespace(), selector, listener);
      return this;
    }
  }, {
    key: "undelegateEvent",
    value: function undelegateEvent(eventName, selector, listener) {
      var name = eventName + this.getEventNamespace();

      if (selector == null) {
        this.$(this.container).off(name);
      } else if (typeof selector === 'string') {
        this.$(this.container).off(name, selector, listener);
      } else {
        this.$(this.container).off(name, selector);
      }

      return this;
    }
  }, {
    key: "addEventListeners",
    value: function addEventListeners(elem, events, data) {
      var _this3 = this;

      if (events == null) {
        return this;
      }

      var ns = this.getEventNamespace();
      var $elem = this.$(elem);
      Object.keys(events).forEach(function (eventName) {
        var method = _this3.getEventHandler(events[eventName]);

        if (typeof method === 'function') {
          $elem.on(eventName + ns, data, method);
        }
      });
      return this;
    }
  }, {
    key: "removeEventListeners",
    value: function removeEventListeners(elem) {
      if (elem != null) {
        this.$(elem).off(this.getEventNamespace());
      }

      return this;
    }
  }, {
    key: "getEventNamespace",
    value: function getEventNamespace() {
      return ".".concat(Config.prefixCls, "-event-").concat(this.cid);
    }
  }, {
    key: "getEventHandler",
    value: function getEventHandler(handler) {
      var _this4 = this;

      var method;

      if (typeof handler === 'string') {
        var fn = this[handler];

        if (typeof fn === 'function') {
          method = function method() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return fn.call.apply(fn, [_this4].concat(args));
          };
        }
      } else {
        method = function method() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return handler.call.apply(handler, [_this4].concat(args));
        };
      }

      return method;
    }
  }, {
    key: "getEventTarget",
    value: function getEventTarget(e) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // Touchmove/Touchend event's target is not reflecting the element
      // under the coordinates as mousemove does.
      // It holds the element when a touchstart triggered.
      var target = e.target,
          type = e.type,
          _e$clientX = e.clientX,
          clientX = _e$clientX === void 0 ? 0 : _e$clientX,
          _e$clientY = e.clientY,
          clientY = _e$clientY === void 0 ? 0 : _e$clientY;

      if (options.fromPoint || type === 'touchmove' || type === 'touchend') {
        return document.elementFromPoint(clientX, clientY);
      }

      return target;
    }
  }, {
    key: "stopPropagation",
    value: function stopPropagation(e) {
      this.setEventData(e, {
        propagationStopped: true
      });
      return this;
    }
  }, {
    key: "isPropagationStopped",
    value: function isPropagationStopped(e) {
      return this.getEventData(e).propagationStopped === true;
    }
  }, {
    key: "getEventData",
    value: function getEventData(e) {
      return this.eventData(e);
    }
  }, {
    key: "setEventData",
    value: function setEventData(e, data) {
      return this.eventData(e, data);
    }
  }, {
    key: "eventData",
    value: function eventData(e, data) {
      if (e == null) {
        throw new TypeError('Event object required');
      }

      var currentData = e.data;
      var key = "__".concat(this.cid, "__"); // get

      if (data == null) {
        if (currentData == null) {
          return {};
        }

        return currentData[key] || {};
      } // set


      if (currentData == null) {
        currentData = e.data = {};
      }

      if (currentData[key] == null) {
        currentData[key] = Object.assign({}, data);
      } else {
        currentData[key] = Object.assign(Object.assign({}, currentData[key]), data);
      }

      return currentData[key];
    }
  }, {
    key: "normalizeEvent",
    value: function normalizeEvent(evt) {
      return View.normalizeEvent(evt);
    }
  }, {
    key: "priority",
    get: function get() {
      return 2;
    }
  }]);

  return View;
}(basecoat_Basecoat);

(function (View) {
  // tslint:disable-next-line
  function $(elem) {
    return jquery_default()(elem);
  }

  View.$ = $;

  function createElement(tagName, isSvgElement) {
    return isSvgElement ? dom_main_namespaceObject.createSvgElement(tagName || 'g') : dom_main_namespaceObject.createElementNS(tagName || 'div');
  }

  View.createElement = createElement;

  function find(selector) {
    var rootElem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;
    var selectors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.selectors;

    if (!selector || selector === '.') {
      return {
        elems: [rootElem]
      };
    }

    if (selectors) {
      var nodes = selectors[selector];

      if (nodes) {
        return {
          elems: Array.isArray(nodes) ? nodes : [nodes]
        };
      }
    }

    if (Config.useCSSSelector) {
      return {
        isCSSSelector: true,
        elems: $(rootElem).find(selector).toArray()
      };
    }

    return {
      elems: []
    };
  }

  View.find = find;

  function normalizeEvent(evt) {
    var normalizedEvent = evt;
    var originalEvent = evt.originalEvent;
    var touchEvt = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];

    if (touchEvt) {
      for (var key in evt) {
        // copy all the properties from the input event that are not
        // defined on the touch event (functions included).
        if (touchEvt[key] === undefined) {
          touchEvt[key] = evt[key];
        }
      }

      normalizedEvent = touchEvt;
    } // IE: evt.target could be set to SVGElementInstance for SVGUseElement


    var target = normalizedEvent.target;

    if (target) {
      var useElement = target.correspondingUseElement;

      if (useElement) {
        normalizedEvent.target = useElement;
      }
    }

    return normalizedEvent;
  }

  View.normalizeEvent = normalizeEvent;
})(view_View || (view_View = {}));

(function (View) {
  View.views = {};

  function getView(cid) {
    return View.views[cid] || null;
  }

  View.getView = getView;
})(view_View || (view_View = {}));

var view_Private;

(function (Private) {
  var counter = 0;

  function uniqueId() {
    var id = "v".concat(counter);
    counter += 1;
    return id;
  }

  Private.uniqueId = uniqueId;
})(view_Private || (view_Private = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connection-strategy/noop.js
var noop_noop = function noop(terminal) {
  return terminal;
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connection-strategy/pin.js


function toPercentage(value, max) {
  if (max === 0) {
    return '0%';
  }

  return "".concat(Math.round(value / max * 100), "%");
}

function pin(relative) {
  var strategy = function strategy(terminal, view, magnet, coords) {
    return view.isEdgeElement(magnet) ? pinEdgeTerminal(relative, terminal, view, magnet, coords) : pinNodeTerminal(relative, terminal, view, magnet, coords);
  };

  return strategy;
}

function pinNodeTerminal(relative, data, view, magnet, coords) {
  var node = view.cell;
  var angle = node.getAngle();
  var bbox = view.getUnrotatedBBoxOfElement(magnet);
  var center = node.getBBox().getCenter();
  var pos = point_Point.create(coords).rotate(angle, center);
  var dx = pos.x - bbox.x;
  var dy = pos.y - bbox.y;

  if (relative) {
    dx = toPercentage(dx, bbox.width);
    dy = toPercentage(dy, bbox.height);
  }

  data.anchor = {
    name: 'topLeft',
    args: {
      dx: dx,
      dy: dy,
      rotate: true
    }
  };
  return data;
}

function pinEdgeTerminal(relative, end, view, magnet, coords) {
  var connection = view.getConnection();

  if (!connection) {
    return end;
  }

  var length = connection.closestPointLength(coords);

  if (relative) {
    var totalLength = connection.length();
    end.anchor = {
      name: 'ratio',
      args: {
        ratio: length / totalLength
      }
    };
  } else {
    end.anchor = {
      name: 'length',
      args: {
        length: length
      }
    };
  }

  return end;
}

var pinRelative = pin(true);
var pinAbsolute = pin(false);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connection-strategy/main.js


// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connection-strategy/index.js


var connection_strategy_ConnectionStrategy;

(function (ConnectionStrategy) {
  ConnectionStrategy.presets = connection_strategy_main_namespaceObject;
  ConnectionStrategy.registry = registry_Registry.create({
    type: 'connection strategy'
  });
  ConnectionStrategy.registry.register(ConnectionStrategy.presets, true);
})(connection_strategy_ConnectionStrategy || (connection_strategy_ConnectionStrategy = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/view/cache.js




var cache_Cache = /*#__PURE__*/function () {
  function Cache(view) {
    Object(classCallCheck["a" /* default */])(this, Cache);

    this.view = view;
    this.clean();
  }

  Object(createClass["a" /* default */])(Cache, [{
    key: "clean",
    value: function clean() {
      if (this.elemCache) {
        this.elemCache.dispose();
      }

      this.elemCache = new dictionary_Dictionary();
      this.pathCache = {};
    }
  }, {
    key: "get",
    value: function get(elem) {
      var cache = this.elemCache;

      if (!cache.has(elem)) {
        this.elemCache.set(elem, {});
      }

      return this.elemCache.get(elem);
    }
  }, {
    key: "getData",
    value: function getData(elem) {
      var meta = this.get(elem);

      if (!meta.data) {
        meta.data = {};
      }

      return meta.data;
    }
  }, {
    key: "getMatrix",
    value: function getMatrix(elem) {
      var meta = this.get(elem);

      if (meta.matrix == null) {
        var target = this.view.rotatableNode || this.view.container;
        meta.matrix = dom_main_namespaceObject.getTransformToElement(elem, target);
      }

      return dom_main_namespaceObject.createSVGMatrix(meta.matrix);
    }
  }, {
    key: "getShape",
    value: function getShape(elem) {
      var meta = this.get(elem);

      if (meta.shape == null) {
        meta.shape = dom_main_namespaceObject.toGeometryShape(elem);
      }

      return meta.shape.clone();
    }
  }, {
    key: "getBoundingRect",
    value: function getBoundingRect(elem) {
      var meta = this.get(elem);

      if (meta.boundingRect == null) {
        meta.boundingRect = dom_main_namespaceObject.getBBox(elem);
      }

      return meta.boundingRect.clone();
    }
  }]);

  return Cache;
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/view/markup.js

var markup_Markup;

(function (Markup) {
  function isJSONMarkup(markup) {
    return markup != null && !isStringMarkup(markup);
  }

  Markup.isJSONMarkup = isJSONMarkup;

  function isStringMarkup(markup) {
    return markup != null && typeof markup === 'string';
  }

  Markup.isStringMarkup = isStringMarkup;

  function clone(markup) {
    return markup == null || isStringMarkup(markup) ? markup : object_namespaceObject.cloneDeep(markup);
  }

  Markup.clone = clone;
  /**
   * Removes blank space in markup to prevent create empty text node.
   */

  function sanitize(markup) {
    return "".concat(markup).trim().replace(/[\r|\n]/g, ' ').replace(/>\s+</g, '><');
  }

  Markup.sanitize = sanitize;

  function parseStringMarkup(markup) {
    var fragment = document.createDocumentFragment();
    var groups = {};
    var selectors = {};
    var sanitized = sanitize(markup);
    var nodes = string_namespaceObject.sanitizeHTML(sanitized, {
      raw: true
    });
    nodes.forEach(function (node) {
      fragment.appendChild(node);
    });
    return {
      fragment: fragment,
      selectors: selectors,
      groups: groups
    };
  }

  Markup.parseStringMarkup = parseStringMarkup;

  function parseJSONMarkup(markup) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ns: dom_main_namespaceObject.ns.svg
    };
    var fragment = document.createDocumentFragment();
    var groups = {};
    var selectors = {};
    var queue = [{
      markup: Array.isArray(markup) ? markup : [markup],
      parent: fragment,
      ns: options.ns
    }];

    var _loop = function _loop() {
      var item = queue.pop();
      var ns = item.ns || dom_main_namespaceObject.ns.svg;
      var defines = item.markup;
      var parentNode = item.parent;
      defines.forEach(function (define) {
        // tagName
        var tagName = define.tagName;

        if (!tagName) {
          throw new TypeError('Invalid tagName');
        } // ns


        if (define.ns) {
          ns = define.ns;
        }

        var svg = ns === dom_main_namespaceObject.ns.svg;
        var node = ns ? dom_main_namespaceObject.createElementNS(tagName, ns) : dom_main_namespaceObject.createElement(tagName); // attrs

        var attrs = define.attrs;

        if (attrs) {
          if (svg) {
            dom_main_namespaceObject.attr(node, attrs);
          } else {
            jquery_default()(node).attr(attrs);
          }
        } // style


        var style = define.style;

        if (style) {
          jquery_default()(node).css(style);
        } // classname


        var className = define.className;

        if (className != null) {
          node.setAttribute('class', Array.isArray(className) ? className.join(' ') : className);
        } // textContent


        if (define.textContent) {
          node.textContent = define.textContent;
        } // selector


        var selector = define.selector;

        if (selector != null) {
          if (selectors[selector]) {
            throw new TypeError('Selector must be unique');
          }

          selectors[selector] = node;
        } // group


        if (define.groupSelector) {
          var nodeGroups = define.groupSelector;

          if (!Array.isArray(nodeGroups)) {
            nodeGroups = [nodeGroups];
          }

          nodeGroups.forEach(function (name) {
            if (!groups[name]) {
              groups[name] = [];
            }

            groups[name].push(node);
          });
        }

        parentNode.appendChild(node); // children

        var children = define.children;

        if (Array.isArray(children)) {
          queue.push({
            ns: ns,
            markup: children,
            parent: node
          });
        }
      });
    };

    while (queue.length > 0) {
      _loop();
    }

    Object.keys(groups).forEach(function (groupName) {
      if (selectors[groupName]) {
        throw new Error('Ambiguous group selector');
      }

      selectors[groupName] = groups[groupName];
    });
    return {
      fragment: fragment,
      selectors: selectors,
      groups: groups
    };
  }

  Markup.parseJSONMarkup = parseJSONMarkup;

  function createContainer(firstChild) {
    return firstChild instanceof SVGElement ? dom_main_namespaceObject.createSvgElement('g') : dom_main_namespaceObject.createElement('div');
  }

  function renderMarkup(markup) {
    if (isStringMarkup(markup)) {
      var nodes = dom_main_namespaceObject.createVectors(markup);
      var count = nodes.length;

      if (count === 1) {
        return {
          elem: nodes[0].node
        };
      }

      if (count > 1) {
        var _elem = createContainer(nodes[0].node);

        nodes.forEach(function (node) {
          _elem.appendChild(node.node);
        });
        return {
          elem: _elem
        };
      }

      return {};
    }

    var result = parseJSONMarkup(markup);
    var fragment = result.fragment;
    var elem = null;

    if (fragment.childNodes.length > 1) {
      elem = createContainer(fragment.firstChild);
      elem.appendChild(fragment);
    } else {
      elem = fragment.firstChild;
    }

    return {
      elem: elem,
      selectors: result.selectors
    };
  }

  Markup.renderMarkup = renderMarkup;

  function parseLabelStringMarkup(markup) {
    var children = dom_main_namespaceObject.createVectors(markup);
    var fragment = document.createDocumentFragment();

    for (var i = 0, n = children.length; i < n; i += 1) {
      var currentChild = children[i].node;
      fragment.appendChild(currentChild);
    }

    return {
      fragment: fragment,
      selectors: {}
    };
  }

  Markup.parseLabelStringMarkup = parseLabelStringMarkup;
})(markup_Markup || (markup_Markup = {}));

(function (Markup) {
  function getPortContainerMarkup() {
    return 'g';
  }

  Markup.getPortContainerMarkup = getPortContainerMarkup;

  function getPortMarkup() {
    return {
      tagName: 'circle',
      selector: 'circle',
      attrs: {
        r: 10,
        fill: '#FFFFFF',
        stroke: '#000000'
      }
    };
  }

  Markup.getPortMarkup = getPortMarkup;

  function getPortLabelMarkup() {
    return {
      tagName: 'text',
      selector: 'text',
      attrs: {
        fill: '#000000'
      }
    };
  }

  Markup.getPortLabelMarkup = getPortLabelMarkup;
})(markup_Markup || (markup_Markup = {}));

(function (Markup) {
  function getEdgeMarkup() {
    return Markup.sanitize("\n    <path class=\"connection\" stroke=\"black\" d=\"M 0 0 0 0\"/>\n    <path class=\"source-marker\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>\n    <path class=\"target-marker\" fill=\"black\" stroke=\"black\" d=\"M 0 0 0 0\"/>\n    <path class=\"connection-wrap\" d=\"M 0 0 0 0\"/>\n    <g class=\"labels\"/>\n    <g class=\"vertices\"/>\n    <g class=\"arrowheads\"/>\n    <g class=\"tools\"/>\n  ");
  }

  Markup.getEdgeMarkup = getEdgeMarkup;

  function getEdgeToolMarkup() {
    return Markup.sanitize("\n    <g class=\"edge-tool\">\n      <g class=\"tool-remove\" event=\"edge:remove\">\n        <circle r=\"11\" />\n        <path transform=\"scale(.8) translate(-16, -16)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\" />\n        <title>Remove edge.</title>\n      </g>\n      <g class=\"tool-options\" event=\"edge:options\">\n        <circle r=\"11\" transform=\"translate(25)\"/>\n        <path fill=\"white\" transform=\"scale(.55) translate(29, -16)\" d=\"M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z\"/>\n        <title>Edge options.</title>\n      </g>\n    </g>\n  ");
  }

  Markup.getEdgeToolMarkup = getEdgeToolMarkup;

  function getEdgeVertexMarkup() {
    return Markup.sanitize("\n    <g class=\"vertex-group\" transform=\"translate(<%= x %>, <%= y %>)\">\n      <circle class=\"vertex\" data-index=\"<%= index %>\" r=\"10\" />\n      <path class=\"vertex-remove-area\" data-index=\"<%= index %>\" d=\"M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z\" transform=\"translate(5, -33)\"/>\n      <path class=\"vertex-remove\" data-index=\"<%= index %>\" transform=\"scale(.8) translate(9.5, -37)\" d=\"M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z\">\n      <title>Remove vertex.</title>\n      </path>\n    </g>\n  ");
  }

  Markup.getEdgeVertexMarkup = getEdgeVertexMarkup;

  function getEdgeArrowheadMarkup() {
    return Markup.sanitize("\n    <g class=\"arrowhead-group arrowhead-group-<%= end %>\">\n      <path class=\"arrowhead\" data-terminal=\"<%= end %>\" d=\"M 26 0 L 0 13 L 26 26 z\" />\n    </g>\n  ");
  }

  Markup.getEdgeArrowheadMarkup = getEdgeArrowheadMarkup;
})(markup_Markup || (markup_Markup = {}));

(function (Markup) {
  function getForeignObjectMarkup() {
    return {
      tagName: 'foreignObject',
      selector: 'fo',
      children: [{
        ns: dom_main_namespaceObject.ns.xhtml,
        tagName: 'body',
        selector: 'foBody',
        attrs: {
          xmlns: dom_main_namespaceObject.ns.xhtml
        },
        style: {
          width: '100%',
          height: '100%'
        },
        children: [{
          tagName: 'div',
          selector: 'foContent',
          style: {
            width: '100%',
            height: '100%'
          }
        }]
      }]
    };
  }

  Markup.getForeignObjectMarkup = getForeignObjectMarkup;
})(markup_Markup || (markup_Markup = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/view/attr.js







var attr_AttrManager = /*#__PURE__*/function () {
  function AttrManager(view) {
    Object(classCallCheck["a" /* default */])(this, AttrManager);

    this.view = view;
  }

  Object(createClass["a" /* default */])(AttrManager, [{
    key: "getDefinition",
    value: function getDefinition(attrName) {
      return this.cell.getAttrDefinition(attrName);
    }
  }, {
    key: "processAttrs",
    value: function processAttrs(elem, raw) {
      var _this = this;

      var normal;
      var set;
      var offset;
      var position;
      var specials = [];

      var kebabCase = function kebabCase(s) {
        return s.replace(/[A-Z]/g, '-$&').toLowerCase();
      }; // divide the attributes between normal and special


      Object.keys(raw).forEach(function (name) {
        var val = raw[name];

        var definition = _this.getDefinition(name);

        var isValid = main_namespaceObject.call(attr_Attr.isValidDefinition, _this.view, definition, val, {
          elem: elem,
          attrs: raw,
          cell: _this.cell,
          view: _this.view
        });

        if (definition && isValid) {
          if (typeof definition === 'string') {
            if (normal == null) {
              normal = {};
            }

            normal[definition] = val;
          } else if (val !== null) {
            specials.push({
              name: name,
              definition: definition
            });
          }
        } else {
          if (normal == null) {
            normal = {};
          }

          normal[kebabCase(name)] = val;
        }
      });
      specials.forEach(function (_ref) {
        var name = _ref.name,
            definition = _ref.definition;
        var val = raw[name];
        var setDefine = definition;

        if (typeof setDefine.set === 'function') {
          if (set == null) {
            set = {};
          }

          set[name] = val;
        }

        var offsetDefine = definition;

        if (typeof offsetDefine.offset === 'function') {
          if (offset == null) {
            offset = {};
          }

          offset[name] = val;
        }

        var positionDefine = definition;

        if (typeof positionDefine.position === 'function') {
          if (position == null) {
            position = {};
          }

          position[name] = val;
        }
      });
      return {
        raw: raw,
        normal: normal,
        set: set,
        offset: offset,
        position: position
      };
    }
  }, {
    key: "mergeProcessedAttrs",
    value: function mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {
      allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);
      allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);
      allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset); // Handle also the special transform property.

      var transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;

      if (transform != null && roProcessedAttrs.normal) {
        roProcessedAttrs.normal.transform = transform;
      }

      allProcessedAttrs.normal = roProcessedAttrs.normal;
    }
  }, {
    key: "findAttrs",
    value: function findAttrs(cellAttrs, rootNode, selectorCache, selectors) {
      var merge = [];
      var result = new dictionary_Dictionary();
      Object.keys(cellAttrs).forEach(function (selector) {
        var attrs = cellAttrs[selector];

        if (!object_namespaceObject.isPlainObject(attrs)) {
          return;
        }

        var _View$find = view_View.find(selector, rootNode, selectors),
            isCSSSelector = _View$find.isCSSSelector,
            elems = _View$find.elems;

        selectorCache[selector] = elems;

        for (var i = 0, l = elems.length; i < l; i += 1) {
          var elem = elems[i];
          var unique = selectors && selectors[selector] === elem;
          var prev = result.get(elem);

          if (prev) {
            if (!prev.array) {
              merge.push(elem);
              prev.array = true;
              prev.attrs = [prev.attrs];
              prev.priority = [prev.priority];
            }

            var attributes = prev.attrs;
            var selectedLength = prev.priority;

            if (unique) {
              // node referenced by `selector`
              attributes.unshift(attrs);
              selectedLength.unshift(-1);
            } else {
              // node referenced by `groupSelector` or CSSSelector
              var sortIndex = array_namespaceObject.sortedIndex(selectedLength, isCSSSelector ? -1 : l);
              attributes.splice(sortIndex, 0, attrs);
              selectedLength.splice(sortIndex, 0, l);
            }
          } else {
            result.set(elem, {
              elem: elem,
              attrs: attrs,
              priority: unique ? -1 : l,
              array: false
            });
          }
        }
      });
      merge.forEach(function (node) {
        var item = result.get(node);
        var arr = item.attrs;
        item.attrs = arr.reduceRight(function (memo, attrs) {
          return Object.assign(Object.assign({}, memo), attrs);
        }, {});
      });
      return result;
    }
  }, {
    key: "updateRelativeAttrs",
    value: function updateRelativeAttrs(elem, processedAttrs, refBBox, options) {
      var _this2 = this;

      var rawAttrs = processedAttrs.raw || {};
      var nodeAttrs = processedAttrs.normal || {};
      var setAttrs = processedAttrs.set;
      var positionAttrs = processedAttrs.position;
      var offsetAttrs = processedAttrs.offset;

      var getOptions = function getOptions() {
        return {
          elem: elem,
          cell: _this2.cell,
          view: _this2.view,
          attrs: rawAttrs,
          refBBox: refBBox.clone()
        };
      };

      if (setAttrs != null) {
        Object.keys(setAttrs).forEach(function (name) {
          var val = setAttrs[name];

          var def = _this2.getDefinition(name);

          if (def != null) {
            var ret = main_namespaceObject.call(def.set, _this2.view, val, getOptions());

            if (typeof ret === 'object') {
              nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);
            } else if (ret != null) {
              nodeAttrs[name] = ret;
            }
          }
        });
      }

      if (elem instanceof HTMLElement) {
        // TODO: setting the `transform` attribute on HTMLElements
        // via `node.style.transform = 'matrix(...)';` would introduce
        // a breaking change (e.g. basic.TextBlock).
        this.view.setAttrs(nodeAttrs, elem);
        return;
      } // The final translation of the subelement.


      var nodeTransform = nodeAttrs.transform;
      var transform = nodeTransform ? "".concat(nodeTransform) : null;
      var nodeMatrix = dom_main_namespaceObject.transformStringToMatrix(transform);
      var nodePosition = new point_Point(nodeMatrix.e, nodeMatrix.f);

      if (nodeTransform) {
        delete nodeAttrs.transform;
        nodeMatrix.e = 0;
        nodeMatrix.f = 0;
      } // Calculates node scale determined by the scalable group.


      var sx = 1;
      var sy = 1;

      if (positionAttrs || offsetAttrs) {
        var scale = this.view.getScaleOfElement(elem, options.scalableNode);
        sx = scale.sx;
        sy = scale.sy;
      }

      var positioned = false;

      if (positionAttrs != null) {
        Object.keys(positionAttrs).forEach(function (name) {
          var val = positionAttrs[name];

          var def = _this2.getDefinition(name);

          if (def != null) {
            var ts = main_namespaceObject.call(def.position, _this2.view, val, getOptions());

            if (ts != null) {
              positioned = true;
              nodePosition.translate(point_Point.create(ts).scale(sx, sy));
            }
          }
        });
      } // The node bounding box could depend on the `size`
      // set from the previous loop.


      this.view.setAttrs(nodeAttrs, elem);
      var offseted = false;

      if (offsetAttrs != null) {
        // Check if the node is visible
        var nodeBoundingRect = this.view.getBoundingRectOfElement(elem);

        if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {
          var nodeBBox = dom_main_namespaceObject.transformRectangle(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);
          Object.keys(offsetAttrs).forEach(function (name) {
            var val = offsetAttrs[name];

            var def = _this2.getDefinition(name);

            if (def != null) {
              var ts = main_namespaceObject.call(def.offset, _this2.view, val, {
                elem: elem,
                cell: _this2.cell,
                view: _this2.view,
                attrs: rawAttrs,
                refBBox: nodeBBox
              });

              if (ts != null) {
                offseted = true;
                nodePosition.translate(point_Point.create(ts).scale(sx, sy));
              }
            }
          });
        }
      }

      if (nodeTransform != null || positioned || offseted) {
        nodePosition.round(1);
        nodeMatrix.e = nodePosition.x;
        nodeMatrix.f = nodePosition.y;
        elem.setAttribute('transform', dom_main_namespaceObject.matrixToTransformString(nodeMatrix));
      }
    }
  }, {
    key: "update",
    value: function update(rootNode, attrs, options) {
      var _this3 = this;

      var selectorCache = {};
      var nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors); // `nodesAttrs` are different from all attributes, when
      // rendering only attributes sent to this method.

      var nodesAllAttrs = options.attrs ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors) : nodesAttrs;
      var specialItems = [];
      nodesAttrs.each(function (data) {
        var node = data.elem;
        var nodeAttrs = data.attrs;

        var processed = _this3.processAttrs(node, nodeAttrs);

        if (processed.set == null && processed.position == null && processed.offset == null) {
          _this3.view.setAttrs(processed.normal, node);
        } else {
          var _data = nodesAllAttrs.get(node);

          var nodeAllAttrs = _data ? _data.attrs : null;
          var refSelector = nodeAllAttrs && nodeAttrs.ref == null ? nodeAllAttrs.ref : nodeAttrs.ref;
          var refNode;

          if (refSelector) {
            refNode = (selectorCache[refSelector] || _this3.view.find(refSelector, rootNode, options.selectors))[0];

            if (!refNode) {
              throw new Error("\"".concat(refSelector, "\" reference does not exist."));
            }
          } else {
            refNode = null;
          }

          var item = {
            node: node,
            refNode: refNode,
            attributes: nodeAllAttrs,
            processedAttributes: processed
          }; // If an element in the list is positioned relative to this one, then
          // we want to insert this one before it in the list.

          var index = specialItems.findIndex(function (item) {
            return item.refNode === node;
          });

          if (index > -1) {
            specialItems.splice(index, 0, item);
          } else {
            specialItems.push(item);
          }
        }
      });
      var bboxCache = new dictionary_Dictionary();
      var rotatableMatrix;
      specialItems.forEach(function (item) {
        var node = item.node;
        var refNode = item.refNode;
        var unrotatedRefBBox;
        var isRefNodeRotatable = refNode != null && options.rotatableNode != null && dom_main_namespaceObject.contains(options.rotatableNode, refNode); // Find the reference element bounding box. If no reference was
        // provided, we use the optional bounding box.

        if (refNode) {
          unrotatedRefBBox = bboxCache.get(refNode);
        }

        if (!unrotatedRefBBox) {
          var target = isRefNodeRotatable ? options.rotatableNode : rootNode;
          unrotatedRefBBox = refNode ? dom_main_namespaceObject.getBBox(refNode, {
            target: target
          }) : options.rootBBox;

          if (refNode) {
            bboxCache.set(refNode, unrotatedRefBBox);
          }
        }

        var processedAttrs;

        if (options.attrs && item.attributes) {
          // If there was a special attribute affecting the position amongst
          // passed-in attributes we have to merge it with the rest of the
          // element's attributes as they are necessary to update the position
          // relatively (i.e `ref-x` && 'ref-dx').
          processedAttrs = _this3.processAttrs(node, item.attributes);

          _this3.mergeProcessedAttrs(processedAttrs, item.processedAttributes);
        } else {
          processedAttrs = item.processedAttributes;
        }

        var refBBox = unrotatedRefBBox;

        if (isRefNodeRotatable && options.rotatableNode != null && !options.rotatableNode.contains(node)) {
          // If the referenced node is inside the rotatable group while the
          // updated node is outside, we need to take the rotatable node
          // transformation into account.
          if (!rotatableMatrix) {
            rotatableMatrix = dom_main_namespaceObject.transformStringToMatrix(dom_main_namespaceObject.attr(options.rotatableNode, 'transform'));
          }

          refBBox = dom_main_namespaceObject.transformRectangle(unrotatedRefBBox, rotatableMatrix);
        }

        _this3.updateRelativeAttrs(node, processedAttrs, refBBox, options);
      });
    }
  }, {
    key: "cell",
    get: function get() {
      return this.view.cell;
    }
  }]);

  return AttrManager;
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/view/flag.js


var flag_FlagManager = /*#__PURE__*/function () {
  function FlagManager(view, actions) {
    var bootstrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    Object(classCallCheck["a" /* default */])(this, FlagManager);

    this.view = view;
    var flags = {};
    var attrs = {};
    var shift = 0;
    Object.keys(actions).forEach(function (attr) {
      var labels = actions[attr];

      if (!Array.isArray(labels)) {
        labels = [labels];
      }

      labels.forEach(function (label) {
        var flag = flags[label];

        if (!flag) {
          shift += 1;
          flag = flags[label] = 1 << shift;
        }

        attrs[attr] |= flag;
      });
    });
    var labels = bootstrap;

    if (!Array.isArray(labels)) {
      labels = [labels];
    }

    labels.forEach(function (label) {
      if (!flags[label]) {
        shift += 1;
        flags[label] = 1 << shift;
      }
    }); // 26 - 30 are reserved for paper flags
    // 31+ overflows maximal number

    if (shift > 25) {
      throw new Error('Maximum number of flags exceeded.');
    }

    this.flags = flags;
    this.attrs = attrs;
    this.bootstrap = bootstrap;
  }

  Object(createClass["a" /* default */])(FlagManager, [{
    key: "getFlag",
    value: function getFlag(label) {
      var flags = this.flags;

      if (flags == null) {
        return 0;
      }

      if (Array.isArray(label)) {
        return label.reduce(function (memo, key) {
          return memo | flags[key];
        }, 0);
      }

      return flags[label] | 0;
    }
  }, {
    key: "hasAction",
    value: function hasAction(flag, label) {
      return flag & this.getFlag(label);
    }
  }, {
    key: "removeAction",
    value: function removeAction(flag, label) {
      return flag ^ flag & this.getFlag(label);
    }
  }, {
    key: "getBootstrapFlag",
    value: function getBootstrapFlag() {
      return this.getFlag(this.bootstrap);
    }
  }, {
    key: "getChangedFlag",
    value: function getChangedFlag() {
      var _this = this;

      var flag = 0;

      if (!this.attrs) {
        return flag;
      }

      Object.keys(this.attrs).forEach(function (attr) {
        if (_this.cell.hasChanged(attr)) {
          flag |= _this.attrs[attr];
        }
      });
      return flag;
    }
  }, {
    key: "cell",
    get: function get() {
      return this.view.cell;
    }
  }]);

  return FlagManager;
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/view/cell.js







var cell_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};











var cell_CellView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(CellView, _View);

  var _super = Object(createSuper["a" /* default */])(CellView);

  function CellView(cell) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    Object(classCallCheck["a" /* default */])(this, CellView);

    _this = _super.call(this);
    _this.cell = cell;
    _this.options = _this.ensureOptions(options);
    _this.attr = new attr_AttrManager(Object(assertThisInitialized["a" /* default */])(_this));
    _this.flag = new flag_FlagManager(Object(assertThisInitialized["a" /* default */])(_this), _this.options.actions, _this.options.bootstrap);
    _this.cache = new cache_Cache(Object(assertThisInitialized["a" /* default */])(_this));

    _this.setContainer(_this.ensureContainer());

    _this.setup();

    _this.$(_this.container).data('view', Object(assertThisInitialized["a" /* default */])(_this));

    _this.init();

    return _this;
  }

  Object(createClass["a" /* default */])(CellView, [{
    key: "init",
    value: function init() {}
  }, {
    key: "getConstructor",
    value: function getConstructor() {
      return this.constructor;
    }
  }, {
    key: "ensureOptions",
    value: function ensureOptions(options) {
      return this.getConstructor().getOptions(options);
    }
  }, {
    key: "getContainerTagName",
    value: function getContainerTagName() {
      return this.options.isSvgElement ? 'g' : 'div';
    }
  }, {
    key: "getContainerStyle",
    value: function getContainerStyle() {}
  }, {
    key: "getContainerAttrs",
    value: function getContainerAttrs() {
      return {
        'data-cell-id': this.cell.id,
        'data-shape': this.cell.shape
      };
    }
  }, {
    key: "getContainerClassName",
    value: function getContainerClassName() {
      return this.prefixClassName('cell');
    }
  }, {
    key: "ensureContainer",
    value: function ensureContainer() {
      return view_View.createElement(this.getContainerTagName(), this.options.isSvgElement);
    }
  }, {
    key: "setContainer",
    value: function setContainer(container) {
      if (this.container !== container) {
        this.undelegateEvents();
        this.container = container;

        if (this.options.events != null) {
          this.delegateEvents(this.options.events);
        }

        var attrs = this.getContainerAttrs();

        if (attrs != null) {
          this.setAttrs(attrs, container);
        }

        var style = this.getContainerStyle();

        if (style != null) {
          this.setStyle(style, container);
        }

        var className = this.getContainerClassName();

        if (className != null) {
          this.addClass(className, container);
        }
      }

      return this;
    }
  }, {
    key: "isNodeView",
    value: function isNodeView() {
      return false;
    }
  }, {
    key: "isEdgeView",
    value: function isEdgeView() {
      return false;
    }
  }, {
    key: "render",
    value: function render() {
      return this;
    }
  }, {
    key: "confirmUpdate",
    value: function confirmUpdate(flag) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return 0;
    }
  }, {
    key: "getBootstrapFlag",
    value: function getBootstrapFlag() {
      return this.flag.getBootstrapFlag();
    }
  }, {
    key: "getFlag",
    value: function getFlag(actions) {
      return this.flag.getFlag(actions);
    }
  }, {
    key: "hasAction",
    value: function hasAction(flag, actions) {
      return this.flag.hasAction(flag, actions);
    }
  }, {
    key: "removeAction",
    value: function removeAction(flag, actions) {
      return this.flag.removeAction(flag, actions);
    }
  }, {
    key: "handleAction",
    value: function handleAction(flag, action, handle, additionalRemovedActions) {
      if (this.hasAction(flag, action)) {
        handle();
        var removedFlags = [action];

        if (additionalRemovedActions) {
          if (typeof additionalRemovedActions === 'string') {
            removedFlags.push(additionalRemovedActions);
          } else {
            removedFlags.push.apply(removedFlags, Object(toConsumableArray["a" /* default */])(additionalRemovedActions));
          }
        }

        return this.removeAction(flag, removedFlags);
      }

      return flag;
    }
  }, {
    key: "setup",
    value: function setup() {
      var _this2 = this;

      this.cell.on('changed', function (_ref) {
        var options = _ref.options;
        return _this2.onAttrsChange(options);
      });
    }
  }, {
    key: "onAttrsChange",
    value: function onAttrsChange(options) {
      var flag = this.flag.getChangedFlag();

      if (options.updated || !flag) {
        return;
      }

      if (options.dirty && this.hasAction(flag, 'update')) {
        flag |= this.getFlag('render');
      } // TODO: tool changes does not need to be sync
      // Fix Segments tools


      if (options.tool) {
        options.async = false;
      }

      if (this.graph != null) {
        this.graph.renderer.requestViewUpdate(this, flag, this.priority, options);
      }
    }
  }, {
    key: "parseJSONMarkup",
    value: function parseJSONMarkup(markup, rootElem) {
      var result = markup_Markup.parseJSONMarkup(markup);
      var selectors = result.selectors;
      var rootSelector = this.rootSelector;

      if (rootElem && rootSelector) {
        if (selectors[rootSelector]) {
          throw new Error('Invalid root selector');
        }

        selectors[rootSelector] = rootElem;
      }

      return result;
    }
  }, {
    key: "can",
    value: function can(feature) {
      var interacting = this.options.interacting;
      interacting = typeof interacting === 'function' ? main_namespaceObject.call(interacting, this.graph, this) : interacting;

      if (typeof interacting === 'object') {
        return interacting[feature] !== false;
      }

      if (typeof interacting === 'boolean') {
        return interacting;
      }

      return false;
    }
  }, {
    key: "setInteracting",
    value: function setInteracting(interacting) {
      this.options.interacting = interacting;
      return this;
    }
  }, {
    key: "cleanCache",
    value: function cleanCache() {
      this.cache.clean();
      return this;
    }
  }, {
    key: "getCache",
    value: function getCache(elem) {
      return this.cache.get(elem);
    }
  }, {
    key: "getDataOfElement",
    value: function getDataOfElement(elem) {
      return this.cache.getData(elem);
    }
  }, {
    key: "getMatrixOfElement",
    value: function getMatrixOfElement(elem) {
      return this.cache.getMatrix(elem);
    }
  }, {
    key: "getShapeOfElement",
    value: function getShapeOfElement(elem) {
      return this.cache.getShape(elem);
    }
  }, {
    key: "getScaleOfElement",
    value: function getScaleOfElement(node, scalableNode) {
      var sx;
      var sy;

      if (scalableNode && scalableNode.contains(node)) {
        var scale = dom_main_namespaceObject.scale(scalableNode);
        sx = 1 / scale.sx;
        sy = 1 / scale.sy;
      } else {
        sx = 1;
        sy = 1;
      }

      return {
        sx: sx,
        sy: sy
      };
    }
  }, {
    key: "getBoundingRectOfElement",
    value: function getBoundingRectOfElement(elem) {
      return this.cache.getBoundingRect(elem);
    }
  }, {
    key: "getBBoxOfElement",
    value: function getBBoxOfElement(elem) {
      var rect = this.getBoundingRectOfElement(elem);
      var matrix = this.getMatrixOfElement(elem);
      var rm = this.getRootRotatedMatrix();
      var tm = this.getRootTranslatedMatrix();
      return dom_main_namespaceObject.transformRectangle(rect, tm.multiply(rm).multiply(matrix));
    }
  }, {
    key: "getUnrotatedBBoxOfElement",
    value: function getUnrotatedBBoxOfElement(elem) {
      var rect = this.getBoundingRectOfElement(elem);
      var matrix = this.getMatrixOfElement(elem);
      var tm = this.getRootTranslatedMatrix();
      return dom_main_namespaceObject.transformRectangle(rect, tm.multiply(matrix));
    }
  }, {
    key: "getBBox",
    value: function getBBox() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var bbox;

      if (options.useCellGeometry) {
        var cell = this.cell;
        var angle = cell.isNode() ? cell.getAngle() : 0;
        bbox = cell.getBBox().bbox(angle);
      } else {
        bbox = this.getBBoxOfElement(this.container);
      }

      return this.graph.localToGraphRect(bbox);
    }
  }, {
    key: "getRootTranslatedMatrix",
    value: function getRootTranslatedMatrix() {
      var cell = this.cell;
      var pos = cell.isNode() ? cell.getPosition() : {
        x: 0,
        y: 0
      };
      return dom_main_namespaceObject.createSVGMatrix().translate(pos.x, pos.y);
    }
  }, {
    key: "getRootRotatedMatrix",
    value: function getRootRotatedMatrix() {
      var matrix = dom_main_namespaceObject.createSVGMatrix();
      var cell = this.cell;
      var angle = cell.isNode() ? cell.getAngle() : 0;

      if (angle) {
        var bbox = cell.getBBox();
        var cx = bbox.width / 2;
        var cy = bbox.height / 2;
        matrix = matrix.translate(cx, cy).rotate(angle).translate(-cx, -cy);
      }

      return matrix;
    }
  }, {
    key: "findMagnet",
    value: function findMagnet() {
      var elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.container;
      // If the overall cell has set `magnet === false`, then returns
      // `undefined` to announce there is no magnet found for this cell.
      // This is especially useful to set on cells that have 'ports'.
      // In this case, only the ports have set `magnet === true` and the
      // overall element has `magnet === false`.
      return this.findByAttr('magnet', elem);
    }
  }, {
    key: "updateAttrs",
    value: function updateAttrs(rootNode, attrs) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (options.rootBBox == null) {
        options.rootBBox = new rectangle_Rectangle();
      }

      if (options.selectors == null) {
        options.selectors = this.selectors;
      }

      this.attr.update(rootNode, attrs, options);
    }
  }, {
    key: "isEdgeElement",
    value: function isEdgeElement(magnet) {
      return this.cell.isEdge() && (magnet == null || magnet === this.container);
    } // #region highlight

  }, {
    key: "prepareHighlight",
    value: function prepareHighlight(elem) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var magnet = elem && this.$(elem)[0] || this.container;
      options.partial = magnet === this.container;
      return magnet;
    }
  }, {
    key: "highlight",
    value: function highlight(elem) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var magnet = this.prepareHighlight(elem, options);
      this.notify('cell:highlight', {
        magnet: magnet,
        options: options,
        view: this,
        cell: this.cell
      });

      if (this.isEdgeView()) {
        this.notify('edge:highlight', {
          magnet: magnet,
          options: options,
          view: this,
          edge: this.cell,
          cell: this.cell
        });
      } else if (this.isNodeView()) {
        this.notify('node:highlight', {
          magnet: magnet,
          options: options,
          view: this,
          node: this.cell,
          cell: this.cell
        });
      }

      return this;
    }
  }, {
    key: "unhighlight",
    value: function unhighlight(elem) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var magnet = this.prepareHighlight(elem, options);
      this.notify('cell:unhighlight', {
        magnet: magnet,
        options: options,
        view: this,
        cell: this.cell
      });

      if (this.isNodeView()) {
        this.notify('node:unhighlight', {
          magnet: magnet,
          options: options,
          view: this,
          node: this.cell,
          cell: this.cell
        });
      } else if (this.isEdgeView()) {
        this.notify('edge:unhighlight', {
          magnet: magnet,
          options: options,
          view: this,
          edge: this.cell,
          cell: this.cell
        });
      }

      return this;
    }
  }, {
    key: "notifyUnhighlight",
    value: function notifyUnhighlight(magnet, options) {} // #endregion

  }, {
    key: "getEdgeTerminal",
    value: function getEdgeTerminal(magnet, x, y, edge, type) {
      var cell = this.cell;
      var portId = this.findAttr('port', magnet);
      var selector = magnet.getAttribute('data-selector');
      var terminal = {
        cell: cell.id
      };

      if (selector != null) {
        terminal.magnet = selector;
      }

      if (portId != null) {
        terminal.port = portId;

        if (cell.isNode()) {
          if (!cell.hasPort(portId) && selector == null) {
            // port created via the `port` attribute (not API)
            terminal.selector = this.getSelector(magnet);
          }
        }
      } else if (selector == null && this.container !== magnet) {
        terminal.selector = this.getSelector(magnet);
      }

      return this.customizeEdgeTerminal(terminal, magnet, x, y, edge, type);
    }
  }, {
    key: "customizeEdgeTerminal",
    value: function customizeEdgeTerminal(terminal, magnet, x, y, edge, type) {
      var raw = edge.getStrategy() || this.graph.options.connecting.strategy;

      if (raw) {
        var name = typeof raw === 'string' ? raw : raw.name;
        var args = typeof raw === 'string' ? {} : raw.args || {};
        var registry = connection_strategy_ConnectionStrategy.registry;

        if (name) {
          var fn = registry.get(name);

          if (fn == null) {
            return registry.onNotFound(name);
          }

          var result = main_namespaceObject.call(fn, this.graph, terminal, this, magnet, new point_Point(x, y), edge, type, args);

          if (result) {
            return result;
          }
        }
      }

      return terminal;
    }
  }, {
    key: "getMagnetFromEdgeTerminal",
    value: function getMagnetFromEdgeTerminal(terminal) {
      var cell = this.cell;
      var root = this.container;
      var portId = terminal.port;
      var selector = terminal.magnet;
      var magnet;

      if (portId != null && cell.isNode() && cell.hasPort(portId)) {
        magnet = this.findPortElem(portId, selector) || root;
      } else {
        if (!selector) {
          selector = terminal.selector;
        }

        if (!selector && portId != null) {
          selector = "[port=\"".concat(portId, "\"]");
        }

        magnet = this.findOne(selector, root, this.selectors);
      }

      return magnet;
    }
  }, {
    key: "hasTools",
    value: function hasTools(name) {
      var tools = this.tools;

      if (tools == null) {
        return false;
      }

      if (name == null) {
        return true;
      }

      return tools.name === name;
    }
  }, {
    key: "addTools",
    value: function addTools(config) {
      this.removeTools();

      if (config) {
        var tools = config instanceof tool_ToolsView ? config : new tool_ToolsView(config);
        this.tools = tools;
        this.graph.on('tools:hide', this.hideTools, this);
        this.graph.on('tools:show', this.showTools, this);
        this.graph.on('tools:remove', this.removeTools, this);
        tools.config({
          cellView: this
        });
        tools.mount();
      }

      return this;
    }
  }, {
    key: "updateTools",
    value: function updateTools() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.tools) {
        this.tools.update(options);
      }

      return this;
    }
  }, {
    key: "removeTools",
    value: function removeTools() {
      if (this.tools) {
        this.tools.remove();
        this.graph.off('tools:hide', this.hideTools, this);
        this.graph.off('tools:show', this.showTools, this);
        this.graph.off('tools:remove', this.removeTools, this);
        this.tools = null;
      }

      return this;
    }
  }, {
    key: "hideTools",
    value: function hideTools() {
      if (this.tools) {
        this.tools.hide();
      }

      return this;
    }
  }, {
    key: "showTools",
    value: function showTools() {
      if (this.tools) {
        this.tools.show();
      }

      return this;
    }
  }, {
    key: "notify",
    value: function notify(name, args) {
      this.trigger(name, args);
      this.graph.trigger(name, args);
      return this;
    }
  }, {
    key: "getEventArgs",
    value: function getEventArgs(e, x, y) {
      var view = this; // tslint:disable-line

      var cell = view.cell;

      if (x == null || y == null) {
        return {
          e: e,
          view: view,
          cell: cell
        };
      }

      return {
        e: e,
        x: x,
        y: y,
        view: view,
        cell: cell
      };
    }
  }, {
    key: "onClick",
    value: function onClick(e, x, y) {
      this.notify('cell:click', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onDblClick",
    value: function onDblClick(e, x, y) {
      this.notify('cell:dblclick', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onContextMenu",
    value: function onContextMenu(e, x, y) {
      this.notify('cell:contextmenu', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(e, x, y) {
      if (this.cell.model) {
        this.cachedModelForMouseEvent = this.cell.model;
        this.cachedModelForMouseEvent.startBatch('mouse');
      }

      this.notify('cell:mousedown', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(e, x, y) {
      this.notify('cell:mouseup', this.getEventArgs(e, x, y));

      if (this.cachedModelForMouseEvent) {
        this.cachedModelForMouseEvent.stopBatch('mouse', {
          cell: this.cell
        });
        this.cachedModelForMouseEvent = null;
      }
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(e, x, y) {
      this.notify('cell:mousemove', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onMouseOver",
    value: function onMouseOver(e) {
      this.notify('cell:mouseover', this.getEventArgs(e));
    }
  }, {
    key: "onMouseOut",
    value: function onMouseOut(e) {
      this.notify('cell:mouseout', this.getEventArgs(e));
    }
  }, {
    key: "onMouseEnter",
    value: function onMouseEnter(e) {
      this.notify('cell:mouseenter', this.getEventArgs(e));
    }
  }, {
    key: "onMouseLeave",
    value: function onMouseLeave(e) {
      this.notify('cell:mouseleave', this.getEventArgs(e));
    }
  }, {
    key: "onMouseWheel",
    value: function onMouseWheel(e, x, y, delta) {
      this.notify('cell:mousewheel', Object.assign({
        delta: delta
      }, this.getEventArgs(e, x, y)));
    }
  }, {
    key: "onCustomEvent",
    value: function onCustomEvent(e, name, x, y) {
      this.notify('cell:customevent', Object.assign({
        name: name
      }, this.getEventArgs(e, x, y)));
      this.notify(name, Object.assign({}, this.getEventArgs(e, x, y)));
    }
  }, {
    key: "onMagnetMouseDown",
    value: function onMagnetMouseDown(e, magnet, x, y) {}
  }, {
    key: "onMagnetDblClick",
    value: function onMagnetDblClick(e, magnet, x, y) {}
  }, {
    key: "onMagnetContextMenu",
    value: function onMagnetContextMenu(e, magnet, x, y) {}
  }, {
    key: "onLabelMouseDown",
    value: function onLabelMouseDown(e, x, y) {}
  }, {
    key: "checkMouseleave",
    value: function checkMouseleave(e) {
      var graph = this.graph;

      if (graph.renderer.isAsync()) {
        // Do the updates of the current view synchronously now
        graph.renderer.dumpView(this);
      }

      var target = this.getEventTarget(e, {
        fromPoint: true
      });
      var view = graph.renderer.findViewByElem(target);

      if (view === this) {
        return;
      } // Leaving the current view


      this.onMouseLeave(e);

      if (!view) {
        return;
      } // Entering another view


      view.onMouseEnter(e);
    }
  }, {
    key: "priority",
    get: function get() {
      return this.options.priority;
    }
  }, {
    key: "rootSelector",
    get: function get() {
      return this.options.rootSelector;
    }
  }], [{
    key: "getDefaults",
    value: function getDefaults() {
      return this.defaults;
    }
  }, {
    key: "config",
    value: function config(options) {
      this.defaults = this.getOptions(options);
    }
  }, {
    key: "getOptions",
    value: function getOptions(options) {
      var mergeActions = function mergeActions(arr1, arr2) {
        if (arr2 != null) {
          return array_namespaceObject.uniq([].concat(Object(toConsumableArray["a" /* default */])(Array.isArray(arr1) ? arr1 : [arr1]), Object(toConsumableArray["a" /* default */])(Array.isArray(arr2) ? arr2 : [arr2])));
        }

        return Array.isArray(arr1) ? Object(toConsumableArray["a" /* default */])(arr1) : [arr1];
      };

      var ret = object_namespaceObject.cloneDeep(this.getDefaults());

      var bootstrap = options.bootstrap,
          actions = options.actions,
          events = options.events,
          documentEvents = options.documentEvents,
          others = cell_rest(options, ["bootstrap", "actions", "events", "documentEvents"]);

      if (bootstrap) {
        ret.bootstrap = mergeActions(ret.bootstrap, bootstrap);
      }

      if (actions) {
        Object.keys(actions).forEach(function (key) {
          var val = actions[key];
          var raw = ret.actions[key];

          if (val && raw) {
            ret.actions[key] = mergeActions(raw, val);
          } else if (val) {
            ret.actions[key] = mergeActions(val);
          }
        });
      }

      if (events) {
        ret.events = Object.assign(Object.assign({}, ret.events), events);
      }

      if (options.documentEvents) {
        ret.documentEvents = Object.assign(Object.assign({}, ret.documentEvents), documentEvents);
      }

      return object_namespaceObject.merge(ret, others);
    }
  }]);

  return CellView;
}(view_View);
cell_CellView.defaults = {
  isSvgElement: true,
  rootSelector: 'root',
  priority: 0,
  bootstrap: [],
  actions: {}
};

(function (CellView) {
  CellView.Flag = flag_FlagManager;
  CellView.Attr = attr_AttrManager;
})(cell_CellView || (cell_CellView = {})); // decorators
// ----


(function (CellView) {
  function priority(value) {
    return function (ctor) {
      ctor.config({
        priority: value
      });
    };
  }

  CellView.priority = priority;

  function bootstrap(actions) {
    return function (ctor) {
      ctor.config({
        bootstrap: actions
      });
    };
  }

  CellView.bootstrap = bootstrap;
})(cell_CellView || (cell_CellView = {}));

(function (CellView) {
  CellView.registry = registry_Registry.create({
    type: 'view'
  });
})(cell_CellView || (cell_CellView = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/view/tool.js











var tool_ToolsView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(ToolsView, _View);

  var _super = Object(createSuper["a" /* default */])(ToolsView);

  function ToolsView() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, ToolsView);

    _this = _super.call(this);
    _this.container = view_View.createElement(options.tagName || 'g', options.isSVGElement !== false);
    dom_main_namespaceObject.addClass(_this.container, _this.prefixClassName('cell-tools'));

    if (options.className) {
      dom_main_namespaceObject.addClass(_this.container, options.className);
    }

    _this.config(options);

    return _this;
  }

  Object(createClass["a" /* default */])(ToolsView, [{
    key: "config",
    value: function config(options) {
      this.options = Object.assign(Object.assign({}, this.options), options);

      if (!(options.cellView instanceof cell_CellView) || options.cellView === this.cellView) {
        return this;
      }

      this.cellView = options.cellView;

      if (this.cell.isEdge()) {
        dom_main_namespaceObject.addClass(this.container, this.prefixClassName('edge-tools'));
      } else if (this.cell.isNode()) {
        dom_main_namespaceObject.addClass(this.container, this.prefixClassName('node-tools'));
      }

      this.container.setAttribute('data-cell-id', this.cell.id);

      if (this.name) {
        this.container.setAttribute('data-tools-name', this.name);
      }

      var tools = this.options.tools;

      if (!Array.isArray(tools)) {
        return this;
      }

      this.tools = [];

      for (var i = 0; i < tools.length; i += 1) {
        var meta = tools[i];
        var tool = void 0;

        if (meta instanceof ToolsView.ToolItem) {
          tool = meta;
        } else {
          var name = typeof meta === 'object' ? meta.name : meta;
          var args = typeof meta === 'object' ? meta.args || {} : {};

          if (name) {
            if (this.cell.isNode()) {
              var ctor = tool_NodeTool.registry.get(name);

              if (ctor) {
                tool = new ctor(args);
              } else {
                return tool_NodeTool.registry.onNotFound(name);
              }
            } else if (this.cell.isEdge()) {
              var _ctor = tool_EdgeTool.registry.get(name);

              if (_ctor) {
                tool = new _ctor(args);
              } else {
                return tool_EdgeTool.registry.onNotFound(name);
              }
            }
          }
        }

        if (tool) {
          tool.config(this.cellView, this);
          tool.render();
          this.container.appendChild(tool.container);
          this.tools.push(tool);
        }
      }

      return this;
    }
  }, {
    key: "update",
    value: function update() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var tools = this.tools;

      if (tools) {
        tools.forEach(function (tool) {
          if (options.toolId !== tool.cid && tool.isVisible()) {
            tool.update();
          }
        });
      }

      return this;
    }
  }, {
    key: "focus",
    value: function focus(focusedTool) {
      var tools = this.tools;

      if (tools) {
        tools.forEach(function (tool) {
          if (focusedTool === tool) {
            tool.show();
          } else {
            tool.hide();
          }
        });
      }

      return this;
    }
  }, {
    key: "blur",
    value: function blur(blurredTool) {
      var tools = this.tools;

      if (tools) {
        tools.forEach(function (tool) {
          if (tool !== blurredTool && !tool.isVisible()) {
            tool.show();
            tool.update();
          }
        });
      }

      return this;
    }
  }, {
    key: "hide",
    value: function hide() {
      return this.focus(null);
    }
  }, {
    key: "show",
    value: function show() {
      return this.blur(null);
    }
  }, {
    key: "remove",
    value: function remove() {
      var tools = this.tools;

      if (tools) {
        tools.forEach(function (tool) {
          return tool.remove();
        });
        this.tools = null;
      }

      return Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(ToolsView.prototype), "remove", this).call(this);
    }
  }, {
    key: "mount",
    value: function mount() {
      var cellView = this.cellView;

      if (cellView) {
        var parent = this.local ? cellView.container : cellView.graph.view.decorator;
        parent.appendChild(this.container);
      }

      return this;
    }
  }, {
    key: "name",
    get: function get() {
      return this.options.name;
    }
  }, {
    key: "graph",
    get: function get() {
      return this.cellView.graph;
    }
  }, {
    key: "cell",
    get: function get() {
      return this.cellView.cell;
    }
  }, {
    key: "local",
    get: function get() {
      return this.options.local;
    }
  }]);

  return ToolsView;
}(view_View);

(function (ToolsView) {
  var ToolItem = /*#__PURE__*/function (_View2) {
    Object(inherits["a" /* default */])(ToolItem, _View2);

    var _super2 = Object(createSuper["a" /* default */])(ToolItem);

    function ToolItem() {
      var _this2;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      Object(classCallCheck["a" /* default */])(this, ToolItem);

      _this2 = _super2.call(this);
      _this2.options = _this2.getOptions(options);
      _this2.container = view_View.createElement(_this2.options.tagName || 'g', _this2.options.isSVGElement !== false);
      dom_main_namespaceObject.addClass(_this2.container, _this2.prefixClassName('cell-tool'));

      if (typeof _this2.options.className === 'string') {
        dom_main_namespaceObject.addClass(_this2.container, _this2.options.className);
      }

      _this2.init();

      return _this2;
    }

    Object(createClass["a" /* default */])(ToolItem, [{
      key: "getOptions",
      value: function getOptions(options) {
        var ctor = this.constructor;
        return ctor.getOptions(options);
      }
    }, {
      key: "init",
      value: function init() {}
    }, {
      key: "delegateEvents",
      value: function delegateEvents() {
        if (this.options.events) {
          Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(ToolItem.prototype), "delegateEvents", this).call(this, this.options.events);
        }

        return this;
      }
    }, {
      key: "config",
      value: function config(view, toolsView) {
        this.cellView = view;
        this.parent = toolsView;
        this.stamp(this.container);

        if (this.cell.isEdge()) {
          dom_main_namespaceObject.addClass(this.container, this.prefixClassName('edge-tool'));
        } else if (this.cell.isNode()) {
          dom_main_namespaceObject.addClass(this.container, this.prefixClassName('node-tool'));
        }

        if (this.name) {
          this.container.setAttribute('data-tool-name', this.name);
        }

        this.delegateEvents();
        return this;
      }
    }, {
      key: "render",
      value: function render() {
        this.empty();
        var markup = this.options.markup;

        if (markup) {
          var meta = markup_Markup.isStringMarkup(markup) ? markup_Markup.parseStringMarkup(markup) : markup_Markup.parseJSONMarkup(markup);
          this.container.appendChild(meta.fragment);
          this.childNodes = meta.selectors;
        }

        this.onRender();
        return this;
      }
    }, {
      key: "onRender",
      value: function onRender() {}
    }, {
      key: "update",
      value: function update() {
        return this;
      }
    }, {
      key: "stamp",
      value: function stamp() {
        var elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.container;

        if (elem) {
          elem.setAttribute('data-cell-id', this.cellView.cell.id);
        }
      }
    }, {
      key: "show",
      value: function show() {
        this.container.style.display = '';
        this.visible = true;
        return this;
      }
    }, {
      key: "hide",
      value: function hide() {
        this.container.style.display = 'none';
        this.visible = false;
        return this;
      }
    }, {
      key: "isVisible",
      value: function isVisible() {
        return this.visible;
      }
    }, {
      key: "focus",
      value: function focus() {
        var opacity = this.options.focusOpacity;

        if (opacity != null && isFinite(opacity)) {
          this.container.style.opacity = "".concat(opacity);
        }

        this.parent.focus(this);
        return this;
      }
    }, {
      key: "blur",
      value: function blur() {
        this.container.style.opacity = '';
        this.parent.blur(this);
        return this;
      }
    }, {
      key: "guard",
      value: function guard(evt) {
        if (this.graph == null || this.cellView == null) {
          return true;
        }

        return this.graph.view.guard(evt, this.cellView);
      }
    }, {
      key: "graph",
      get: function get() {
        return this.cellView.graph;
      }
    }, {
      key: "cell",
      get: function get() {
        return this.cellView.cell;
      }
    }, {
      key: "name",
      get: function get() {
        return this.options.name;
      }
    }], [{
      key: "getDefaults",
      value: function getDefaults() {
        return this.defaults;
      }
    }, {
      key: "config",
      value: function config(options) {
        this.defaults = this.getOptions(options);
      }
    }, {
      key: "getOptions",
      value: function getOptions(options) {
        return object_namespaceObject.merge(object_namespaceObject.cloneDeep(this.getDefaults()), options);
      }
    }]);

    return ToolItem;
  }(view_View); // #region static


  ToolItem.defaults = {
    isSVGElement: true,
    tagName: 'g'
  };
  ToolsView.ToolItem = ToolItem;

  (function (ToolItem) {
    var counter = 0;

    function getClassName(name) {
      if (name) {
        return string_namespaceObject.pascalCase(name);
      }

      counter += 1;
      return "CustomTool".concat(counter);
    }

    function define(options) {
      var tool = object_namespaceObject.createClass(getClassName(options.name), this);
      tool.config(options);
      return tool;
    }

    ToolItem.define = define;
  })(ToolItem = ToolsView.ToolItem || (ToolsView.ToolItem = {}));
})(tool_ToolsView || (tool_ToolsView = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/tool/util.js


function util_getAnchor(pos, terminalView, terminalMagnet, type) {
  var end = main_namespaceObject.call(connection_strategy_ConnectionStrategy.presets.pinRelative, this.graph, {}, terminalView, terminalMagnet, pos, this.cell, type, {});
  return end.anchor;
}
function getViewBBox(view, quick) {
  if (quick) {
    return view.cell.getBBox();
  }

  return view.cell.isEdge() ? view.getConnection().bbox() : view.getUnrotatedBBoxOfElement(view.container);
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/tool/button.js








var button_Button = /*#__PURE__*/function (_ToolsView$ToolItem) {
  Object(inherits["a" /* default */])(Button, _ToolsView$ToolItem);

  var _super = Object(createSuper["a" /* default */])(Button);

  function Button() {
    Object(classCallCheck["a" /* default */])(this, Button);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Button, [{
    key: "onRender",
    value: function onRender() {
      dom_main_namespaceObject.addClass(this.container, this.prefixClassName('cell-tool-button'));
      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      this.updatePosition();
      return this;
    }
  }, {
    key: "updatePosition",
    value: function updatePosition() {
      var view = this.cellView;
      var matrix = view.cell.isEdge() ? this.getEdgeMatrix() : this.getNodeMatrix();
      dom_main_namespaceObject.transform(this.container, matrix, {
        absolute: true
      });
    }
  }, {
    key: "getNodeMatrix",
    value: function getNodeMatrix() {
      var view = this.cellView;
      var options = this.options;
      var _options$x = options.x,
          x = _options$x === void 0 ? 0 : _options$x,
          _options$y = options.y,
          y = _options$y === void 0 ? 0 : _options$y;
      var offset = options.offset,
          useCellGeometry = options.useCellGeometry,
          rotate = options.rotate;
      var bbox = getViewBBox(view, useCellGeometry);
      var angle = view.cell.getAngle();

      if (!rotate) {
        bbox = bbox.bbox(angle);
      }

      var offsetX = 0;
      var offsetY = 0;

      if (typeof offset === 'number') {
        offsetX = offset;
        offsetY = offset;
      } else if (typeof offset === 'object') {
        offsetX = offset.x;
        offsetY = offset.y;
      }

      x = number_namespaceObject.normalizePercentage(x, bbox.width);
      y = number_namespaceObject.normalizePercentage(y, bbox.height);
      var matrix = dom_main_namespaceObject.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);

      if (rotate) {
        matrix = matrix.rotate(angle);
      }

      matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);
      return matrix;
    }
  }, {
    key: "getEdgeMatrix",
    value: function getEdgeMatrix() {
      var view = this.cellView;
      var options = this.options;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? 0 : _options$offset,
          _options$distance = options.distance,
          distance = _options$distance === void 0 ? 0 : _options$distance,
          rotate = options.rotate;
      var tangent;
      var position;
      var angle;

      if (number_namespaceObject.isPercentage(distance)) {
        tangent = view.getTangentAtRatio(parseFloat(distance) / 100);
      } else {
        tangent = view.getTangentAtLength(distance);
      }

      if (tangent) {
        position = tangent.start;
        angle = tangent.vector().vectorAngle(new point_Point(1, 0)) || 0;
      } else {
        position = view.getConnection().start;
        angle = 0;
      }

      var matrix = dom_main_namespaceObject.createSVGMatrix().translate(position.x, position.y).rotate(angle).translate(0, offset);

      if (!rotate) {
        matrix = matrix.rotate(-angle);
      }

      return matrix;
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(evt) {
      if (this.guard(evt)) {
        return;
      }

      evt.stopPropagation();
      evt.preventDefault();
      var onClick = this.options.onClick;

      if (typeof onClick === 'function') {
        main_namespaceObject.call(onClick, this.cellView, evt, this.cellView, this);
      }
    }
  }]);

  return Button;
}(tool_ToolsView.ToolItem);

(function (Button) {
  Button.config({
    name: 'button',
    events: {
      mousedown: 'onMouseDown',
      touchstart: 'onMouseDown'
    }
  });
})(button_Button || (button_Button = {}));

(function (Button) {
  Button.Remove = Button.define({
    name: 'button-remove',
    markup: [{
      tagName: 'circle',
      selector: 'button',
      attrs: {
        r: 7,
        fill: '#FF1D00',
        cursor: 'pointer'
      }
    }, {
      tagName: 'path',
      selector: 'icon',
      attrs: {
        d: 'M -3 -3 3 3 M -3 3 3 -3',
        fill: 'none',
        stroke: '#FFFFFF',
        'stroke-width': 2,
        'pointer-events': 'none'
      }
    }],
    distance: 60,
    offset: 0,
    onClick: function onClick(evt, view, btn) {
      btn.parent.remove();
      view.cell.remove({
        ui: true,
        toolId: btn.cid
      });
    }
  });
})(button_Button || (button_Button = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/tool/boundary.js





var boundary_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




var boundary_Boundary = /*#__PURE__*/function (_ToolsView$ToolItem) {
  Object(inherits["a" /* default */])(Boundary, _ToolsView$ToolItem);

  var _super = Object(createSuper["a" /* default */])(Boundary);

  function Boundary() {
    Object(classCallCheck["a" /* default */])(this, Boundary);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Boundary, [{
    key: "onRender",
    value: function onRender() {
      dom_main_namespaceObject.addClass(this.container, this.prefixClassName('cell-tool-boundary'));

      if (this.options.attrs) {
        var _a = this.options.attrs,
            className = _a.class,
            attrs = boundary_rest(_a, ["class"]);

        dom_main_namespaceObject.attr(this.container, attrs);

        if (className) {
          dom_main_namespaceObject.addClass(this.container, className);
        }
      }

      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      var view = this.cellView;
      var options = this.options;
      var useCellGeometry = options.useCellGeometry,
          rotate = options.rotate;
      var padding = number_namespaceObject.normalizeSides(options.padding);
      var bbox = getViewBBox(view, useCellGeometry).moveAndExpand({
        x: -padding.left,
        y: -padding.top,
        width: padding.left + padding.right,
        height: padding.top + padding.bottom
      });
      var cell = view.cell;

      if (cell.isNode()) {
        var angle = cell.getAngle();

        if (angle) {
          if (rotate) {
            var origin = cell.getBBox().getCenter();
            dom_main_namespaceObject.rotate(this.container, angle, origin.x, origin.y, {
              absolute: true
            });
          } else {
            bbox = bbox.bbox(angle);
          }
        }
      }

      dom_main_namespaceObject.attr(this.container, bbox.toJSON());
      return this;
    }
  }]);

  return Boundary;
}(tool_ToolsView.ToolItem);

(function (Boundary) {
  Boundary.config({
    name: 'boundary',
    tagName: 'rect',
    padding: 10,
    attrs: {
      fill: 'none',
      stroke: '#33334F',
      'stroke-width': 0.5,
      'stroke-dasharray': '5, 5',
      'pointer-events': 'none'
    }
  });
})(boundary_Boundary || (boundary_Boundary = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/tool/vertices.js










var vertices_Vertices = /*#__PURE__*/function (_ToolsView$ToolItem) {
  Object(inherits["a" /* default */])(Vertices, _ToolsView$ToolItem);

  var _super = Object(createSuper["a" /* default */])(Vertices);

  function Vertices() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Vertices);

    _this = _super.apply(this, arguments);
    _this.handles = [];
    return _this;
  }

  Object(createClass["a" /* default */])(Vertices, [{
    key: "onRender",
    value: function onRender() {
      dom_main_namespaceObject.addClass(this.container, this.prefixClassName('edge-tool-vertices'));

      if (this.options.vertexAdding) {
        this.updatePath();
      }

      this.resetHandles();
      this.renderHandles();
      return this;
    }
  }, {
    key: "update",
    value: function update() {
      var vertices = this.vertices;

      if (vertices.length === this.handles.length) {
        this.updateHandles();
      } else {
        this.resetHandles();
        this.renderHandles();
      }

      if (this.options.vertexAdding) {
        this.updatePath();
      }

      return this;
    }
  }, {
    key: "resetHandles",
    value: function resetHandles() {
      var _this2 = this;

      var handles = this.handles;
      this.handles = [];

      if (handles) {
        handles.forEach(function (handle) {
          _this2.stopHandleListening(handle);

          handle.remove();
        });
      }
    }
  }, {
    key: "renderHandles",
    value: function renderHandles() {
      var _this3 = this;

      var vertices = this.vertices;

      for (var i = 0, l = vertices.length; i < l; i += 1) {
        var vertex = vertices[i];
        var handle = new this.options.handleConstructor({
          index: i,
          graph: this.graph,
          guard: function guard(evt) {
            return _this3.guard(evt);
          }
        });
        handle.updatePosition(vertex.x, vertex.y);
        this.stamp(handle.container);
        this.container.appendChild(handle.container);
        this.handles.push(handle);
        this.startHandleListening(handle);
      }
    }
  }, {
    key: "updateHandles",
    value: function updateHandles() {
      var vertices = this.vertices;

      for (var i = 0, l = vertices.length; i < l; i += 1) {
        var vertex = vertices[i];
        var handle = this.handles[i];

        if (handle) {
          handle.updatePosition(vertex.x, vertex.y);
        }
      }
    }
  }, {
    key: "updatePath",
    value: function updatePath() {
      var connection = this.childNodes.connection;

      if (connection) {
        connection.setAttribute('d', this.cellView.getConnectionPathData());
      }
    }
  }, {
    key: "startHandleListening",
    value: function startHandleListening(handle) {
      var edgeView = this.cellView;

      if (edgeView.can('vertexMovable')) {
        handle.on('change', this.onHandleChange, this);
        handle.on('changing', this.onHandleChanging, this);
        handle.on('changed', this.onHandleChanged, this);
      }

      if (edgeView.can('vertexDeletable')) {
        handle.on('remove', this.onHandleRemove, this);
      }
    }
  }, {
    key: "stopHandleListening",
    value: function stopHandleListening(handle) {
      var edgeView = this.cellView;

      if (edgeView.can('vertexMovable')) {
        handle.off('change', this.onHandleChange, this);
        handle.off('changing', this.onHandleChanging, this);
        handle.off('changed', this.onHandleChanged, this);
      }

      if (edgeView.can('vertexDeletable')) {
        handle.off('remove', this.onHandleRemove, this);
      }
    }
  }, {
    key: "getNeighborPoints",
    value: function getNeighborPoints(index) {
      var edgeView = this.cellView;
      var vertices = this.vertices;
      var prev = index > 0 ? vertices[index - 1] : edgeView.sourceAnchor;
      var next = index < vertices.length - 1 ? vertices[index + 1] : edgeView.targetAnchor;
      return {
        prev: point_Point.create(prev),
        next: point_Point.create(next)
      };
    }
  }, {
    key: "getMouseEventArgs",
    value: function getMouseEventArgs(evt) {
      var e = this.normalizeEvent(evt);

      var _this$graph$snapToGri = this.graph.snapToGrid(e.clientX, e.clientY),
          x = _this$graph$snapToGri.x,
          y = _this$graph$snapToGri.y;

      return {
        e: e,
        x: x,
        y: y
      };
    }
  }, {
    key: "onHandleChange",
    value: function onHandleChange(_ref) {
      var e = _ref.e;
      this.focus();
      var edgeView = this.cellView;
      edgeView.cell.startBatch('move-vertex', {
        ui: true,
        toolId: this.cid
      });

      if (!this.options.stopPropagation) {
        var _this$getMouseEventAr = this.getMouseEventArgs(e),
            evt = _this$getMouseEventAr.e,
            x = _this$getMouseEventAr.x,
            y = _this$getMouseEventAr.y;

        edgeView.notifyMouseDown(evt, x, y);
      }
    }
  }, {
    key: "onHandleChanging",
    value: function onHandleChanging(_ref2) {
      var handle = _ref2.handle,
          e = _ref2.e;
      var edgeView = this.cellView;
      var index = handle.options.index;

      var _this$getMouseEventAr2 = this.getMouseEventArgs(e),
          evt = _this$getMouseEventAr2.e,
          x = _this$getMouseEventAr2.x,
          y = _this$getMouseEventAr2.y;

      var vertex = {
        x: x,
        y: y
      };
      this.snapVertex(vertex, index);
      edgeView.cell.setVertexAt(index, vertex, {
        ui: true,
        toolId: this.cid
      });
      handle.updatePosition(vertex.x, vertex.y);

      if (!this.options.stopPropagation) {
        edgeView.notifyMouseMove(evt, x, y);
      }
    }
  }, {
    key: "onHandleChanged",
    value: function onHandleChanged(_ref3) {
      var e = _ref3.e;
      var options = this.options;
      var edgeView = this.cellView;

      if (options.vertexAdding) {
        this.updatePath();
      }

      if (!options.redundancyRemoval) {
        return;
      }

      var verticesRemoved = edgeView.removeRedundantLinearVertices({
        ui: true,
        toolId: this.cid
      });

      if (verticesRemoved) {
        this.render();
      }

      this.blur();
      edgeView.cell.stopBatch('move-vertex', {
        ui: true,
        toolId: this.cid
      });

      if (this.eventData(e).vertexAdded) {
        edgeView.cell.stopBatch('add-vertex', {
          ui: true,
          toolId: this.cid
        });
      }

      var _this$getMouseEventAr3 = this.getMouseEventArgs(e),
          evt = _this$getMouseEventAr3.e,
          x = _this$getMouseEventAr3.x,
          y = _this$getMouseEventAr3.y;

      if (!this.options.stopPropagation) {
        edgeView.notifyMouseUp(evt, x, y);
      }

      edgeView.checkMouseleave(evt);
    }
  }, {
    key: "snapVertex",
    value: function snapVertex(vertex, index) {
      var snapRadius = this.options.snapRadius || 0;

      if (snapRadius > 0) {
        var neighbors = this.getNeighborPoints(index);
        var prev = neighbors.prev;
        var next = neighbors.next;

        if (Math.abs(vertex.x - prev.x) < snapRadius) {
          vertex.x = prev.x;
        } else if (Math.abs(vertex.x - next.x) < snapRadius) {
          vertex.x = next.x;
        }

        if (Math.abs(vertex.y - prev.y) < snapRadius) {
          vertex.y = neighbors.prev.y;
        } else if (Math.abs(vertex.y - next.y) < snapRadius) {
          vertex.y = next.y;
        }
      }
    }
  }, {
    key: "onHandleRemove",
    value: function onHandleRemove(_ref4) {
      var handle = _ref4.handle,
          e = _ref4.e;
      var index = handle.options.index;
      var edgeView = this.cellView;
      edgeView.cell.removeVertexAt(index, {
        ui: true
      });

      if (this.options.vertexAdding) {
        this.updatePath();
      }

      edgeView.checkMouseleave(this.normalizeEvent(e));
    }
  }, {
    key: "onPathMouseDown",
    value: function onPathMouseDown(evt) {
      if (this.guard(evt)) {
        return;
      }

      evt.stopPropagation();
      evt.preventDefault();
      var e = this.normalizeEvent(evt);
      var vertex = this.graph.snapToGrid(e.clientX, e.clientY).toJSON();
      var edgeView = this.cellView;
      edgeView.cell.startBatch('add-vertex', {
        ui: true,
        toolId: this.cid
      });
      var index = edgeView.getVertexIndex(vertex.x, vertex.y);
      this.snapVertex(vertex, index);
      edgeView.cell.setVertexAt(index, vertex, {
        ui: true,
        toolId: this.cid
      });
      this.render();
      var handle = this.handles[index];
      this.eventData(e, {
        vertexAdded: true
      });
      handle.onMouseDown(e);
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.resetHandles();
    }
  }, {
    key: "vertices",
    get: function get() {
      return this.cellView.cell.getVertices();
    }
  }]);

  return Vertices;
}(tool_ToolsView.ToolItem);

(function (Vertices) {
  var Handle = /*#__PURE__*/function (_View) {
    Object(inherits["a" /* default */])(Handle, _View);

    var _super2 = Object(createSuper["a" /* default */])(Handle);

    function Handle(options) {
      var _this4;

      Object(classCallCheck["a" /* default */])(this, Handle);

      _this4 = _super2.call(this);
      _this4.options = options;
      _this4.container = view_View.createElement('circle', true);
      dom_main_namespaceObject.attr(_this4.container, {
        r: 6,
        fill: '#33334F',
        stroke: '#FFFFFF',
        cursor: 'move',
        'stroke-width': 2
      });
      dom_main_namespaceObject.addClass(_this4.container, _this4.prefixClassName('edge-tool-vertex'));

      _this4.delegateEvents({
        mousedown: 'onMouseDown',
        touchstart: 'onMouseDown',
        dblclick: 'onDoubleClick'
      });

      return _this4;
    }

    Object(createClass["a" /* default */])(Handle, [{
      key: "updatePosition",
      value: function updatePosition(x, y) {
        dom_main_namespaceObject.attr(this.container, {
          cx: x,
          cy: y
        });
      }
    }, {
      key: "onMouseDown",
      value: function onMouseDown(evt) {
        if (this.options.guard(evt)) {
          return;
        }

        evt.stopPropagation();
        evt.preventDefault();
        this.graph.view.undelegateEvents();
        this.delegateDocumentEvents({
          mousemove: 'onMouseMove',
          touchmove: 'onMouseMove',
          mouseup: 'onMouseUp',
          touchend: 'onMouseUp',
          touchcancel: 'onMouseUp'
        }, evt.data);
        this.emit('change', {
          e: evt,
          handle: this
        });
      }
    }, {
      key: "onMouseMove",
      value: function onMouseMove(evt) {
        this.emit('changing', {
          e: evt,
          handle: this
        });
      }
    }, {
      key: "onMouseUp",
      value: function onMouseUp(evt) {
        this.emit('changed', {
          e: evt,
          handle: this
        });
        this.undelegateDocumentEvents();
        this.graph.view.delegateEvents();
      }
    }, {
      key: "onDoubleClick",
      value: function onDoubleClick(evt) {
        this.emit('remove', {
          e: evt,
          handle: this
        });
      }
    }, {
      key: "graph",
      get: function get() {
        return this.options.graph;
      }
    }]);

    return Handle;
  }(view_View);

  Vertices.Handle = Handle;
})(vertices_Vertices || (vertices_Vertices = {}));

(function (Vertices) {
  var _events;

  var pathClassName = util_Util.prefix('edge-tool-vertex-path');
  Vertices.config({
    name: 'vertices',
    snapRadius: 20,
    redundancyRemoval: true,
    vertexAdding: true,
    stopPropagation: true,
    handleConstructor: Vertices.Handle,
    markup: [{
      tagName: 'path',
      selector: 'connection',
      className: pathClassName,
      attrs: {
        fill: 'none',
        stroke: 'transparent',
        'stroke-width': 10,
        cursor: 'pointer'
      }
    }],
    events: (_events = {}, Object(defineProperty["a" /* default */])(_events, "mousedown .".concat(pathClassName), 'onPathMouseDown'), Object(defineProperty["a" /* default */])(_events, "touchstart .".concat(pathClassName), 'onPathMouseDown'), _events)
  });
})(vertices_Vertices || (vertices_Vertices = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/tool/segments.js











var segments_Segments = /*#__PURE__*/function (_ToolsView$ToolItem) {
  Object(inherits["a" /* default */])(Segments, _ToolsView$ToolItem);

  var _super = Object(createSuper["a" /* default */])(Segments);

  function Segments() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Segments);

    _this = _super.apply(this, arguments);
    _this.handles = [];
    return _this;
  }

  Object(createClass["a" /* default */])(Segments, [{
    key: "update",
    value: function update() {
      this.render();
      return this;
    }
  }, {
    key: "onRender",
    value: function onRender() {
      dom_main_namespaceObject.addClass(this.container, this.prefixClassName('edge-tool-segments'));
      this.resetHandles();
      var edgeView = this.cellView;

      var vertices = Object(toConsumableArray["a" /* default */])(this.vertices);

      vertices.unshift(edgeView.sourcePoint);
      vertices.push(edgeView.targetPoint);

      for (var i = 0, l = vertices.length; i < l - 1; i += 1) {
        var vertex = vertices[i];
        var nextVertex = vertices[i + 1];
        var handle = this.renderHandle(vertex, nextVertex);
        this.stamp(handle.container);
        this.handles.push(handle);
        handle.options.index = i;
      }

      return this;
    }
  }, {
    key: "renderHandle",
    value: function renderHandle(vertex, nextVertex) {
      var _this2 = this;

      var handle = new this.options.handleConstructor({
        graph: this.graph,
        guard: function guard(evt) {
          return _this2.guard(evt);
        }
      });
      this.updateHandle(handle, vertex, nextVertex);
      this.container.appendChild(handle.container);
      this.startHandleListening(handle);
      return handle;
    }
  }, {
    key: "startHandleListening",
    value: function startHandleListening(handle) {
      handle.on('change', this.onHandleChange, this);
      handle.on('changing', this.onHandleChanging, this);
      handle.on('changed', this.onHandleChanged, this);
    }
  }, {
    key: "stopHandleListening",
    value: function stopHandleListening(handle) {
      handle.off('change', this.onHandleChange, this);
      handle.off('changing', this.onHandleChanging, this);
      handle.off('changed', this.onHandleChanged, this);
    }
  }, {
    key: "resetHandles",
    value: function resetHandles() {
      var _this3 = this;

      var handles = this.handles;
      this.handles = [];

      if (handles) {
        handles.forEach(function (handle) {
          _this3.stopHandleListening(handle);

          handle.remove();
        });
      }
    }
  }, {
    key: "shiftHandleIndexes",
    value: function shiftHandleIndexes(delta) {
      var handles = this.handles;

      for (var i = 0, n = handles.length; i < n; i += 1) {
        handles[i].options.index += delta;
      }
    }
  }, {
    key: "resetAnchor",
    value: function resetAnchor(type, anchor) {
      var edge = this.cellView.cell;

      if (anchor) {
        edge.prop([type, 'anchor'], anchor, {
          rewrite: true,
          ui: true,
          toolId: this.cid
        });
      } else {
        edge.removeProp([type, 'anchor'], {
          ui: true,
          toolId: this.cid
        });
      }
    }
  }, {
    key: "snapHandle",
    value: function snapHandle(handle, position, data) {
      var axis = handle.options.axis;
      var index = handle.options.index;
      var edgeView = this.cellView;
      var edge = edgeView.cell;
      var vertices = edge.getVertices();
      var prev = vertices[index - 2] || data.sourceAnchor;
      var next = vertices[index + 1] || data.targetAnchor;
      var snapRadius = this.options.snapRadius;

      if (Math.abs(position[axis] - prev[axis]) < snapRadius) {
        position[axis] = prev[axis];
      } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {
        position[axis] = next[axis];
      }

      return position;
    }
  }, {
    key: "onHandleChanging",
    value: function onHandleChanging(_ref) {
      var handle = _ref.handle,
          e = _ref.e;
      var graph = this.graph;
      var options = this.options;
      var edgeView = this.cellView;
      var anchorFn = options.anchor;
      var axis = handle.options.axis;
      var index = handle.options.index - 1;
      var data = this.getEventData(e);
      var normalizedEvent = this.normalizeEvent(e);
      var coords = graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
      var position = this.snapHandle(handle, coords.clone(), data);
      var offset = this.options.snapHandle ? 0 : coords[axis] - position[axis];
      var vertices = object_namespaceObject.cloneDeep(this.vertices);
      var vertex = vertices[index];
      var nextVertex = vertices[index + 1]; // First Segment

      var sourceView = edgeView.sourceView;
      var sourceBBox = edgeView.sourceBBox;
      var changeSourceAnchor = false;
      var deleteSourceAnchor = false;

      if (!vertex) {
        vertex = edgeView.sourceAnchor.toJSON();
        vertex[axis] = position[axis];

        if (sourceBBox.containsPoint(vertex)) {
          changeSourceAnchor = true;
        } else {
          vertices.unshift(vertex);
          this.shiftHandleIndexes(1);
          deleteSourceAnchor = true;
        }
      } else if (index === 0) {
        if (sourceBBox.containsPoint(vertex)) {
          vertices.shift();
          this.shiftHandleIndexes(-1);
          changeSourceAnchor = true;
        } else {
          vertex[axis] = position[axis];
          deleteSourceAnchor = true;
        }
      } else {
        vertex[axis] = position[axis];
      }

      if (typeof anchorFn === 'function' && sourceView) {
        if (changeSourceAnchor) {
          var sourceAnchorPosition = data.sourceAnchor.clone();
          sourceAnchorPosition[axis] = position[axis];
          var sourceAnchor = main_namespaceObject.call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, 'source', edgeView, this);
          this.resetAnchor('source', sourceAnchor);
        }

        if (deleteSourceAnchor) {
          this.resetAnchor('source', data.sourceAnchorDef);
        }
      } // Last segment


      var targetView = edgeView.targetView;
      var targetBBox = edgeView.targetBBox;
      var changeTargetAnchor = false;
      var deleteTargetAnchor = false;

      if (!nextVertex) {
        nextVertex = edgeView.targetAnchor.toJSON();
        nextVertex[axis] = position[axis];

        if (targetBBox.containsPoint(nextVertex)) {
          changeTargetAnchor = true;
        } else {
          vertices.push(nextVertex);
          deleteTargetAnchor = true;
        }
      } else if (index === vertices.length - 2) {
        if (targetBBox.containsPoint(nextVertex)) {
          vertices.pop();
          changeTargetAnchor = true;
        } else {
          nextVertex[axis] = position[axis];
          deleteTargetAnchor = true;
        }
      } else {
        nextVertex[axis] = position[axis];
      }

      if (typeof anchorFn === 'function' && targetView) {
        if (changeTargetAnchor) {
          var targetAnchorPosition = data.targetAnchor.clone();
          targetAnchorPosition[axis] = position[axis];
          var targetAnchor = main_namespaceObject.call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, 'target', edgeView, this);
          this.resetAnchor('target', targetAnchor);
        }

        if (deleteTargetAnchor) {
          this.resetAnchor('target', data.targetAnchorDef);
        }
      }

      if (!point_Point.equalPoints(vertices, this.vertices)) {
        this.cellView.cell.setVertices(vertices, {
          ui: true,
          toolId: this.cid
        });
      }

      this.updateHandle(handle, vertex, nextVertex, offset);

      if (!options.stopPropagation) {
        edgeView.notifyMouseMove(normalizedEvent, coords.x, coords.y);
      }
    }
  }, {
    key: "onHandleChange",
    value: function onHandleChange(_ref2) {
      var handle = _ref2.handle,
          e = _ref2.e;
      var options = this.options;
      var handles = this.handles;
      var edgeView = this.cellView;
      var index = handle.options.index;

      if (!Array.isArray(handles)) {
        return;
      }

      for (var i = 0, n = handles.length; i < n; i += 1) {
        if (i !== index) {
          handles[i].hide();
        }
      }

      this.focus();
      this.setEventData(e, {
        sourceAnchor: edgeView.sourceAnchor.clone(),
        targetAnchor: edgeView.targetAnchor.clone(),
        sourceAnchorDef: object_namespaceObject.cloneDeep(this.cell.prop(['source', 'anchor'])),
        targetAnchorDef: object_namespaceObject.cloneDeep(this.cell.prop(['target', 'anchor']))
      });
      this.cell.startBatch('move-segment', {
        ui: true,
        toolId: this.cid
      });

      if (!options.stopPropagation) {
        var normalizedEvent = this.normalizeEvent(e);
        var coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
        edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);
      }
    }
  }, {
    key: "onHandleChanged",
    value: function onHandleChanged(_ref3) {
      var e = _ref3.e;
      var options = this.options;
      var edgeView = this.cellView;

      if (options.redundancyRemoval) {
        edgeView.removeRedundantLinearVertices({
          ui: true,
          toolId: this.cid
        });
      }

      var normalizedEvent = this.normalizeEvent(e);
      var coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
      this.render();
      this.blur();
      this.cell.stopBatch('move-segment', {
        ui: true,
        toolId: this.cid
      });

      if (!options.stopPropagation) {
        edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);
      }

      edgeView.checkMouseleave(normalizedEvent);
    }
  }, {
    key: "updateHandle",
    value: function updateHandle(handle, vertex, nextVertex) {
      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var precision = this.options.precision || 0;
      var vertical = Math.abs(vertex.x - nextVertex.x) < precision;
      var horizontal = Math.abs(vertex.y - nextVertex.y) < precision;

      if (vertical || horizontal) {
        var segmentLine = new line_Line(vertex, nextVertex);
        var length = segmentLine.length();

        if (length < this.options.segmentLengthThreshold) {
          handle.hide();
        } else {
          var position = segmentLine.getCenter();
          var axis = vertical ? 'x' : 'y';
          position[axis] += offset || 0;
          var angle = segmentLine.vector().vectorAngle(new point_Point(1, 0));
          handle.updatePosition(position.x, position.y, angle, this.cellView);
          handle.show();
          handle.options.axis = axis;
        }
      } else {
        handle.hide();
      }
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.resetHandles();
    }
  }, {
    key: "vertices",
    get: function get() {
      return this.cellView.cell.getVertices();
    }
  }]);

  return Segments;
}(tool_ToolsView.ToolItem);

(function (Segments) {
  var Handle = /*#__PURE__*/function (_View) {
    Object(inherits["a" /* default */])(Handle, _View);

    var _super2 = Object(createSuper["a" /* default */])(Handle);

    function Handle(options) {
      var _this4;

      Object(classCallCheck["a" /* default */])(this, Handle);

      _this4 = _super2.call(this);
      _this4.options = options;
      _this4.container = view_View.createElement('g', true);
      dom_main_namespaceObject.addClass(_this4.container, _this4.prefixClassName('edge-tool-segment'));

      _this4.delegateEvents({
        mousedown: 'onMouseDown',
        touchstart: 'onMouseDown'
      });

      var meta = markup_Markup.parseJSONMarkup([{
        tagName: 'line',
        selector: 'line',
        attrs: {
          stroke: '#33334F',
          'stroke-width': 2,
          fill: 'none',
          'pointer-events': 'none'
        }
      }, {
        tagName: 'rect',
        selector: 'handle',
        attrs: {
          width: 20,
          height: 8,
          x: -10,
          y: -4,
          rx: 4,
          ry: 4,
          fill: '#33334F',
          stroke: '#FFFFFF',
          'stroke-width': 2
        }
      }]);
      _this4.lineElem = meta.selectors.line;
      _this4.handleElem = meta.selectors.handle;

      _this4.container.appendChild(meta.fragment);

      return _this4;
    }

    Object(createClass["a" /* default */])(Handle, [{
      key: "updatePosition",
      value: function updatePosition(x, y, angle, view) {
        var matrix = dom_main_namespaceObject.createSVGMatrix().translate(x, y).rotate(angle);
        var handle = this.handleElem;
        handle.setAttribute('transform', dom_main_namespaceObject.matrixToTransformString(matrix));
        handle.setAttribute('cursor', angle % 180 === 0 ? 'row-resize' : 'col-resize');
        var pt = view.getClosestPoint(new point_Point(x, y));
        var line = this.lineElem;
        line.setAttribute('x1', "".concat(x));
        line.setAttribute('y1', "".concat(y));
        line.setAttribute('x2', "".concat(pt.x));
        line.setAttribute('y2', "".concat(pt.y));
      }
    }, {
      key: "onMouseDown",
      value: function onMouseDown(evt) {
        if (this.options.guard(evt)) {
          return;
        }

        this.trigger('change', {
          e: evt,
          handle: this
        });
        evt.stopPropagation();
        evt.preventDefault();
        this.options.graph.view.undelegateEvents();
        this.delegateDocumentEvents({
          mousemove: 'onMouseMove',
          touchmove: 'onMouseMove',
          mouseup: 'onMouseUp',
          touchend: 'onMouseUp',
          touchcancel: 'onMouseUp'
        }, evt.data);
      }
    }, {
      key: "onMouseMove",
      value: function onMouseMove(evt) {
        this.emit('changing', {
          e: evt,
          handle: this
        });
      }
    }, {
      key: "onMouseUp",
      value: function onMouseUp(evt) {
        this.emit('changed', {
          e: evt,
          handle: this
        });
        this.undelegateDocumentEvents();
        this.options.graph.view.delegateEvents();
      }
    }, {
      key: "show",
      value: function show() {
        this.container.style.display = '';
      }
    }, {
      key: "hide",
      value: function hide() {
        this.container.style.display = 'none';
      }
    }]);

    return Handle;
  }(view_View);

  Segments.Handle = Handle;
})(segments_Segments || (segments_Segments = {}));

(function (Segments) {
  Segments.config({
    name: 'segments',
    precision: 0.5,
    handleConstructor: Segments.Handle,
    segmentLengthThreshold: 40,
    redundancyRemoval: true,
    anchor: util_getAnchor,
    snapRadius: 10,
    snapHandle: true,
    stopPropagation: true
  });
})(segments_Segments || (segments_Segments = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/tool/anchor.js









var anchor_Anchor = /*#__PURE__*/function (_ToolsView$ToolItem) {
  Object(inherits["a" /* default */])(Anchor, _ToolsView$ToolItem);

  var _super = Object(createSuper["a" /* default */])(Anchor);

  function Anchor() {
    Object(classCallCheck["a" /* default */])(this, Anchor);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Anchor, [{
    key: "onRender",
    value: function onRender() {
      dom_main_namespaceObject.addClass(this.container, this.prefixClassName("edge-tool-".concat(this.type, "-anchor")));
      this.toggleArea(false);
      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      var type = this.type;
      var edgeView = this.cellView;
      var terminalView = edgeView.getTerminalView(type);

      if (terminalView) {
        this.updateAnchor();
        this.updateArea();
        this.container.style.display = '';
      } else {
        this.container.style.display = 'none';
      }

      return this;
    }
  }, {
    key: "updateAnchor",
    value: function updateAnchor() {
      var childNodes = this.childNodes;

      if (!childNodes) {
        return;
      }

      var anchorNode = childNodes.anchor;

      if (!anchorNode) {
        return;
      }

      var type = this.type;
      var edgeView = this.cellView;
      var options = this.options;
      var position = edgeView.getTerminalAnchor(type);
      var customAnchor = edgeView.cell.prop([type, 'anchor']);
      anchorNode.setAttribute('transform', "translate(".concat(position.x, ", ").concat(position.y, ")"));
      var anchorAttrs = customAnchor ? options.customAnchorAttrs : options.defaultAnchorAttrs;

      if (anchorAttrs) {
        for (var attrName in anchorAttrs) {
          anchorNode.setAttribute(attrName, anchorAttrs[attrName]);
        }
      }
    }
  }, {
    key: "updateArea",
    value: function updateArea() {
      var childNodes = this.childNodes;

      if (!childNodes) {
        return;
      }

      var areaNode = childNodes.area;

      if (!areaNode) {
        return;
      }

      var type = this.type;
      var edgeView = this.cellView;
      var terminalView = edgeView.getTerminalView(type);

      if (terminalView) {
        var terminalCell = terminalView.cell;
        var magnet = edgeView.getTerminalMagnet(type);
        var padding = this.options.areaPadding || 0;

        if (!isFinite(padding)) {
          padding = 0;
        }

        var bbox;
        var angle;
        var center;

        if (terminalView.isEdgeElement(magnet)) {
          bbox = terminalView.getBBox();
          angle = 0;
          center = bbox.getCenter();
        } else {
          bbox = terminalView.getUnrotatedBBoxOfElement(magnet);
          angle = terminalCell.getAngle();
          center = bbox.getCenter();

          if (angle) {
            center.rotate(-angle, terminalCell.getBBox().getCenter());
          }
        }

        bbox.inflate(padding);
        dom_main_namespaceObject.attr(areaNode, {
          x: -bbox.width / 2,
          y: -bbox.height / 2,
          width: bbox.width,
          height: bbox.height,
          transform: "translate(".concat(center.x, ", ").concat(center.y, ") rotate(").concat(angle, ")")
        });
      }
    }
  }, {
    key: "toggleArea",
    value: function toggleArea(visible) {
      if (this.childNodes) {
        var elem = this.childNodes.area;

        if (elem) {
          elem.style.display = visible ? '' : 'none';
        }
      }
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(evt) {
      if (this.guard(evt)) {
        return;
      }

      evt.stopPropagation();
      evt.preventDefault();
      this.graph.view.undelegateEvents();

      if (this.options.documentEvents) {
        this.delegateDocumentEvents(this.options.documentEvents);
      }

      this.focus();
      this.toggleArea(this.options.restrictArea);
      this.cell.startBatch('move-anchor', {
        ui: true,
        toolId: this.cid
      });
    }
  }, {
    key: "resetAnchor",
    value: function resetAnchor(anchor) {
      var type = this.type;
      var cell = this.cell;

      if (anchor) {
        cell.prop([type, 'anchor'], anchor, {
          rewrite: true,
          ui: true,
          toolId: this.cid
        });
      } else {
        cell.removeProp([type, 'anchor'], {
          ui: true,
          toolId: this.cid
        });
      }
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(evt) {
      var terminalType = this.type;
      var edgeView = this.cellView;
      var terminalView = edgeView.getTerminalView(terminalType);

      if (terminalView == null) {
        return;
      }

      var e = this.normalizeEvent(evt);
      var terminalCell = terminalView.cell;
      var terminalMagnet = edgeView.getTerminalMagnet(terminalType);
      var coords = this.graph.clientToLocalPoint(e.clientX, e.clientY);
      var snapFn = this.options.snap;

      if (typeof snapFn === 'function') {
        var tmp = main_namespaceObject.call(snapFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
        coords = point_Point.create(tmp);
      }

      if (this.options.restrictArea) {
        if (terminalView.isEdgeElement(terminalMagnet)) {
          var pointAtConnection = terminalView.getClosestPoint(coords);

          if (pointAtConnection) {
            coords = pointAtConnection;
          }
        } else {
          var bbox = terminalView.getUnrotatedBBoxOfElement(terminalMagnet);
          var angle = terminalCell.getAngle();
          var origin = terminalCell.getBBox().getCenter();
          var rotatedCoords = coords.clone().rotate(angle, origin);

          if (!bbox.containsPoint(rotatedCoords)) {
            coords = bbox.pointNearestToPoint(rotatedCoords).rotate(-angle, origin);
          }
        }
      }

      var anchor;
      var anchorFn = this.options.anchor;

      if (typeof anchorFn === 'function') {
        anchor = main_namespaceObject.call(anchorFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
      }

      this.resetAnchor(anchor);
      this.update();
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(evt) {
      this.graph.view.delegateEvents();
      this.undelegateDocumentEvents();
      this.blur();
      this.toggleArea(false);
      var edgeView = this.cellView;

      if (this.options.redundancyRemoval) {
        edgeView.removeRedundantLinearVertices({
          ui: true,
          toolId: this.cid
        });
      }

      this.cell.stopBatch('move-anchor', {
        ui: true,
        toolId: this.cid
      });
    }
  }, {
    key: "onDblClick",
    value: function onDblClick() {
      this.resetAnchor();
      this.update();
    }
  }, {
    key: "type",
    get: function get() {
      return this.options.type;
    }
  }]);

  return Anchor;
}(tool_ToolsView.ToolItem);

(function (Anchor) {
  Anchor.config({
    tagName: 'g',
    markup: [{
      tagName: 'circle',
      selector: 'anchor',
      attrs: {
        cursor: 'pointer'
      }
    }, {
      tagName: 'rect',
      selector: 'area',
      attrs: {
        'pointer-events': 'none',
        fill: 'none',
        stroke: '#33334F',
        'stroke-dasharray': '2,4',
        rx: 5,
        ry: 5
      }
    }],
    events: {
      mousedown: 'onMouseDown',
      touchstart: 'onMouseDown',
      dblclick: 'onDblClick'
    },
    documentEvents: {
      mousemove: 'onMouseMove',
      touchmove: 'onMouseMove',
      mouseup: 'onMouseUp',
      touchend: 'onMouseUp',
      touchcancel: 'onMouseUp'
    },
    customAnchorAttrs: {
      'stroke-width': 4,
      stroke: '#33334F',
      fill: '#FFFFFF',
      r: 5
    },
    defaultAnchorAttrs: {
      'stroke-width': 2,
      stroke: '#FFFFFF',
      fill: '#33334F',
      r: 6
    },
    areaPadding: 6,
    restrictArea: true,
    redundancyRemoval: true,
    snapRadius: 10,
    anchor: util_getAnchor,
    snap: function snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {
      var snapRadius = toolView.options.snapRadius || 0;
      var isSource = terminalType === 'source';
      var refIndex = isSource ? 0 : -1;
      var ref = this.cell.getVertexAt(refIndex) || this.getTerminalAnchor(isSource ? 'target' : 'source');

      if (ref) {
        if (Math.abs(ref.x - pos.x) < snapRadius) pos.x = ref.x;
        if (Math.abs(ref.y - pos.y) < snapRadius) pos.y = ref.y;
      }

      return pos;
    }
  });
})(anchor_Anchor || (anchor_Anchor = {}));

var SourceAnchor = anchor_Anchor.define({
  name: 'source-anchor',
  type: 'source'
});
var TargetAnchor = anchor_Anchor.define({
  name: 'target-anchor',
  type: 'target'
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/tool/arrowhead.js





var arrowhead_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};





var arrowhead_Arrowhead = /*#__PURE__*/function (_ToolsView$ToolItem) {
  Object(inherits["a" /* default */])(Arrowhead, _ToolsView$ToolItem);

  var _super = Object(createSuper["a" /* default */])(Arrowhead);

  function Arrowhead() {
    Object(classCallCheck["a" /* default */])(this, Arrowhead);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Arrowhead, [{
    key: "init",
    value: function init() {
      if (this.options.attrs) {
        var _a = this.options.attrs,
            className = _a.class,
            attrs = arrowhead_rest(_a, ["class"]);

        this.setAttrs(attrs, this.container);

        if (className) {
          dom_main_namespaceObject.addClass(this.container, className);
        }
      }
    }
  }, {
    key: "onRender",
    value: function onRender() {
      dom_main_namespaceObject.addClass(this.container, this.prefixClassName("edge-tool-".concat(this.type, "-arrowhead")));
      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      var ratio = this.ratio;
      var edgeView = this.cellView;
      var tangent = edgeView.getTangentAtRatio(ratio);
      var position = tangent ? tangent.start : edgeView.getPointAtRatio(ratio);
      var angle = tangent && tangent.vector().vectorAngle(new point_Point(1, 0)) || 0;

      if (!position) {
        return this;
      }

      var matrix = dom_main_namespaceObject.createSVGMatrix().translate(position.x, position.y).rotate(angle);
      dom_main_namespaceObject.transform(this.container, matrix, {
        absolute: true
      });
      return this;
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(evt) {
      if (this.guard(evt)) {
        return;
      }

      evt.stopPropagation();
      evt.preventDefault();
      var edgeView = this.cellView;
      edgeView.cell.startBatch('move-arrowhead', {
        ui: true,
        toolId: this.cid
      });

      if (edgeView.can('arrowheadMovable')) {
        var data = edgeView.prepareArrowheadDragging(this.type);
        this.cellView.setEventData(evt, data);
        this.delegateDocumentEvents(this.options.documentEvents, evt.data);
        edgeView.graph.view.undelegateEvents();
      }

      this.focus();
      this.container.style.pointerEvents = 'none';
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(evt) {
      var e = this.normalizeEvent(evt);
      var coords = this.graph.snapToGrid(e.clientX, e.clientY);
      this.cellView.onMouseMove(e, coords.x, coords.y);
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(evt) {
      this.undelegateDocumentEvents();
      var e = this.normalizeEvent(evt);
      var edgeView = this.cellView;
      var coords = this.graph.snapToGrid(e.clientX, e.clientY);
      edgeView.onMouseUp(e, coords.x, coords.y);
      this.graph.view.delegateEvents();
      this.blur();
      this.container.style.pointerEvents = '';
      edgeView.cell.stopBatch('move-arrowhead', {
        ui: true,
        toolId: this.cid
      });
    }
  }, {
    key: "type",
    get: function get() {
      return this.options.type;
    }
  }, {
    key: "ratio",
    get: function get() {
      return this.options.ratio;
    }
  }]);

  return Arrowhead;
}(tool_ToolsView.ToolItem);

(function (Arrowhead) {
  Arrowhead.config({
    tagName: 'path',
    isSVGElement: true,
    events: {
      mousedown: 'onMouseDown',
      touchstart: 'onMouseDown'
    },
    documentEvents: {
      mousemove: 'onMouseMove',
      touchmove: 'onMouseMove',
      mouseup: 'onMouseUp',
      touchend: 'onMouseUp',
      touchcancel: 'onMouseUp'
    }
  });
})(arrowhead_Arrowhead || (arrowhead_Arrowhead = {}));

var SourceArrowhead = arrowhead_Arrowhead.define({
  name: 'source-arrowhead',
  type: 'source',
  ratio: 0,
  attrs: {
    d: 'M 10 -8 -10 0 10 8 Z',
    fill: '#333',
    stroke: '#fff',
    'stroke-width': 2,
    cursor: 'move'
  }
});
var TargetArrowhead = arrowhead_Arrowhead.define({
  name: 'target-arrowhead',
  type: 'target',
  ratio: 1,
  attrs: {
    d: 'M -10 -8 10 0 -10 8 Z',
    fill: '#333',
    stroke: '#fff',
    'stroke-width': 2,
    cursor: 'move'
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/tool/index.js
var tool_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};









var tool_NodeTool;

(function (NodeTool) {
  NodeTool.presets = {
    boundary: boundary_Boundary,
    button: button_Button,
    'button-remove': button_Button.Remove
  };
  NodeTool.registry = registry_Registry.create({
    type: 'node tool',
    process: function process(name, options) {
      if (typeof options === 'function') {
        return options;
      }

      var parent = tool_ToolsView.ToolItem;

      var inherit = options.inherit,
          others = tool_rest(options, ["inherit"]);

      if (inherit) {
        var base = this.get(inherit);

        if (base == null) {
          this.onNotFound(inherit, 'inherited');
        } else {
          parent = base;
        }
      }

      if (others.name == null) {
        others.name = name;
      }

      return parent.define.call(parent, others);
    }
  });
  NodeTool.registry.register(NodeTool.presets, true);
})(tool_NodeTool || (tool_NodeTool = {}));

var tool_EdgeTool;

(function (EdgeTool) {
  EdgeTool.presets = {
    boundary: boundary_Boundary,
    vertices: vertices_Vertices,
    segments: segments_Segments,
    button: button_Button,
    'button-remove': button_Button.Remove,
    'source-anchor': SourceAnchor,
    'target-anchor': TargetAnchor,
    'source-arrowhead': SourceArrowhead,
    'target-arrowhead': TargetArrowhead
  };
  EdgeTool.registry = registry_Registry.create({
    type: 'edge tool',
    process: function process(name, options) {
      if (typeof options === 'function') {
        return options;
      }

      var parent = tool_ToolsView.ToolItem;

      var inherit = options.inherit,
          others = tool_rest(options, ["inherit"]);

      if (inherit) {
        var base = this.get(inherit);

        if (base == null) {
          this.onNotFound(inherit, 'inherited');
        } else {
          parent = base;
        }
      }

      if (others.name == null) {
        others.name = name;
      }

      return parent.define.call(parent, others);
    }
  });
  EdgeTool.registry.register(EdgeTool.presets, true);
})(tool_EdgeTool || (tool_EdgeTool = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/node-anchor/bbox.js

var bbox_center = createBBoxAnchor('center');
var bbox_top = createBBoxAnchor('topCenter');
var bbox_bottom = createBBoxAnchor('bottomCenter');
var bbox_left = createBBoxAnchor('leftMiddle');
var bbox_right = createBBoxAnchor('rightMiddle');
var bbox_topLeft = createBBoxAnchor('topLeft');
var topRight = createBBoxAnchor('topRight');
var bottomLeft = createBBoxAnchor('bottomLeft');
var bbox_bottomRight = createBBoxAnchor('bottomRight');

function createBBoxAnchor(method) {
  return function (view, magnet, ref) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var bbox = options.rotated ? view.getUnrotatedBBoxOfElement(magnet) : view.getBBoxOfElement(magnet);
    var result = bbox[method];
    result.x += number_namespaceObject.normalizePercentage(options.dx, bbox.width);
    result.y += number_namespaceObject.normalizePercentage(options.dy, bbox.height);
    var cell = view.cell;
    return options.rotated ? result.rotate(-cell.getAngle(), cell.getBBox().getCenter()) : result;
  };
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/node-anchor/util.js


function util_resolve(fn) {
  return function (view, magnet, ref, options) {
    if (ref instanceof Element) {
      var refView = this.graph.renderer.findViewByElem(ref);
      var refPoint;

      if (refView) {
        if (refView.isEdgeElement(ref)) {
          var distance = options.fixedAt != null ? options.fixedAt : '50%';
          refPoint = getPointAtEdge(refView, distance);
        } else {
          refPoint = refView.getBBoxOfElement(ref).getCenter();
        }
      } else {
        refPoint = new point_Point();
      }

      return fn.call(this, view, magnet, refPoint, options);
    }

    return fn.apply(this, arguments);
  };
}
function getPointAtEdge(edgeView, value) {
  var isPercentage = number_namespaceObject.isPercentage(value);
  var num = typeof value === 'string' ? parseFloat(value) : value;

  if (isPercentage) {
    return edgeView.getPointAtRatio(num / 100);
  }

  return edgeView.getPointAtLength(num);
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/node-anchor/orth.js



var orth_orthogonal = function orthogonal(view, magnet, refPoint, options) {
  var angle = view.cell.getAngle();
  var bbox = view.getBBoxOfElement(magnet);
  var result = bbox.getCenter();
  var topLeft = bbox.getTopLeft();
  var bottomRight = bbox.getBottomRight();
  var padding = options.padding;

  if (!isFinite(padding)) {
    padding = 0;
  }

  if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {
    var dy = refPoint.y - result.y;
    result.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(Angle.toRad(angle));
    result.y += dy;
  } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {
    var dx = refPoint.x - result.x;
    result.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(Angle.toRad(angle));
    result.x += dx;
  }

  return result;
};
/**
 * Tries to place the anchor of the edge inside the view bbox so that the
 * edge is made orthogonal. The anchor is placed along two line segments
 * inside the view bbox (between the centers of the top and bottom side and
 * between the centers of the left and right sides). If it is not possible
 * to place the anchor so that the edge would be orthogonal, the anchor is
 * placed at the center of the view bbox instead.
 */


var orth_orth = util_resolve(orth_orthogonal);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/node-anchor/node-center.js
/**
 * Places the anchor of the edge at center of the node bbox.
 */
var node_center_nodeCenter = function nodeCenter(view, magnet, ref, options, endType) {
  var result = view.cell.getConnectionPoint(this.cell, endType);

  if (options.dx || options.dy) {
    result.translate(options.dx || 0, options.dy || 0);
  }

  return result;
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/node-anchor/middle-side.js


var middleSide = function middleSide(view, magnet, refPoint, options) {
  var bbox;
  var angle = 0;
  var center;
  var node = view.cell;

  if (options.rotated) {
    bbox = view.getUnrotatedBBoxOfElement(magnet);
    center = node.getBBox().getCenter();
    angle = node.getAngle();
  } else {
    bbox = view.getBBoxOfElement(magnet);
  }

  var padding = options.padding;

  if (padding != null && isFinite(padding)) {
    bbox.inflate(padding);
  }

  if (options.rotated) {
    refPoint.rotate(angle, center);
  }

  var side = bbox.sideNearestToPoint(refPoint);
  var result;

  switch (side) {
    case 'left':
      result = bbox.getLeftMiddle();
      break;

    case 'right':
      result = bbox.getRightMiddle();
      break;

    case 'top':
      result = bbox.getTopCenter();
      break;

    case 'bottom':
      result = bbox.getBottomCenter();
      break;
  }

  return options.rotated ? result.rotate(-angle, center) : result;
};
/**
 * Places the anchor of the edge in the middle of the side of view bbox
 * closest to the other endpoint.
 */


var midSide = util_resolve(middleSide);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/node-anchor/main.js




// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/node-anchor/index.js


var node_anchor_NodeAnchor;

(function (NodeAnchor) {
  NodeAnchor.presets = node_anchor_main_namespaceObject;
  NodeAnchor.registry = registry_Registry.create({
    type: 'node endpoint'
  });
  NodeAnchor.registry.register(NodeAnchor.presets, true);
})(node_anchor_NodeAnchor || (node_anchor_NodeAnchor = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/edge-anchor/ratio.js
var ratio_ratio = function ratio(view, magnet, ref, options) {
  var ratio = options.ratio != null ? options.ratio : 0.5;

  if (ratio > 1) {
    ratio = ratio / 100;
  }

  return view.getPointAtRatio(ratio);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/edge-anchor/length.js
var length_length = function length(view, magnet, ref, options) {
  var length = options.length != null ? options.length : 20;
  return view.getPointAtLength(length);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/edge-anchor/closest.js


var closest_getClosestPoint = function getClosestPoint(view, magnet, refPoint, options) {
  var closestPoint = view.getClosestPoint(refPoint);
  return closestPoint != null ? closestPoint : new point_Point();
};
var closest_closest = util_resolve(closest_getClosestPoint);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/edge-anchor/orth.js






var edge_anchor_orth_orthogonal = function orthogonal(view, magnet, refPoint, options) {
  var OFFSET = 1e6;
  var path = view.getConnection();
  var segmentSubdivisions = view.getConnectionSubdivisions();
  var vLine = new line_Line(refPoint.clone().translate(0, OFFSET), refPoint.clone().translate(0, -OFFSET));
  var hLine = new line_Line(refPoint.clone().translate(OFFSET, 0), refPoint.clone().translate(-OFFSET, 0));
  var vIntersections = vLine.intersect(path, {
    segmentSubdivisions: segmentSubdivisions
  });
  var hIntersections = hLine.intersect(path, {
    segmentSubdivisions: segmentSubdivisions
  });
  var intersections = [];

  if (vIntersections) {
    intersections.push.apply(intersections, Object(toConsumableArray["a" /* default */])(vIntersections));
  }

  if (hIntersections) {
    intersections.push.apply(intersections, Object(toConsumableArray["a" /* default */])(hIntersections));
  }

  if (intersections.length > 0) {
    return refPoint.closest(intersections);
  }

  if (options.fallbackAt != null) {
    return getPointAtEdge(view, options.fallbackAt);
  }

  return main_namespaceObject.call(closest_getClosestPoint, this, view, magnet, refPoint, options);
};

var edge_anchor_orth_orth = util_resolve(edge_anchor_orth_orthogonal);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/edge-anchor/main.js




// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/edge-anchor/index.js


var edge_anchor_EdgeAnchor;

(function (EdgeAnchor) {
  EdgeAnchor.presets = edge_anchor_main_namespaceObject;
  EdgeAnchor.registry = registry_Registry.create({
    type: 'edge endpoint'
  });
  EdgeAnchor.registry.register(EdgeAnchor.presets, true);
})(edge_anchor_EdgeAnchor || (edge_anchor_EdgeAnchor = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connection-point/util.js
function util_offset(p1, p2, offset) {
  if (offset == null) {
    return p1;
  }

  var length = p1.distance(p2);

  if (offset === 0 && length > 0) {
    return p1;
  }

  return p1.move(p2, -Math.min(offset, length - 1));
}
function getStrokeWidth(magnet) {
  var stroke = magnet.getAttribute('stroke-width');

  if (stroke === null) {
    return 0;
  }

  return parseFloat(stroke) || 0;
}
function findShapeNode(magnet) {
  if (magnet == null) {
    return null;
  }

  var node = magnet;

  do {
    var tagName = node.tagName;
    if (typeof tagName !== 'string') return null;
    tagName = tagName.toUpperCase();

    if (tagName === 'G') {
      node = node.firstElementChild;
    } else if (tagName === 'TITLE') {
      node = node.nextElementSibling;
    } else break;
  } while (node);

  return node;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connection-point/bbox.js

/**
 * Places the connection point at the intersection between the edge
 * path end segment and the target node bbox.
 */

var bbox_bbox = function bbox(line, view, magnet, options) {
  var bbox = view.getBBoxOfElement(magnet);

  if (options.stroked) {
    bbox.inflate(getStrokeWidth(magnet) / 2);
  }

  var intersections = line.intersect(bbox);
  var p = intersections && intersections.length ? line.start.closest(intersections) : line.end;
  return util_offset(p, line.start, options.offset);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connection-point/rect.js



/**
 * Places the connection point at the intersection between the
 * link path end segment and the element's unrotated bbox.
 */

var rect_rect = function rect(line, view, magnet, options, type) {
  var cell = view.cell;
  var angle = cell.isNode() ? cell.getAngle() : 0;

  if (angle === 0) {
    return main_namespaceObject.call(bbox_bbox, this, line, view, magnet, options, type);
  }

  var bboxRaw = view.getUnrotatedBBoxOfElement(magnet);

  if (options.stroked) {
    bboxRaw.inflate(getStrokeWidth(magnet) / 2);
  }

  var center = bboxRaw.getCenter();
  var lineRaw = line.clone().rotate(angle, center);
  var intersections = lineRaw.setLength(1e6).intersect(bboxRaw);
  var p = intersections && intersections.length ? lineRaw.start.closest(intersections).rotate(-angle, center) : line.end;
  return util_offset(p, line.start, options.offset);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connection-point/boundary.js



/**
 * Places the connection point at the intersection between the
 * edge path end segment and the actual shape of the target magnet.
 */

var boundary_boundary = function boundary(line, view, magnet, options) {
  var node;
  var intersection;
  var anchor = line.end;
  var selector = options.selector;

  if (typeof selector === 'string') {
    node = view.findOne(selector);
  } else if (Array.isArray(selector)) {
    node = object_namespaceObject.getByPath(magnet, selector);
  } else {
    node = findShapeNode(magnet);
  }

  if (!dom_main_namespaceObject.isSVGGraphicsElement(node)) {
    if (node === magnet || !dom_main_namespaceObject.isSVGGraphicsElement(magnet)) {
      return anchor;
    }

    node = magnet;
  }

  var localShape = view.getShapeOfElement(node);
  var magnetMatrix = view.getMatrixOfElement(node);
  var translateMatrix = view.getRootTranslatedMatrix();
  var rotateMatrix = view.getRootRotatedMatrix();
  var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);
  var localMatrix = targetMatrix.inverse();
  var localLine = dom_main_namespaceObject.transformLine(line, localMatrix);
  var localRef = localLine.start.clone();
  var data = view.getDataOfElement(node);

  if (options.insideout === false) {
    if (data.shapeBBox == null) {
      data.shapeBBox = localShape.bbox();
    }

    var localBBox = data.shapeBBox;

    if (localBBox != null && localBBox.containsPoint(localRef)) {
      return anchor;
    }
  }

  if (options.extrapolate === true) {
    localLine.setLength(1e6);
  } // Caching segment subdivisions for paths


  var pathOptions;

  if (localShape instanceof path_Path) {
    var precision = options.precision || 2;

    if (data.segmentSubdivisions == null) {
      data.segmentSubdivisions = localShape.getSegmentSubdivisions({
        precision: precision
      });
    }

    pathOptions = {
      precision: precision,
      segmentSubdivisions: data.segmentSubdivisions
    };
    intersection = localLine.intersect(localShape, pathOptions);
  } else {
    intersection = localLine.intersect(localShape);
  }

  if (intersection) {
    if (Array.isArray(intersection)) {
      intersection = localRef.closest(intersection);
    }
  } else if (options.sticky === true) {
    // No intersection, find the closest point instead
    if (localShape instanceof rectangle_Rectangle) {
      intersection = localShape.pointNearestToPoint(localRef);
    } else if (localShape instanceof ellipse_Ellipse) {
      intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);
    } else {
      intersection = localShape.closestPoint(localRef, pathOptions);
    }
  }

  var cp = intersection ? dom_main_namespaceObject.transformPoint(intersection, targetMatrix) : anchor;
  var cpOffset = options.offset || 0;

  if (options.stroked) {
    cpOffset += getStrokeWidth(node) / 2;
  }

  return util_offset(cp, line.start, cpOffset);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connection-point/anchor.js

/**
 * Places the connection point at the edge's endpoint.
 */

var anchor_anchor = function anchor(line, view, magnet, options) {
  return util_offset(line.end, line.start, options.offset);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connection-point/main.js




// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connection-point/index.js


var connection_point_ConnectionPoint;

(function (ConnectionPoint) {
  ConnectionPoint.presets = connection_point_main_namespaceObject;
  ConnectionPoint.registry = registry_Registry.create({
    type: 'connection point'
  });
  ConnectionPoint.registry.register(ConnectionPoint.presets, true);
})(connection_point_ConnectionPoint || (connection_point_ConnectionPoint = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/normal.js

var normal_normal = function normal(vertices) {
  return Object(toConsumableArray["a" /* default */])(vertices);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/oneside.js


/**
 * Routes the edge always to/from a certain side
 */

var oneside_oneSide = function oneSide(vertices, options, edgeView) {
  var side = options.side || 'bottom';
  var padding = number_namespaceObject.normalizeSides(options.padding || 40);
  var sourceBBox = edgeView.sourceBBox;
  var targetBBox = edgeView.targetBBox;
  var sourcePoint = sourceBBox.getCenter();
  var targetPoint = targetBBox.getCenter();
  var coord;
  var dim;
  var factor;

  switch (side) {
    case 'top':
      factor = -1;
      coord = 'y';
      dim = 'height';
      break;

    case 'left':
      factor = -1;
      coord = 'x';
      dim = 'width';
      break;

    case 'right':
      factor = 1;
      coord = 'x';
      dim = 'width';
      break;

    case 'bottom':
    default:
      factor = 1;
      coord = 'y';
      dim = 'height';
      break;
  } // Move the points from the center of the element to outside of it.


  sourcePoint[coord] += factor * (sourceBBox[dim] / 2 + padding[side]);
  targetPoint[coord] += factor * (targetBBox[dim] / 2 + padding[side]); // Make edge orthogonal (at least the first and last vertex).

  if (factor * (sourcePoint[coord] - targetPoint[coord]) > 0) {
    targetPoint[coord] = sourcePoint[coord];
  } else {
    sourcePoint[coord] = targetPoint[coord];
  }

  return [sourcePoint.toJSON()].concat(Object(toConsumableArray["a" /* default */])(vertices), [targetPoint.toJSON()]);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/util.js


function getPointBBox(p) {
  return new rectangle_Rectangle(p.x, p.y, 0, 0);
}
function getPaddingBox() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var sides = number_namespaceObject.normalizeSides(options.padding || 20);
  return {
    x: -sides.left,
    y: -sides.top,
    width: sides.left + sides.right,
    height: sides.top + sides.bottom
  };
}
function getSourceBBox(view) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return view.sourceBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getTargetBBox(view) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return view.targetBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getSourceAnchor(view) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (view.sourceAnchor) {
    return view.sourceAnchor;
  }

  var bbox = getSourceBBox(view, options);
  return bbox.getCenter();
}
function getTargetAnchor(view) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (view.targetAnchor) {
    return view.targetAnchor;
  }

  var bbox = getTargetBBox(view, options);
  return bbox.getCenter();
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/orth.js




/**
 * Returns a route with orthogonal line segments.
 */

var router_orth_orth = function orth(vertices, options, edgeView) {
  var sourceBBox = getSourceBBox(edgeView, options);
  var targetBBox = getTargetBBox(edgeView, options);
  var sourceAnchor = getSourceAnchor(edgeView, options);
  var targetAnchor = getTargetAnchor(edgeView, options); // If anchor lies outside of bbox, the bbox expands to include it

  sourceBBox = sourceBBox.union(getPointBBox(sourceAnchor));
  targetBBox = targetBBox.union(getPointBBox(targetAnchor));
  var points = vertices.map(function (p) {
    return point_Point.create(p);
  });
  points.unshift(sourceAnchor);
  points.push(targetAnchor); // bearing of previous route segment

  var bearing = null;
  var result = [];

  for (var i = 0, len = points.length - 1; i < len; i += 1) {
    var route = null;
    var from = points[i];
    var to = points[i + 1];
    var isOrthogonal = orth_Private.getBearing(from, to) != null;

    if (i === 0) {
      // source
      if (i + 1 === len) {
        // route source -> target
        // Expand one of the nodes by 1px to detect situations when the two
        // nodes are positioned next to each other with no gap in between.
        if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {
          route = orth_Private.insideElement(from, to, sourceBBox, targetBBox);
        } else if (!isOrthogonal) {
          route = orth_Private.elementElement(from, to, sourceBBox, targetBBox);
        }
      } else {
        // route source -> vertex
        if (sourceBBox.containsPoint(to)) {
          route = orth_Private.insideElement(from, to, sourceBBox, getPointBBox(to).moveAndExpand(getPaddingBox(options)));
        } else if (!isOrthogonal) {
          route = orth_Private.elementVertex(from, to, sourceBBox);
        }
      }
    } else if (i + 1 === len) {
      // route vertex -> target
      // prevent overlaps with previous line segment
      var isOrthogonalLoop = isOrthogonal && orth_Private.getBearing(to, from) === bearing;

      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {
        route = orth_Private.insideElement(from, to, getPointBBox(from).moveAndExpand(getPaddingBox(options)), targetBBox, bearing);
      } else if (!isOrthogonal) {
        route = orth_Private.vertexElement(from, to, targetBBox, bearing);
      }
    } else if (!isOrthogonal) {
      // route vertex -> vertex
      route = orth_Private.vertexVertex(from, to, bearing);
    } // set bearing for next iteration


    if (route) {
      result.push.apply(result, Object(toConsumableArray["a" /* default */])(route.points));
      bearing = route.direction;
    } else {
      // orthogonal route and not looped
      bearing = orth_Private.getBearing(from, to);
    } // push `to` point to identified orthogonal vertices array


    if (i + 1 < len) {
      result.push(to);
    }
  }

  return result;
};
var orth_Private;

(function (Private) {
  /**
   * Bearing to opposite bearing map
   */
  var opposites = {
    N: 'S',
    S: 'N',
    E: 'W',
    W: 'E'
  };
  /**
   * Bearing to radians map
   */

  var radians = {
    N: -Math.PI / 2 * 3,
    S: -Math.PI / 2,
    E: 0,
    W: Math.PI
  };
  /**
   * Returns a point `p` where lines p,p1 and p,p2 are perpendicular
   * and p is not contained in the given box
   */

  function freeJoin(p1, p2, bbox) {
    var p = new point_Point(p1.x, p2.y);

    if (bbox.containsPoint(p)) {
      p = new point_Point(p2.x, p1.y);
    } // kept for reference
    // if (bbox.containsPoint(p)) {
    //   return null
    // }


    return p;
  }
  /**
   * Returns either width or height of a bbox based on the given bearing.
   */


  function getBBoxSize(bbox, bearing) {
    return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];
  }

  Private.getBBoxSize = getBBoxSize;

  function getBearing(from, to) {
    if (from.x === to.x) {
      return from.y > to.y ? 'N' : 'S';
    }

    if (from.y === to.y) {
      return from.x > to.x ? 'W' : 'E';
    }

    return null;
  }

  Private.getBearing = getBearing;

  function vertexVertex(from, to, bearing) {
    var p1 = new point_Point(from.x, to.y);
    var p2 = new point_Point(to.x, from.y);
    var d1 = getBearing(from, p1);
    var d2 = getBearing(from, p2);
    var opposite = bearing ? opposites[bearing] : null;
    var p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;
    return {
      points: [p],
      direction: getBearing(p, to)
    };
  }

  Private.vertexVertex = vertexVertex;

  function elementVertex(from, to, fromBBox) {
    var p = freeJoin(from, to, fromBBox);
    return {
      points: [p],
      direction: getBearing(p, to)
    };
  }

  Private.elementVertex = elementVertex;

  function vertexElement(from, to, toBBox, bearing) {
    var points = [new point_Point(from.x, to.y), new point_Point(to.x, from.y)];
    var freePoints = points.filter(function (p) {
      return !toBBox.containsPoint(p);
    });
    var freeBearingPoints = freePoints.filter(function (p) {
      return getBearing(p, from) !== bearing;
    });
    var p;

    if (freeBearingPoints.length > 0) {
      // Try to pick a point which bears the same direction as the previous segment.
      p = freeBearingPoints.filter(function (p) {
        return getBearing(from, p) === bearing;
      }).pop();
      p = p || freeBearingPoints[0];
      return {
        points: [p],
        direction: getBearing(p, to)
      };
    }

    {
      // Here we found only points which are either contained in the element or they would create
      // a link segment going in opposite direction from the previous one.
      // We take the point inside element and move it outside the element in the direction the
      // route is going. Now we can join this point with the current end (using freeJoin).
      p = array_namespaceObject.difference(points, freePoints)[0];
      var p2 = point_Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);
      var p1 = freeJoin(p2, from, toBBox);
      return {
        points: [p1, p2],
        direction: getBearing(p2, to)
      };
    }
  }

  Private.vertexElement = vertexElement;

  function elementElement(from, to, fromBBox, toBBox) {
    var route = elementVertex(to, from, toBBox);
    var p1 = route.points[0];

    if (fromBBox.containsPoint(p1)) {
      route = elementVertex(from, to, fromBBox);
      var p2 = route.points[0];

      if (toBBox.containsPoint(p2)) {
        var fromBorder = point_Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);
        var toBorder = point_Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);
        var mid = new line_Line(fromBorder, toBorder).getCenter();
        var startRoute = elementVertex(from, mid, fromBBox);
        var endRoute = vertexVertex(mid, to, startRoute.direction);
        route.points = [startRoute.points[0], endRoute.points[0]];
        route.direction = endRoute.direction;
      }
    }

    return route;
  }

  Private.elementElement = elementElement; // Finds route for situations where one node is inside the other.
  // Typically the route is directed outside the outer node first and
  // then back towards the inner node.

  function insideElement(from, to, fromBBox, toBBox, bearing) {
    var boundary = fromBBox.union(toBBox).inflate(1); // start from the point which is closer to the boundary

    var center = boundary.getCenter();
    var reversed = center.distance(to) > center.distance(from);
    var start = reversed ? to : from;
    var end = reversed ? from : to;
    var p1;
    var p2;
    var p3;

    if (bearing) {
      // Points on circle with radius equals 'W + H` are always outside the rectangle
      // with width W and height H if the center of that circle is the center of that rectangle.
      p1 = point_Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);
      p1 = boundary.pointNearestToPoint(p1).move(p1, -1);
    } else {
      p1 = boundary.pointNearestToPoint(start).move(start, 1);
    }

    p2 = freeJoin(p1, end, boundary);
    var points;

    if (p1.round().equals(p2.round())) {
      p2 = point_Point.fromPolar(boundary.width + boundary.height, Angle.toRad(p1.theta(start)) + Math.PI / 2, end);
      p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();
      p3 = freeJoin(p1, p2, boundary);
      points = reversed ? [p2, p3, p1] : [p1, p3, p2];
    } else {
      points = reversed ? [p2, p1] : [p1, p2];
    }

    var direction = reversed ? getBearing(p1, to) : getBearing(p2, to);
    return {
      points: points,
      direction: direction
    };
  }

  Private.insideElement = insideElement;
})(orth_Private || (orth_Private = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/manhattan/options.js



var options_defaults = {
  step: 10,
  maxLoopCount: 2000,
  precision: 1,
  maxDirectionChange: 90,
  perpendicular: true,
  excludeTerminals: [],
  excludeShapes: [],
  startDirections: ['top', 'right', 'bottom', 'left'],
  endDirections: ['top', 'right', 'bottom', 'left'],
  directionMap: {
    top: {
      x: 0,
      y: -1
    },
    right: {
      x: 1,
      y: 0
    },
    bottom: {
      x: 0,
      y: 1
    },
    left: {
      x: -1,
      y: 0
    }
  },
  cost: function cost() {
    var step = options_resolve(this.step, this);
    return step;
  },
  directions: function directions() {
    var step = options_resolve(this.step, this);
    var cost = options_resolve(this.cost, this);
    return [{
      cost: cost,
      offsetX: step,
      offsetY: 0
    }, {
      cost: cost,
      offsetX: 0,
      offsetY: step
    }, {
      cost: cost,
      offsetX: -step,
      offsetY: 0
    }, {
      cost: cost,
      offsetX: 0,
      offsetY: -step
    }];
  },
  penalties: function penalties() {
    var step = options_resolve(this.step, this);
    return {
      0: 0,
      45: step / 2,
      90: step / 2
    };
  },
  paddingBox: function paddingBox() {
    var step = options_resolve(this.step, this);
    return {
      x: -step,
      y: -step,
      width: 2 * step,
      height: 2 * step
    };
  },
  fallbackRouter: router_orth_orth,
  draggingRouter: null
};
function options_resolve(input, options) {
  if (typeof input === 'function') {
    return input.call(options);
  }

  return input;
}
function resolveOptions(options) {
  var result = Object.keys(options).reduce(function (memo, key) {
    var ret = memo;

    if (key === 'fallbackRouter' || key === 'draggingRouter' || key === 'fallbackRoute') {
      ret[key] = options[key];
    } else {
      ret[key] = options_resolve(options[key], options);
    }

    return memo;
  }, {});

  if (result.padding) {
    var sides = number_namespaceObject.normalizeSides(result.padding);
    options.paddingBox = {
      x: -sides.left,
      y: -sides.top,
      width: sides.left + sides.right,
      height: sides.top + sides.bottom
    };
  }

  result.directions.forEach(function (direction) {
    var point1 = new point_Point(0, 0);
    var point2 = new point_Point(direction.offsetX, direction.offsetY);
    direction.angle = Angle.normalize(point1.theta(point2));
  });
  return result;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/manhattan/sorted-set.js



var OPEN = 1;
var CLOSE = 2;
var sorted_set_SortedSet = /*#__PURE__*/function () {
  function SortedSet() {
    Object(classCallCheck["a" /* default */])(this, SortedSet);

    this.items = [];
    this.hash = {};
    this.values = {};
  }

  Object(createClass["a" /* default */])(SortedSet, [{
    key: "add",
    value: function add(item, value) {
      var _this = this;

      if (this.hash[item]) {
        // item removal
        this.items.splice(this.items.indexOf(item), 1);
      } else {
        this.hash[item] = OPEN;
      }

      this.values[item] = value;
      var index = array_namespaceObject.sortedIndexBy(this.items, item, function (key) {
        return _this.values[key];
      });
      this.items.splice(index, 0, item);
    }
  }, {
    key: "pop",
    value: function pop() {
      var item = this.items.shift();

      if (item) {
        this.hash[item] = CLOSE;
      }

      return item;
    }
  }, {
    key: "isOpen",
    value: function isOpen(item) {
      return this.hash[item] === OPEN;
    }
  }, {
    key: "isClose",
    value: function isClose(item) {
      return this.hash[item] === CLOSE;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.items.length === 0;
    }
  }]);

  return SortedSet;
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/manhattan/obstacle-map.js




/**
 * Helper structure to identify whether a point lies inside an obstacle.
 */

var obstacle_map_ObstacleMap = /*#__PURE__*/function () {
  function ObstacleMap(options) {
    Object(classCallCheck["a" /* default */])(this, ObstacleMap);

    this.options = options;
    this.mapGridSize = 100;
    this.map = {};
  }
  /**
   * Builds a map of all nodes for quicker obstacle queries i.e. is a point
   * contained in any obstacle?
   *
   * A simplified grid search.
   */


  Object(createClass["a" /* default */])(ObstacleMap, [{
    key: "build",
    value: function build(model, edge) {
      var options = this.options; // source or target node could be excluded from set of obstacles

      var excludedTerminals = options.excludeTerminals.reduce(function (memo, type) {
        var terminal = edge[type];

        if (terminal) {
          var cell = model.getCell(terminal.cell);

          if (cell) {
            memo.push(cell);
          }
        }

        return memo;
      }, []);
      var excludedAncestors = [];
      var source = model.getCell(edge.getSourceCellId());

      if (source) {
        excludedAncestors = array_namespaceObject.union(excludedAncestors, source.getAncestors().map(function (cell) {
          return cell.id;
        }));
      }

      var target = model.getCell(edge.getTargetCellId());

      if (target) {
        excludedAncestors = array_namespaceObject.union(excludedAncestors, target.getAncestors().map(function (cell) {
          return cell.id;
        }));
      } // The graph is divided into smaller cells, where each holds information
      // about which node belong to it. When we query whether a point lies
      // inside an obstacle we don't need to go through all obstacles, we check
      // only those in a particular cell.


      var mapGridSize = this.mapGridSize;
      model.getNodes().reduce(function (map, node) {
        var shape = node.shape;
        var excludeShapes = options.excludeShapes;
        var excType = shape ? excludeShapes.includes(shape) : false;
        var excTerminal = excludedTerminals.some(function (cell) {
          return cell.id === node.id;
        });
        var excAncestor = excludedAncestors.includes(node.id);
        var excluded = excType || excTerminal || excAncestor;

        if (!excluded) {
          var bbox = node.getBBox().moveAndExpand(options.paddingBox);
          var origin = bbox.getOrigin().snapToGrid(mapGridSize);
          var corner = bbox.getCorner().snapToGrid(mapGridSize);

          for (var x = origin.x; x <= corner.x; x += mapGridSize) {
            for (var y = origin.y; y <= corner.y; y += mapGridSize) {
              var key = new point_Point(x, y).toString();

              if (map[key] == null) {
                map[key] = [];
              }

              map[key].push(bbox);
            }
          }
        }

        return map;
      }, this.map);
      return this;
    }
  }, {
    key: "isAccessible",
    value: function isAccessible(point) {
      var key = point.clone().snapToGrid(this.mapGridSize).toString();
      var rects = this.map[key];
      return rects ? rects.every(function (rect) {
        return !rect.containsPoint(point);
      }) : true;
    }
  }]);

  return ObstacleMap;
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/manhattan/util.js


function util_getSourceBBox(view, options) {
  var bbox = view.sourceBBox.clone();

  if (options && options.paddingBox) {
    return bbox.moveAndExpand(options.paddingBox);
  }

  return bbox;
}
function util_getTargetBBox(view, options) {
  var bbox = view.targetBBox.clone();

  if (options && options.paddingBox) {
    return bbox.moveAndExpand(options.paddingBox);
  }

  return bbox;
}
function getSourceEndpoint(view, options) {
  if (view.sourceAnchor) {
    return view.sourceAnchor;
  }

  var sourceBBox = util_getSourceBBox(view, options);
  return sourceBBox.getCenter();
}
function getTargetEndpoint(view, options) {
  if (view.targetAnchor) {
    return view.targetAnchor;
  }

  var targetBBox = util_getTargetBBox(view, options);
  return targetBBox.getCenter();
} // returns a direction index from start point to end point
// corrects for grid deformation between start and end

function getDirectionAngle(start, end, directionCount, grid, options) {
  var quadrant = 360 / directionCount;
  var angleTheta = start.theta(fixAngleEnd(start, end, grid, options));
  var normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);
  return quadrant * Math.floor(normalizedAngle / quadrant);
}

function fixAngleEnd(start, end, grid, options) {
  var step = options.step;
  var diffX = end.x - start.x;
  var diffY = end.y - start.y;
  var gridStepsX = diffX / grid.x;
  var gridStepsY = diffY / grid.y;
  var distanceX = gridStepsX * step;
  var distanceY = gridStepsY * step;
  return new point_Point(start.x + distanceX, start.y + distanceY);
}
/**
 * Returns the change in direction between two direction angles.
 */


function getDirectionChange(angle1, angle2) {
  var change = Math.abs(angle1 - angle2);
  return change > 180 ? 360 - change : change;
} // fix direction offsets according to current grid

function getGridOffsets(grid, options) {
  var step = options.step;
  options.directions.forEach(function (direction) {
    direction.gridOffsetX = direction.offsetX / step * grid.x;
    direction.gridOffsetY = direction.offsetY / step * grid.y;
  });
  return options.directions;
} // get grid size in x and y dimensions, adapted to source and target positions

function getGrid(step, source, target) {
  return {
    source: source.clone(),
    x: getGridDimension(target.x - source.x, step),
    y: getGridDimension(target.y - source.y, step)
  };
}

function getGridDimension(diff, step) {
  // return step if diff = 0
  if (!diff) {
    return step;
  }

  var abs = Math.abs(diff);
  var count = Math.round(abs / step); // return `abs` if less than one step apart

  if (!count) {
    return abs;
  } // otherwise, return corrected step


  var roundedDiff = count * step;
  var remainder = abs - roundedDiff;
  var correction = remainder / count;
  return step + correction;
}

function snapGrid(point, grid) {
  var source = grid.source;
  var x = util_Util.snapToGrid(point.x - source.x, grid.x) + source.x;
  var y = util_Util.snapToGrid(point.y - source.y, grid.y) + source.y;
  return new point_Point(x, y);
}

function manhattan_util_round(point, precision) {
  return point.round(precision);
}
function align(point, grid, precision) {
  return manhattan_util_round(snapGrid(point.clone(), grid), precision);
}
function getKey(point) {
  return point.toString();
}
function util_normalizePoint(point) {
  return new point_Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
}
function getCost(from, anchors) {
  var min = Infinity;

  for (var i = 0, len = anchors.length; i < len; i += 1) {
    var dist = from.manhattanDistance(anchors[i]);

    if (dist < min) {
      min = dist;
    }
  }

  return min;
} // Find points around the bbox taking given directions into account
// lines are drawn from anchor in given directions, intersections recorded
// if anchor is outside bbox, only those directions that intersect get a rect point
// the anchor itself is returned as rect point (representing some directions)
// (since those directions are unobstructed by the bbox)

function getRectPoints(anchor, bbox, directionList, grid, options) {
  var precision = options.precision;
  var directionMap = options.directionMap;
  var centerVector = anchor.diff(bbox.getCenter());
  var rectPoints = Object.keys(directionMap).reduce(function (res, key) {
    if (directionList.includes(key)) {
      var direction = directionMap[key]; // Create a line that is guaranteed to intersect the bbox if bbox
      // is in the direction even if anchor lies outside of bbox.

      var ending = new point_Point(anchor.x + direction.x * (Math.abs(centerVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(centerVector.y) + bbox.height));
      var intersectionLine = new line_Line(anchor, ending); // Get the farther intersection, in case there are two
      // (that happens if anchor lies next to bbox)

      var intersections = intersectionLine.intersect(bbox) || [];
      var farthestIntersectionDistance;
      var farthestIntersection = null;

      for (var i = 0; i < intersections.length; i += 1) {
        var intersection = intersections[i];
        var distance = anchor.squaredDistance(intersection);

        if (farthestIntersectionDistance == null || distance > farthestIntersectionDistance) {
          farthestIntersectionDistance = distance;
          farthestIntersection = intersection;
        }
      } // If an intersection was found in this direction, it is our rectPoint


      if (farthestIntersection) {
        var target = align(farthestIntersection, grid, precision); // If the rectPoint lies inside the bbox, offset it by one more step

        if (bbox.containsPoint(target)) {
          target = align(target.translate(direction.x * grid.x, direction.y * grid.y), grid, precision);
        }

        res.push(target);
      }
    }

    return res;
  }, []); // if anchor lies outside of bbox, add it to the array of points

  if (!bbox.containsPoint(anchor)) {
    rectPoints.push(align(anchor, grid, precision));
  }

  return rectPoints;
} // reconstructs a route by concatenating points with their parents

function reconstructRoute(parents, points, tailPoint, from, to) {
  var route = [];
  var prevDiff = util_normalizePoint(to.diff(tailPoint)); // tailPoint is assumed to be aligned already

  var currentKey = getKey(tailPoint);
  var parent = parents[currentKey];
  var point;

  while (parent) {
    // point is assumed to be aligned already
    point = points[currentKey];
    var diff = util_normalizePoint(point.diff(parent));

    if (!diff.equals(prevDiff)) {
      route.unshift(point);
      prevDiff = diff;
    } // parent is assumed to be aligned already


    currentKey = getKey(parent);
    parent = parents[currentKey];
  } // leadPoint is assumed to be aligned already


  var leadPoint = points[currentKey];
  var fromDiff = util_normalizePoint(leadPoint.diff(from));

  if (!fromDiff.equals(prevDiff)) {
    route.unshift(leadPoint);
  }

  return route;
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/manhattan/router.js







/**
 * Finds the route between two points (`from`, `to`).
 */

function findRoute(edgeView, from, to, map, options) {
  var precision = options.precision;
  var sourceEndpoint;
  var targetEndpoint;

  if (from instanceof rectangle_Rectangle) {
    sourceEndpoint = manhattan_util_round(getSourceEndpoint(edgeView, options).clone(), precision);
  } else {
    sourceEndpoint = manhattan_util_round(from.clone(), precision);
  }

  if (to instanceof rectangle_Rectangle) {
    targetEndpoint = manhattan_util_round(getTargetEndpoint(edgeView, options).clone(), precision);
  } else {
    targetEndpoint = manhattan_util_round(to.clone(), precision);
  } // Get grid for this route.


  var grid = getGrid(options.step, sourceEndpoint, targetEndpoint); // Get pathfinding points.
  // -----------------------

  var startPoint = sourceEndpoint;
  var endPoint = targetEndpoint;
  var startPoints;
  var endPoints;

  if (from instanceof rectangle_Rectangle) {
    startPoints = getRectPoints(startPoint, from, options.startDirections, grid, options);
  } else {
    startPoints = [startPoint];
  }

  if (to instanceof rectangle_Rectangle) {
    endPoints = getRectPoints(targetEndpoint, to, options.endDirections, grid, options);
  } else {
    endPoints = [endPoint];
  } // take into account only accessible rect points (those not under obstacles)


  startPoints = startPoints.filter(function (p) {
    return map.isAccessible(p);
  });
  endPoints = endPoints.filter(function (p) {
    return map.isAccessible(p);
  }); // There is an accessible route point on both sides.

  if (startPoints.length > 0 && endPoints.length > 0) {
    var openSet = new sorted_set_SortedSet(); // Keeps the actual points for given nodes of the open set.

    var points = {}; // Keeps the point that is immediate predecessor of given element.

    var parents = {}; // Cost from start to a point along best known path.

    var costs = {};

    for (var i = 0, n = startPoints.length; i < n; i += 1) {
      // startPoint is assumed to be aligned already
      var _startPoint = startPoints[i];
      var key = getKey(_startPoint);
      openSet.add(key, getCost(_startPoint, endPoints));
      points[key] = _startPoint;
      costs[key] = 0;
    }

    var previousRouteDirectionAngle = options.previousDirectionAngle; // undefined for first route

    var isPathBeginning = previousRouteDirectionAngle === undefined; // directions

    var direction;
    var directionChange;
    var directions = getGridOffsets(grid, options);
    var numDirections = directions.length;
    var endPointsKeys = endPoints.reduce(function (res, endPoint) {
      var key = getKey(endPoint);
      res.push(key);
      return res;
    }, []); // main route finding loop

    var sameStartEndPoints = point_Point.equalPoints(startPoints, endPoints);
    var loopsRemaining = options.maxLoopCount;

    while (!openSet.isEmpty() && loopsRemaining > 0) {
      // Get the closest item and mark it CLOSED
      var currentKey = openSet.pop();
      var currentPoint = points[currentKey];
      var currentParent = parents[currentKey];
      var currentCost = costs[currentKey];
      var isStartPoint = currentPoint.equals(startPoint);
      var isRouteBeginning = currentParent == null;
      var previousDirectionAngle = void 0;

      if (!isRouteBeginning) {
        previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);
      } else if (!isPathBeginning) {
        // a vertex on the route
        previousDirectionAngle = previousRouteDirectionAngle;
      } else if (!isStartPoint) {
        // beginning of route on the path
        previousDirectionAngle = getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);
      } else {
        previousDirectionAngle = null;
      } // Check if we reached any endpoint


      var skipEndCheck = isRouteBeginning && sameStartEndPoints;

      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {
        options.previousDirectionAngle = previousDirectionAngle;
        return reconstructRoute(parents, points, currentPoint, startPoint, endPoint);
      } // Go over all possible directions and find neighbors


      for (var _i = 0; _i < numDirections; _i += 1) {
        direction = directions[_i];
        var directionAngle = direction.angle;
        directionChange = getDirectionChange(previousDirectionAngle, directionAngle); // Don't use the point changed rapidly.

        if (!(isPathBeginning && isStartPoint) && directionChange > options.maxDirectionChange) {
          continue;
        }

        var neighborPoint = align(currentPoint.clone().translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);
        var neighborKey = getKey(neighborPoint); // Closed points were already evaluated.

        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {
          continue;
        } // Neighbor is an end point.


        if (endPointsKeys.indexOf(neighborKey) >= 0) {
          var isEndPoint = neighborPoint.equals(endPoint);

          if (!isEndPoint) {
            var endDirectionAngle = getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);
            var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);

            if (endDirectionChange > options.maxDirectionChange) {
              continue;
            }
          }
        } // The current direction is ok.
        // ----------------------------


        var neighborCost = direction.cost;
        var neighborPenalty = isStartPoint ? 0 : options.penalties[directionChange];
        var costFromStart = currentCost + neighborCost + neighborPenalty; // Neighbor point has not been processed yet or the cost of
        // the path from start is lower than previously calculated.

        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {
          points[neighborKey] = neighborPoint;
          parents[neighborKey] = currentPoint;
          costs[neighborKey] = costFromStart;
          openSet.add(neighborKey, costFromStart + getCost(neighborPoint, endPoints));
        }
      }

      loopsRemaining -= 1;
    }
  }

  if (options.fallbackRoute) {
    return main_namespaceObject.call(options.fallbackRoute, this, startPoint, endPoint, options);
  }

  return null;
}

var router_router = function router(vertices, optionsRaw, edgeView) {
  var options = resolveOptions(optionsRaw);
  var sourceBBox = util_getSourceBBox(edgeView, options);
  var targetBBox = util_getTargetBBox(edgeView, options);
  var sourceEndpoint = getSourceEndpoint(edgeView, options); // pathfinding

  var map = new obstacle_map_ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);
  var oldVertices = vertices.map(function (p) {
    return point_Point.create(p);
  });
  var newVertices = []; // The origin of first route's grid, does not need snapping

  var tailPoint = sourceEndpoint;
  var from;
  var to;

  for (var i = 0, len = oldVertices.length; i <= len; i += 1) {
    var partialRoute = null;
    from = to || sourceBBox;
    to = oldVertices[i]; // This is the last iteration

    if (to == null) {
      to = targetBBox; // If the target is a point, we should use dragging route
      // instead of main routing method if it has been provided.

      var edge = edgeView.cell;
      var isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;

      if (isEndingAtPoint && typeof options.draggingRouter === 'function') {
        var dragFrom = from === sourceBBox ? sourceEndpoint : from;
        var dragTo = to.getOrigin();
        partialRoute = main_namespaceObject.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);
      }
    } // Find the partial route


    if (partialRoute == null) {
      partialRoute = findRoute(edgeView, from, to, map, options);
    } // Cannot found the partial route.


    if (partialRoute === null) {
      return main_namespaceObject.call(options.fallbackRouter, this, vertices, options, edgeView);
    } // Remove the first point if the previous partial route has
    // the same point as last.


    var leadPoint = partialRoute[0];

    if (leadPoint && leadPoint.equals(tailPoint)) {
      partialRoute.shift();
    } // Save tailPoint for next iteration


    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;
    newVertices.push.apply(newVertices, Object(toConsumableArray["a" /* default */])(partialRoute));
  }

  return newVertices;
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/manhattan/index.js



var manhattan_manhattan = function manhattan(vertices, options, edgeView) {
  return main_namespaceObject.call(router_router, this, vertices, Object.assign(Object.assign({}, options_defaults), options), edgeView);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/metro.js




var metro_defaults = {
  maxDirectionChange: 45,
  // an array of directions to find next points on the route
  // different from start/end directions
  directions: function directions() {
    var step = options_resolve(this.step, this);
    var cost = options_resolve(this.cost, this);
    var diagonalCost = Math.ceil(Math.sqrt(step * step << 1));
    return [{
      cost: cost,
      offsetX: step,
      offsetY: 0
    }, {
      cost: diagonalCost,
      offsetX: step,
      offsetY: step
    }, {
      cost: cost,
      offsetX: 0,
      offsetY: step
    }, {
      cost: diagonalCost,
      offsetX: -step,
      offsetY: step
    }, {
      cost: cost,
      offsetX: -step,
      offsetY: 0
    }, {
      cost: diagonalCost,
      offsetX: -step,
      offsetY: -step
    }, {
      cost: cost,
      offsetX: 0,
      offsetY: -step
    }, {
      cost: diagonalCost,
      offsetX: step,
      offsetY: -step
    }];
  },
  // a simple route used in situations when main routing method fails
  // (exceed max number of loop iterations, inaccessible)
  fallbackRoute: function fallbackRoute(from, to, options) {
    // Find a route which breaks by 45 degrees ignoring all obstacles.
    var theta = from.theta(to);
    var route = [];
    var a = {
      x: to.x,
      y: from.y
    };
    var b = {
      x: from.x,
      y: to.y
    };

    if (theta % 180 > 90) {
      var t = a;
      a = b;
      b = t;
    }

    var p1 = theta % 90 < 45 ? a : b;
    var l1 = new line_Line(from, p1);
    var alpha = 90 * Math.ceil(theta / 90);
    var p2 = point_Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1);
    var l2 = new line_Line(to, p2);
    var intersectionPoint = l1.intersectionWithLine(l2);
    var point = intersectionPoint ? intersectionPoint : to;
    var directionFrom = intersectionPoint ? point : from;
    var quadrant = 360 / options.directions.length;
    var angleTheta = directionFrom.theta(to);
    var normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);
    var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);
    options.previousDirectionAngle = directionAngle;
    if (point) route.push(point.round());
    route.push(to);
    return route;
  }
};
var metro_metro = function metro(vertices, options, linkView) {
  return main_namespaceObject.call(manhattan_manhattan, this, vertices, Object.assign(Object.assign({}, metro_defaults), options), linkView);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/er.js

var er_er = function er(vertices, options, edgeView) {
  var offset = options.offset || 32;
  var direction = options.direction;
  var sourceBBox = edgeView.sourceBBox;
  var targetBBox = edgeView.targetBBox;
  var sourcePoint = sourceBBox.getCenter();
  var targetPoint = targetBBox.getCenter();

  if (direction == null) {
    var dx = sourcePoint.x - targetPoint.x;
    var dy = sourcePoint.y - targetPoint.y;

    if (Math.abs(dx) > Math.abs(dy)) {
      direction = dx > 0 ? 'R' : 'L';
    } else {
      direction = dy > 0 ? 'B' : 'T';
    }
  }

  var coord;
  var dim;
  var factor;
  var horizontal = direction === 'L' || direction === 'R' || direction === 'H';

  if (horizontal) {
    if (targetPoint.y === sourcePoint.y) {
      return Object(toConsumableArray["a" /* default */])(vertices);
    }

    factor = direction === 'L' || direction === 'H' && targetPoint.x > sourcePoint.x ? 1 : -1;
    coord = 'x';
    dim = 'width';
  } else {
    if (targetPoint.x === sourcePoint.x) {
      return Object(toConsumableArray["a" /* default */])(vertices);
    }

    factor = direction === 'T' || direction === 'V' && targetPoint.y > sourcePoint.y ? 1 : -1;
    coord = 'y';
    dim = 'height';
  }

  var source = sourcePoint.clone();
  var target = targetPoint.clone();
  source[coord] += factor * (sourceBBox[dim] / 2 + offset);
  target[coord] -= factor * (targetBBox[dim] / 2 + offset);
  var min = 16;

  if (horizontal) {
    var sourceX = source.x;
    var targetX = target.x;
    var sourceDelta = sourceBBox.width / 2 + min;
    var targetDelta = targetBBox.width / 2 + min;

    if (targetPoint.x > sourcePoint.x) {
      if (targetX <= sourceX) {
        source.x = Math.max(targetX, sourcePoint.x + sourceDelta);
        target.x = Math.min(sourceX, targetPoint.x - targetDelta);
      }
    } else {
      if (targetX >= sourceX) {
        source.x = Math.min(targetX, sourcePoint.x - sourceDelta);
        target.x = Math.max(sourceX, targetPoint.x + targetDelta);
      }
    }
  } else {
    var sourceY = source.y;
    var targetY = target.y;

    var _sourceDelta = sourceBBox.height / 2 + min;

    var _targetDelta = targetBBox.height / 2 + min;

    if (targetPoint.y > sourcePoint.y) {
      if (targetY <= sourceY) {
        source.y = Math.max(targetY, sourcePoint.y + _sourceDelta);
        target.y = Math.min(sourceY, targetPoint.y - _targetDelta);
      }
    } else {
      if (targetY >= sourceY) {
        source.y = Math.min(targetY, sourcePoint.y - _sourceDelta);
        target.y = Math.max(sourceY, targetPoint.y + _targetDelta);
      }
    }
  }

  return [source.toJSON()].concat(Object(toConsumableArray["a" /* default */])(vertices), [target.toJSON()]);
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/main.js






// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/router/index.js


var router_Router;

(function (Router) {
  Router.presets = router_main_namespaceObject;
  Router.registry = registry_Registry.create({
    type: 'router'
  });
  Router.registry.register(Router.presets, true);
})(router_Router || (router_Router = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connector/normal.js


var connector_normal_normal = function normal(sourcePoint, targetPoint, routePoints) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var points = [sourcePoint].concat(Object(toConsumableArray["a" /* default */])(routePoints), [targetPoint]);
  var polyline = new polyline_Polyline(points);
  var path = new path_Path(polyline);
  return options.raw ? path : path.serialize();
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connector/rounded.js

var rounded_rounded = function rounded(sourcePoint, targetPoint, routePoints) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var path = new path_Path();
  path.appendSegment(path_Path.createSegment('M', sourcePoint));
  var f13 = 1 / 3;
  var f23 = 2 / 3;
  var radius = options.radius || 10;
  var prevDistance;
  var nextDistance;

  for (var i = 0, ii = routePoints.length; i < ii; i += 1) {
    var curr = point_Point.create(routePoints[i]);
    var prev = routePoints[i - 1] || sourcePoint;
    var next = routePoints[i + 1] || targetPoint;
    prevDistance = nextDistance || curr.distance(prev) / 2;
    nextDistance = curr.distance(next) / 2;
    var startMove = -Math.min(radius, prevDistance);
    var endMove = -Math.min(radius, nextDistance);
    var roundedStart = curr.clone().move(prev, startMove).round();
    var roundedEnd = curr.clone().move(next, endMove).round();
    var control1 = new point_Point(f13 * roundedStart.x + f23 * curr.x, f23 * curr.y + f13 * roundedStart.y);
    var control2 = new point_Point(f13 * roundedEnd.x + f23 * curr.x, f23 * curr.y + f13 * roundedEnd.y);
    path.appendSegment(path_Path.createSegment('L', roundedStart));
    path.appendSegment(path_Path.createSegment('C', control1, control2, roundedEnd));
  }

  path.appendSegment(path_Path.createSegment('L', targetPoint));
  return options.raw ? path : path.serialize();
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connector/smooth.js


var smooth_smooth = function smooth(sourcePoint, targetPoint, routePoints) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var path;

  if (routePoints && routePoints.length !== 0) {
    var points = [sourcePoint].concat(Object(toConsumableArray["a" /* default */])(routePoints), [targetPoint]);
    var curves = curve_Curve.throughPoints(points);
    path = new path_Path(curves);
  } else {
    // If we have no route, use a default cubic bezier curve, cubic bezier
    // requires two control points, the control points have `x` midway
    // between source and target. This produces an S-like curve.
    path = new path_Path();
    path.appendSegment(path_Path.createSegment('M', sourcePoint));

    if (Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y)) {
      var controlPointX = (sourcePoint.x + targetPoint.x) / 2;
      path.appendSegment(path_Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y));
    } else {
      var controlPointY = (sourcePoint.y + targetPoint.y) / 2;
      path.appendSegment(path_Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y));
    }
  }

  return options.raw ? path : path.serialize();
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connector/jumpover.js

 // takes care of math. error for case when jump is too close to end of line

var CLOSE_PROXIMITY_PADDING = 1;
var F13 = 1 / 3;
var F23 = 2 / 3;

function setupUpdating(view) {
  var updateList = view.graph._jumpOverUpdateList; // first time setup for this paper

  if (updateList == null) {
    updateList = view.graph._jumpOverUpdateList = [];
    /**
     * Handler for a batch:stop event to force
     * update of all registered links with jump over connector
     */

    view.graph.on('cell:mouseup', function () {
      var list = view.graph._jumpOverUpdateList;

      for (var i = 0; i < list.length; i += 1) {
        list[i].update();
      }
    });
    view.graph.on('model:reseted', function () {
      updateList = view.graph._jumpOverUpdateList = [];
    });
  } // add this link to a list so it can be updated when some other link is updated


  if (updateList.indexOf(view) < 0) {
    updateList.push(view); // watch for change of connector type or removal of link itself
    // to remove the link from a list of jump over connectors

    var clean = function clean() {
      return updateList.splice(updateList.indexOf(view), 1);
    };

    view.cell.once('change:connector', clean);
    view.cell.once('removed', clean);
  }
}

function createLines(sourcePoint, targetPoint, route) {
  var points = [sourcePoint].concat(Object(toConsumableArray["a" /* default */])(route), [targetPoint]);
  var lines = [];
  points.forEach(function (point, idx) {
    var next = points[idx + 1];

    if (next != null) {
      lines.push(new line_Line(point, next));
    }
  });
  return lines;
}

function findLineIntersections(line, crossCheckLines) {
  var intersections = [];
  crossCheckLines.forEach(function (crossCheckLine) {
    var intersection = line.intersectionWithLine(crossCheckLine);

    if (intersection) {
      intersections.push(intersection);
    }
  });
  return intersections;
}

function getDistence(p1, p2) {
  return new line_Line(p1, p2).squaredLength();
}
/**
 * Split input line into multiple based on intersection points.
 */


function createJumps(line, intersections, jumpSize) {
  return intersections.reduce(function (memo, point, idx) {
    // skipping points that were merged with the previous line
    // to make bigger arc over multiple lines that are close to each other
    if (skippedPoints.includes(point)) {
      return memo;
    } // always grab the last line from buffer and modify it


    var lastLine = memo.pop() || line; // calculate start and end of jump by moving by a given size of jump

    var jumpStart = point_Point.create(point).move(lastLine.start, -jumpSize);
    var jumpEnd = point_Point.create(point).move(lastLine.start, +jumpSize); // now try to look at the next intersection point

    var nextPoint = intersections[idx + 1];

    if (nextPoint != null) {
      var distance = jumpEnd.distance(nextPoint);

      if (distance <= jumpSize) {
        // next point is close enough, move the jump end by this
        // difference and mark the next point to be skipped
        jumpEnd = nextPoint.move(lastLine.start, distance);
        skippedPoints.push(nextPoint);
      }
    } else {
      // this block is inside of `else` as an optimization so the distance is
      // not calculated when we know there are no other intersection points
      var endDistance = jumpStart.distance(lastLine.end); // if the end is too close to possible jump, draw remaining line instead of a jump

      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
        memo.push(lastLine);
        return memo;
      }
    }

    var startDistance = jumpEnd.distance(lastLine.start);

    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
      // if the start of line is too close to jump, draw that line instead of a jump
      memo.push(lastLine);
      return memo;
    } // finally create a jump line


    var jumpLine = new line_Line(jumpStart, jumpEnd); // it's just simple line but with a `isJump` property

    jumppedLines.push(jumpLine);
    memo.push(new line_Line(lastLine.start, jumpStart), jumpLine, new line_Line(jumpEnd, lastLine.end));
    return memo;
  }, []);
}

function buildPath(lines, jumpSize, jumpType, radius) {
  var path = new path_Path();
  var segment; // first move to the start of a first line

  segment = path_Path.createSegment('M', lines[0].start);
  path.appendSegment(segment);
  lines.forEach(function (line, index) {
    if (jumppedLines.includes(line)) {
      var angle;
      var diff;
      var control1;
      var control2;

      if (jumpType === 'arc') {
        // approximates semicircle with 2 curves
        angle = -90; // determine rotation of arc based on difference between points

        diff = line.start.diff(line.end); // make sure the arc always points up (or right)

        var xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;

        if (xAxisRotate) {
          angle += 180;
        }

        var center = line.getCenter();
        var centerLine = new line_Line(center, line.end).rotate(angle, center);
        var halfLine; // first half

        halfLine = new line_Line(line.start, center);
        control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start);
        control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);
        segment = path_Path.createSegment('C', control1, control2, centerLine.end);
        path.appendSegment(segment); // second half

        halfLine = new line_Line(center, line.end);
        control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);
        control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end);
        segment = path_Path.createSegment('C', control1, control2, line.end);
        path.appendSegment(segment);
      } else if (jumpType === 'gap') {
        segment = path_Path.createSegment('M', line.end);
        path.appendSegment(segment);
      } else if (jumpType === 'cubic') {
        // approximates semicircle with 1 curve
        angle = line.start.theta(line.end);
        var xOffset = jumpSize * 0.6;
        var yOffset = jumpSize * 1.35; // determine rotation of arc based on difference between points

        diff = line.start.diff(line.end); // make sure the arc always points up (or right)

        var _xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;

        if (_xAxisRotate) {
          yOffset *= -1;
        }

        control1 = new point_Point(line.start.x + xOffset, line.start.y + yOffset).rotate(angle, line.start);
        control2 = new point_Point(line.end.x - xOffset, line.end.y + yOffset).rotate(angle, line.end);
        segment = path_Path.createSegment('C', control1, control2, line.end);
        path.appendSegment(segment);
      }
    } else {
      var nextLine = lines[index + 1];

      if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {
        segment = path_Path.createSegment('L', line.end);
        path.appendSegment(segment);
      } else {
        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);
      }
    }
  });
  return path;
}

function buildRoundedSegment(offset, path, curr, prev, next) {
  var prevDistance = curr.distance(prev) / 2;
  var nextDistance = curr.distance(next) / 2;
  var startMove = -Math.min(offset, prevDistance);
  var endMove = -Math.min(offset, nextDistance);
  var roundedStart = curr.clone().move(prev, startMove).round();
  var roundedEnd = curr.clone().move(next, endMove).round();
  var control1 = new point_Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);
  var control2 = new point_Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);
  var segment;
  segment = path_Path.createSegment('L', roundedStart);
  path.appendSegment(segment);
  segment = path_Path.createSegment('C', control1, control2, roundedEnd);
  path.appendSegment(segment);
}

var jumppedLines;
var skippedPoints;
var jumpover_jumpover = function jumpover(sourcePoint, targetPoint, routePoints) {
  var _this = this;

  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  jumppedLines = [];
  skippedPoints = [];
  setupUpdating(this);
  var jumpSize = options.size || 5;
  var jumpType = options.type || 'arc';
  var radius = options.radius || 0; // list of connector types not to jump over.

  var ignoreConnectors = options.ignoreConnectors || ['smooth'];
  var graph = this.graph;
  var model = graph.model;
  var allLinks = model.getEdges(); // there is just one link, draw it directly

  if (allLinks.length === 1) {
    return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);
  }

  var edge = this.cell;
  var thisIndex = allLinks.indexOf(edge);
  var defaultConnector = graph.options.connecting.connector || {}; // not all links are meant to be jumped over.

  var edges = allLinks.filter(function (link, idx) {
    var connector = link.getConnector() || defaultConnector; // avoid jumping over links with connector type listed in `ignored connectors`.

    if (ignoreConnectors.includes(connector.name)) {
      return false;
    } // filter out links that are above this one and  have the same connector type
    // otherwise there would double hoops for each intersection


    if (idx > thisIndex) {
      return connector.name !== 'jumpover';
    }

    return true;
  }); // find views for all links

  var linkViews = edges.map(function (edge) {
    return graph.renderer.findViewByCell(edge);
  }); // create lines for this link

  var thisLines = createLines(sourcePoint, targetPoint, routePoints); // create lines for all other links

  var linkLines = linkViews.map(function (linkView) {
    if (linkView == null) {
      return [];
    }

    if (linkView === _this) {
      return thisLines;
    }

    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);
  }); // transform lines for this link by splitting with jump lines at
  // points of intersection with other links

  var jumpingLines = [];
  thisLines.forEach(function (line) {
    // iterate all links and grab the intersections with this line
    // these are then sorted by distance so the line can be split more easily
    var intersections = edges.reduce(function (memo, link, i) {
      // don't intersection with itself
      if (link !== edge) {
        var lineIntersections = findLineIntersections(line, linkLines[i]);
        memo.push.apply(memo, Object(toConsumableArray["a" /* default */])(lineIntersections));
      }

      return memo;
    }, []).sort(function (a, b) {
      return getDistence(line.start, a) - getDistence(line.start, b);
    });

    if (intersections.length > 0) {
      // split the line based on found intersection points
      jumpingLines.push.apply(jumpingLines, Object(toConsumableArray["a" /* default */])(createJumps(line, intersections, jumpSize)));
    } else {
      // without any intersection the line goes uninterrupted
      jumpingLines.push(line);
    }
  });
  var path = buildPath(jumpingLines, jumpSize, jumpType, radius);
  jumppedLines = [];
  skippedPoints = [];
  return options.raw ? path : path.serialize();
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connector/main.js




// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/connector/index.js


var connector_Connector;

(function (Connector) {
  Connector.presets = connector_main_namespaceObject;
  Connector.registry = registry_Registry.create({
    type: 'connector'
  });
  Connector.registry.register(Connector.presets, true);
})(connector_Connector || (connector_Connector = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/registry/index.js







 // connection







 //



var registry_create = registry_Registry.create;
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/model/animation.js




var animation_Animation = /*#__PURE__*/function () {
  function Animation(cell) {
    Object(classCallCheck["a" /* default */])(this, Animation);

    this.cell = cell;
    this.ids = {};
  }

  Object(createClass["a" /* default */])(Animation, [{
    key: "get",
    value: function get() {
      return Object.keys(this.ids);
    }
  }, {
    key: "start",
    value: function start(path, target) {
      var _this = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var delim = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';
      var localOptions = Object.assign({
        delay: 10,
        duration: 100,
        timing: 'linear'
      }, options);
      var timing = Timing.linear;

      if (localOptions.timing != null) {
        if (typeof localOptions.timing === 'string') {
          timing = Timing[localOptions.timing];
        } else {
          timing = localOptions.timing;
        }
      }

      var current = this.cell.getPropByPath(path);
      var interp = localOptions.interp;
      var interpolate;

      if (interp) {
        interpolate = interp(current, target);
      } else if (typeof target === 'object') {
        interpolate = Interp.object(current, target);
      } else if (typeof target === 'number') {
        interpolate = Interp.number(current, target);
      } else if (typeof target === 'string') {
        if (target[0] === '#') {
          interpolate = Interp.color(current, target);
        } else {
          interpolate = Interp.unit(current, target);
        }
      }

      var startTime = 0;
      var pathStr = Array.isArray(path) ? path.join(delim) : path;

      var setter = function setter() {
        var id;
        var val;
        var now = new Date().getTime();

        if (startTime === 0) {
          startTime = now;
        }

        var elaspe = now - startTime;
        var progress = elaspe / localOptions.duration;

        if (progress < 1) {
          _this.ids[pathStr] = id = dom_main_namespaceObject.requestAnimationFrame(setter);
        } else {
          progress = 1;
          delete _this.ids[pathStr];
        }

        val = interpolate(timing(progress));
        options.transitionId = id;

        _this.cell.setPropByPath(Array.isArray(path) ? path : path.split(delim), val);

        if (id == null) {
          _this.cell.notify('transition:end', {
            cell: _this.cell,
            path: pathStr
          });
        }
      };

      var initiator = function initiator(transition) {
        _this.stop(path, delim);

        _this.ids[pathStr] = dom_main_namespaceObject.requestAnimationFrame(transition);

        _this.cell.notify('transition:begin', {
          cell: _this.cell,
          path: pathStr
        });
      };

      return setTimeout(function () {
        initiator(setter);
      }, options.delay);
    }
  }, {
    key: "stop",
    value: function stop(path) {
      var _this2 = this;

      var delim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';
      var paths = Array.isArray(path) ? path : path.split(delim);
      Object.keys(this.ids).filter(function (key) {
        return object_namespaceObject.isEqual(paths, key.split(delim).slice(0, paths.length));
      }).forEach(function (key) {
        dom_main_namespaceObject.cancelAnimationFrame(_this2.ids[key]);
        delete _this2.ids[key];

        _this2.cell.notify('transition:end', {
          cell: _this2.cell,
          path: key
        });
      });
      return this;
    }
  }]);

  return Animation;
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/model/store.js






var store_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



var store_Store = /*#__PURE__*/function (_Basecoat) {
  Object(inherits["a" /* default */])(Store, _Basecoat);

  var _super = Object(createSuper["a" /* default */])(Store);

  function Store() {
    var _this;

    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, Store);

    _this = _super.call(this);
    _this.pending = false;
    _this.changing = false;
    _this.data = {};

    _this.mutate(object_namespaceObject.cloneDeep(data));

    _this.changed = {};
    return _this;
  }

  Object(createClass["a" /* default */])(Store, [{
    key: "mutate",
    value: function mutate(data) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var unset = options.unset === true;
      var silent = options.silent === true;
      var changes = [];
      var changing = this.changing;
      this.changing = true;

      if (!changing) {
        this.previous = object_namespaceObject.cloneDeep(this.data);
        this.changed = {};
      }

      var current = this.data;
      var previous = this.previous;
      var changed = this.changed;
      Object.keys(data).forEach(function (k) {
        var key = k;
        var newValue = data[key];

        if (!object_namespaceObject.isEqual(current[key], newValue)) {
          changes.push(key);
        }

        if (!object_namespaceObject.isEqual(previous[key], newValue)) {
          changed[key] = newValue;
        } else {
          delete changed[key];
        }

        if (unset) {
          delete current[key];
        } else {
          current[key] = newValue;
        }
      });

      if (!silent && changes.length > 0) {
        this.pending = true;
        this.pendingOptions = options;
        changes.forEach(function (key) {
          _this2.emit('change:*', {
            key: key,
            options: options,
            store: _this2,
            current: current[key],
            previous: previous[key]
          });
        });
      }

      if (changing) {
        return this;
      }

      if (!silent) {
        // Changes can be recursively nested within `"change"` events.
        while (this.pending) {
          this.pending = false;
          this.emit('changed', {
            current: current,
            previous: previous,
            store: this,
            options: this.pendingOptions
          });
        }
      }

      this.pending = false;
      this.changing = false;
      this.pendingOptions = null;
      return this;
    }
  }, {
    key: "get",
    value: function get(key, defaultValue) {
      if (key == null) {
        return this.data;
      }

      var ret = this.data[key];
      return ret == null ? defaultValue : ret;
    }
  }, {
    key: "getPrevious",
    value: function getPrevious(key) {
      if (this.previous) {
        var ret = this.previous[key];
        return ret == null ? undefined : ret;
      }

      return undefined;
    }
  }, {
    key: "set",
    value: function set(key, value, options) {
      if (key != null) {
        if (typeof key === 'object') {
          this.mutate(key, value);
        } else {
          this.mutate(Object(defineProperty["a" /* default */])({}, key, value), options);
        }
      }

      return this;
    }
  }, {
    key: "remove",
    value: function remove(key, options) {
      var empty = void 0;
      var subset = {};
      var opts;

      if (typeof key === 'string') {
        subset[key] = empty;
        opts = options;
      } else if (Array.isArray(key)) {
        key.forEach(function (k) {
          return subset[k] = empty;
        });
        opts = options;
      } else {
        for (var _key in this.data) {
          subset[_key] = empty;
        }

        opts = key;
      }

      this.mutate(subset, Object.assign(Object.assign({}, opts), {
        unset: true
      }));
      return this;
    }
  }, {
    key: "getByPath",
    value: function getByPath(path) {
      return object_namespaceObject.getByPath(this.data, path, '/');
    }
  }, {
    key: "setByPath",
    value: function setByPath(path, value) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var delim = '/';
      var pathArray = Array.isArray(path) ? path : path.split(delim);
      var pathString = Array.isArray(path) ? path.join(delim) : path;
      var property = pathArray[0];
      var pathArrayLength = pathArray.length;
      options.propertyPath = pathString;
      options.propertyValue = value;
      options.propertyPathArray = pathArray;

      if (pathArrayLength === 1) {
        this.set(property, value, options);
      } else {
        var update = {};
        var diver = update;
        var nextKey = property; // Initialize the nested object. Subobjects are either arrays or objects.
        // An empty array is created if the sub-key is an integer. Otherwise, an
        // empty object is created.

        for (var i = 1; i < pathArrayLength; i += 1) {
          var key = pathArray[i];
          var isArrayIndex = Number.isFinite(Number(key));
          diver = diver[nextKey] = isArrayIndex ? [] : {};
          nextKey = key;
        } // Fills update with the `value` on `path`.


        object_namespaceObject.setByPath(update, pathArray, value, delim);
        var data = object_namespaceObject.cloneDeep(this.data); // If rewrite mode enabled, we replace value referenced by path with the
        // new one (we don't merge).

        if (options.rewrite) {
          object_namespaceObject.unsetByPath(data, path, delim);
        }

        var merged = object_namespaceObject.merge(data, update);
        this.set(property, merged[property], options);
      }

      return this;
    }
  }, {
    key: "removeByPath",
    value: function removeByPath(path, options) {
      var keys = Array.isArray(path) ? path : path.split('/');
      var key = keys[0];

      if (keys.length === 1) {
        this.remove(key, options);
      } else {
        var paths = keys.slice(1);
        var prop = object_namespaceObject.cloneDeep(this.get(key));

        if (prop) {
          object_namespaceObject.unsetByPath(prop, paths);
        }

        this.set(key, prop, options);
      }

      return this;
    }
  }, {
    key: "hasChanged",
    value: function hasChanged(key) {
      if (key == null) {
        return Object.keys(this.changed).length > 0;
      }

      return key in this.changed;
    }
    /**
     * Returns an object containing all the data that have changed,
     * or `null` if there are no changes. Useful for determining what
     * parts of a view need to be updated.
     */

  }, {
    key: "getChanges",
    value: function getChanges(diff) {
      if (diff == null) {
        return this.hasChanged() ? object_namespaceObject.cloneDeep(this.changed) : null;
      }

      var old = this.changing ? this.previous : this.data;
      var changed = {};
      var hasChanged;

      for (var key in diff) {
        var val = diff[key];

        if (!object_namespaceObject.isEqual(old[key], val)) {
          changed[key] = val;
          hasChanged = true;
        }
      }

      return hasChanged ? object_namespaceObject.cloneDeep(changed) : null;
    }
    /**
     * Returns a copy of the store's `data` object.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      return object_namespaceObject.cloneDeep(this.data);
    }
  }, {
    key: "clone",
    value: function clone() {
      var constructor = this.constructor;
      return new constructor(this.data);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.off();
      this.data = {};
      this.previous = {};
      this.changed = {};
      this.pending = false;
      this.changing = false;
      this.pendingOptions = null;
      this.trigger('disposed', {
        store: this
      });
    }
  }]);

  return Store;
}(basecoat_Basecoat);

store_decorate([basecoat_Basecoat.dispose()], store_Store.prototype, "dispose", null);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/model/cell.js







var cell_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var model_cell_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







var cell_Cell = /*#__PURE__*/function (_Basecoat) {
  Object(inherits["a" /* default */])(Cell, _Basecoat);

  var _super = Object(createSuper["a" /* default */])(Cell);

  function Cell() {
    var _this;

    var metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, Cell);

    _this = _super.call(this);
    var ctor = _this.constructor;
    var defaults = ctor.getDefaults(true);
    var props = object_namespaceObject.merge({}, _this.preprocess(defaults), _this.preprocess(metadata));
    _this.id = props.id || string_namespaceObject.uuid();
    _this.store = new store_Store(props);
    _this.animation = new animation_Animation(Object(assertThisInitialized["a" /* default */])(_this));

    _this.setup();

    _this.init();

    _this.postprocess(metadata);

    return _this;
  }

  Object(createClass["a" /* default */])(Cell, [{
    key: "init",
    value: function init() {} // #region model

  }, {
    key: "preprocess",
    // #endregion
    value: function preprocess(metadata, ignoreIdCheck) {
      var id = metadata.id;
      var ctor = this.constructor;
      var props = ctor.applyPropHooks(this, metadata);

      if (id == null && ignoreIdCheck !== true) {
        props.id = string_namespaceObject.uuid();
      }

      return props;
    }
  }, {
    key: "postprocess",
    value: function postprocess(metadata) {}
  }, {
    key: "setup",
    value: function setup() {
      var _this2 = this;

      this.store.on('change:*', function (metadata) {
        var key = metadata.key,
            current = metadata.current,
            previous = metadata.previous,
            options = metadata.options;

        _this2.notify('change:*', {
          key: key,
          options: options,
          current: current,
          previous: previous,
          cell: _this2
        });

        _this2.notify("change:".concat(key), {
          options: options,
          current: current,
          previous: previous,
          cell: _this2
        });

        var type = key;

        if (type === 'source' || type === 'target') {
          _this2.notify("change:terminal", {
            type: type,
            current: current,
            previous: previous,
            options: options,
            cell: _this2
          });
        }
      });
      this.store.on('changed', function (_ref) {
        var options = _ref.options;
        return _this2.notify('changed', {
          options: options,
          cell: _this2
        });
      });
    }
  }, {
    key: "notify",
    value: function notify(name, args) {
      this.trigger(name, args);
      var model = this.model;

      if (model) {
        model.notify("cell:".concat(name), args);

        if (this.isNode()) {
          model.notify("node:".concat(name), Object.assign(Object.assign({}, args), {
            node: this
          }));
        } else if (this.isEdge()) {
          model.notify("edge:".concat(name), Object.assign(Object.assign({}, args), {
            edge: this
          }));
        }
      }

      return this;
    }
  }, {
    key: "isNode",
    value: function isNode() {
      return false;
    }
  }, {
    key: "isEdge",
    value: function isEdge() {
      return false;
    }
  }, {
    key: "isSameStore",
    value: function isSameStore(cell) {
      return this.store === cell.store;
    }
  }, {
    key: "getProp",
    value: function getProp(key, defaultValue) {
      if (key == null) {
        return this.store.get();
      }

      return this.store.get(key, defaultValue);
    }
  }, {
    key: "setProp",
    value: function setProp(key, value, options) {
      if (typeof key === 'string') {
        this.store.set(key, value, options);
      } else {
        this.store.set(object_namespaceObject.merge({}, this.getProp(), key), value);
      }

      return this;
    }
  }, {
    key: "removeProp",
    value: function removeProp(key, options) {
      this.store.remove(key, options);
      return this;
    }
  }, {
    key: "hasChanged",
    value: function hasChanged(key) {
      return key == null ? this.store.hasChanged() : this.store.hasChanged(key);
    }
  }, {
    key: "getPropByPath",
    value: function getPropByPath(path) {
      return this.store.getByPath(path);
    }
  }, {
    key: "setPropByPath",
    value: function setPropByPath(path, value) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.store.setByPath(path, value, options);
      return this;
    }
  }, {
    key: "removePropByPath",
    value: function removePropByPath(path) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var paths = Array.isArray(path) ? path : path.split('/'); // Once a property is removed from the `attrs` the CellView will
      // recognize a `dirty` flag and re-render itself in order to remove
      // the attribute from SVGElement.

      if (paths[0] === 'attrs') {
        options.dirty = true;
      }

      this.store.removeByPath(paths, options);
      return this;
    }
  }, {
    key: "prop",
    value: function prop(key, value, options) {
      if (key == null) {
        return this.getProp();
      }

      if (typeof key === 'string' || Array.isArray(key)) {
        if (arguments.length === 1) {
          return Array.isArray(key) ? this.getPropByPath(key) : this.getPropByPath(key);
        }

        if (value == null) {
          return Array.isArray(key) ? this.removePropByPath(key) : this.removeAttrByPath(key, options || {});
        }

        return Array.isArray(key) ? this.setPropByPath(key, value, options || {}) : this.setPropByPath(key, value, options || {});
      }

      return this.setProp(key, value || {});
    }
  }, {
    key: "previous",
    value: function previous(name) {
      return this.store.getPrevious(name);
    } // #endregion
    // #region zIndex

  }, {
    key: "getZIndex",
    value: function getZIndex() {
      return this.store.get('zIndex');
    }
  }, {
    key: "setZIndex",
    value: function setZIndex(z) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('zIndex', z, options);
      return this;
    }
  }, {
    key: "removeZIndex",
    value: function removeZIndex() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.store.remove('zIndex', options);
      return this;
    }
  }, {
    key: "toFront",
    value: function toFront() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var model = this.model;

      if (model) {
        var z = model.getMaxZIndex();
        var cells;

        if (options.deep) {
          cells = this.getDescendants({
            deep: true,
            breadthFirst: true
          });
          cells.unshift(this);
        } else {
          cells = [this];
        }

        z = z - cells.length + 1;
        var count = model.total();
        var changed = model.indexOf(this) !== count - cells.length;

        if (!changed) {
          changed = cells.some(function (cell, index) {
            return cell.getZIndex() !== z + index;
          });
        }

        if (changed) {
          this.batchUpdate('to-front', function () {
            z = z + cells.length;
            cells.forEach(function (cell, index) {
              cell.setZIndex(z + index, options);
            });
          });
        }
      }

      return this;
    }
  }, {
    key: "toBack",
    value: function toBack() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var model = this.model;

      if (model) {
        var z = model.getMinZIndex();
        var cells;

        if (options.deep) {
          cells = this.getDescendants({
            deep: true,
            breadthFirst: true
          });
          cells.unshift(this);
        } else {
          cells = [this];
        }

        var changed = model.indexOf(this) !== 0;

        if (!changed) {
          changed = cells.some(function (cell, index) {
            return cell.getZIndex() !== z + index;
          });
        }

        if (changed) {
          this.batchUpdate('to-back', function () {
            z -= cells.length;
            cells.forEach(function (cell, index) {
              cell.setZIndex(z + index, options);
            });
          });
        }
      }

      return this;
    } // #endregion
    // #region markup

  }, {
    key: "getMarkup",
    value: function getMarkup() {
      var markup = this.store.get('markup');

      if (markup == null) {
        var ctor = this.constructor;
        markup = ctor.getMarkup();
      }

      return markup;
    }
  }, {
    key: "setMarkup",
    value: function setMarkup(markup) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('markup', markup, options);
      return this;
    }
  }, {
    key: "removeMarkup",
    value: function removeMarkup() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.store.remove('markup', options);
      return this;
    } // #endregion
    // #region attrs

  }, {
    key: "getAttrs",
    value: function getAttrs() {
      var result = this.store.get('attrs');
      return result ? Object.assign({}, result) : {};
    }
  }, {
    key: "setAttrs",
    value: function setAttrs(attrs) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (attrs == null) {
        this.removeAttrs(options);
      } else {
        var set = function set(attrs) {
          return _this3.store.set('attrs', attrs, options);
        };

        if (options.overwrite === true) {
          set(attrs);
        } else {
          var prev = this.getAttrs();

          if (options.deep === false) {
            set(Object.assign(Object.assign({}, prev), attrs));
          } else {
            set(object_namespaceObject.merge({}, prev, attrs));
          }
        }
      }

      return this;
    }
  }, {
    key: "replaceAttrs",
    value: function replaceAttrs(attrs) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {
        overwrite: true
      }));
    }
  }, {
    key: "updateAttrs",
    value: function updateAttrs(attrs) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {
        deep: false
      }));
    }
  }, {
    key: "removeAttrs",
    value: function removeAttrs() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.store.remove('attrs', options);
      return this;
    }
  }, {
    key: "getAttrDefinition",
    value: function getAttrDefinition(attrName) {
      if (!attrName) {
        return null;
      }

      var ctor = this.constructor;
      var hooks = ctor.getAttrHooks() || {};
      var definition = hooks[attrName] || attr_Attr.registry.get(attrName);

      if (!definition) {
        var name = string_namespaceObject.camelCase(attrName);
        definition = hooks[name] || attr_Attr.registry.get(name);
      }

      return definition || null;
    }
  }, {
    key: "getAttrByPath",
    value: function getAttrByPath(path) {
      if (path == null || path === '') {
        return this.getAttrs();
      }

      return this.getPropByPath(this.prefixAttrPath(path));
    }
  }, {
    key: "setAttrByPath",
    value: function setAttrByPath(path, value) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.setPropByPath(this.prefixAttrPath(path), value, options);
      return this;
    }
  }, {
    key: "removeAttrByPath",
    value: function removeAttrByPath(path) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.removePropByPath(this.prefixAttrPath(path), options);
      return this;
    }
  }, {
    key: "prefixAttrPath",
    value: function prefixAttrPath(path) {
      return Array.isArray(path) ? ['attrs'].concat(path) : "attrs/".concat(path);
    }
  }, {
    key: "attr",
    value: function attr(path, value, options) {
      if (path == null) {
        return this.getAttrByPath();
      }

      if (typeof path === 'string' || Array.isArray(path)) {
        if (arguments.length === 1) {
          return this.getAttrByPath(path);
        }

        if (value == null) {
          return this.removeAttrByPath(path, options || {});
        }

        return this.setAttrByPath(path, value, options || {});
      }

      return this.setAttrs(path, value || {});
    } // #endregion
    // #region visible

  }, {
    key: "setVisible",
    value: function setVisible(visible) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('visible', visible, options);
      return this;
    }
  }, {
    key: "isVisible",
    value: function isVisible() {
      return this.store.get('visible') !== false;
    }
  }, {
    key: "show",
    value: function show() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.isVisible()) {
        this.setVisible(true, options);
      }

      return this;
    }
  }, {
    key: "hide",
    value: function hide() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.isVisible()) {
        this.setVisible(false, options);
      }

      return this;
    }
  }, {
    key: "toggleVisible",
    value: function toggleVisible() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.isVisible()) {
        this.hide(options);
      } else {
        this.show(options);
      }

      return this;
    } // #endregion
    // #region data

  }, {
    key: "getData",
    value: function getData() {
      return this.store.get('data');
    }
  }, {
    key: "setData",
    value: function setData(data) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (data == null) {
        this.removeData(options);
      } else {
        var set = function set(data) {
          return _this4.store.set('data', data, options);
        };

        if (options.overwrite === true) {
          set(data);
        } else {
          var prev = this.getData();

          if (options.deep === false) {
            set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);
          } else {
            set(object_namespaceObject.merge({}, prev, data));
          }
        }
      }

      return this;
    }
  }, {
    key: "replaceData",
    value: function replaceData(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.setData(data, Object.assign(Object.assign({}, options), {
        overwrite: true
      }));
    }
  }, {
    key: "updateData",
    value: function updateData(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.setData(data, Object.assign(Object.assign({}, options), {
        deep: false
      }));
    }
  }, {
    key: "removeData",
    value: function removeData() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.store.remove('data', options);
      return this;
    } // #endregion
    // #region parent children

  }, {
    key: "getParent",
    value: function getParent() {
      var parent = this._parent;

      if (parent == null && this.store) {
        var parentId = this.getParentId();

        if (parentId != null && this.model) {
          parent = this.model.getCell(parentId);
          this._parent = parent;
        }
      }

      return parent;
    }
  }, {
    key: "getParentId",
    value: function getParentId() {
      return this.store.get('parent');
    }
  }, {
    key: "getChildren",
    value: function getChildren() {
      var _this5 = this;

      var children = this._children;

      if (children == null) {
        var childrenIds = this.store.get('children');

        if (childrenIds && childrenIds.length && this.model) {
          children = childrenIds.map(function (id) {
            var _a;

            return (_a = _this5.model) === null || _a === void 0 ? void 0 : _a.getCell(id);
          }).filter(function (cell) {
            return cell != null;
          });
          this._children = children;
        }
      }

      return children ? Object(toConsumableArray["a" /* default */])(children) : null;
    }
  }, {
    key: "hasParent",
    value: function hasParent() {
      return this.parent != null;
    }
  }, {
    key: "isParentOf",
    value: function isParentOf(child) {
      return child != null && child.getParent() === this;
    }
  }, {
    key: "isChildOf",
    value: function isChildOf(parent) {
      return parent != null && this.getParent() === parent;
    }
  }, {
    key: "eachChild",
    value: function eachChild(iterator, context) {
      array_namespaceObject.forEach(this.children, iterator, context);
      return this;
    }
  }, {
    key: "filterChild",
    value: function filterChild(filter, thisArg) {
      return array_namespaceObject.filter(this.children, filter, thisArg);
    }
  }, {
    key: "getChildCount",
    value: function getChildCount() {
      return this.children == null ? 0 : this.children.length;
    }
  }, {
    key: "getChildIndex",
    value: function getChildIndex(child) {
      return this.children == null ? -1 : this.children.indexOf(child);
    }
  }, {
    key: "getChildAt",
    value: function getChildAt(index) {
      return this.children != null && index >= 0 ? this.children[index] : null;
    }
  }, {
    key: "getAncestors",
    value: function getAncestors() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var ancestors = [];
      var parent = this.getParent();

      while (parent) {
        ancestors.push(parent);
        parent = options.deep !== false ? parent.getParent() : null;
      }

      return ancestors;
    }
  }, {
    key: "getDescendants",
    value: function getDescendants() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.deep !== false) {
        // breadth first
        if (options.breadthFirst) {
          var cells = [];
          var queue = this.getChildren() || [];

          while (queue.length > 0) {
            var parent = queue.shift();
            var children = parent.getChildren();
            cells.push(parent);

            if (children) {
              queue.push.apply(queue, Object(toConsumableArray["a" /* default */])(children));
            }
          }

          return cells;
        } // depth first


        {
          var _cells = this.getChildren() || [];

          _cells.forEach(function (cell) {
            _cells.push.apply(_cells, Object(toConsumableArray["a" /* default */])(cell.getDescendants(options)));
          });

          return _cells;
        }
      }

      return this.getChildren() || [];
    }
  }, {
    key: "isDescendantOf",
    value: function isDescendantOf(ancestor) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (ancestor == null) {
        return false;
      }

      if (options.deep !== false) {
        var current = this.getParent();

        while (current) {
          if (current === ancestor) {
            return true;
          }

          current = current.getParent();
        }

        return false;
      }

      return this.isChildOf(ancestor);
    }
  }, {
    key: "isAncestorOf",
    value: function isAncestorOf(descendant) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (descendant == null) {
        return false;
      }

      return descendant.isDescendantOf(this, options);
    }
  }, {
    key: "contains",
    value: function contains(cell) {
      return this.isAncestorOf(cell);
    }
  }, {
    key: "getCommonAncestor",
    value: function getCommonAncestor() {
      for (var _len = arguments.length, cells = new Array(_len), _key = 0; _key < _len; _key++) {
        cells[_key] = arguments[_key];
      }

      return Cell.getCommonAncestor.apply(Cell, [this].concat(cells));
    }
  }, {
    key: "setParent",
    value: function setParent(parent) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this._parent = parent;

      if (parent) {
        this.store.set('parent', parent.id, options);
      } else {
        this.store.remove('parent', options);
      }

      return this;
    }
  }, {
    key: "setChildren",
    value: function setChildren(children) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this._children = children;

      if (children != null) {
        this.store.set('children', children.map(function (child) {
          return child.id;
        }), options);
      } else {
        this.store.remove('children', options);
      }

      return this;
    }
  }, {
    key: "unembed",
    value: function unembed(child) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var children = this.children;

      if (children != null && child != null) {
        var index = this.getChildIndex(child);
        children.splice(index, 1);
        child.setParent(null, options);
        this.setChildren(children, options);
      }

      return this;
    }
  }, {
    key: "embed",
    value: function embed(child) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      child.addTo(this, options);
      return this;
    }
  }, {
    key: "addTo",
    value: function addTo(target) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (target instanceof Cell) {
        target.addChild(this, options);
      } else {
        target.addCell(this, options);
      }

      return this;
    }
  }, {
    key: "insertTo",
    value: function insertTo(parent, index) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      parent.insertChild(this, index, options);
      return this;
    }
  }, {
    key: "addChild",
    value: function addChild(child) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.insertChild(child, undefined, options);
    }
  }, {
    key: "insertChild",
    value: function insertChild(child, index) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (child != null && child !== this) {
        var oldParent = child.getParent();
        var changed = this !== oldParent;
        var pos = index;

        if (pos == null) {
          pos = this.getChildCount();

          if (!changed) {
            pos -= 1;
          }
        } // remove from old parent


        if (oldParent) {
          var _children = oldParent.getChildren();

          if (_children) {
            var _index = _children.indexOf(child);

            if (_index >= 0) {
              child.setParent(null, options);

              _children.splice(_index, 1);

              oldParent.setChildren(_children, options);
            }
          }
        }

        var children = this.children;

        if (children == null) {
          children = [];
          children.push(child);
        } else {
          children.splice(pos, 0, child);
        }

        child.setParent(this, options);
        this.setChildren(children, options);

        if (changed) {
          if (this.incomings) {
            this.incomings.forEach(function (edge) {
              return edge.updateParent(options);
            });
          }

          if (this.outgoings) {
            this.outgoings.forEach(function (edge) {
              return edge.updateParent(options);
            });
          }
        }

        if (this.model) {
          this.model.addCell(child, options);
        }
      }

      return this;
    }
  }, {
    key: "removeFromParent",
    value: function removeFromParent() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var parent = this.getParent();

      if (parent != null) {
        var index = parent.getChildIndex(this);
        parent.removeChildAt(index, options);
      }

      return this;
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var index = this.getChildIndex(child);
      return this.removeChildAt(index, options);
    }
  }, {
    key: "removeChildAt",
    value: function removeChildAt(index) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var child = this.getChildAt(index);
      var children = this.children;

      if (children != null && child != null) {
        this.unembed(child, options);
        child.remove(options);
      }

      return child;
    }
  }, {
    key: "remove",
    value: function remove() {
      var _this6 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var parent = this.getParent();

      if (parent) {
        parent.removeChild(this, options);
      } else {
        this.batchUpdate('remove', function () {
          if (options.deep !== false) {
            _this6.eachChild(function (child) {
              return child.remove(options);
            });
          }

          if (_this6.model) {
            _this6.model.removeCell(_this6, options);
          }
        });
      }

      return this;
    } // #endregion
    // #region terminal

  }, {
    key: "getOutgoingEdges",
    value: function getOutgoingEdges() {
      return this.outgoings;
    }
  }, {
    key: "getIncomingEdges",
    value: function getIncomingEdges() {
      return this.incomings;
    }
  }, {
    key: "transition",
    value: function transition(path, target) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var delim = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';
      return this.animation.start(path, target, options, delim);
    }
  }, {
    key: "stopTransition",
    value: function stopTransition(path) {
      var delim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';
      this.animation.stop(path, delim);
      return this;
    }
  }, {
    key: "getTransitions",
    value: function getTransitions() {
      return this.animation.get();
    } // #endregion
    // #region transform

  }, {
    key: "translate",
    value: function translate(tx, ty, options) {
      return this;
    }
  }, {
    key: "scale",
    value: function scale(sx, sy, origin, options) {
      return this;
    } // #endregion
    // #region common

  }, {
    key: "getBBox",
    value: function getBBox(options) {
      return new rectangle_Rectangle();
    }
  }, {
    key: "getConnectionPoint",
    value: function getConnectionPoint(edge, type) {
      return new point_Point();
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _this7 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var props = Object.assign({}, this.store.get());
      var toString = Object.prototype.toString;
      var cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';

      if (!props.shape) {
        var _ctor = this.constructor;
        throw new Error("Unable to serialize ".concat(cellType, " missing \"shape\" prop, check the ").concat(cellType, " \"").concat(_ctor.name || toString.call(_ctor), "\""));
      }

      var ctor = this.constructor;
      var diff = options.diff === true;
      var attrs = props.attrs || {};
      var presets = ctor.getDefaults(true); // When `options.diff` is `true`, we should process the custom options,
      // such as `width`, `height` etc. to ensure the comparing work correctly.

      var defaults = diff ? this.preprocess(presets, true) : presets;
      var defaultAttrs = defaults.attrs || {};
      var finalAttrs = {};
      Object.keys(props).forEach(function (key) {
        var val = props[key];

        if (!Array.isArray(val) && typeof val === 'object' && !object_namespaceObject.isPlainObject(val)) {
          throw new Error("Can only serialize ".concat(cellType, " with plain-object props, but got a \"").concat(toString.call(val), "\" type of key \"").concat(key, "\" on ").concat(cellType, " \"").concat(_this7.id, "\""));
        }

        if (key !== 'attrs' && key !== 'shape' && diff) {
          var preset = defaults[key];

          if (object_namespaceObject.isEqual(val, preset)) {
            delete props[key];
          }
        }
      });
      Object.keys(attrs).forEach(function (key) {
        var attr = attrs[key];
        var defaultAttr = defaultAttrs[key];
        Object.keys(attr).forEach(function (name) {
          var value = attr[name];
          var defaultValue = defaultAttr ? defaultAttr[name] : null;

          if (value != null && typeof value === 'object' && !Array.isArray(value)) {
            Object.keys(value).forEach(function (subName) {
              var subValue = value[subName];

              if (defaultAttr == null || defaultValue == null || !object_namespaceObject.isObject(defaultValue) || !object_namespaceObject.isEqual(defaultValue[subName], subValue)) {
                if (finalAttrs[key] == null) {
                  finalAttrs[key] = {};
                }

                if (finalAttrs[key][name] == null) {
                  finalAttrs[key][name] = {};
                }

                var tmp = finalAttrs[key][name];
                tmp[subName] = subValue;
              }
            });
          } else if (defaultAttr == null || !object_namespaceObject.isEqual(defaultValue, value)) {
            // `value` is not an object, default attribute with `key` does not
            // exist or it is different than the attribute value set on the cell.
            if (finalAttrs[key] == null) {
              finalAttrs[key] = {};
            }

            finalAttrs[key][name] = value;
          }
        });
      });
      var finalProps = Object.assign(Object.assign({}, props), {
        attrs: object_namespaceObject.isEmpty(finalAttrs) ? undefined : finalAttrs
      });

      if (finalProps.attrs == null) {
        delete finalProps.attrs;
      }

      var ret = finalProps;

      if (ret.angle === 0) {
        delete ret.angle;
      }

      return object_namespaceObject.cloneDeep(ret);
    }
  }, {
    key: "clone",
    value: function clone() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!options.deep) {
        var data = Object.assign({}, this.store.get());
        delete data.id;
        delete data.parent;
        delete data.children;
        var ctor = this.constructor;
        return new ctor(data);
      } // Deep cloning. Clone the cell itself and all its children.


      var map = Cell.deepClone(this);
      return map[this.id];
    }
  }, {
    key: "findView",
    value: function findView(graph) {
      return graph.renderer.findViewByCell(this);
    } // #endregion
    // #region batch

  }, {
    key: "startBatch",
    value: function startBatch(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var model = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.model;

      if (model) {
        model.startBatch(name, Object.assign(Object.assign({}, data), {
          cell: this
        }));
      }

      return this;
    }
  }, {
    key: "stopBatch",
    value: function stopBatch(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var model = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.model;

      if (model) {
        model.stopBatch(name, Object.assign(Object.assign({}, data), {
          cell: this
        }));
      }

      return this;
    }
  }, {
    key: "batchUpdate",
    value: function batchUpdate(name, execute, data) {
      // The model is null after cell was removed(remove batch).
      // So we should temp save model to trigger pairing batch event.
      var model = this.model;
      this.startBatch(name, data, model);
      var result = execute();
      this.stopBatch(name, data, model);
      return result;
    } // #endregion
    // #region IDisposable

  }, {
    key: "dispose",
    value: function dispose() {
      this.removeFromParent();
      this.store.dispose();
    }
  }, {
    key: "model",
    get: function get() {
      return this._model;
    },
    set: function set(model) {
      if (this._model !== model) {
        this._model = model;
      }
    }
  }, {
    key: "view",
    get: function get() {
      return this.store.get('view');
    }
  }, {
    key: "shape",
    get: function get() {
      return this.store.get('shape', '');
    }
  }, {
    key: "zIndex",
    get: function get() {
      return this.getZIndex();
    },
    set: function set(z) {
      if (z == null) {
        this.removeZIndex();
      } else {
        this.setZIndex(z);
      }
    }
  }, {
    key: "markup",
    get: function get() {
      return this.getMarkup();
    },
    set: function set(value) {
      if (value == null) {
        this.removeMarkup();
      } else {
        this.setMarkup(value);
      }
    }
  }, {
    key: "attrs",
    get: function get() {
      return this.getAttrs();
    },
    set: function set(value) {
      if (value == null) {
        this.removeAttrs();
      } else {
        this.setAttrs(value);
      }
    }
  }, {
    key: "visible",
    get: function get() {
      return this.isVisible();
    },
    set: function set(value) {
      this.setVisible(value);
    }
  }, {
    key: "data",
    get: function get() {
      return this.getData();
    },
    set: function set(val) {
      this.setData(val);
    }
  }, {
    key: "parent",
    get: function get() {
      return this.getParent();
    }
  }, {
    key: "children",
    get: function get() {
      return this.getChildren();
    }
  }], [{
    key: "config",
    value: function config(presets) {
      var _this8 = this;

      var markup = presets.markup,
          propHooks = presets.propHooks,
          attrHooks = presets.attrHooks,
          others = model_cell_rest(presets, ["markup", "propHooks", "attrHooks"]);

      if (markup != null) {
        this.markup = markup;
      }

      if (propHooks) {
        this.propHooks = this.propHooks.slice();

        if (Array.isArray(propHooks)) {
          var _this$propHooks;

          (_this$propHooks = this.propHooks).push.apply(_this$propHooks, Object(toConsumableArray["a" /* default */])(propHooks));
        } else if (typeof propHooks === 'function') {
          this.propHooks.push(propHooks);
        } else {
          Object.keys(propHooks).forEach(function (name) {
            var hook = propHooks[name];

            if (typeof hook === 'function') {
              _this8.propHooks.push(hook);
            }
          });
        }
      }

      if (attrHooks) {
        this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);
      }

      this.defaults = object_namespaceObject.merge({}, this.defaults, others);
    }
  }, {
    key: "getMarkup",
    value: function getMarkup() {
      return this.markup;
    }
  }, {
    key: "getDefaults",
    value: function getDefaults(raw) {
      return raw ? this.defaults : object_namespaceObject.cloneDeep(this.defaults);
    }
  }, {
    key: "getAttrHooks",
    value: function getAttrHooks() {
      return this.attrHooks;
    }
  }, {
    key: "applyPropHooks",
    value: function applyPropHooks(cell, metadata) {
      return this.propHooks.reduce(function (memo, hook) {
        return hook ? main_namespaceObject.call(hook, cell, memo) : memo;
      }, metadata);
    }
  }]);

  return Cell;
}(basecoat_Basecoat);
cell_Cell.defaults = {};
cell_Cell.attrHooks = {};
cell_Cell.propHooks = [];

cell_decorate([basecoat_Basecoat.dispose()], cell_Cell.prototype, "dispose", null);

(function (Cell) {
  function getCommonAncestor() {
    for (var _len2 = arguments.length, cells = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      cells[_key2] = arguments[_key2];
    }

    var ancestors = cells.filter(function (cell) {
      return cell != null;
    }).map(function (cell) {
      return cell.getAncestors();
    }).sort(function (a, b) {
      return a.length - b.length;
    });
    var first = ancestors.shift();
    return first.find(function (cell) {
      return ancestors.every(function (item) {
        return item.includes(cell);
      });
    }) || null;
  }

  Cell.getCommonAncestor = getCommonAncestor;

  function getCellsBBox(cells) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var bbox = null;

    for (var i = 0, ii = cells.length; i < ii; i += 1) {
      var cell = cells[i];
      var rect = cell.getBBox(options);

      if (rect) {
        if (cell.isNode()) {
          var angle = cell.getAngle();

          if (angle != null && angle !== 0) {
            rect = rect.bbox(angle);
          }
        }

        bbox = bbox == null ? rect : bbox.union(rect);
      }
    }

    return bbox;
  }

  Cell.getCellsBBox = getCellsBBox;

  function deepClone(cell) {
    var cells = [cell].concat(Object(toConsumableArray["a" /* default */])(cell.getDescendants({
      deep: true
    })));
    return Cell.cloneCells(cells);
  }

  Cell.deepClone = deepClone;

  function cloneCells(cells) {
    var inputs = array_namespaceObject.uniq(cells);
    var cloneMap = inputs.reduce(function (map, cell) {
      map[cell.id] = cell.clone();
      return map;
    }, {});
    inputs.forEach(function (cell) {
      var clone = cloneMap[cell.id];

      if (clone.isEdge()) {
        var sourceId = clone.getSourceCellId();
        var targetId = clone.getTargetCellId();

        if (sourceId && cloneMap[sourceId]) {
          // Source is a node and the node is among the clones.
          // Then update the source of the cloned edge.
          clone.setSource(Object.assign(Object.assign({}, clone.getSource()), {
            cell: cloneMap[sourceId].id
          }));
        }

        if (targetId && cloneMap[targetId]) {
          // Target is a node and the node is among the clones.
          // Then update the target of the cloned edge.
          clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), {
            cell: cloneMap[targetId].id
          }));
        }
      } // Find the parent of the original cell


      var parent = cell.getParent();

      if (parent && cloneMap[parent.id]) {
        clone.setParent(cloneMap[parent.id]);
      } // Find the children of the original cell


      var children = cell.getChildren();

      if (children && children.length) {
        var embeds = children.reduce(function (memo, child) {
          // Embedded cells that are not being cloned can not be carried
          // over with other embedded cells.
          if (cloneMap[child.id]) {
            memo.push(cloneMap[child.id]);
          }

          return memo;
        }, []);

        if (embeds.length > 0) {
          clone.setChildren(embeds);
        }
      }
    });
    return cloneMap;
  }

  Cell.cloneCells = cloneCells;
})(cell_Cell || (cell_Cell = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/model/registry.js
var ShareRegistry;

(function (ShareRegistry) {
  var edgeRegistry;
  var nodeRegistry;

  function exist(name, isNode) {
    return isNode ? edgeRegistry != null && edgeRegistry.exist(name) : nodeRegistry != null && nodeRegistry.exist(name);
  }

  ShareRegistry.exist = exist;

  function setEdgeRegistry(registry) {
    edgeRegistry = registry;
  }

  ShareRegistry.setEdgeRegistry = setEdgeRegistry;

  function setNodeRegistry(registry) {
    nodeRegistry = registry;
  }

  ShareRegistry.setNodeRegistry = setNodeRegistry;
})(ShareRegistry || (ShareRegistry = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/model/port.js





var port_PortManager = /*#__PURE__*/function () {
  function PortManager(data) {
    Object(classCallCheck["a" /* default */])(this, PortManager);

    this.ports = [];
    this.groups = {};
    this.init(object_namespaceObject.cloneDeep(data));
  }

  Object(createClass["a" /* default */])(PortManager, [{
    key: "getPorts",
    value: function getPorts() {
      return this.ports;
    }
  }, {
    key: "getGroup",
    value: function getGroup(groupName) {
      return groupName != null ? this.groups[groupName] : null;
    }
  }, {
    key: "getPortsByGroup",
    value: function getPortsByGroup(groupName) {
      return this.ports.filter(function (p) {
        return p.group === groupName || p.group == null && groupName == null;
      });
    }
  }, {
    key: "getPortsLayoutByGroup",
    value: function getPortsLayoutByGroup(groupName, elemBBox) {
      var _this = this;

      var ports = this.getPortsByGroup(groupName);
      var group = groupName ? this.getGroup(groupName) : null;
      var groupPosition = group ? group.position : null;
      var groupPositionName = groupPosition ? groupPosition.name : null;
      var layoutFn;

      if (groupPositionName != null) {
        var fn = port_layout_PortLayout.registry.get(groupPositionName);

        if (fn == null) {
          return port_layout_PortLayout.registry.onNotFound(groupPositionName);
        }

        layoutFn = fn;
      } else {
        layoutFn = port_layout_PortLayout.presets.left;
      }

      var portsArgs = ports.map(function (port) {
        return port && port.position && port.position.args || {};
      });
      var groupArgs = groupPosition && groupPosition.args || {};
      var layouts = layoutFn(portsArgs, elemBBox, groupArgs);
      return layouts.map(function (portLayout, index) {
        var port = ports[index];
        return {
          portLayout: portLayout,
          portId: port.id,
          portSize: port.size,
          portAttrs: port.attrs,
          labelSize: port.label.size,
          labelLayout: _this.getPortLabelLayout(port, point_Point.create(portLayout.position), elemBBox)
        };
      });
    }
  }, {
    key: "init",
    value: function init(data) {
      var _this2 = this;

      var groups = data.groups,
          items = data.items;

      if (groups != null) {
        Object.keys(groups).forEach(function (key) {
          _this2.groups[key] = _this2.parseGroup(groups[key]);
        });
      }

      if (Array.isArray(items)) {
        items.forEach(function (item) {
          _this2.ports.push(_this2.parsePort(item));
        });
      }
    }
  }, {
    key: "parseGroup",
    value: function parseGroup(group) {
      return Object.assign(Object.assign({}, group), {
        label: this.getLabel(group, true),
        position: this.getPortPosition(group.position, true)
      });
    }
  }, {
    key: "parsePort",
    value: function parsePort(port) {
      var result = Object.assign({}, port);
      var group = this.getGroup(port.group) || {};
      result.markup = result.markup || group.markup;
      result.attrs = object_namespaceObject.merge({}, group.attrs, result.attrs);
      result.position = this.createPosition(group, result);
      result.label = object_namespaceObject.merge({}, group.label, this.getLabel(result));
      result.zIndex = this.getZIndex(group, result);
      result.size = Object.assign({}, group.size, result.size);
      return result;
    }
  }, {
    key: "getZIndex",
    value: function getZIndex(group, port) {
      if (typeof port.zIndex === 'number') {
        return port.zIndex;
      }

      if (typeof group.zIndex === 'number' || group.zIndex === 'auto') {
        return group.zIndex;
      }

      return 'auto';
    }
  }, {
    key: "createPosition",
    value: function createPosition(group, port) {
      return object_namespaceObject.merge({
        name: 'left',
        args: {}
      }, group.position, {
        args: port.args
      });
    }
  }, {
    key: "getPortPosition",
    value: function getPortPosition(position) {
      var setDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (position == null) {
        if (setDefault) {
          return {
            name: 'left',
            args: {}
          };
        }
      } else {
        if (typeof position === 'string') {
          return {
            name: position,
            args: {}
          };
        }

        if (Array.isArray(position)) {
          return {
            name: 'absolute',
            args: {
              x: position[0],
              y: position[1]
            }
          };
        }

        if (typeof position === 'object') {
          return position;
        }
      }

      return {
        args: {}
      };
    }
  }, {
    key: "getPortLabelPosition",
    value: function getPortLabelPosition(position) {
      var setDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (position == null) {
        if (setDefault) {
          return {
            name: 'left',
            args: {}
          };
        }
      } else {
        if (typeof position === 'string') {
          return {
            name: position,
            args: {}
          };
        }

        if (typeof position === 'object') {
          return position;
        }
      }

      return {
        args: {}
      };
    }
  }, {
    key: "getLabel",
    value: function getLabel(item) {
      var setDefaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var label = item.label || {};
      label.position = this.getPortLabelPosition(label.position, setDefaults);
      return label;
    }
  }, {
    key: "getPortLabelLayout",
    value: function getPortLabelLayout(port, portPosition, elemBBox) {
      var name = port.label.position.name || 'left';
      var args = port.label.position.args || {};
      var layoutFn = port_label_layout_PortLabelLayout.registry.get(name) || port_label_layout_PortLabelLayout.presets.left;

      if (layoutFn) {
        return layoutFn(portPosition, elemBBox, args);
      }

      return null;
    }
  }]);

  return PortManager;
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/model/node.js








var node_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};









var node_Node = /*#__PURE__*/function (_Cell) {
  Object(inherits["a" /* default */])(Node, _Cell);

  var _super = Object(createSuper["a" /* default */])(Node);

  function Node() {
    var _this;

    var metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, Node);

    _this = _super.call(this, metadata);

    _this.initPorts();

    return _this;
  }

  Object(createClass["a" /* default */])(Node, [{
    key: "preprocess",
    value: function preprocess(metadata, ignoreIdCheck) {
      var x = metadata.x,
          y = metadata.y,
          width = metadata.width,
          height = metadata.height,
          others = node_rest(metadata, ["x", "y", "width", "height"]);

      if (x != null || y != null) {
        var position = others.position;
        others.position = Object.assign(Object.assign({}, position), {
          x: x != null ? x : position ? position.x : 0,
          y: y != null ? y : position ? position.y : 0
        });
      }

      if (width != null || height != null) {
        var size = others.size;
        others.size = Object.assign(Object.assign({}, size), {
          width: width != null ? width : size ? size.width : 0,
          height: height != null ? height : size ? size.height : 0
        });
      }

      return Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(Node.prototype), "preprocess", this).call(this, others, ignoreIdCheck);
    }
  }, {
    key: "isNode",
    value: function isNode() {
      return true;
    }
  }, {
    key: "size",
    value: function size(width, height, options) {
      if (width === undefined) {
        return this.getSize();
      }

      if (typeof width === 'number') {
        return this.setSize(width, height, options);
      }

      return this.setSize(width, height);
    }
  }, {
    key: "getSize",
    value: function getSize() {
      var size = this.store.get('size');
      return size ? Object.assign({}, size) : {
        width: 1,
        height: 1
      };
    }
  }, {
    key: "setSize",
    value: function setSize(width, height, options) {
      if (typeof width === 'object') {
        this.resize(width.width, width.height, height);
      } else {
        this.resize(width, height, options);
      }

      return this;
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.startBatch('resize', options);
      var direction = options.direction;

      if (direction) {
        var currentSize = this.getSize();

        switch (direction) {
          case 'left':
          case 'right':
            // Don't change height when resizing horizontally.
            height = currentSize.height; // tslint:disable-line

            break;

          case 'top':
          case 'bottom':
            // Don't change width when resizing vertically.
            width = currentSize.width; // tslint:disable-line

            break;
        }

        var map = {
          right: 0,
          'top-right': 0,
          top: 1,
          'top-left': 1,
          left: 2,
          'bottom-left': 2,
          bottom: 3,
          'bottom-right': 3
        };
        var quadrant = map[direction];
        var angle = Angle.normalize(this.getAngle() || 0);

        if (options.absolute) {
          // We are taking the node's rotation into account
          quadrant += Math.floor((angle + 45) / 90);
          quadrant %= 4;
        } // This is a rectangle in size of the un-rotated node.


        var bbox = this.getBBox(); // Pick the corner point on the node, which meant to stay on its
        // place before and after the rotation.

        var fixedPoint;

        if (quadrant === 0) {
          fixedPoint = bbox.getBottomLeft();
        } else if (quadrant === 1) {
          fixedPoint = bbox.getCorner();
        } else if (quadrant === 2) {
          fixedPoint = bbox.getTopRight();
        } else {
          fixedPoint = bbox.getOrigin();
        } // Find an image of the previous indent point. This is the position,
        // where is the point actually located on the screen.


        var imageFixedPoint = fixedPoint.clone().rotate(-angle, bbox.getCenter()); // Every point on the element rotates around a circle with the centre of
        // rotation in the middle of the element while the whole element is being
        // rotated. That means that the distance from a point in the corner of
        // the element (supposed its always rect) to the center of the element
        // doesn't change during the rotation and therefore it equals to a
        // distance on un-rotated element.
        // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.

        var radius = Math.sqrt(width * width + height * height) / 2; // Now we are looking for an angle between x-axis and the line starting
        // at image of fixed point and ending at the center of the element.
        // We call this angle `alpha`.
        // The image of a fixed point is located in n-th quadrant. For each
        // quadrant passed going anti-clockwise we have to add 90 degrees.
        // Note that the first quadrant has index 0.
        //
        // 3 | 2
        // --c-- Quadrant positions around the element's center `c`
        // 0 | 1
        //

        var alpha = quadrant * Math.PI / 2; // Add an angle between the beginning of the current quadrant (line
        // parallel with x-axis or y-axis going through the center of the
        // element) and line crossing the indent of the fixed point and the
        // center of the element. This is the angle we need but on the
        // un-rotated element.

        alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height); // Lastly we have to deduct the original angle the element was rotated
        // by and that's it.

        alpha -= Angle.toRad(angle); // With this angle and distance we can easily calculate the centre of
        // the un-rotated element.
        // Note that fromPolar constructor accepts an angle in radians.

        var center = point_Point.fromPolar(radius, alpha, imageFixedPoint); // The top left corner on the un-rotated element has to be half a width
        // on the left and half a height to the top from the center. This will
        // be the origin of rectangle we were looking for.

        var origin = center.clone().translate(width / -2, height / -2);
        this.store.set('size', {
          width: width,
          height: height
        }, options);
        this.setPosition(origin.x, origin.y, options);
      } else {
        this.store.set('size', {
          width: width,
          height: height
        }, options);
      }

      this.stopBatch('resize', options);
      return this;
    }
  }, {
    key: "scale",
    value: function scale(sx, sy, origin) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);
      this.startBatch('scale', options);
      this.setPosition(scaledBBox.x, scaledBBox.y, options);
      this.resize(scaledBBox.width, scaledBBox.height, options);
      this.stopBatch('scale');
      return this;
    }
  }, {
    key: "position",
    value: function position(arg0, arg1, arg2) {
      if (typeof arg0 === 'number') {
        return this.setPosition(arg0, arg1, arg2);
      }

      return this.getPosition(arg0);
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.relative) {
        var parent = this.getParent();

        if (parent != null && parent.isNode()) {
          var currentPosition = this.getPosition();
          var parentPosition = parent.getPosition();
          return {
            x: currentPosition.x - parentPosition.x,
            y: currentPosition.y - parentPosition.y
          };
        }
      }

      var pos = this.store.get('position');
      return pos ? Object.assign({}, pos) : {
        x: 0,
        y: 0
      };
    }
  }, {
    key: "setPosition",
    value: function setPosition(arg0, arg1) {
      var arg2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var x;
      var y;
      var options;

      if (typeof arg0 === 'object') {
        x = arg0.x;
        y = arg0.y;
        options = arg1 || {};
      } else {
        x = arg0;
        y = arg1;
        options = arg2 || {};
      }

      if (options.relative) {
        var parent = this.getParent();

        if (parent != null && parent.isNode()) {
          var parentPosition = parent.getPosition();
          x += parentPosition.x;
          y += parentPosition.y;
        }
      }

      if (options.deep) {
        var currentPosition = this.getPosition();
        this.translate(x - currentPosition.x, y - currentPosition.y, options);
      } else {
        this.store.set('position', {
          x: x,
          y: y
        }, options);
      }

      return this;
    }
  }, {
    key: "translate",
    value: function translate() {
      var tx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (tx === 0 && ty === 0) {
        return this;
      } // Pass the initiator of the translation.


      options.translateBy = options.translateBy || this.id;
      var position = this.getPosition();

      if (options.restrict != null && options.translateBy === this.id) {
        // We are restricting the translation for the element itself only. We get
        // the bounding box of the element including all its embeds.
        // All embeds have to be translated the exact same way as the element.
        var bbox = this.getBBox({
          deep: true
        });
        var ra = options.restrict; // - - - - - - - - - - - - -> ra.x + ra.width
        // - - - -> position.x      |
        // -> bbox.x
        //                   |
        //         
        //                 |
        //   
        //                  |
        //   <-dx->                     | restricted area right border
        //         <-width->        |    translated element
        //   <- - bbox.width - ->        embedded element

        var dx = position.x - bbox.x;
        var dy = position.y - bbox.y; // Find the maximal/minimal coordinates that the element can be translated
        // while complies the restrictions.

        var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));
        var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty)); // recalculate the translation taking the restrictions into account.

        tx = x - position.x; // tslint:disable-line

        ty = y - position.y; // tslint:disable-line
      }

      var translatedPosition = {
        x: position.x + tx,
        y: position.y + ty
      }; // To find out by how much an element was translated in event
      // 'change:position' handlers.

      options.tx = tx;
      options.ty = ty;

      if (options.transition) {
        if (typeof options.transition !== 'object') {
          options.transition = {};
        }

        this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), {
          interp: Interp.object
        }));
        this.eachChild(function (child) {
          return child.translate(tx, ty, options);
        });
      } else {
        this.startBatch('translate', options);
        this.store.set('position', translatedPosition, options);
        this.eachChild(function (child) {
          return child.translate(tx, ty, options);
        });
        this.stopBatch('translate', options);
      }

      return this;
    }
  }, {
    key: "angle",
    value: function angle(val, options) {
      if (val == null) {
        return this.getAngle();
      }

      return this.rotate(val);
    }
  }, {
    key: "getAngle",
    value: function getAngle() {
      return this.store.get('angle', 0);
    }
  }, {
    key: "rotate",
    value: function rotate(angle) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var currentAngle = this.getAngle();

      if (options.center) {
        var size = this.getSize();
        var position = this.getPosition();
        var center = this.getBBox().getCenter();
        center.rotate(currentAngle - angle, options.center);
        var dx = center.x - size.width / 2 - position.x;
        var dy = center.y - size.height / 2 - position.y;
        this.startBatch('rotate', {
          angle: angle,
          options: options
        });
        this.setPosition(position.x + dx, position.y + dy, options);
        this.rotate(angle, Object.assign(Object.assign({}, options), {
          center: null
        }));
        this.stopBatch('rotate');
      } else {
        this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);
      }

      return this;
    } // #endregion
    // #region common

  }, {
    key: "getBBox",
    value: function getBBox() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.deep) {
        var cells = this.getDescendants({
          deep: true,
          breadthFirst: true
        });
        cells.push(this);
        return cell_Cell.getCellsBBox(cells);
      }

      return rectangle_Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());
    }
  }, {
    key: "getConnectionPoint",
    value: function getConnectionPoint(edge, type) {
      var bbox = this.getBBox();
      var center = bbox.getCenter();
      var terminal = edge.getTerminal(type);

      if (terminal == null) {
        return center;
      }

      var portId = terminal.port;

      if (!portId || !this.hasPort(portId)) {
        return center;
      }

      var port = this.getPort(portId);

      if (!port || !port.group) {
        return center;
      }

      var layouts = this.getPortsPosition(port.group);
      var position = layouts[portId].position;
      var portCenter = point_Point.create(position).translate(bbox.getOrigin());
      var angle = this.getAngle();

      if (angle) {
        portCenter.rotate(-angle, center);
      }

      return portCenter;
    }
    /**
     * Sets cell's size and position based on the children bbox and given padding.
     */

  }, {
    key: "fit",
    value: function fit() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var children = this.getChildren() || [];
      var embeds = children.filter(function (cell) {
        return cell.isNode();
      });

      if (embeds.length === 0) {
        return this;
      }

      this.startBatch('fit-embeds', options);

      if (options.deep) {
        embeds.forEach(function (cell) {
          return cell.fit(options);
        });
      }

      var _Cell$getCellsBBox = cell_Cell.getCellsBBox(embeds),
          x = _Cell$getCellsBBox.x,
          y = _Cell$getCellsBBox.y,
          width = _Cell$getCellsBBox.width,
          height = _Cell$getCellsBBox.height;

      var padding = number_namespaceObject.normalizeSides(options.padding);
      x -= padding.left;
      y -= padding.top;
      width += padding.left + padding.right;
      height += padding.bottom + padding.top;
      this.store.set({
        position: {
          x: x,
          y: y
        },
        size: {
          width: width,
          height: height
        }
      }, options);
      this.stopBatch('fit-embeds');
      return this;
    } // #endregion
    // #region ports

  }, {
    key: "getDefaultPortContainerMarkup",
    value: function getDefaultPortContainerMarkup() {
      return this.store.get('defaultPortContainerMarkup') || markup_Markup.getPortContainerMarkup();
    }
  }, {
    key: "getPortContainerMarkup",
    value: function getPortContainerMarkup() {
      return this.store.get('portContainerMarkup') || this.getDefaultPortContainerMarkup();
    }
  }, {
    key: "setPortContainerMarkup",
    value: function setPortContainerMarkup(markup) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('portContainerMarkup', markup_Markup.clone(markup), options);
      return this;
    }
  }, {
    key: "getDefaultPortMarkup",
    value: function getDefaultPortMarkup() {
      return this.store.get('defaultPortMarkup') || markup_Markup.getPortMarkup();
    }
  }, {
    key: "getPortMarkup",
    value: function getPortMarkup() {
      return this.store.get('portMarkup') || this.getDefaultPortMarkup();
    }
  }, {
    key: "setPortMarkup",
    value: function setPortMarkup(markup) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('portMarkup', markup_Markup.clone(markup), options);
      return this;
    }
  }, {
    key: "getDefaultPortLabelMarkup",
    value: function getDefaultPortLabelMarkup() {
      return this.store.get('defaultPortLabelMarkup') || markup_Markup.getPortLabelMarkup();
    }
  }, {
    key: "getPortLabelMarkup",
    value: function getPortLabelMarkup() {
      return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();
    }
  }, {
    key: "setPortLabelMarkup",
    value: function setPortLabelMarkup(markup) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('portLabelMarkup', markup_Markup.clone(markup), options);
      return this;
    }
  }, {
    key: "getPorts",
    value: function getPorts() {
      return object_namespaceObject.cloneDeep(this.ports.items);
    }
  }, {
    key: "getPortsByGroup",
    value: function getPortsByGroup(groupName) {
      return this.getPorts().filter(function (port) {
        return port.group === groupName;
      });
    }
  }, {
    key: "getPort",
    value: function getPort(portId) {
      return object_namespaceObject.cloneDeep(this.ports.items.find(function (port) {
        return port.id && port.id === portId;
      }));
    }
  }, {
    key: "getPortAt",
    value: function getPortAt(index) {
      return this.ports.items[index] || null;
    }
  }, {
    key: "hasPorts",
    value: function hasPorts() {
      return this.ports.items.length > 0;
    }
  }, {
    key: "hasPort",
    value: function hasPort(portId) {
      return this.getPortIndex(portId) !== -1;
    }
  }, {
    key: "getPortIndex",
    value: function getPortIndex(port) {
      var portId = typeof port === 'string' ? port : port.id;
      return portId != null ? this.ports.items.findIndex(function (item) {
        return item.id === portId;
      }) : -1;
    }
  }, {
    key: "getPortsPosition",
    value: function getPortsPosition(groupName) {
      var size = this.getSize();
      var layouts = this.port.getPortsLayoutByGroup(groupName, new rectangle_Rectangle(0, 0, size.width, size.height));
      return layouts.reduce(function (memo, item) {
        var layout = item.portLayout;
        memo[item.portId] = {
          position: Object.assign({}, layout.position),
          angle: layout.angle || 0
        };
        return memo;
      }, {});
    }
  }, {
    key: "getPortProp",
    value: function getPortProp(portId, path) {
      return this.getPropByPath(this.prefixPortPath(portId, path));
    }
  }, {
    key: "setPortProp",
    value: function setPortProp(portId, arg1, arg2, arg3) {
      if (typeof arg1 === 'string' || Array.isArray(arg1)) {
        var _path = this.prefixPortPath(portId, arg1);

        var _value = arg2;
        return this.setPropByPath(_path, _value, arg3);
      }

      var path = this.prefixPortPath(portId);
      var value = arg1;
      return this.setPropByPath(path, value, arg2);
    }
  }, {
    key: "removePortProp",
    value: function removePortProp(portId, path, options) {
      if (typeof path === 'string' || Array.isArray(path)) {
        return this.removePropByPath(this.prefixPortPath(portId, path), options);
      }

      return this.removePropByPath(this.prefixPortPath(portId), path);
    }
  }, {
    key: "portProp",
    value: function portProp(portId, path, value, options) {
      if (path == null) {
        return this.getPortProp(portId);
      }

      if (typeof path === 'string' || Array.isArray(path)) {
        if (arguments.length === 2) {
          return this.getPortProp(portId, path);
        }

        if (value == null) {
          return this.removePortProp(portId, path, options);
        }

        return this.setPortProp(portId, path, value, options);
      }

      return this.setPortProp(portId, path, value);
    }
  }, {
    key: "prefixPortPath",
    value: function prefixPortPath(portId, path) {
      var index = this.getPortIndex(portId);

      if (index === -1) {
        throw new Error("Unable to find port with id: \"".concat(portId, "\""));
      }

      if (path == null || path === '') {
        return ['ports', 'items', "".concat(index)];
      }

      if (Array.isArray(path)) {
        return ['ports', 'items', "".concat(index)].concat(Object(toConsumableArray["a" /* default */])(path));
      }

      return "ports/items/".concat(index, "/").concat(path);
    }
  }, {
    key: "addPort",
    value: function addPort(port, options) {
      var ports = Object(toConsumableArray["a" /* default */])(this.ports.items);

      ports.push(port);
      this.setPropByPath('ports/items', ports, options);
      return this;
    }
  }, {
    key: "addPorts",
    value: function addPorts(ports, options) {
      this.setPropByPath('ports/items', [].concat(Object(toConsumableArray["a" /* default */])(this.ports.items), Object(toConsumableArray["a" /* default */])(ports)), options);
      return this;
    }
  }, {
    key: "removePort",
    value: function removePort(port) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.removePortAt(this.getPortIndex(port), options);
    }
  }, {
    key: "removePortAt",
    value: function removePortAt(index) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (index >= 0) {
        var ports = Object(toConsumableArray["a" /* default */])(this.ports.items);

        ports.splice(index, 1);
        options.rewrite = true;
        this.setPropByPath('ports/items', ports, options);
      }

      return this;
    }
  }, {
    key: "removePorts",
    value: function removePorts(portsForRemoval, opt) {
      var options;

      if (Array.isArray(portsForRemoval)) {
        options = opt || {};

        if (portsForRemoval.length) {
          options.rewrite = true;

          var currentPorts = Object(toConsumableArray["a" /* default */])(this.ports.items);

          var remainingPorts = currentPorts.filter(function (cp) {
            return !portsForRemoval.some(function (p) {
              var id = typeof p === 'string' ? p : p.id;
              return cp.id === id;
            });
          });
          this.setPropByPath('ports/items', remainingPorts, options);
        }
      } else {
        options = portsForRemoval || {};
        options.rewrite = true;
        this.setPropByPath('ports/items', [], options);
      }

      return this;
    }
  }, {
    key: "getParsedPorts",
    value: function getParsedPorts() {
      return this.port.getPorts();
    }
  }, {
    key: "getParsedGroups",
    value: function getParsedGroups() {
      return this.port.groups;
    }
  }, {
    key: "getPortsLayoutByGroup",
    value: function getPortsLayoutByGroup(groupName, bbox) {
      return this.port.getPortsLayoutByGroup(groupName, bbox);
    }
  }, {
    key: "initPorts",
    value: function initPorts() {
      var _this2 = this;

      this.updatePortData();
      this.on('change:ports', function () {
        _this2.processRemovedPort();

        _this2.updatePortData();
      });
    }
  }, {
    key: "processRemovedPort",
    value: function processRemovedPort() {
      var current = this.ports;
      var currentItemsMap = {};
      current.items.forEach(function (item) {
        if (item.id) {
          currentItemsMap[item.id] = true;
        }
      });
      var removed = {};
      var previous = this.store.getPrevious('ports') || {
        items: []
      };
      previous.items.forEach(function (item) {
        if (item.id && !currentItemsMap[item.id]) {
          removed[item.id] = true;
        }
      });
      var model = this.model;

      if (model && !object_namespaceObject.isEmpty(removed)) {
        var incomings = model.getConnectedEdges(this, {
          incoming: true
        });
        incomings.forEach(function (edge) {
          var portId = edge.getTargetPortId();

          if (portId && removed[portId]) {
            edge.remove();
          }
        });
        var outgoings = model.getConnectedEdges(this, {
          outgoing: true
        });
        outgoings.forEach(function (edge) {
          var portId = edge.getSourcePortId();

          if (portId && removed[portId]) {
            edge.remove();
          }
        });
      }
    }
  }, {
    key: "validatePorts",
    value: function validatePorts() {
      var _this3 = this;

      var ids = {};
      var errors = [];
      this.ports.items.forEach(function (p) {
        if (typeof p !== 'object') {
          errors.push("Invalid port ".concat(p, "."));
        }

        if (p.id == null) {
          p.id = _this3.generatePortId();
        }

        if (ids[p.id]) {
          errors.push('Duplicitied port id.');
        }

        ids[p.id] = true;
      });
      return errors;
    }
  }, {
    key: "generatePortId",
    value: function generatePortId() {
      return string_namespaceObject.uuid();
    }
  }, {
    key: "updatePortData",
    value: function updatePortData() {
      var err = this.validatePorts();

      if (err.length > 0) {
        this.store.set('ports', this.store.getPrevious('ports'));
        throw new Error(err.join(' '));
      }

      var prev = this.port ? this.port.getPorts() : null;
      this.port = new port_PortManager(this.ports);
      var curr = this.port.getPorts();
      var added = prev ? curr.filter(function (item) {
        if (!prev.find(function (prevPort) {
          return prevPort.id === item.id;
        })) {
          return item;
        }
      }) : Object(toConsumableArray["a" /* default */])(curr);
      var removed = prev ? prev.filter(function (item) {
        if (!curr.find(function (curPort) {
          return curPort.id === item.id;
        })) {
          return item;
        }
      }) : [];

      if (added.length > 0) {
        this.notify('ports:added', {
          added: added,
          cell: this,
          node: this
        });
      }

      if (removed.length > 0) {
        this.notify('ports:removed', {
          removed: removed,
          cell: this,
          node: this
        });
      }
    }
  }, {
    key: "portContainerMarkup",
    get: function get() {
      return this.getPortContainerMarkup();
    },
    set: function set(markup) {
      this.setPortContainerMarkup(markup);
    }
  }, {
    key: "portMarkup",
    get: function get() {
      return this.getPortMarkup();
    },
    set: function set(markup) {
      this.setPortMarkup(markup);
    }
  }, {
    key: "portLabelMarkup",
    get: function get() {
      return this.getPortLabelMarkup();
    },
    set: function set(markup) {
      this.setPortLabelMarkup(markup);
    }
  }, {
    key: "ports",
    get: function get() {
      var res = this.store.get('ports', {
        items: []
      });

      if (res.items == null) {
        res.items = [];
      }

      return res;
    }
  }]);

  return Node;
}(cell_Cell);
node_Node.defaults = {
  angle: 0,
  position: {
    x: 0,
    y: 0
  },
  size: {
    width: 1,
    height: 1
  }
};

(function (Node) {
  Node.registry = registry_Registry.create({
    type: 'node',
    process: function process(shape, options) {
      if (ShareRegistry.exist(shape, true)) {
        throw new Error("Node with name '".concat(shape, "' was registered by anthor Edge"));
      }

      if (typeof options === 'function') {
        options.config({
          shape: shape
        });
        return options;
      }

      var parent = Node;

      var inherit = options.inherit,
          others = node_rest(options, ["inherit"]);

      if (inherit) {
        if (typeof inherit === 'string') {
          var base = this.get(inherit);

          if (base == null) {
            this.onNotFound(inherit, 'inherited');
          } else {
            parent = base;
          }
        } else {
          parent = inherit;
        }
      }

      if (others.constructorName == null) {
        others.constructorName = shape;
      }

      var ret = parent.define.call(parent, others);
      ret.config({
        shape: shape
      });
      return ret;
    }
  });
  ShareRegistry.setNodeRegistry(Node.registry);
})(node_Node || (node_Node = {}));

(function (Node) {
  Node.config({
    propHooks: function propHooks(_a) {
      var ports = _a.ports,
          metadata = node_rest(_a, ["ports"]);

      if (ports) {
        metadata.ports = Array.isArray(ports) ? {
          items: ports
        } : ports;
      }

      return metadata;
    }
  });
})(node_Node || (node_Node = {}));

(function (Node) {
  var counter = 0;

  function getClassName(name) {
    if (name) {
      return string_namespaceObject.pascalCase(name);
    }

    counter += 1;
    return "CustomNode".concat(counter);
  }

  function define(config) {
    var constructorName = config.constructorName,
        others = node_rest(config, ["constructorName"]);

    var shape = object_namespaceObject.createClass(getClassName(constructorName || others.shape), this);
    shape.config(others);

    if (others.shape) {
      Node.registry.register(others.shape, shape);
    }

    return shape;
  }

  Node.define = define;

  function create(options) {
    var shape = options.shape || 'rect';
    var Ctor = Node.registry.get(shape);

    if (Ctor) {
      return new Ctor(options);
    }

    return Node.registry.onNotFound(shape);
  }

  Node.create = create;
})(node_Node || (node_Node = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/model/edge.js








var edge_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







var edge_Edge = /*#__PURE__*/function (_Cell) {
  Object(inherits["a" /* default */])(Edge, _Cell);

  var _super = Object(createSuper["a" /* default */])(Edge);

  function Edge() {
    var metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, Edge);

    return _super.call(this, metadata);
  }

  Object(createClass["a" /* default */])(Edge, [{
    key: "preprocess",
    value: function preprocess(metadata, ignoreIdCheck) {
      var source = metadata.source,
          sourceCell = metadata.sourceCell,
          sourcePort = metadata.sourcePort,
          sourcePoint = metadata.sourcePoint,
          target = metadata.target,
          targetCell = metadata.targetCell,
          targetPort = metadata.targetPort,
          targetPoint = metadata.targetPoint,
          others = edge_rest(metadata, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell", "targetPort", "targetPoint"]);

      var data = others;

      var isValidId = function isValidId(val) {
        return typeof val === 'string' || typeof val === 'number';
      };

      if (source != null) {
        if (source instanceof cell_Cell) {
          data.source = {
            cell: source.id
          };
        } else if (isValidId(source)) {
          data.source = {
            cell: source
          };
        } else if (source instanceof point_Point) {
          data.source = source.toJSON();
        } else if (Array.isArray(source)) {
          data.source = {
            x: source[0],
            y: source[1]
          };
        } else {
          var cell = source.cell;

          if (cell instanceof cell_Cell) {
            data.source = Object.assign(Object.assign({}, source), {
              cell: cell.id
            });
          } else {
            data.source = source;
          }
        }
      }

      if (sourceCell != null || sourcePort != null) {
        var terminal = data.source;

        if (sourceCell != null) {
          var id = isValidId(sourceCell) ? sourceCell : sourceCell.id;

          if (terminal) {
            terminal.cell = id;
          } else {
            terminal = data.source = {
              cell: id
            };
          }
        }

        if (sourcePort != null && terminal) {
          terminal.port = sourcePort;
        }
      } else if (sourcePoint != null) {
        data.source = point_Point.create(sourcePoint).toJSON();
      }

      if (target != null) {
        if (target instanceof cell_Cell) {
          data.target = {
            cell: target.id
          };
        } else if (isValidId(target)) {
          data.target = {
            cell: target
          };
        } else if (target instanceof point_Point) {
          data.target = target.toJSON();
        } else if (Array.isArray(target)) {
          data.target = {
            x: target[0],
            y: target[1]
          };
        } else {
          var _cell = target.cell;

          if (_cell instanceof cell_Cell) {
            data.target = Object.assign(Object.assign({}, target), {
              cell: _cell.id
            });
          } else {
            data.target = target;
          }
        }
      }

      if (targetCell != null || targetPort != null) {
        var _terminal = data.target;

        if (targetCell != null) {
          var _id = isValidId(targetCell) ? targetCell : targetCell.id;

          if (_terminal) {
            _terminal.cell = _id;
          } else {
            _terminal = data.target = {
              cell: _id
            };
          }
        }

        if (targetPort != null && _terminal) {
          _terminal.port = targetPort;
        }
      } else if (targetPoint != null) {
        data.target = point_Point.create(targetPoint).toJSON();
      }

      return Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(Edge.prototype), "preprocess", this).call(this, data, ignoreIdCheck);
    }
  }, {
    key: "postprocess",
    value: function postprocess(metadata) {
      var source = metadata.source,
          target = metadata.target,
          sourceCell = metadata.sourceCell,
          targetCell = metadata.targetCell;
      var sourceCellFound;
      var targetCellFound;

      if (source != null) {
        if (source instanceof cell_Cell) {
          sourceCellFound = source;
        } else {
          var cell = source.cell;

          if (cell instanceof cell_Cell) {
            sourceCellFound = cell;
          }
        }
      }

      if (sourceCell != null && typeof sourceCell !== 'string') {
        sourceCellFound = sourceCell;
      }

      if (target != null) {
        if (target instanceof cell_Cell) {
          targetCellFound = target;
        } else {
          var _cell2 = target.cell;

          if (_cell2 instanceof cell_Cell) {
            targetCellFound = _cell2;
          }
        }
      }

      if (targetCell != null && typeof targetCell !== 'string') {
        targetCellFound = targetCell;
      }

      if (sourceCellFound) {
        this.reference('source', sourceCellFound);
      }

      if (targetCellFound) {
        this.reference('target', targetCellFound);
      }
    }
  }, {
    key: "setup",
    value: function setup() {
      var _this = this;

      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(Edge.prototype), "setup", this).call(this);

      this.on('change:labels', function (args) {
        return _this.onLabelsChanged(args);
      });
      this.on('change:vertices', function (args) {
        return _this.onVertexsChanged(args);
      });
    }
  }, {
    key: "isEdge",
    value: function isEdge() {
      return true;
    } // #region terminal

  }, {
    key: "disconnect",
    value: function disconnect() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.store.set({
        source: {
          x: 0,
          y: 0
        },
        target: {
          x: 0,
          y: 0
        }
      }, options);
      this.reference('source', null);
      this.reference('target', null);
      return this;
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return this.getTerminal('source');
    }
  }, {
    key: "getSourceCellId",
    value: function getSourceCellId() {
      return this.source.cell;
    }
  }, {
    key: "getSourcePortId",
    value: function getSourcePortId() {
      return this.source.port;
    }
  }, {
    key: "setSource",
    value: function setSource(source, args) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.setTerminal('source', source, args, options);
    }
  }, {
    key: "getTarget",
    value: function getTarget() {
      return this.getTerminal('target');
    }
  }, {
    key: "getTargetCellId",
    value: function getTargetCellId() {
      return this.target.cell;
    }
  }, {
    key: "getTargetPortId",
    value: function getTargetPortId() {
      return this.target.port;
    }
  }, {
    key: "setTarget",
    value: function setTarget(target, args) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.setTerminal('target', target, args, options);
    }
  }, {
    key: "getTerminal",
    value: function getTerminal(type) {
      return Object.assign({}, this.store.get(type));
    }
  }, {
    key: "setTerminal",
    value: function setTerminal(type, terminal, args) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      // `terminal` is a cell
      if (terminal instanceof cell_Cell) {
        this.reference(type, terminal);
        this.store.set(type, object_namespaceObject.merge({}, args, {
          cell: terminal.id
        }), options);
        return this;
      } // `terminal` is a point-like object


      var p = terminal;

      if (terminal instanceof point_Point || p.x != null && p.y != null) {
        this.reference(type, null);
        this.store.set(type, object_namespaceObject.merge({}, args, {
          x: p.x,
          y: p.y
        }), options);
        return this;
      } // `terminal` is an object


      {
        var cellId = terminal.cell;
        var cell = cellId && this._model ? this._model.getCell(cellId) : null;
        this.reference(type, cell);
        this.store.set(type, object_namespaceObject.cloneDeep(terminal), options);
      }
      return this;
    }
  }, {
    key: "reference",
    value: function reference(type, terminalCell) {
      var terminalCellKey = "".concat(type, "Cell");
      var prev = this[terminalCellKey];
      this[terminalCellKey] = terminalCell;

      if (prev !== terminalCell) {
        var edgesKey = type === 'source' ? 'outgoings' : 'incomings';

        if (prev) {
          var ref = prev[edgesKey];

          if (ref) {
            var index = ref.indexOf(this);

            if (index >= 0) {
              ref.splice(index, 1);
            }
          }
        }

        if (terminalCell) {
          var _ref = terminalCell[edgesKey];

          if (_ref == null) {
            _ref = terminalCell[edgesKey] = [];
          }

          _ref.push(this);
        }

        this.updateParent();
      }
    }
  }, {
    key: "getSourcePoint",
    value: function getSourcePoint() {
      return this.getTerminalPoint('source');
    }
  }, {
    key: "getTargetPoint",
    value: function getTargetPoint() {
      return this.getTerminalPoint('target');
    }
  }, {
    key: "getTerminalPoint",
    value: function getTerminalPoint(type) {
      var terminal = this[type];

      if (point_Point.isPointLike(terminal)) {
        return point_Point.create(terminal);
      }

      var cell = this.getTerminalCell(type);

      if (cell) {
        return cell.getConnectionPoint(this, type);
      }

      return new point_Point();
    }
  }, {
    key: "getSourceCell",
    value: function getSourceCell() {
      return this.getTerminalCell('source');
    }
  }, {
    key: "getTargetCell",
    value: function getTargetCell() {
      return this.getTerminalCell('target');
    }
  }, {
    key: "getTerminalCell",
    value: function getTerminalCell(type) {
      var key = "".concat(type, "Cell");
      var cell = this[key];

      if (cell == null && this._model) {
        var cellId = type === 'source' ? this.getSourceCellId() : type === 'target' ? this.getTargetCellId() : null;

        if (cellId) {
          cell = this._model.getCell(cellId);

          if (cell) {
            this.reference(type, cell);
          }
        }
      }

      return cell;
    }
  }, {
    key: "getSourceNode",
    value: function getSourceNode() {
      return this.getTerminalNode('source');
    }
  }, {
    key: "getTargetNode",
    value: function getTargetNode() {
      return this.getTerminalNode('target');
    }
  }, {
    key: "getTerminalNode",
    value: function getTerminalNode(type) {
      var cell = this; // tslint:disable-line

      var visited = {};

      while (cell && cell.isEdge()) {
        if (visited[cell.id]) {
          return null;
        }

        visited[cell.id] = true;
        cell = cell.getTerminalCell(type);
      }

      return cell;
    } // #endregion
    // #region router

  }, {
    key: "getRouter",
    value: function getRouter() {
      return this.store.get('router');
    }
  }, {
    key: "setRouter",
    value: function setRouter(name, args, options) {
      if (typeof name === 'object') {
        this.store.set('router', name, args);
      } else {
        this.store.set('router', {
          name: name,
          args: args
        }, options);
      }

      return this;
    }
  }, {
    key: "removeRouter",
    value: function removeRouter() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.store.remove('router', options);
      return this;
    } // #endregion
    // #region connector

  }, {
    key: "getConnector",
    value: function getConnector() {
      return this.store.get('connector');
    }
  }, {
    key: "setConnector",
    value: function setConnector(name, args, options) {
      if (typeof name === 'object') {
        this.store.set('connector', name, args);
      } else {
        this.store.set('connector', {
          name: name,
          args: args
        }, options);
      }

      return this;
    }
  }, {
    key: "removeConnector",
    value: function removeConnector() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.store.remove('connector', options);
    } // #endregion
    // #region strategy

  }, {
    key: "getStrategy",
    value: function getStrategy() {
      return this.store.get('strategy');
    }
  }, {
    key: "setStrategy",
    value: function setStrategy(name, args, options) {
      if (typeof name === 'object') {
        this.store.set('strategy', name, args);
      } else {
        this.store.set('strategy', {
          name: name,
          args: args
        }, options);
      }

      return this;
    }
  }, {
    key: "removeStrategy",
    value: function removeStrategy() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.store.remove('strategy', options);
    } // #endregion
    // #region labels

  }, {
    key: "getDefaultLabel",
    value: function getDefaultLabel() {
      var ctor = this.constructor;
      var defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};
      return object_namespaceObject.cloneDeep(defaults);
    }
  }, {
    key: "getLabels",
    value: function getLabels() {
      var _this2 = this;

      return Object(toConsumableArray["a" /* default */])(this.store.get('labels', [])).map(function (item) {
        return _this2.parseLabel(item);
      });
    }
  }, {
    key: "setLabels",
    value: function setLabels(labels) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);
      return this;
    }
  }, {
    key: "insertLabel",
    value: function insertLabel(label, index) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var labels = this.getLabels();
      var len = labels.length;
      var idx = index != null && isFinite(index) ? index : len;

      if (idx < 0) {
        idx = len + idx + 1;
      }

      labels.splice(idx, 0, this.parseLabel(label));
      return this.setLabels(labels, options);
    }
  }, {
    key: "appendLabel",
    value: function appendLabel(label) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.insertLabel(label, -1, options);
    }
  }, {
    key: "getLabelAt",
    value: function getLabelAt(index) {
      var labels = this.getLabels();

      if (index != null && isFinite(index)) {
        return this.parseLabel(labels[index]);
      }

      return null;
    }
  }, {
    key: "setLabelAt",
    value: function setLabelAt(index, label) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (index != null && isFinite(index)) {
        var labels = this.getLabels();
        labels[index] = this.parseLabel(label);
        this.setLabels(labels, options);
      }

      return this;
    }
  }, {
    key: "removeLabelAt",
    value: function removeLabelAt(index) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var labels = this.getLabels();
      var idx = index != null && isFinite(index) ? index : -1;
      var removed = labels.splice(idx, 1);
      this.setLabels(labels, options);
      return removed.length ? removed[0] : null;
    }
  }, {
    key: "parseLabel",
    value: function parseLabel(label) {
      if (typeof label === 'string') {
        var ctor = this.constructor;
        return ctor.parseStringLabel(label);
      }

      return label;
    }
  }, {
    key: "onLabelsChanged",
    value: function onLabelsChanged(_ref2) {
      var previous = _ref2.previous,
          current = _ref2.current;
      var added = previous && current ? current.filter(function (label1) {
        if (!previous.find(function (label2) {
          return label1 === label2 || object_namespaceObject.isEqual(label1, label2);
        })) {
          return label1;
        }
      }) : current ? Object(toConsumableArray["a" /* default */])(current) : [];
      var removed = previous && current ? previous.filter(function (label1) {
        if (!current.find(function (label2) {
          return label1 === label2 || object_namespaceObject.isEqual(label1, label2);
        })) {
          return label1;
        }
      }) : previous ? Object(toConsumableArray["a" /* default */])(previous) : [];

      if (added.length > 0) {
        this.notify('labels:added', {
          added: added,
          cell: this,
          edge: this
        });
      }

      if (removed.length > 0) {
        this.notify('labels:removed', {
          removed: removed,
          cell: this,
          edge: this
        });
      }
    } // #endregion
    // #region vertices

  }, {
    key: "getDefaultVertexMarkup",
    value: function getDefaultVertexMarkup() {
      return this.store.get('defaultVertexMarkup') || markup_Markup.getEdgeVertexMarkup();
    }
  }, {
    key: "getVertexMarkup",
    value: function getVertexMarkup() {
      return this.store.get('vertexMarkup') || this.getDefaultVertexMarkup();
    }
  }, {
    key: "setVertexMarkup",
    value: function setVertexMarkup(markup) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('vertexMarkup', markup_Markup.clone(markup), options);
      return this;
    }
  }, {
    key: "getVertices",
    value: function getVertices() {
      return Object(toConsumableArray["a" /* default */])(this.store.get('vertices', []));
    }
  }, {
    key: "setVertices",
    value: function setVertices(vertices) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var points = Array.isArray(vertices) ? vertices : [vertices];
      this.store.set('vertices', points.map(function (p) {
        return point_Point.toJSON(p);
      }), options);
      return this;
    }
  }, {
    key: "insertVertex",
    value: function insertVertex(vertice, index) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var vertices = this.getVertices();
      var len = vertices.length;
      var idx = index != null && isFinite(index) ? index : len;

      if (idx < 0) {
        idx = len + idx + 1;
      }

      vertices.splice(idx, 0, point_Point.toJSON(vertice));
      return this.setVertices(vertices, options);
    }
  }, {
    key: "appendVertex",
    value: function appendVertex(vertex) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.insertVertex(vertex, -1, options);
    }
  }, {
    key: "getVertexAt",
    value: function getVertexAt(index) {
      if (index != null && isFinite(index)) {
        var vertices = this.getVertices();
        return vertices[index];
      }

      return null;
    }
  }, {
    key: "setVertexAt",
    value: function setVertexAt(index, vertice) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (index != null && isFinite(index)) {
        var vertices = this.getVertices();
        vertices[index] = vertice;
        this.setVertices(vertices, options);
      }

      return this;
    }
  }, {
    key: "removeVertexAt",
    value: function removeVertexAt(index) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var vertices = this.getVertices();
      var idx = index != null && isFinite(index) ? index : -1;
      vertices.splice(idx, 1);
      return this.setVertices(vertices, options);
    }
  }, {
    key: "onVertexsChanged",
    value: function onVertexsChanged(_ref3) {
      var previous = _ref3.previous,
          current = _ref3.current;
      var added = previous && current ? current.filter(function (p1) {
        if (!previous.find(function (p2) {
          return point_Point.equals(p1, p2);
        })) {
          return p1;
        }
      }) : current ? Object(toConsumableArray["a" /* default */])(current) : [];
      var removed = previous && current ? previous.filter(function (p1) {
        if (!current.find(function (p2) {
          return point_Point.equals(p1, p2);
        })) {
          return p1;
        }
      }) : previous ? Object(toConsumableArray["a" /* default */])(previous) : [];

      if (added.length > 0) {
        this.notify('vertexs:added', {
          added: added,
          cell: this,
          edge: this
        });
      }

      if (removed.length > 0) {
        this.notify('vertexs:removed', {
          removed: removed,
          cell: this,
          edge: this
        });
      }
    } // #endregion
    // #region markup

  }, {
    key: "getDefaultMarkup",
    value: function getDefaultMarkup() {
      return this.store.get('defaultMarkup') || markup_Markup.getEdgeMarkup();
    }
  }, {
    key: "getMarkup",
    value: function getMarkup() {
      return Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(Edge.prototype), "getMarkup", this).call(this) || this.getDefaultMarkup();
    } // #endregion
    // #region toolMarkup

  }, {
    key: "getDefaultToolMarkup",
    value: function getDefaultToolMarkup() {
      return this.store.get('defaultToolMarkup') || markup_Markup.getEdgeToolMarkup();
    }
  }, {
    key: "getToolMarkup",
    value: function getToolMarkup() {
      return this.store.get('toolMarkup') || this.getDefaultToolMarkup();
    }
  }, {
    key: "setToolMarkup",
    value: function setToolMarkup(markup) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('toolMarkup', markup, options);
      return this;
    }
  }, {
    key: "getDefaultDoubleToolMarkup",
    value: function getDefaultDoubleToolMarkup() {
      return this.store.get('defaultDoubleToolMarkup');
    }
  }, {
    key: "getDoubleToolMarkup",
    value: function getDoubleToolMarkup() {
      return this.store.get('doubleToolMarkup') || this.getDefaultDoubleToolMarkup();
    }
  }, {
    key: "setDoubleToolMarkup",
    value: function setDoubleToolMarkup(markup) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('doubleToolMarkup', markup, options);
      return this;
    } // #endregion
    // #region arrowheadMarkup

  }, {
    key: "getDefaultArrowheadMarkup",
    value: function getDefaultArrowheadMarkup() {
      return this.store.get('defaultArrowheadMarkup') || markup_Markup.getEdgeArrowheadMarkup();
    }
  }, {
    key: "getArrowheadMarkup",
    value: function getArrowheadMarkup() {
      return this.store.get('arrowheadMarkup') || this.getDefaultArrowheadMarkup();
    }
  }, {
    key: "setArrowheadMarkup",
    value: function setArrowheadMarkup(markup) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('arrowheadMarkup', markup, options);
      return this;
    } // #endregion
    // #region transform

    /**
     * Translate the edge vertices (and source and target if they are points)
     * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.
     */

  }, {
    key: "translate",
    value: function translate(tx, ty) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      options.translateBy = options.translateBy || this.id;
      options.tx = tx;
      options.ty = ty;
      return this.applyToPoints(function (p) {
        return {
          x: (p.x || 0) + tx,
          y: (p.y || 0) + ty
        };
      }, options);
    }
    /**
     * Scales the edge's points (vertices) relative to the given origin.
     */

  }, {
    key: "scale",
    value: function scale(sx, sy, origin) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      return this.applyToPoints(function (p) {
        return point_Point.create(p).scale(sx, sy, origin).toJSON();
      }, options);
    }
  }, {
    key: "applyToPoints",
    value: function applyToPoints(worker) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var attrs = {};
      var source = this.getSource();
      var target = this.getTarget();

      if (point_Point.isPointLike(source)) {
        attrs.source = worker(source);
      }

      if (point_Point.isPointLike(target)) {
        attrs.target = worker(target);
      }

      var vertices = this.getVertices();

      if (vertices.length > 0) {
        attrs.vertices = vertices.map(worker);
      }

      this.store.set(attrs, options);
      return this;
    } // #endregion
    // #region common

  }, {
    key: "getBBox",
    value: function getBBox() {
      return this.getPolyline().bbox();
    }
  }, {
    key: "getConnectionPoint",
    value: function getConnectionPoint() {
      return this.getPolyline().pointAt(0.5);
    }
  }, {
    key: "getPolyline",
    value: function getPolyline() {
      var points = [this.getSourcePoint(), this.getTargetPoint()];
      var vertices = this.getVertices();
      vertices.forEach(function (p) {
        return points.push(point_Point.create(p));
      });
      return new polyline_Polyline(points);
    }
  }, {
    key: "updateParent",
    value: function updateParent(options) {
      var newParent = null;
      var source = this.getSourceCell();
      var target = this.getTargetCell();
      var prevParent = this.getParent();

      if (source && target) {
        if (source === target || source.isDescendantOf(target)) {
          newParent = target;
        } else if (target.isDescendantOf(source)) {
          newParent = source;
        } else {
          newParent = cell_Cell.getCommonAncestor(source, target);
        }
      } // Unembeds the edge if source and target has no common
      // ancestor or common ancestor changed


      if (prevParent && (!newParent || newParent.id !== prevParent.id)) {
        prevParent.unembed(this, options);
      }

      if (newParent) {
        newParent.embed(this, options);
      }

      return newParent;
    }
  }, {
    key: "hasLoop",
    value: function hasLoop() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var source = this.getSource();
      var target = this.getTarget();
      var sourceId = source.cell;
      var targetId = target.cell;

      if (!sourceId || !targetId) {
        return false;
      }

      var loop = sourceId === targetId; // Note that there in the deep mode a edge can have a loop,
      // even if it connects only a parent and its embed.
      // A loop "target equals source" is valid in both shallow and deep mode.

      if (!loop && options.deep && this._model) {
        var sourceCell = this.getSourceCell();
        var targetCell = this.getTargetCell();

        if (sourceCell && targetCell) {
          loop = sourceCell.isAncestorOf(targetCell, options) || targetCell.isAncestorOf(sourceCell, options);
        }
      }

      return loop;
    }
  }, {
    key: "getFragmentAncestor",
    value: function getFragmentAncestor() {
      var cells = [this, this.getSourceNode(), this.getTargetNode()].filter(function (item) {
        return item != null;
      });
      return this.getCommonAncestor.apply(this, Object(toConsumableArray["a" /* default */])(cells));
    }
  }, {
    key: "isFragmentDescendantOf",
    value: function isFragmentDescendantOf(cell) {
      var ancestor = this.getFragmentAncestor();
      return !!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell));
    }
  }, {
    key: "model",
    get: function get() {
      return this._model;
    },
    set: function set(model) {
      if (this._model !== model) {
        this._model = model;

        if (model) {
          // update reference
          this.getSourceCell();
          this.getTargetCell();
        }
      }
    }
  }, {
    key: "source",
    get: function get() {
      return this.getSource();
    },
    set: function set(data) {
      this.setSource(data);
    }
  }, {
    key: "target",
    get: function get() {
      return this.getTarget();
    },
    set: function set(data) {
      this.setTarget(data);
    }
  }, {
    key: "router",
    get: function get() {
      return this.getRouter();
    },
    set: function set(data) {
      if (data == null) {
        this.removeRouter();
      } else {
        this.setRouter(data);
      }
    }
  }, {
    key: "connector",
    get: function get() {
      return this.getConnector();
    },
    set: function set(data) {
      if (data == null) {
        this.removeConnector();
      } else {
        this.setConnector(data);
      }
    }
  }, {
    key: "strategy",
    get: function get() {
      return this.getStrategy();
    },
    set: function set(data) {
      if (data == null) {
        this.removeStrategy();
      } else {
        this.setStrategy(data);
      }
    }
  }, {
    key: "labels",
    get: function get() {
      return this.getLabels();
    },
    set: function set(labels) {
      this.setLabels(labels);
    }
  }, {
    key: "vertexMarkup",
    get: function get() {
      return this.getVertexMarkup();
    },
    set: function set(markup) {
      this.setVertexMarkup(markup);
    }
  }, {
    key: "vertices",
    get: function get() {
      return this.getVertices();
    },
    set: function set(vertices) {
      this.setVertices(vertices);
    }
  }, {
    key: "toolMarkup",
    get: function get() {
      return this.getToolMarkup();
    },
    set: function set(markup) {
      this.setToolMarkup(markup);
    }
  }, {
    key: "doubleToolMarkup",
    get: function get() {
      return this.getDoubleToolMarkup();
    },
    set: function set(markup) {
      this.setDoubleToolMarkup(markup);
    }
  }, {
    key: "arrowheadMarkup",
    get: function get() {
      return this.getArrowheadMarkup();
    },
    set: function set(markup) {
      this.setArrowheadMarkup(markup);
    }
  }]);

  return Edge;
}(cell_Cell);
edge_Edge.defaults = {};

(function (Edge) {
  function equalTerminals(a, b) {
    var a1 = a;
    var b1 = b;

    if (a1.cell === b1.cell) {
      return a1.port === b1.port || a1.port == null && b1.port == null;
    }

    return false;
  }

  Edge.equalTerminals = equalTerminals;
})(edge_Edge || (edge_Edge = {}));

(function (Edge) {
  Edge.defaultLabel = {
    markup: [{
      tagName: 'rect',
      selector: 'body'
    }, {
      tagName: 'text',
      selector: 'label'
    }],
    attrs: {
      text: {
        fill: '#000',
        fontSize: 14,
        textAnchor: 'middle',
        textVerticalAnchor: 'middle',
        pointerEvents: 'none'
      },
      rect: {
        ref: 'label',
        fill: '#fff',
        rx: 3,
        ry: 3,
        refWidth: 1,
        refHeight: 1,
        refX: 0,
        refY: 0
      }
    },
    position: {
      distance: 0.5
    }
  };

  function parseStringLabel(text) {
    return {
      attrs: {
        label: {
          text: text
        }
      }
    };
  }

  Edge.parseStringLabel = parseStringLabel;
})(edge_Edge || (edge_Edge = {}));

(function (Edge) {
  Edge.registry = registry_Registry.create({
    type: 'edge',
    process: function process(shape, options) {
      if (ShareRegistry.exist(shape, false)) {
        throw new Error("Edge with name '".concat(shape, "' was registered by anthor Node"));
      }

      if (typeof options === 'function') {
        options.config({
          shape: shape
        });
        return options;
      }

      var parent = Edge;

      var inherit = options.inherit,
          others = edge_rest(options, ["inherit"]);

      if (inherit) {
        var base = this.get(inherit);

        if (base == null) {
          this.onNotFound(inherit, 'inherited');
        } else {
          parent = base;
        }
      }

      if (others.constructorName == null) {
        others.constructorName = shape;
      }

      var ret = parent.define.call(parent, others);
      ret.config({
        shape: shape
      });
      return ret;
    }
  });
  ShareRegistry.setEdgeRegistry(Edge.registry);
})(edge_Edge || (edge_Edge = {}));

(function (Edge) {
  var shape = 'basic.edge';
  Edge.config({
    shape: shape,
    propHooks: function propHooks(metadata) {
      var label = metadata.label,
          others = edge_rest(metadata, ["label"]);

      if (label) {
        if (others.labels == null) {
          others.labels = [];
        }

        var formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;
        others.labels.push(formated);
      }

      return others;
    }
  });
  Edge.registry.register(shape, Edge);
})(edge_Edge || (edge_Edge = {}));

(function (Edge) {
  var counter = 0;

  function getClassName(name) {
    if (name) {
      return string_namespaceObject.pascalCase(name);
    }

    counter += 1;
    return "CustomEdge".concat(counter);
  }

  function define(config) {
    var constructorName = config.constructorName,
        others = edge_rest(config, ["constructorName"]);

    var ctor = object_namespaceObject.createClass(getClassName(constructorName || others.shape), this);
    ctor.config(others);

    if (others.shape) {
      Edge.registry.register(others.shape, ctor);
    }

    return ctor;
  }

  Edge.define = define;

  function create(options) {
    var shape = options.shape || 'edge';
    var Ctor = Edge.registry.get(shape);

    if (Ctor) {
      return new Ctor(options);
    }

    return Edge.registry.onNotFound(shape);
  }

  Edge.create = create;
})(edge_Edge || (edge_Edge = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/model/collection.js






var collection_Collection = /*#__PURE__*/function (_Basecoat) {
  Object(inherits["a" /* default */])(Collection, _Basecoat);

  var _super = Object(createSuper["a" /* default */])(Collection);

  function Collection(cells) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    Object(classCallCheck["a" /* default */])(this, Collection);

    _this = _super.call(this);
    _this.length = 0;
    _this.comparator = options.comparator || 'zIndex';

    _this.clean();

    if (cells) {
      _this.reset(cells, {
        silent: true
      });
    }

    return _this;
  }

  Object(createClass["a" /* default */])(Collection, [{
    key: "toJSON",
    value: function toJSON() {
      return this.cells.map(function (cell) {
        return cell.toJSON();
      });
    }
  }, {
    key: "add",
    value: function add(cells, index, options) {
      var _this2 = this;

      var localIndex;
      var localOptions;

      if (typeof index === 'number') {
        localIndex = index;
        localOptions = Object.assign({
          merge: false
        }, options);
      } else {
        localIndex = this.length;
        localOptions = Object.assign({
          merge: false
        }, index);
      }

      if (localIndex > this.length) {
        localIndex = this.length;
      }

      if (localIndex < 0) {
        localIndex += this.length + 1;
      }

      var entities = Array.isArray(cells) ? cells : [cells];
      var sortable = this.comparator && typeof index !== 'number' && localOptions.sort !== false;
      var sortAttr = this.comparator || null;
      var sort = false;
      var added = [];
      var merged = [];
      entities.forEach(function (cell) {
        var existing = _this2.get(cell);

        if (existing) {
          if (localOptions.merge && !cell.isSameStore(existing)) {
            existing.setProp(cell.getProp(), options); // merge

            merged.push(existing);

            if (sortable && !sort) {
              if (sortAttr == null || typeof sortAttr === 'function') {
                sort = existing.hasChanged();
              } else if (typeof sortAttr === 'string') {
                sort = existing.hasChanged(sortAttr);
              } else {
                sort = sortAttr.some(function (key) {
                  return existing.hasChanged(key);
                });
              }
            }
          }
        } else {
          added.push(cell);

          _this2.reference(cell);
        }
      });

      if (added.length) {
        var _this$cells;

        if (sortable) {
          sort = true;
        }

        (_this$cells = this.cells).splice.apply(_this$cells, [localIndex, 0].concat(added));

        this.length = this.cells.length;
      }

      if (sort) {
        this.sort({
          silent: true
        });
      }

      if (!localOptions.silent) {
        added.forEach(function (cell, i) {
          var args = {
            cell: cell,
            index: localIndex + i,
            options: localOptions
          };

          _this2.trigger('added', args);

          if (!localOptions.dryrun) {
            cell.notify('added', Object.assign({}, args));
          }
        });

        if (sort) {
          this.trigger('sorted');
        }

        if (added.length || merged.length) {
          this.trigger('updated', {
            added: added,
            merged: merged,
            removed: [],
            options: localOptions
          });
        }
      }

      return this;
    }
  }, {
    key: "remove",
    value: function remove(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var arr = Array.isArray(cells) ? cells : [cells];
      var removed = this.removeCells(arr, options);

      if (!options.silent && removed.length > 0) {
        this.trigger('updated', {
          options: options,
          removed: removed,
          added: [],
          merged: []
        });
      }

      return Array.isArray(cells) ? removed : removed[0];
    }
  }, {
    key: "removeCells",
    value: function removeCells(cells, options) {
      var removed = [];

      for (var i = 0; i < cells.length; i += 1) {
        var cell = this.get(cells[i]);

        if (cell == null) {
          continue;
        }

        var index = this.cells.indexOf(cell);
        this.cells.splice(index, 1);
        this.length -= 1;
        delete this.map[cell.id];
        removed.push(cell);
        this.unreference(cell);

        if (!options.dryrun) {
          cell.remove();
        }

        if (!options.silent) {
          this.trigger('removed', {
            cell: cell,
            index: index,
            options: options
          });

          if (!options.dryrun) {
            cell.notify('removed', {
              cell: cell,
              index: index,
              options: options
            });
          }
        }
      }

      return removed;
    }
  }, {
    key: "reset",
    value: function reset(cells) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var previous = this.cells.slice();
      previous.forEach(function (cell) {
        return _this3.unreference(cell);
      });
      this.clean();
      this.add(cells, Object.assign({
        silent: true
      }, options));

      if (!options.silent) {
        var current = this.cells.slice();
        this.trigger('reseted', {
          options: options,
          previous: previous,
          current: current
        });
        var added = [];
        var removed = [];
        current.forEach(function (a) {
          var exist = previous.some(function (b) {
            return b.id === a.id;
          });

          if (!exist) {
            added.push(a);
          }
        });
        previous.forEach(function (a) {
          var exist = current.some(function (b) {
            return b.id === a.id;
          });

          if (!exist) {
            removed.push(a);
          }
        });
        this.trigger('updated', {
          options: options,
          added: added,
          removed: removed,
          merged: []
        });
      }

      return this;
    }
  }, {
    key: "push",
    value: function push(cell, options) {
      return this.add(cell, this.length, options);
    }
  }, {
    key: "pop",
    value: function pop(options) {
      var cell = this.at(this.length - 1);
      return this.remove(cell, options);
    }
  }, {
    key: "unshift",
    value: function unshift(cell, options) {
      return this.add(cell, 0, options);
    }
  }, {
    key: "shift",
    value: function shift(options) {
      var cell = this.at(0);
      return this.remove(cell, options);
    }
  }, {
    key: "get",
    value: function get(cell) {
      if (cell == null) {
        return null;
      }

      var id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;
      return this.map[id] || null;
    }
  }, {
    key: "has",
    value: function has(cell) {
      return this.get(cell) != null;
    }
  }, {
    key: "at",
    value: function at(index) {
      if (index < 0) {
        index += this.length; // tslint:disable-line
      }

      return this.cells[index] || null;
    }
  }, {
    key: "first",
    value: function first() {
      return this.at(0);
    }
  }, {
    key: "last",
    value: function last() {
      return this.at(-1);
    }
  }, {
    key: "indexOf",
    value: function indexOf(cell) {
      return this.cells.indexOf(cell);
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return this.cells.slice();
    }
  }, {
    key: "sort",
    value: function sort() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.comparator != null) {
        this.cells = array_namespaceObject.sortBy(this.cells, this.comparator);

        if (!options.silent) {
          this.trigger('sorted');
        }
      }

      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var constructor = this.constructor;
      return new constructor(this.cells.slice(), {
        comparator: this.comparator
      });
    }
  }, {
    key: "reference",
    value: function reference(cell) {
      this.map[cell.id] = cell;
      cell.on('*', this.notifyCellEvent, this);
      cell.on('change:zIndex', this.onCellZIndexChanged, this);
    }
  }, {
    key: "unreference",
    value: function unreference(cell) {
      cell.off('*', this.notifyCellEvent, this);
      cell.off('change:zIndex', this.onCellZIndexChanged, this);
      delete this.map[cell.id];
    }
  }, {
    key: "notifyCellEvent",
    value: function notifyCellEvent(name, args) {
      var cell = args.cell;
      this.trigger("cell:".concat(name), args);

      if (cell) {
        if (cell.isNode()) {
          this.trigger("node:".concat(name), Object.assign(Object.assign({}, args), {
            node: this
          }));
        } else if (cell.isEdge()) {
          this.trigger("edge:".concat(name), Object.assign(Object.assign({}, args), {
            edge: this
          }));
        }
      }
    }
  }, {
    key: "onCellZIndexChanged",
    value: function onCellZIndexChanged(args) {
      this.sort(args.options);
    }
  }, {
    key: "clean",
    value: function clean() {
      this.length = 0;
      this.cells = [];
      this.map = {};
    }
  }]);

  return Collection;
}(basecoat_Basecoat);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/model/model.js












var model_Model = /*#__PURE__*/function (_Basecoat) {
  Object(inherits["a" /* default */])(Model, _Basecoat);

  var _super = Object(createSuper["a" /* default */])(Model);

  function Model() {
    var _this;

    var cells = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    Object(classCallCheck["a" /* default */])(this, Model);

    _this = _super.call(this);
    _this.batches = {};
    _this.addings = new WeakMap();
    _this.nodes = {};
    _this.edges = {};
    _this.collection = new collection_Collection(cells);

    _this.setup();

    return _this;
  }

  Object(createClass["a" /* default */])(Model, [{
    key: "notify",
    value: function notify(name, args) {
      this.trigger(name, args);
      var graph = this.graph;

      if (graph) {
        if (name === 'sorted' || name === 'reseted' || name === 'updated') {
          graph.trigger("model:".concat(name), args);
        } else {
          graph.trigger(name, args);
        }
      }

      return this;
    }
  }, {
    key: "setup",
    value: function setup() {
      var _this2 = this;

      var collection = this.collection;
      collection.on('sorted', function () {
        return _this2.notify('sorted', null);
      });
      collection.on('updated', function (args) {
        return _this2.notify('updated', args);
      });
      collection.on('reseted', function (args) {
        _this2.onReset(args.current);

        _this2.notify('reseted', args);
      });
      collection.on('added', function (args) {
        var cell = args.cell;

        _this2.onCellAdded(cell);
      });
      collection.on('removed', function (args) {
        var cell = args.cell;

        _this2.onCellRemoved(cell, args.options); // Should trigger remove-event manually after cell was removed.


        _this2.notify('cell:removed', args);

        if (cell.isNode()) {
          _this2.notify('node:removed', Object.assign(Object.assign({}, args), {
            node: cell
          }));
        } else if (cell.isEdge()) {
          _this2.notify('edge:removed', Object.assign(Object.assign({}, args), {
            edge: cell
          }));
        }
      });
    }
  }, {
    key: "onReset",
    value: function onReset(cells) {
      var _this3 = this;

      this.nodes = {};
      this.edges = {};
      cells.forEach(function (cell) {
        return _this3.onCellAdded(cell);
      });
    }
  }, {
    key: "sortOnChangeZ",
    value: function sortOnChangeZ() {
      this.collection.sort();
    }
  }, {
    key: "onCellAdded",
    value: function onCellAdded(cell) {
      var cellId = cell.id;

      if (cell.isEdge()) {
        this.edges[cellId] = true;
      } else {
        this.nodes[cellId] = true;
      }
    }
  }, {
    key: "onCellRemoved",
    value: function onCellRemoved(cell, options) {
      var cellId = cell.id;

      if (cell.isEdge()) {
        delete this.edges[cellId];
      } else {
        delete this.nodes[cellId];
      }

      this.afterCellRemoved(cell, options);
    }
  }, {
    key: "afterCellRemoved",
    value: function afterCellRemoved(cell, options) {
      if (!options.clear) {
        if (options.disconnectEdges) {
          this.disconnectEdges(cell, options);
        } else {
          this.removeConnectedEdges(cell, options);
        }
      }

      if (cell.model === this) {
        cell.model = null;
      }
    }
  }, {
    key: "prepareCell",
    value: function prepareCell(cell, options) {
      if (!cell.model && (!options || !options.dryrun)) {
        // A cell can not be member of more than one graph.
        // A cell stops being the member of the graph after it's removed.
        cell.model = this;
      }

      if (cell.zIndex == null) {
        cell.zIndex = this.getMaxZIndex() + 1;
      }

      return cell;
    }
  }, {
    key: "resetCells",
    value: function resetCells(cells) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // Do not update model at this time. Because if we just update the graph
      // with the same json-data, the edge will reference to the old nodes.
      cells.map(function (cell) {
        return _this4.prepareCell(cell, Object.assign(Object.assign({}, options), {
          dryrun: true
        }));
      });
      this.collection.reset(cells, options); // Update model and trigger edge update it's references

      cells.map(function (cell) {
        return _this4.prepareCell(cell, {
          options: options
        });
      }); // cells.forEach((cell) => {
      //   if (cell.isEdge()) {
      //     // update reference
      //     cell.getSourceCell()
      //     cell.getTargetCell()
      //   }
      // })

      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var raw = this.getCells();

      if (raw.length === 0) {
        return this;
      }

      var localOptions = Object.assign(Object.assign({}, options), {
        clear: true
      });
      this.batchUpdate('clear', function () {
        // The nodes come after the edges.
        var cells = raw.sort(function (cell) {
          return cell.isEdge() ? 1 : 2;
        });

        while (cells.length > 0) {
          // Note that all the edges are removed first, so it's safe to
          // remove the nodes without removing the connected edges first.
          var cell = cells.shift();

          if (cell) {
            cell.remove(localOptions);
          }
        }
      }, localOptions);
      return this;
    }
  }, {
    key: "addNode",
    value: function addNode(metadata) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var node = metadata instanceof node_Node ? metadata : this.createNode(metadata);
      this.addCell(node, options);
      return node;
    }
  }, {
    key: "createNode",
    value: function createNode(metadata) {
      return node_Node.create(metadata);
    }
  }, {
    key: "addEdge",
    value: function addEdge(metadata) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var edge = metadata instanceof edge_Edge ? metadata : this.createEdge(metadata);
      this.addCell(edge, options);
      return edge;
    }
  }, {
    key: "createEdge",
    value: function createEdge(metadata) {
      return edge_Edge.create(metadata);
    }
  }, {
    key: "addCell",
    value: function addCell(cell) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (Array.isArray(cell)) {
        return this.addCells(cell, options);
      }

      if (!this.collection.has(cell) && !this.addings.has(cell)) {
        this.addings.set(cell, true);
        this.collection.add(this.prepareCell(cell, options), options);
        cell.eachChild(function (child) {
          return _this5.addCell(child, options);
        });
        this.addings.delete(cell);
      }

      return this;
    }
  }, {
    key: "addCells",
    value: function addCells(cells) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var count = cells.length;

      if (count === 0) {
        return this;
      }

      var localOptions = Object.assign(Object.assign({}, options), {
        position: count - 1,
        maxPosition: count - 1
      });
      this.startBatch('add', localOptions);
      cells.forEach(function (cell) {
        _this6.addCell(cell, localOptions);

        localOptions.position -= 1;
      });
      this.stopBatch('add', localOptions);
      return this;
    }
  }, {
    key: "removeCell",
    value: function removeCell(obj) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cell = typeof obj === 'string' ? this.getCell(obj) : obj;

      if (cell && this.has(cell)) {
        return this.collection.remove(cell, options);
      }

      return null;
    }
  }, {
    key: "removeCells",
    value: function removeCells(cells) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (cells.length) {
        return this.batchUpdate('remove', function () {
          return cells.map(function (cell) {
            return _this7.removeCell(cell, options);
          });
        });
      }

      return [];
    }
  }, {
    key: "removeConnectedEdges",
    value: function removeConnectedEdges(cell) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var edges = this.getConnectedEdges(cell);
      edges.forEach(function (edge) {
        edge.remove(options);
      });
      return edges;
    }
  }, {
    key: "disconnectEdges",
    value: function disconnectEdges(cell, options) {
      var cellId = typeof cell === 'string' ? cell : cell.id;
      this.getConnectedEdges(cell).forEach(function (edge) {
        var sourceCell = edge.getSourceCell();
        var targetCell = edge.getTargetCell();

        if (sourceCell && sourceCell.id === cellId) {
          edge.setSource({
            x: 0,
            y: 0
          }, options);
        }

        if (targetCell && targetCell.id === cellId) {
          edge.setTarget({
            x: 0,
            y: 0
          }, options);
        }
      });
    }
  }, {
    key: "has",
    value: function has(obj) {
      return this.collection.has(obj);
    }
  }, {
    key: "total",
    value: function total() {
      return this.collection.length;
    }
  }, {
    key: "indexOf",
    value: function indexOf(cell) {
      return this.collection.indexOf(cell);
    }
    /**
     * Returns a cell from the graph by its id.
     */

  }, {
    key: "getCell",
    value: function getCell(id) {
      return this.collection.get(id);
    }
    /**
     * Returns all the nodes and edges in the graph.
     */

  }, {
    key: "getCells",
    value: function getCells() {
      return this.collection.toArray();
    }
    /**
     * Returns the first cell (node or edge) in the graph. The first cell is
     * defined as the cell with the lowest `zIndex`.
     */

  }, {
    key: "getFirstCell",
    value: function getFirstCell() {
      return this.collection.first();
    }
    /**
     * Returns the last cell (node or edge) in the graph. The last cell is
     * defined as the cell with the highest `zIndex`.
     */

  }, {
    key: "getLastCell",
    value: function getLastCell() {
      return this.collection.last();
    }
    /**
     * Returns the lowest `zIndex` value in the graph.
     */

  }, {
    key: "getMinZIndex",
    value: function getMinZIndex() {
      var first = this.collection.first();
      return first ? first.getZIndex() || 0 : 0;
    }
    /**
     * Returns the highest `zIndex` value in the graph.
     */

  }, {
    key: "getMaxZIndex",
    value: function getMaxZIndex() {
      var last = this.collection.last();
      return last ? last.getZIndex() || 0 : 0;
    }
  }, {
    key: "getCellsFromCache",
    value: function getCellsFromCache(cache) {
      var _this8 = this;

      return cache ? Object.keys(cache).map(function (id) {
        return _this8.getCell(id);
      }).filter(function (cell) {
        return cell != null;
      }) : [];
    }
    /**
     * Returns all the nodes in the graph.
     */

  }, {
    key: "getNodes",
    value: function getNodes() {
      return this.getCellsFromCache(this.nodes);
    }
    /**
     * Returns all the edges in the graph.
     */

  }, {
    key: "getEdges",
    value: function getEdges() {
      return this.getCellsFromCache(this.edges);
    }
    /**
     * Returns all outgoing edges for the node.
     */

  }, {
    key: "getOutgoingEdges",
    value: function getOutgoingEdges(cell) {
      var node = typeof cell === 'string' ? this.getCell(cell) : cell;
      return node.getOutgoingEdges();
    }
    /**
     * Returns all incoming edges for the node.
     */

  }, {
    key: "getIncomingEdges",
    value: function getIncomingEdges(cell) {
      var node = typeof cell === 'string' ? this.getCell(cell) : cell;
      return node.getIncomingEdges();
    }
    /**
     * Returns edges connected with cell.
     */

  }, {
    key: "getConnectedEdges",
    value: function getConnectedEdges(cell) {
      var _this9 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var result = [];
      var node = typeof cell === 'string' ? this.getCell(cell) : cell;

      if (node == null) {
        return result;
      }

      var cache = {};
      var indirect = options.indirect;
      var incoming = options.incoming;
      var outgoing = options.outgoing;

      if (incoming == null && outgoing == null) {
        incoming = outgoing = true;
      }

      var collect = function collect(cell, isOutgoing) {
        var edges = isOutgoing ? _this9.getOutgoingEdges(cell) : _this9.getIncomingEdges(cell);

        if (edges != null) {
          edges.forEach(function (edge) {
            if (cache[edge.id]) {
              return;
            }

            result.push(edge);
            cache[edge.id] = true;

            if (indirect) {
              if (incoming) {
                collect(edge, false);
              }

              if (outgoing) {
                collect(edge, true);
              }
            }
          });
        }

        if (indirect && cell.isEdge()) {
          var terminal = isOutgoing ? cell.getTargetCell() : cell.getSourceCell();

          if (terminal && terminal.isEdge()) {
            if (!cache[terminal.id]) {
              result.push(terminal);
              collect(terminal, isOutgoing);
            }
          }
        }
      };

      if (outgoing) {
        collect(node, true);
      }

      if (incoming) {
        collect(node, false);
      }

      if (options.deep) {
        var descendants = node.getDescendants({
          deep: true
        });
        var embedsCache = {};
        descendants.forEach(function (cell) {
          if (cell.isNode()) {
            embedsCache[cell.id] = true;
          }
        });

        var collectSub = function collectSub(cell, isOutgoing) {
          var edges = isOutgoing ? _this9.getOutgoingEdges(cell.id) : _this9.getIncomingEdges(cell.id);

          if (edges != null) {
            edges.forEach(function (edge) {
              if (!cache[edge.id]) {
                var sourceCell = edge.getSourceCell();
                var targetCell = edge.getTargetCell();

                if (!options.enclosed && sourceCell && embedsCache[sourceCell.id] && targetCell && embedsCache[targetCell.id]) {
                  return;
                }

                result.push(edge);
                cache[edge.id] = true;
              }
            });
          }
        };

        descendants.forEach(function (cell) {
          if (cell.isEdge()) {
            return;
          }

          if (outgoing) {
            collectSub(cell, true);
          }

          if (incoming) {
            collectSub(cell, false);
          }
        });
      }

      return result;
    }
  }, {
    key: "isBoundary",
    value: function isBoundary(cell, isOrigin) {
      var node = typeof cell === 'string' ? this.getCell(cell) : cell;
      var arr = isOrigin ? node.getIncomingEdges() : node.getOutgoingEdges();
      return arr == null || arr.length === 0;
    }
  }, {
    key: "getBoundaryNodes",
    value: function getBoundaryNodes(isOrigin) {
      var _this10 = this;

      var result = [];
      Object.keys(this.nodes).forEach(function (nodeId) {
        if (_this10.isBoundary(nodeId, isOrigin)) {
          var node = _this10.getCell(nodeId);

          if (node) {
            result.push(node);
          }
        }
      });
      return result;
    }
    /**
     * Returns an array of all the roots of the graph.
     */

  }, {
    key: "getRoots",
    value: function getRoots() {
      return this.getBoundaryNodes(true);
    }
    /**
     * Returns an array of all the leafs of the graph.
     */

  }, {
    key: "getLeafs",
    value: function getLeafs() {
      return this.getBoundaryNodes(false);
    }
    /**
     * Returns `true` if the node is a root node, i.e. there is no edges
     * coming to the node.
     */

  }, {
    key: "isOrigin",
    value: function isOrigin(cell) {
      return this.isBoundary(cell, true);
    }
    /**
     * Returns `true` if the node is a leaf node, i.e. there is no edges
     * going out from the node.
     */

  }, {
    key: "isLeaf",
    value: function isLeaf(cell) {
      return this.isBoundary(cell, false);
    }
    /**
     * Returns all the neighbors of node in the graph. Neighbors are all
     * the nodes connected to node via either incoming or outgoing edge.
     */

  }, {
    key: "getNeighbors",
    value: function getNeighbors(cell) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var incoming = options.incoming;
      var outgoing = options.outgoing;

      if (incoming == null && outgoing == null) {
        incoming = outgoing = true;
      }

      var edges = this.getConnectedEdges(cell, options);
      var map = edges.reduce(function (memo, edge) {
        var hasLoop = edge.hasLoop(options);
        var sourceCell = edge.getSourceCell();
        var targetCell = edge.getTargetCell();

        if (incoming && sourceCell && sourceCell.isNode() && !memo[sourceCell.id]) {
          if (hasLoop || sourceCell !== cell && (!options.deep || !sourceCell.isDescendantOf(cell))) {
            memo[sourceCell.id] = sourceCell;
          }
        }

        if (outgoing && targetCell && targetCell.isNode() && !memo[targetCell.id]) {
          if (hasLoop || targetCell !== cell && (!options.deep || !targetCell.isDescendantOf(cell))) {
            memo[targetCell.id] = targetCell;
          }
        }

        return memo;
      }, {});

      if (cell.isEdge()) {
        if (incoming) {
          var sourceCell = cell.getSourceCell();

          if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {
            map[sourceCell.id] = sourceCell;
          }
        }

        if (outgoing) {
          var targetCell = cell.getTargetCell();

          if (targetCell && targetCell.isNode() && !map[targetCell.id]) {
            map[targetCell.id] = targetCell;
          }
        }
      }

      return Object.keys(map).map(function (id) {
        return map[id];
      });
    }
    /**
     * Returns `true` if `cell2` is a neighbor of `cell1`.
     */

  }, {
    key: "isNeighbor",
    value: function isNeighbor(cell1, cell2) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var incoming = options.incoming;
      var outgoing = options.outgoing;

      if (incoming == null && outgoing == null) {
        incoming = outgoing = true;
      }

      return this.getConnectedEdges(cell1, options).some(function (edge) {
        var sourceCell = edge.getSourceCell();
        var targetCell = edge.getTargetCell();

        if (incoming && sourceCell && sourceCell.id === cell2.id) {
          return true;
        }

        if (outgoing && targetCell && targetCell.id === cell2.id) {
          return true;
        }
      });
    }
  }, {
    key: "getSuccessors",
    value: function getSuccessors(cell, options) {
      var descendants = [];
      this.search(cell, function (curr) {
        if (curr !== cell) {
          descendants.push(curr);
        }
      }, Object.assign(Object.assign({}, options), {
        outgoing: true
      }));
      return descendants;
    }
    /**
     * Returns `true` if `cell2` is a successor of `cell1`.
     */

  }, {
    key: "isSuccessor",
    value: function isSuccessor(cell1, cell2) {
      var result = false;
      this.search(cell1, function (curr) {
        if (curr === cell2 && curr !== cell1) {
          result = true;
          return false;
        }
      }, {
        outgoing: true
      });
      return result;
    }
  }, {
    key: "getPredecessors",
    value: function getPredecessors(cell, options) {
      var ancestors = [];
      this.search(cell, function (curr) {
        if (curr !== cell) {
          ancestors.push(curr);
        }
      }, Object.assign(Object.assign({}, options), {
        incoming: true
      }));
      return ancestors;
    }
    /**
     * Returns `true` if `cell2` is a predecessor of `cell1`.
     */

  }, {
    key: "isPredecessor",
    value: function isPredecessor(cell1, cell2) {
      var result = false;
      this.search(cell1, function (curr) {
        if (curr === cell2 && curr !== cell1) {
          result = true;
          return false;
        }
      }, {
        incoming: true
      });
      return result;
    }
    /**
     * Returns the common ancestor of the passed cells.
     */

  }, {
    key: "getCommonAncestor",
    value: function getCommonAncestor() {
      return cell_Cell.getCommonAncestor.apply(cell_Cell, arguments);
    }
    /**
     * Returns an array of cells that result from finding nodes/edges that
     * are connected to any of the cells in the cells array. This function
     * loops over cells and if the current cell is a edge, it collects its
     * source/target nodes; if it is an node, it collects its incoming and
     * outgoing edges if both the edge terminal (source/target) are in the
     * cells array.
     */

  }, {
    key: "getSubGraph",
    value: function getSubGraph(cells) {
      var _this11 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var subgraph = [];
      var cache = {};
      var nodes = [];
      var edges = [];

      var collect = function collect(cell) {
        if (!cache[cell.id]) {
          subgraph.push(cell);
          cache[cell.id] = cell;

          if (cell.isEdge()) {
            edges.push(cell);
          }

          if (cell.isNode()) {
            nodes.push(cell);
          }
        }
      };

      cells.forEach(function (cell) {
        collect(cell);

        if (options.deep) {
          var descendants = cell.getDescendants({
            deep: true
          });
          descendants.forEach(function (descendant) {
            return collect(descendant);
          });
        }
      });
      edges.forEach(function (edge) {
        // For edges, include their source & target
        var sourceCell = edge.getSourceCell();
        var targetCell = edge.getTargetCell();

        if (sourceCell && !cache[sourceCell.id]) {
          subgraph.push(sourceCell);
          cache[sourceCell.id] = sourceCell;

          if (sourceCell.isNode()) {
            nodes.push(sourceCell);
          }
        }

        if (targetCell && !cache[targetCell.id]) {
          subgraph.push(targetCell);
          cache[targetCell.id] = targetCell;

          if (targetCell.isNode()) {
            nodes.push(targetCell);
          }
        }
      });
      nodes.forEach(function (node) {
        // For nodes, include their connected edges if their source/target
        // is in the subgraph.
        var edges = _this11.getConnectedEdges(node, options);

        edges.forEach(function (edge) {
          var sourceCell = edge.getSourceCell();
          var targetCell = edge.getTargetCell();

          if (!cache[edge.id] && sourceCell && cache[sourceCell.id] && targetCell && cache[targetCell.id]) {
            subgraph.push(edge);
            cache[edge.id] = edge;
          }
        });
      });
      return subgraph;
    }
    /**
     * Clones the whole subgraph (including all the connected links whose
     * source/target is in the subgraph). If `options.deep` is `true`, also
     * take into account all the embedded cells of all the subgraph cells.
     *
     * Returns a map of the form: { [original cell ID]: [clone] }.
     */

  }, {
    key: "cloneSubGraph",
    value: function cloneSubGraph(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var subgraph = this.getSubGraph(cells, options);
      return this.cloneCells(subgraph);
    }
  }, {
    key: "cloneCells",
    value: function cloneCells(cells) {
      return cell_Cell.cloneCells(cells);
    }
  }, {
    key: "getNodesFromPoint",
    value: function getNodesFromPoint(x, y) {
      var p = typeof x === 'number' ? {
        x: x,
        y: y || 0
      } : x;
      return this.getNodes().filter(function (node) {
        return node.getBBox().containsPoint(p);
      });
    }
  }, {
    key: "getNodesInArea",
    value: function getNodesInArea(x, y, w, h, options) {
      var rect = typeof x === 'number' ? new rectangle_Rectangle(x, y, w, h) : rectangle_Rectangle.create(x);
      var opts = typeof x === 'number' ? options : y;
      var strict = opts && opts.strict;
      return this.getNodes().filter(function (node) {
        var bbox = node.getBBox();
        return strict ? rect.containsRect(bbox) : rect.isIntersectWith(bbox);
      });
    }
  }, {
    key: "getNodesUnderNode",
    value: function getNodesUnderNode(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var bbox = node.getBBox();
      var nodes = options.by == null || options.by === 'bbox' ? this.getNodesInArea(bbox) : this.getNodesFromPoint(bbox[options.by]);
      return nodes.filter(function (curr) {
        return node.id !== curr.id && !curr.isDescendantOf(node);
      });
    }
    /**
     * Returns the bounding box that surrounds all cells in the graph.
     */

  }, {
    key: "getAllCellsBBox",
    value: function getAllCellsBBox() {
      return this.getCellsBBox(this.getCells());
    }
    /**
     * Returns the bounding box that surrounds all the given cells.
     */

  }, {
    key: "getCellsBBox",
    value: function getCellsBBox(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return cell_Cell.getCellsBBox(cells, options);
    } // #region search

  }, {
    key: "search",
    value: function search(cell, iterator) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (options.breadthFirst) {
        this.breadthFirstSearch(cell, iterator, options);
      } else {
        this.depthFirstSearch(cell, iterator, options);
      }
    }
  }, {
    key: "breadthFirstSearch",
    value: function breadthFirstSearch(cell, iterator) {
      var _this12 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var queue = [];
      var visited = {};
      var distance = {};
      queue.push(cell);
      distance[cell.id] = 0;

      var _loop = function _loop() {
        var next = queue.shift();

        if (next == null || visited[next.id]) {
          return "continue";
        }

        visited[next.id] = true;

        if (main_namespaceObject.call(iterator, _this12, next, distance[next.id]) === false) {
          return "continue";
        }

        var neighbors = _this12.getNeighbors(next, options);

        neighbors.forEach(function (neighbor) {
          distance[neighbor.id] = distance[next.id] + 1;
          queue.push(neighbor);
        });
      };

      while (queue.length > 0) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }
    }
  }, {
    key: "depthFirstSearch",
    value: function depthFirstSearch(cell, iterator) {
      var _this13 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var queue = [];
      var visited = {};
      var distance = {};
      queue.push(cell);
      distance[cell.id] = 0;

      var _loop2 = function _loop2() {
        var next = queue.pop();

        if (next == null || visited[next.id]) {
          return "continue";
        }

        visited[next.id] = true;

        if (main_namespaceObject.call(iterator, _this13, next, distance[next.id]) === false) {
          return "continue";
        }

        var neighbors = _this13.getNeighbors(next, options);

        var lastIndex = queue.length;
        neighbors.forEach(function (neighbor) {
          distance[neighbor.id] = distance[next.id] + 1;
          queue.splice(lastIndex, 0, neighbor);
        });
      };

      while (queue.length > 0) {
        var _ret2 = _loop2();

        if (_ret2 === "continue") continue;
      }
    } // #endregion
    // #region shortest path

    /***
     * Returns an array of IDs of nodes on the shortest
     * path between source and target.
     */

  }, {
    key: "getShortestPath",
    value: function getShortestPath(source, target) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var adjacencyList = {};
      this.getEdges().forEach(function (edge) {
        var sourceId = edge.getSourceCellId();
        var targetId = edge.getTargetCellId();

        if (sourceId && targetId) {
          if (!adjacencyList[sourceId]) {
            adjacencyList[sourceId] = [];
          }

          if (!adjacencyList[targetId]) {
            adjacencyList[targetId] = [];
          }

          adjacencyList[sourceId].push(targetId);

          if (!options.directed) {
            adjacencyList[targetId].push(sourceId);
          }
        }
      });
      var sourceId = typeof source === 'string' ? source : source.id;
      var previous = dijkstra_Dijkstra.run(adjacencyList, sourceId, options.weight);
      var path = [];
      var targetId = typeof target === 'string' ? target : target.id;

      if (previous[targetId]) {
        path.push(targetId);
      }

      while (targetId = previous[targetId]) {
        path.unshift(targetId);
      }

      return path;
    } // #endregion
    // #region transform

    /**
     * Translate all cells in the graph by `tx` and `ty` pixels.
     */

  }, {
    key: "translate",
    value: function translate(tx, ty, options) {
      this.getCells().filter(function (cell) {
        return !cell.hasParent();
      }).forEach(function (cell) {
        return cell.translate(tx, ty, options);
      });
      return this;
    }
  }, {
    key: "resize",
    value: function resize(width, height, options) {
      return this.resizeCells(width, height, this.getCells(), options);
    }
  }, {
    key: "resizeCells",
    value: function resizeCells(width, height, cells) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var bbox = this.getCellsBBox(cells);

      if (bbox) {
        var sx = Math.max(width / bbox.width, 0);
        var sy = Math.max(height / bbox.height, 0);
        var origin = bbox.getOrigin();
        cells.forEach(function (cell) {
          return cell.scale(sx, sy, origin, options);
        });
      }

      return this;
    } // #endregion
    // #region serialize/deserialize

  }, {
    key: "toJSON",
    value: function toJSON() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return Model.toJSON(this.getCells(), options);
    }
  }, {
    key: "parseJSON",
    value: function parseJSON(data) {
      return Model.fromJSON(data);
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cells = this.parseJSON(data);
      this.resetCells(cells, options);
      return this;
    } // #endregion
    // #region batch

  }, {
    key: "startBatch",
    value: function startBatch(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.batches[name] = (this.batches[name] || 0) + 1;
      this.notify('batch:start', {
        name: name,
        data: data
      });
      return this;
    }
  }, {
    key: "stopBatch",
    value: function stopBatch(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.batches[name] = (this.batches[name] || 0) - 1;
      this.notify('batch:stop', {
        name: name,
        data: data
      });
      return this;
    }
  }, {
    key: "batchUpdate",
    value: function batchUpdate(name, execute) {
      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.startBatch(name, data);
      var result = execute();
      this.stopBatch(name, data);
      return result;
    }
  }, {
    key: "hasActiveBatch",
    value: function hasActiveBatch() {
      var _this14 = this;

      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(this.batches);
      var names = Array.isArray(name) ? name : [name];
      return names.some(function (batch) {
        return _this14.batches[batch] > 0;
      });
    }
  }]);

  return Model;
}(basecoat_Basecoat);

(function (Model) {
  function toJSON(cells) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return {
      cells: cells.map(function (cell) {
        return cell.toJSON(options);
      })
    };
  }

  Model.toJSON = toJSON;

  function fromJSON(data) {
    var cells = [];

    if (Array.isArray(data)) {
      cells.push.apply(cells, Object(toConsumableArray["a" /* default */])(data));
    } else {
      if (data.cells) {
        cells.push.apply(cells, Object(toConsumableArray["a" /* default */])(data.cells));
      }

      if (data.nodes) {
        data.nodes.forEach(function (node) {
          if (node.shape == null) {
            node.shape = 'rect';
          }

          cells.push(node);
        });
      }

      if (data.edges) {
        data.edges.forEach(function (edge) {
          if (edge.shape == null) {
            edge.shape = 'edge';
          }

          cells.push(edge);
        });
      }
    }

    return cells.map(function (cell) {
      var type = cell.shape;

      if (type) {
        if (node_Node.registry.exist(type)) {
          return node_Node.create(cell);
        }

        if (edge_Edge.registry.exist(type)) {
          return edge_Edge.create(cell);
        }
      }

      throw new Error('The `shape` should be specipied when creating a node/edge instance');
    });
  }

  Model.fromJSON = fromJSON;
})(model_Model || (model_Model = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/model/index.js





// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/view/edge.js














var edge_EdgeView = /*#__PURE__*/function (_CellView) {
  Object(inherits["a" /* default */])(EdgeView, _CellView);

  var _super = Object(createSuper["a" /* default */])(EdgeView);

  function EdgeView() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, EdgeView);

    _this = _super.apply(this, arguments);
    _this.POINT_ROUNDING = 2;
    _this.markerCache = {}; // #endregion
    // #endregion

    return _this;
  }

  Object(createClass["a" /* default */])(EdgeView, [{
    key: "getContainerClassName",
    value: function getContainerClassName() {
      return [Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "getContainerClassName", this).call(this), this.prefixClassName('edge')].join(' ');
    }
  }, {
    key: "isEdgeView",
    value: function isEdgeView() {
      return true;
    }
  }, {
    key: "confirmUpdate",
    value: function confirmUpdate(flag) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var ref = flag;

      if (this.hasAction(ref, 'source')) {
        if (!this.updateTerminalProperties('source')) {
          return ref;
        }

        ref = this.removeAction(ref, 'source');
      }

      if (this.hasAction(ref, 'target')) {
        if (!this.updateTerminalProperties('target')) {
          return ref;
        }

        ref = this.removeAction(ref, 'target');
      }

      var graph = this.graph;
      var sourceView = this.sourceView;
      var targetView = this.targetView;

      if (graph && (sourceView && !graph.renderer.isViewMounted(sourceView) || targetView && !graph.renderer.isViewMounted(targetView))) {
        // Wait for the sourceView and targetView to be rendered.
        return ref;
      }

      if (this.hasAction(ref, 'render')) {
        this.render();
        ref = this.removeAction(ref, ['render', 'update', 'vertices', 'labels', 'tools']);
        return ref;
      }

      ref = this.handleAction(ref, 'vertices', function () {
        return _this2.renderVertexMarkers();
      });
      ref = this.handleAction(ref, 'update', function () {
        return _this2.update(null, options);
      });
      ref = this.handleAction(ref, 'labels', function () {
        return _this2.onLabelsChange(options);
      });
      ref = this.handleAction(ref, 'tools', function () {
        return _this2.renderTools().updateToolsPosition();
      });
      return ref;
    }
  }, {
    key: "onLabelsChange",
    value: function onLabelsChange() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // Note: this optimization works in async=false mode only
      if (this.shouldRerenderLabels(options)) {
        this.renderLabels();
      } else {
        this.updateLabels();
      }

      this.updateLabelPositions();
    }
  }, {
    key: "shouldRerenderLabels",
    value: function shouldRerenderLabels() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var previousLabels = this.cell.previous('labels');

      if (previousLabels == null) {
        return true;
      } // Here is an optimization for cases when we know, that change does
      // not require re-rendering of all labels.


      if ('propertyPathArray' in options && 'propertyValue' in options) {
        // The label is setting by `prop()` method
        var pathArray = options.propertyPathArray || [];
        var pathLength = pathArray.length;

        if (pathLength > 1) {
          // We are changing a single label here e.g. 'labels/0/position'
          var index = pathArray[1];

          if (previousLabels[index]) {
            if (pathLength === 2) {
              // We are changing the entire label. Need to check if the
              // markup is also being changed.
              return typeof options.propertyValue === 'object' && object_namespaceObject.has(options.propertyValue, 'markup');
            } // We are changing a label property but not the markup


            if (pathArray[2] !== 'markup') {
              return false;
            }
          }
        }
      }

      return true;
    }
  }, {
    key: "render",
    value: function render() {
      this.empty();
      this.containers = {};
      this.renderMarkup();
      this.renderLabels();
      this.update();
      return this;
    }
  }, {
    key: "renderMarkup",
    value: function renderMarkup() {
      var markup = this.cell.markup;

      if (markup) {
        if (typeof markup === 'string') {
          return this.renderStringMarkup(markup);
        }

        return this.renderJSONMarkup(markup);
      }

      throw new TypeError('Invalid edge markup.');
    }
  }, {
    key: "renderJSONMarkup",
    value: function renderJSONMarkup(markup) {
      var ret = this.parseJSONMarkup(markup, this.container);
      this.selectors = ret.selectors;
      this.container.append(ret.fragment);
    }
  }, {
    key: "renderStringMarkup",
    value: function renderStringMarkup(markup) {
      var cache = this.containers;
      var children = dom_main_namespaceObject.createVectors(markup); // Cache children elements for quicker access.

      children.forEach(function (child) {
        var className = child.attr('class');

        if (className) {
          cache[string_namespaceObject.camelCase(className)] = child.node;
        }
      });
      this.renderTools();
      this.renderVertexMarkers();
      this.renderArrowheadMarkers();
      dom_main_namespaceObject.append(this.container, children.map(function (child) {
        return child.node;
      }));
    }
  }, {
    key: "renderLabels",
    value: function renderLabels() {
      var edge = this.cell;
      var labels = edge.getLabels();
      var count = labels.length;
      var container = this.containers.labels;
      this.labelCache = {};
      this.labelSelectors = {};

      if (count <= 0) {
        if (container && container.parentNode) {
          container.parentNode.removeChild(container);
        }

        return this;
      }

      if (container) {
        this.empty(container);
      } else {
        container = dom_main_namespaceObject.createSvgElement('g');
        this.addClass(this.prefixClassName('edge-labels'), container);
        this.containers.labels = container;
      }

      for (var i = 0, ii = labels.length; i < ii; i += 1) {
        var label = labels[i];
        var normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));
        var labelNode = void 0;
        var selectors = void 0;

        if (normalized) {
          labelNode = normalized.node;
          selectors = normalized.selectors;
        } else {
          var defaultLabel = edge.getDefaultLabel();

          var _normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));

          labelNode = _normalized.node;
          selectors = _normalized.selectors;
        }

        labelNode.setAttribute('data-index', "".concat(i));
        container.appendChild(labelNode);
        var rootSelector = this.rootSelector;

        if (selectors[rootSelector]) {
          throw new Error('Ambiguous label root selector.');
        }

        selectors[rootSelector] = labelNode;
        this.labelCache[i] = labelNode;
        this.labelSelectors[i] = selectors;
      }

      if (container.parentNode == null) {
        this.container.appendChild(container);
      }

      this.updateLabels();
      this.customizeLabels();
      return this;
    }
  }, {
    key: "parseLabelMarkup",
    value: function parseLabelMarkup(markup) {
      if (markup) {
        if (typeof markup === 'string') {
          return this.parseLabelStringMarkup(markup);
        }

        return this.parseJSONMarkup(markup);
      }

      return null;
    }
  }, {
    key: "parseLabelStringMarkup",
    value: function parseLabelStringMarkup(labelMarkup) {
      var children = dom_main_namespaceObject.createVectors(labelMarkup);
      var fragment = document.createDocumentFragment();

      for (var i = 0, n = children.length; i < n; i += 1) {
        var currentChild = children[i].node;
        fragment.appendChild(currentChild);
      }

      return {
        fragment: fragment,
        selectors: {}
      };
    }
  }, {
    key: "normalizeLabelMarkup",
    value: function normalizeLabelMarkup(markup) {
      if (markup == null) {
        return;
      }

      var fragment = markup.fragment;

      if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {
        throw new Error('Invalid label markup.');
      }

      var vel;
      var childNodes = fragment.childNodes;

      if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {
        // default markup fragment is not wrapped in `<g/>`
        // add a `<g/>` container
        vel = dom_main_namespaceObject.createVector('g').append(fragment);
      } else {
        vel = dom_main_namespaceObject.createVector(childNodes[0]);
      }

      vel.addClass(this.prefixClassName('edge-label'));
      return {
        node: vel.node,
        selectors: markup.selectors
      };
    }
  }, {
    key: "updateLabels",
    value: function updateLabels() {
      if (this.containers.labels) {
        var edge = this.cell;
        var labels = edge.labels;
        var canLabelMove = this.can('edgeLabelMovable');
        var defaultLabel = edge.getDefaultLabel();

        for (var i = 0, n = labels.length; i < n; i += 1) {
          var elem = this.labelCache[i];
          var selectors = this.labelSelectors[i];
          elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');
          var label = labels[i];
          var attrs = object_namespaceObject.merge({}, defaultLabel.attrs, label.attrs);
          this.updateAttrs(elem, attrs, {
            selectors: selectors,
            rootBBox: label.size ? rectangle_Rectangle.fromSize(label.size) : undefined
          });
        }
      }
    }
  }, {
    key: "mergeLabelAttrs",
    value: function mergeLabelAttrs(hasCustomMarkup, labelAttrs, defaultLabelAttrs) {
      if (labelAttrs === null) {
        return null;
      }

      if (labelAttrs === undefined) {
        if (defaultLabelAttrs === null) {
          return null;
        }

        if (defaultLabelAttrs === undefined) {
          return undefined;
        }

        if (hasCustomMarkup) {
          return defaultLabelAttrs;
        }

        return object_namespaceObject.merge({}, defaultLabelAttrs);
      }

      if (hasCustomMarkup) {
        return object_namespaceObject.merge({}, defaultLabelAttrs, labelAttrs);
      }
    }
  }, {
    key: "customizeLabels",
    value: function customizeLabels() {
      if (this.containers.labels) {
        var edge = this.cell;
        var labels = edge.labels;

        for (var i = 0, n = labels.length; i < n; i += 1) {
          var label = labels[i];
          var container = this.labelCache[i];
          var selectors = this.labelSelectors[i];
          this.graph.hook.onEdgeLabelRendered({
            edge: edge,
            label: label,
            container: container,
            selectors: selectors
          });
        }
      }
    }
    /**
     * Tools are a group of clickable elements that manipulate the whole edge.
     * A good example of this is the remove tool that removes the whole edge.
     * Tools appear after hovering the edge close to the `source` element/point
     * of the edge but are offset a bit so that they don't cover the `marker-arrowhead`.
     */

  }, {
    key: "renderTools",
    value: function renderTools() {
      var container = this.containers.tools;

      if (container == null) {
        return this;
      }

      var markup = this.cell.toolMarkup;
      var $container = this.$(container).empty();

      if (markup_Markup.isStringMarkup(markup)) {
        var template = string_namespaceObject.template(markup);
        var tool = dom_main_namespaceObject.createVector(template());
        $container.append(tool.node);
        this.toolCache = tool.node; // If `doubleTools` is enabled, we render copy of the tools on the
        // other side of the edge as well but only if the edge is longer
        // than `longLength`.

        if (this.options.doubleTools) {
          var tool2;
          var doubleToolMarkup = this.cell.doubleToolMarkup;

          if (markup_Markup.isStringMarkup(doubleToolMarkup)) {
            template = string_namespaceObject.template(doubleToolMarkup);
            tool2 = dom_main_namespaceObject.createVector(template());
          } else {
            tool2 = tool.clone();
          }

          $container.append(tool2.node);
          this.tool2Cache = tool2.node;
        }
      }

      return this;
    }
  }, {
    key: "renderVertexMarkers",
    value: function renderVertexMarkers() {
      var container = this.containers.vertices;

      if (container == null) {
        return this;
      }

      var markup = this.cell.vertexMarkup;
      var $container = this.$(container).empty();

      if (markup_Markup.isStringMarkup(markup)) {
        var template = string_namespaceObject.template(markup);
        this.cell.getVertices().forEach(function (vertex, index) {
          $container.append(dom_main_namespaceObject.createVector(template(Object.assign({
            index: index
          }, vertex))).node);
        });
      }

      return this;
    }
  }, {
    key: "renderArrowheadMarkers",
    value: function renderArrowheadMarkers() {
      var container = this.containers.arrowheads;

      if (container == null) {
        return this;
      }

      var markup = this.cell.arrowheadMarkup;
      var $container = this.$(container).empty();

      if (markup_Markup.isStringMarkup(markup)) {
        var template = string_namespaceObject.template(markup);
        var sourceArrowhead = dom_main_namespaceObject.createVector(template({
          end: 'source'
        })).node;
        var targetArrowhead = dom_main_namespaceObject.createVector(template({
          end: 'target'
        })).node;
        this.containers.sourceArrowhead = sourceArrowhead;
        this.containers.targetArrowhead = targetArrowhead;
        $container.append(sourceArrowhead, targetArrowhead);
      }

      return this;
    } // #endregion
    // #region updating

  }, {
    key: "update",
    value: function update(partialAttrs) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.cleanCache();
      this.updateConnection(options);
      var attrs = this.cell.getAttrs();

      if (attrs != null) {
        this.updateAttrs(this.container, attrs, {
          attrs: partialAttrs === attrs ? null : partialAttrs,
          selectors: this.selectors
        });
      }

      this.updateConnectionPath();
      this.updateLabelPositions();
      this.updateToolsPosition();
      this.updateArrowheadMarkers();
      this.updateTools(options);
      return this;
    }
  }, {
    key: "removeRedundantLinearVertices",
    value: function removeRedundantLinearVertices() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var edge = this.cell;
      var vertices = edge.getVertices();
      var routePoints = [this.sourceAnchor].concat(Object(toConsumableArray["a" /* default */])(vertices), [this.targetAnchor]);
      var rawCount = routePoints.length; // Puts the route points into a polyline and try to simplify.

      var polyline = new polyline_Polyline(routePoints);
      polyline.simplify({
        threshold: 0.01
      });
      var simplifiedPoints = polyline.points.map(function (point) {
        return point.toJSON();
      });
      var simplifiedCount = simplifiedPoints.length; // If simplification did not remove any redundant vertices.

      if (rawCount === simplifiedCount) {
        return 0;
      } // Sets simplified polyline points as edge vertices.
      // Removes first and last polyline points again (source/target anchors).


      edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);
      return rawCount - simplifiedCount;
    }
  }, {
    key: "updateConnectionPath",
    value: function updateConnectionPath() {
      var containers = this.containers;

      if (containers.connection) {
        var pathData = this.getConnectionPathData();
        containers.connection.setAttribute('d', pathData);
      }

      if (containers.connectionWrap) {
        var _pathData = this.getConnectionPathData();

        containers.connectionWrap.setAttribute('d', _pathData);
      }

      if (containers.sourceMarker && containers.targetMarker) {
        this.translateAndAutoOrientArrows(containers.sourceMarker, containers.targetMarker);
      }
    }
  }, {
    key: "getTerminalView",
    value: function getTerminalView(type) {
      switch (type) {
        case 'source':
          return this.sourceView || null;

        case 'target':
          return this.targetView || null;

        default:
          throw new Error("Unknown terminal type '".concat(type, "'"));
      }
    }
  }, {
    key: "getTerminalAnchor",
    value: function getTerminalAnchor(type) {
      switch (type) {
        case 'source':
          return point_Point.create(this.sourceAnchor);

        case 'target':
          return point_Point.create(this.targetAnchor);

        default:
          throw new Error("Unknown terminal type '".concat(type, "'"));
      }
    }
  }, {
    key: "getTerminalConnectionPoint",
    value: function getTerminalConnectionPoint(type) {
      switch (type) {
        case 'source':
          return point_Point.create(this.sourcePoint);

        case 'target':
          return point_Point.create(this.targetPoint);

        default:
          throw new Error("Unknown terminal type '".concat(type, "'"));
      }
    }
  }, {
    key: "getTerminalMagnet",
    value: function getTerminalMagnet(type) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      switch (type) {
        case 'source':
          if (options.raw) {
            return this.sourceMagnet;
          }

          var sourceView = this.sourceView;

          if (!sourceView) {
            return null;
          }

          return this.sourceMagnet || sourceView.container;

        case 'target':
          if (options.raw) {
            return this.targetMagnet;
          }

          var targetView = this.targetView;

          if (!targetView) {
            return null;
          }

          return this.targetMagnet || targetView.container;

        default:
          throw new Error("Unknown terminal type '".concat(type, "'"));
      }
    }
  }, {
    key: "updateConnection",
    value: function updateConnection() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var edge = this.cell; // The edge is being translated by an ancestor that will shift
      // source, target and vertices by an equal distance.

      if (options.translateBy && edge.isFragmentDescendantOf(options.translateBy)) {
        var tx = options.tx || 0;
        var ty = options.ty || 0;
        this.routePoints = new polyline_Polyline(this.routePoints).translate(tx, ty).points;
        this.translateConnectionPoints(tx, ty);
        this.path.translate(tx, ty);
      } else {
        var vertices = edge.getVertices(); // 1. Find anchor points

        var anchors = this.findAnchors(vertices);
        this.sourceAnchor = anchors.source;
        this.targetAnchor = anchors.target; // 2. Find route points

        this.routePoints = this.findRoutePoints(vertices); // 3. Find connection points

        var connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
        this.sourcePoint = connectionPoints.source;
        this.targetPoint = connectionPoints.target; // 4. Find Marker Connection Point

        var markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint); // 5. Make path

        this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);
      }

      this.cleanCache();
    }
  }, {
    key: "findAnchors",
    value: function findAnchors(vertices) {
      var edge = this.cell;
      var source = edge.source;
      var target = edge.target;
      var firstVertex = vertices[0];
      var lastVertex = vertices[vertices.length - 1];

      if (target.priority && !source.priority) {
        // Reversed order
        return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);
      } // Usual order


      return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);
    }
  }, {
    key: "findAnchorsOrdered",
    value: function findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {
      var _ref;

      var firstAnchor;
      var secondAnchor;
      var edge = this.cell;
      var firstTerminal = edge[firstType];
      var secondTerminal = edge[secondType];
      var firstView = this.getTerminalView(firstType);
      var secondView = this.getTerminalView(secondType);
      var firstMagnet = this.getTerminalMagnet(firstType);
      var secondMagnet = this.getTerminalMagnet(secondType);

      if (firstView) {
        var firstRef;

        if (firstPoint) {
          firstRef = point_Point.create(firstPoint);
        } else if (secondView) {
          firstRef = secondMagnet;
        } else {
          firstRef = point_Point.create(secondTerminal);
        }

        firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);
      } else {
        firstAnchor = point_Point.create(firstTerminal);
      }

      if (secondView) {
        var secondRef = point_Point.create(secondPoint || firstAnchor);
        secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);
      } else {
        secondAnchor = point_Point.isPointLike(secondTerminal) ? point_Point.create(secondTerminal) : new point_Point();
      }

      return _ref = {}, Object(defineProperty["a" /* default */])(_ref, firstType, firstAnchor), Object(defineProperty["a" /* default */])(_ref, secondType, secondAnchor), _ref;
    }
  }, {
    key: "getAnchor",
    value: function getAnchor(def, cellView, magnet, ref, terminalType) {
      var isEdge = cellView.isEdgeElement(magnet);
      var connecting = this.graph.options.connecting;
      var config = typeof def === 'string' ? {
        name: def
      } : def;

      if (!config) {
        var defaults = isEdge ? (terminalType === 'source' ? connecting.sourceEdgeAnchor : connecting.targetEdgeAnchor) || connecting.edgeAnchor : (terminalType === 'source' ? connecting.sourceAnchor : connecting.targetAnchor) || connecting.anchor;
        config = typeof defaults === 'string' ? {
          name: defaults
        } : defaults;
      }

      if (!config) {
        throw new Error("Anchor should be specified.");
      }

      var anchor;
      var name = config.name;

      if (isEdge) {
        var fn = edge_anchor_EdgeAnchor.registry.get(name);

        if (typeof fn !== 'function') {
          return edge_anchor_EdgeAnchor.registry.onNotFound(name);
        }

        anchor = main_namespaceObject.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);
      } else {
        var _fn = node_anchor_NodeAnchor.registry.get(name);

        if (typeof _fn !== 'function') {
          return node_anchor_NodeAnchor.registry.onNotFound(name);
        }

        anchor = main_namespaceObject.call(_fn, this, cellView, magnet, ref, config.args || {}, terminalType);
      }

      return anchor ? anchor.round(this.POINT_ROUNDING) : new point_Point();
    }
  }, {
    key: "findRoutePoints",
    value: function findRoutePoints() {
      var vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var defaultRouter = this.graph.options.connecting.router || router_Router.presets.normal;
      var router = this.cell.getRouter() || defaultRouter;
      var routePoints;

      if (typeof router === 'function') {
        routePoints = main_namespaceObject.call(router, this, vertices, {}, this);
      } else {
        var name = typeof router === 'string' ? router : router.name;
        var args = typeof router === 'string' ? {} : router.args || {};
        var fn = name ? router_Router.registry.get(name) : router_Router.presets.normal;

        if (typeof fn !== 'function') {
          return router_Router.registry.onNotFound(name);
        }

        routePoints = main_namespaceObject.call(fn, this, vertices, args, this);
      }

      return routePoints == null ? vertices.map(function (p) {
        return point_Point.create(p);
      }) : routePoints.map(function (p) {
        return point_Point.create(p);
      });
    }
  }, {
    key: "findConnectionPoints",
    value: function findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {
      var edge = this.cell;
      var connecting = this.graph.options.connecting;
      var sourceTerminal = edge.getSource();
      var targetTerminal = edge.getTarget();
      var sourceView = this.sourceView;
      var targetView = this.targetView;
      var firstRoutePoint = routePoints[0];
      var lastRoutePoint = routePoints[routePoints.length - 1]; // source

      var sourcePoint;

      if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {
        var sourceMagnet = this.sourceMagnet || sourceView.container;
        var sourcePointRef = firstRoutePoint || targetAnchor;
        var sourceLine = new line_Line(sourcePointRef, sourceAnchor);
        var connectionPointDef = sourceTerminal.connectionPoint || connecting.sourceConnectionPoint || connecting.connectionPoint;
        sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');
      } else {
        sourcePoint = sourceAnchor;
      } // target


      var targetPoint;

      if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {
        var targetMagnet = this.targetMagnet || targetView.container;
        var targetConnectionPointDef = targetTerminal.connectionPoint || connecting.targetConnectionPoint || connecting.connectionPoint;
        var targetPointRef = lastRoutePoint || sourceAnchor;
        var targetLine = new line_Line(targetPointRef, targetAnchor);
        targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');
      } else {
        targetPoint = targetAnchor;
      }

      return {
        source: sourcePoint,
        target: targetPoint
      };
    }
  }, {
    key: "getConnectionPoint",
    value: function getConnectionPoint(def, view, magnet, line, endType) {
      var anchor = line.end;

      if (def == null) {
        return anchor;
      }

      var name = typeof def === 'string' ? def : def.name;
      var args = typeof def === 'string' ? {} : def.args;
      var fn = connection_point_ConnectionPoint.registry.get(name);

      if (typeof fn !== 'function') {
        return connection_point_ConnectionPoint.registry.onNotFound(name);
      }

      var connectionPoint = main_namespaceObject.call(fn, this, line, view, magnet, args || {}, endType);
      return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;
    }
  }, {
    key: "updateMarkerAttr",
    value: function updateMarkerAttr(type) {
      var attrs = this.cell.getAttrs();
      var key = ".".concat(type, "-marker");
      var partial = attrs && attrs[key];

      if (partial) {
        this.updateAttrs(this.container, {}, {
          attrs: Object(defineProperty["a" /* default */])({}, key, partial),
          selectors: this.selectors
        });
      }
    }
  }, {
    key: "findMarkerPoints",
    value: function findMarkerPoints(routePoints, sourcePoint, targetPoint) {
      var firstRoutePoint = routePoints[0];
      var lastRoutePoint = routePoints[routePoints.length - 1];
      var sourceMarkerElem = this.containers.sourceMarker;
      var targetMarkerElem = this.containers.targetMarker;
      var cache = this.markerCache;
      var sourceMarkerPoint;
      var targetMarkerPoint; // Move the source point by the width of the marker taking into
      // account its scale around x-axis. Note that scale is the only
      // transform that makes sense to be set in `.marker-source`
      // attributes object as all other transforms (translate/rotate)
      // will be replaced by the `translateAndAutoOrient()` function.

      if (sourceMarkerElem) {
        this.updateMarkerAttr('source'); // support marker connection point registry???

        cache.sourceBBox = cache.sourceBBox || dom_main_namespaceObject.getBBox(sourceMarkerElem);

        if (cache.sourceBBox.width > 0) {
          var scale = dom_main_namespaceObject.scale(sourceMarkerElem);
          sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, cache.sourceBBox.width * scale.sx * -1).round();
        }
      }

      if (targetMarkerElem) {
        this.updateMarkerAttr('target');
        cache.targetBBox = cache.targetBBox || dom_main_namespaceObject.getBBox(targetMarkerElem);

        if (cache.targetBBox.width > 0) {
          var _scale = dom_main_namespaceObject.scale(targetMarkerElem);

          targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, cache.targetBBox.width * _scale.sx * -1).round();
        }
      } // If there was no markup for the marker, use the connection point.


      cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();
      cache.targetPoint = targetMarkerPoint || targetPoint.clone();
      return {
        source: sourceMarkerPoint,
        target: targetMarkerPoint
      };
    }
  }, {
    key: "findPath",
    value: function findPath(routePoints, sourcePoint, targetPoint) {
      var def = this.cell.getConnector() || this.graph.options.connecting.connector;
      var name;
      var args;
      var fn;

      if (typeof def === 'string') {
        name = def;
      } else {
        name = def.name;
        args = def.args;
      }

      if (name) {
        var method = connector_Connector.registry.get(name);

        if (typeof method !== 'function') {
          return connector_Connector.registry.onNotFound(name);
        }

        fn = method;
      } else {
        fn = connector_Connector.presets.normal;
      }

      var path = main_namespaceObject.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), {
        raw: true
      }), this);
      return typeof path === 'string' ? path_Path.parse(path) : path;
    }
  }, {
    key: "translateConnectionPoints",
    value: function translateConnectionPoints(tx, ty) {
      var cache = this.markerCache;

      if (cache.sourcePoint) {
        cache.sourcePoint.translate(tx, ty);
      }

      if (cache.targetPoint) {
        cache.targetPoint.translate(tx, ty);
      }

      this.sourcePoint.translate(tx, ty);
      this.targetPoint.translate(tx, ty);
      this.sourceAnchor.translate(tx, ty);
      this.targetAnchor.translate(tx, ty);
    }
  }, {
    key: "updateLabelPositions",
    value: function updateLabelPositions() {
      if (this.containers.labels == null) {
        return this;
      }

      var path = this.path;

      if (!path) {
        return this;
      }

      var edge = this.cell;
      var labels = edge.getLabels();

      if (labels.length === 0) {
        return this;
      }

      var defaultLabel = edge.getDefaultLabel();
      var defaultPosition = this.normalizeLabelPosition(defaultLabel.position);

      for (var i = 0, ii = labels.length; i < ii; i += 1) {
        var label = labels[i];
        var labelPosition = this.normalizeLabelPosition(label.position);
        var pos = object_namespaceObject.merge({}, defaultPosition, labelPosition);
        var matrix = this.getLabelTransformationMatrix(pos);
        this.labelCache[i].setAttribute('transform', dom_main_namespaceObject.matrixToTransformString(matrix));
      }

      return this;
    }
  }, {
    key: "updateToolsPosition",
    value: function updateToolsPosition() {
      if (this.containers.tools == null) {
        return this;
      } // Move the tools a bit to the target position but don't cover the
      // `sourceArrowhead` marker. Note that the offset is hardcoded here.
      // The offset should be always more than the
      // `this.$('.marker-arrowhead[end="source"]')[0].bbox().width` but looking
      // this up all the time would be slow.


      var scale = '';
      var offset = this.options.toolsOffset;
      var connectionLength = this.getConnectionLength(); // Firefox returns `connectionLength=NaN` in odd cases (for bezier curves).
      // In that case we won't update tools position at all.

      if (connectionLength != null) {
        // If the edge is too short, make the tools half the
        // size and the offset twice as low.
        if (connectionLength < this.options.shortLength) {
          scale = 'scale(.5)';
          offset /= 2;
        }

        var pos = this.getPointAtLength(offset);

        if (pos != null) {
          dom_main_namespaceObject.attr(this.toolCache, 'transform', "translate(".concat(pos.x, ",").concat(pos.y, ") ").concat(scale));
        }

        if (this.options.doubleTools && connectionLength >= this.options.longLength) {
          var doubleToolsOffset = this.options.doubleToolsOffset || offset;
          pos = this.getPointAtLength(connectionLength - doubleToolsOffset);

          if (pos != null) {
            dom_main_namespaceObject.attr(this.tool2Cache, 'transform', "translate(".concat(pos.x, ",").concat(pos.y, ") ").concat(scale));
          }

          dom_main_namespaceObject.attr(this.tool2Cache, 'visibility', 'visible');
        } else if (this.options.doubleTools) {
          dom_main_namespaceObject.attr(this.tool2Cache, 'visibility', 'hidden');
        }
      }

      return this;
    }
  }, {
    key: "updateArrowheadMarkers",
    value: function updateArrowheadMarkers() {
      var container = this.containers.arrowheads;

      if (container == null) {
        return this;
      }

      if (container.style.display === 'none') {
        return this;
      }

      var sourceArrowhead = this.containers.sourceArrowhead;
      var targetArrowhead = this.containers.targetArrowhead;

      if (sourceArrowhead && targetArrowhead) {
        var len = this.getConnectionLength() || 0;
        var sx = len < this.options.shortLength ? 0.5 : 1;
        dom_main_namespaceObject.scale(sourceArrowhead, sx);
        dom_main_namespaceObject.scale(targetArrowhead, sx);
        this.translateAndAutoOrientArrows(sourceArrowhead, targetArrowhead);
      }

      return this;
    }
  }, {
    key: "updateTerminalProperties",
    value: function updateTerminalProperties(type) {
      var edge = this.cell;
      var graph = this.graph;
      var terminal = edge[type];
      var nodeId = terminal && terminal.cell;
      var viewKey = "".concat(type, "View"); // terminal is a point

      if (!nodeId) {
        this[viewKey] = null;
        this.updateTerminalMagnet(type);
        return true;
      }

      var terminalCell = graph.getCellById(nodeId);

      if (!terminalCell) {
        throw new Error("Edge's ".concat(type, " node with id \"").concat(nodeId, "\" not exists"));
      }

      var endView = terminalCell.findView(graph);

      if (!endView) {
        return false;
      }

      this[viewKey] = endView;
      this.updateTerminalMagnet(type);
      return true;
    }
  }, {
    key: "updateTerminalMagnet",
    value: function updateTerminalMagnet(type) {
      var propName = "".concat(type, "Magnet");
      var terminalView = this.getTerminalView(type);

      if (terminalView) {
        var magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);

        if (magnet === terminalView.container) {
          magnet = null;
        }

        this[propName] = magnet;
      } else {
        this[propName] = null;
      }
    }
  }, {
    key: "translateAndAutoOrientArrows",
    value: function translateAndAutoOrientArrows(sourceArrow, targetArrow) {
      var route = this.routePoints;

      if (sourceArrow) {
        dom_main_namespaceObject.translateAndAutoOrient(sourceArrow, this.sourcePoint, route[0] || this.targetPoint, this.graph.view.stage);
      }

      if (targetArrow) {
        dom_main_namespaceObject.translateAndAutoOrient(targetArrow, this.targetPoint, route[route.length - 1] || this.sourcePoint, this.graph.view.stage);
      }
    }
  }, {
    key: "getLabelPositionAngle",
    value: function getLabelPositionAngle(idx) {
      var label = this.cell.getLabelAt(idx);

      if (label && label.position && typeof label.position === 'object') {
        return label.position.angle || 0;
      }

      return 0;
    }
  }, {
    key: "getLabelPositionArgs",
    value: function getLabelPositionArgs(idx) {
      var label = this.cell.getLabelAt(idx);

      if (label && label.position && typeof label.position === 'object') {
        return label.position.options;
      }
    }
  }, {
    key: "getDefaultLabelPositionArgs",
    value: function getDefaultLabelPositionArgs() {
      var defaultLabel = this.cell.getDefaultLabel();

      if (defaultLabel && defaultLabel.position && typeof defaultLabel.position === 'object') {
        return defaultLabel.position.options;
      }
    } // merge default label position args into label position args
    // keep `undefined` or `null` because `{}` means something else

  }, {
    key: "mergeLabelPositionArgs",
    value: function mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {
      if (labelPositionArgs === null) {
        return null;
      }

      if (labelPositionArgs === undefined) {
        if (defaultLabelPositionArgs === null) {
          return null;
        }

        return defaultLabelPositionArgs;
      }

      return object_namespaceObject.merge({}, defaultLabelPositionArgs, labelPositionArgs);
    }
  }, {
    key: "addLabel",
    value: function addLabel(p1, p2, p3, options) {
      var localX;
      var localY;
      var localAngle = 0;
      var localOptions;

      if (typeof p1 !== 'number') {
        localX = p1.x;
        localY = p1.y;

        if (typeof p2 === 'number') {
          localAngle = p2;
          localOptions = p3;
        } else {
          localOptions = p2;
        }
      } else {
        localX = p1;
        localY = p2;

        if (typeof p3 === 'number') {
          localAngle = p3;
          localOptions = options;
        } else {
          localOptions = p3;
        }
      } // merge label position arguments


      var defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();
      var labelPositionArgs = localOptions;
      var positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs); // append label to labels array

      var label = {
        position: this.getLabelPosition(localX, localY, localAngle, positionArgs)
      };
      var index = -1;
      this.cell.insertLabel(label, index, localOptions);
      return index;
    }
  }, {
    key: "addVertex",
    value: function addVertex(x, y, options) {
      var isPoint = typeof x !== 'number';
      var localX = isPoint ? x.x : x;
      var localY = isPoint ? x.y : y;
      var localOptions = isPoint ? y : options;
      var vertex = {
        x: localX,
        y: localY
      };
      var index = this.getVertexIndex(localX, localY);
      this.cell.insertVertex(vertex, index, localOptions);
      return index;
    }
  }, {
    key: "sendToken",
    value: function sendToken(token, options, callback) {
      var duration;
      var reversed;
      var selector;

      if (typeof options === 'object') {
        duration = options.duration;
        reversed = options.reversed === true;
        selector = options.selector;
      } else {
        duration = options;
        reversed = false;
        selector = null;
      }

      duration = duration || 1000;
      var props = {
        dur: "".concat(duration, "ms"),
        repeatCount: '1',
        calcMode: 'linear',
        fill: 'freeze'
      };

      if (reversed) {
        props.keyPoints = '1;0';
        props.keyTimes = '0;1';
      }

      var path;

      if (typeof selector === 'string') {
        path = this.findOne(selector, this.container, this.selectors);
      } else {
        // Select connection path automatically.
        path = this.containers.connection ? this.containers.connection : this.container.querySelector('path');
      }

      if (!(path instanceof SVGPathElement)) {
        throw new Error('Token animation requires a valid connection path.');
      }

      var vToken = dom_main_namespaceObject.createVector(token);
      vToken.appendTo(this.graph.view.stage).animateAlongPath(props, path);
      setTimeout(function () {
        vToken.remove();

        if (typeof callback === 'function') {
          callback();
        }
      }, duration);
      return this;
    } // #endregion

  }, {
    key: "getConnection",
    value: function getConnection() {
      return this.path != null ? this.path.clone() : null;
    }
  }, {
    key: "getConnectionPathData",
    value: function getConnectionPathData() {
      if (this.path == null) {
        return '';
      }

      var cache = this.cache.pathCache;

      if (!object_namespaceObject.has(cache, 'data')) {
        cache.data = this.path.serialize();
      }

      return cache.data || '';
    }
  }, {
    key: "getConnectionSubdivisions",
    value: function getConnectionSubdivisions() {
      if (this.path == null) {
        return null;
      }

      var cache = this.cache.pathCache;

      if (!object_namespaceObject.has(cache, 'segmentSubdivisions')) {
        cache.segmentSubdivisions = this.path.getSegmentSubdivisions();
      }

      return cache.segmentSubdivisions;
    }
  }, {
    key: "getConnectionLength",
    value: function getConnectionLength() {
      if (this.path == null) {
        return 0;
      }

      var cache = this.cache.pathCache;

      if (!object_namespaceObject.has(cache, 'length')) {
        cache.length = this.path.length({
          segmentSubdivisions: this.getConnectionSubdivisions()
        });
      }

      return cache.length;
    }
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength(length) {
      if (this.path == null) {
        return null;
      }

      return this.path.pointAtLength(length, {
        segmentSubdivisions: this.getConnectionSubdivisions()
      });
    }
  }, {
    key: "getPointAtRatio",
    value: function getPointAtRatio(ratio) {
      if (this.path == null) {
        return null;
      }

      if (number_namespaceObject.isPercentage(ratio)) {
        // tslint:disable-next-line
        ratio = parseFloat(ratio) / 100;
      }

      return this.path.pointAt(ratio, {
        segmentSubdivisions: this.getConnectionSubdivisions()
      });
    }
  }, {
    key: "getTangentAtLength",
    value: function getTangentAtLength(length) {
      if (this.path == null) {
        return null;
      }

      return this.path.tangentAtLength(length, {
        segmentSubdivisions: this.getConnectionSubdivisions()
      });
    }
  }, {
    key: "getTangentAtRatio",
    value: function getTangentAtRatio(ratio) {
      if (this.path == null) {
        return null;
      }

      return this.path.tangentAt(ratio, {
        segmentSubdivisions: this.getConnectionSubdivisions()
      });
    }
  }, {
    key: "getClosestPoint",
    value: function getClosestPoint(point) {
      if (this.path == null) {
        return null;
      }

      return this.path.closestPoint(point, {
        segmentSubdivisions: this.getConnectionSubdivisions()
      });
    }
  }, {
    key: "getClosestPointLength",
    value: function getClosestPointLength(point) {
      if (this.path == null) {
        return null;
      }

      return this.path.closestPointLength(point, {
        segmentSubdivisions: this.getConnectionSubdivisions()
      });
    }
  }, {
    key: "getClosestPointRatio",
    value: function getClosestPointRatio(point) {
      if (this.path == null) {
        return null;
      }

      return this.path.closestPointNormalizedLength(point, {
        segmentSubdivisions: this.getConnectionSubdivisions()
      });
    }
  }, {
    key: "getLabelPosition",
    value: function getLabelPosition(x, y, p3, p4) {
      var pos = {
        distance: 0
      }; // normalize data from the two possible signatures

      var angle = 0;
      var options;

      if (typeof p3 === 'number') {
        angle = p3;
        options = p4;
      } else {
        options = p3;
      }

      if (options != null) {
        pos.options = options;
      } // identify distance/offset settings


      var isOffsetAbsolute = options && options.absoluteOffset;
      var isDistanceRelative = !(options && options.absoluteDistance);
      var isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance; // find closest point t

      var path = this.path;
      var pathOptions = {
        segmentSubdivisions: this.getConnectionSubdivisions()
      };
      var labelPoint = new point_Point(x, y);
      var t = path.closestPointT(labelPoint, pathOptions); // distance

      var totalLength = this.getConnectionLength() || 0;
      var labelDistance = path.lengthAtT(t, pathOptions);

      if (isDistanceRelative) {
        labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;
      }

      if (isDistanceAbsoluteReverse) {
        // fix for end point (-0 => 1)
        labelDistance = -1 * (totalLength - labelDistance) || 1;
      }

      pos.distance = labelDistance; // offset
      // use absolute offset if:
      // - options.absoluteOffset is true,
      // - options.absoluteOffset is not true but there is no tangent

      var tangent;
      if (!isOffsetAbsolute) tangent = path.tangentAtT(t);
      var labelOffset;

      if (tangent) {
        labelOffset = tangent.pointOffset(labelPoint);
      } else {
        var closestPoint = path.pointAtT(t);
        var labelOffsetDiff = labelPoint.diff(closestPoint);
        labelOffset = {
          x: labelOffsetDiff.x,
          y: labelOffsetDiff.y
        };
      }

      pos.offset = labelOffset;
      pos.angle = angle;
      return pos;
    }
  }, {
    key: "normalizeLabelPosition",
    value: function normalizeLabelPosition(pos) {
      if (typeof pos === 'number') {
        return {
          distance: pos
        };
      }

      return pos;
    }
  }, {
    key: "getLabelTransformationMatrix",
    value: function getLabelTransformationMatrix(labelPosition) {
      var pos = this.normalizeLabelPosition(labelPosition);
      var options = pos.options || {};
      var labelAngle = pos.angle || 0;
      var labelDistance = pos.distance;
      var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;
      var labelOffset = 0;
      var offsetCoord = {
        x: 0,
        y: 0
      };
      var offset = pos.offset;

      if (offset) {
        if (typeof offset === 'number') {
          labelOffset = offset;
        } else {
          if (offset.x != null) {
            offsetCoord.x = offset.x;
          }

          if (offset.y != null) {
            offsetCoord.y = offset.y;
          }
        }
      }

      var isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;
      var isKeepGradient = options.keepGradient;
      var isEnsureLegibility = options.ensureLegibility;
      var path = this.path;
      var pathOpt = {
        segmentSubdivisions: this.getConnectionSubdivisions()
      };
      var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;
      var tangent = path.tangentAtLength(distance, pathOpt);
      var translation;
      var angle = labelAngle;

      if (tangent) {
        if (isOffsetAbsolute) {
          translation = tangent.start;
          translation.translate(offsetCoord);
        } else {
          var normal = tangent.clone();
          normal.rotate(-90, tangent.start);
          normal.setLength(labelOffset);
          translation = normal.end;
        }

        if (isKeepGradient) {
          angle = tangent.angle() + labelAngle;

          if (isEnsureLegibility) {
            angle = Angle.normalize((angle + 90) % 180 - 90);
          }
        }
      } else {
        // fallback - the connection has zero length
        translation = path.start;

        if (isOffsetAbsolute) {
          translation.translate(offsetCoord);
        }
      }

      return dom_main_namespaceObject.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);
    }
  }, {
    key: "getLabelCoordinates",
    value: function getLabelCoordinates(pos) {
      var matrix = this.getLabelTransformationMatrix(pos);
      return new point_Point(matrix.e, matrix.f);
    }
  }, {
    key: "getVertexIndex",
    value: function getVertexIndex(x, y) {
      var edge = this.cell;
      var vertices = edge.getVertices();
      var vertexLength = this.getClosestPointLength(new point_Point(x, y));
      var index = 0;

      if (vertexLength != null) {
        for (var ii = vertices.length; index < ii; index += 1) {
          var currentVertex = vertices[index];
          var currentLength = this.getClosestPointLength(currentVertex);

          if (currentLength != null && vertexLength < currentLength) {
            break;
          }
        }
      }

      return index;
    }
  }, {
    key: "getEventArgs",
    value: function getEventArgs(e, x, y) {
      var view = this; // tslint:disable-line

      var edge = view.cell;
      var cell = edge;

      if (x == null || y == null) {
        return {
          e: e,
          view: view,
          edge: edge,
          cell: cell
        };
      }

      return {
        e: e,
        x: x,
        y: y,
        view: view,
        edge: edge,
        cell: cell
      };
    }
  }, {
    key: "notifyUnhandledMouseDown",
    value: function notifyUnhandledMouseDown(e, x, y) {
      this.notify('edge:unhandled:mousedown', {
        e: e,
        x: x,
        y: y,
        view: this,
        cell: this.cell,
        edge: this.cell
      });
    }
  }, {
    key: "notifyMouseDown",
    value: function notifyMouseDown(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onMouseDown", this).call(this, e, x, y);

      this.notify('edge:mousedown', this.getEventArgs(e, x, y));
    }
  }, {
    key: "notifyMouseMove",
    value: function notifyMouseMove(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onMouseMove", this).call(this, e, x, y);

      this.notify('edge:mousemove', this.getEventArgs(e, x, y));
    }
  }, {
    key: "notifyMouseUp",
    value: function notifyMouseUp(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onMouseUp", this).call(this, e, x, y);

      this.notify('edge:mouseup', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onClick",
    value: function onClick(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onClick", this).call(this, e, x, y);

      this.notify('edge:click', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onDblClick",
    value: function onDblClick(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onDblClick", this).call(this, e, x, y);

      this.notify('edge:dblclick', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onContextMenu",
    value: function onContextMenu(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onContextMenu", this).call(this, e, x, y);

      this.notify('edge:contextmenu', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(e, x, y) {
      this.notifyMouseDown(e, x, y);
      var className = e.target.getAttribute('class');

      switch (className) {
        case 'vertex':
          this.startVertexDragging(e, x, y);
          return;

        case 'vertex-remove':
        case 'vertex-remove-area':
          this.handleVertexRemoving(e, x, y);
          return;

        case 'connection':
        case 'connection-wrap':
          this.handleVertexAdding(e, x, y);
          return;

        case 'arrowhead':
          this.startArrowheadDragging(e, x, y);
          return;

        case 'source-marker':
        case 'target-marker':
          this.notifyUnhandledMouseDown(e, x, y);
          return;
      }

      this.startEdgeDragging(e, x, y);
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(e, x, y) {
      var data = this.getEventData(e);

      switch (data.action) {
        case 'drag-vertex':
          this.dragVertex(e, x, y);
          break;

        case 'drag-label':
          this.dragLabel(e, x, y);
          break;

        case 'drag-arrowhead':
          this.dragArrowhead(e, x, y);
          break;

        case 'drag-edge':
          this.dragEdge(e, x, y);
          break;
      }

      this.notifyMouseMove(e, x, y);
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(e, x, y) {
      var data = this.getEventData(e);

      switch (data.action) {
        case 'drag-vertex':
          this.stopVertexDragging(e, x, y);
          break;

        case 'drag-label':
          this.stopLabelDragging(e, x, y);
          break;

        case 'drag-arrowhead':
          this.stopArrowheadDragging(e, x, y);
          break;

        case 'drag-edge':
          this.stopEdgeDragging(e, x, y);
      }

      this.notifyMouseUp(e, x, y);
      this.checkMouseleave(e);
    }
  }, {
    key: "onMouseOver",
    value: function onMouseOver(e) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onMouseOver", this).call(this, e);

      this.notify('edge:mouseover', this.getEventArgs(e));
    }
  }, {
    key: "onMouseOut",
    value: function onMouseOut(e) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onMouseOut", this).call(this, e);

      this.notify('edge:mouseout', this.getEventArgs(e));
    }
  }, {
    key: "onMouseEnter",
    value: function onMouseEnter(e) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onMouseEnter", this).call(this, e);

      this.notify('edge:mouseenter', this.getEventArgs(e));
    }
  }, {
    key: "onMouseLeave",
    value: function onMouseLeave(e) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onMouseLeave", this).call(this, e);

      this.notify('edge:mouseleave', this.getEventArgs(e));
    }
  }, {
    key: "onMouseWheel",
    value: function onMouseWheel(e, x, y, delta) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onMouseWheel", this).call(this, e, x, y, delta);

      this.notify('edge:mousewheel', Object.assign({
        delta: delta
      }, this.getEventArgs(e, x, y)));
    }
  }, {
    key: "onCustomEvent",
    value: function onCustomEvent(e, name, x, y) {
      // For default edge tool
      var tool = dom_main_namespaceObject.findParentByClass(e.target, 'edge-tool', this.container);

      if (tool) {
        e.stopPropagation(); // no further action to be executed

        if (this.can('useEdgeTools')) {
          if (name === 'edge:remove') {
            this.cell.remove({
              ui: true
            });
            return;
          }

          this.notify('edge:customevent', Object.assign({
            name: name
          }, this.getEventArgs(e, x, y)));
        }

        this.notifyMouseDown(e, x, y);
      } else {
        this.notify('edge:customevent', Object.assign({
          name: name
        }, this.getEventArgs(e, x, y)));

        Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(EdgeView.prototype), "onCustomEvent", this).call(this, e, name, x, y);
      }
    }
  }, {
    key: "onLabelMouseDown",
    value: function onLabelMouseDown(e, x, y) {
      this.notifyMouseDown(e, x, y);
      this.startLabelDragging(e, x, y);
      var stopPropagation = this.getEventData(e).stopPropagation;

      if (stopPropagation) {
        e.stopPropagation();
      }
    } // #region drag edge

  }, {
    key: "startEdgeDragging",
    value: function startEdgeDragging(e, x, y) {
      if (!this.can('edgeMovable')) {
        this.notifyUnhandledMouseDown(e, x, y);
        return;
      }

      this.setEventData(e, {
        x: x,
        y: y,
        action: 'drag-edge'
      });
    }
  }, {
    key: "dragEdge",
    value: function dragEdge(e, x, y) {
      var data = this.getEventData(e);

      if (!data.dragged) {
        data.dragged = true;
      }

      this.cell.translate(x - data.x, y - data.y, {
        ui: true
      });
      this.setEventData(e, {
        x: x,
        y: y
      });
    }
  }, {
    key: "stopEdgeDragging",
    value: function stopEdgeDragging(e, x, y) {
      var data = this.getEventData(e);

      if (data.dragged) {
        data.dragged = false;
        this.notify('edge:moved', {
          e: e,
          x: x,
          y: y,
          view: this,
          cell: this.cell,
          edge: this.cell
        });
      }
    } // #endregion
    // #region drag arrowhead

  }, {
    key: "prepareArrowheadDragging",
    value: function prepareArrowheadDragging(type) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var magnet = this.getTerminalMagnet(type);
      var data = {
        action: 'drag-arrowhead',
        isNewEdge: options.isNewEdge === true,
        terminalType: type,
        initialMagnet: magnet,
        initialTerminal: object_namespaceObject.clone(this.cell[type]),
        fallbackAction: options.fallbackAction || 'revert',
        getValidateConnectionArgs: this.createValidateConnectionArgs(type)
      };
      this.beforeArrowheadDragging(data);
      return data;
    }
  }, {
    key: "createValidateConnectionArgs",
    value: function createValidateConnectionArgs(type) {
      var args = [];
      args[4] = type;
      args[5] = this;
      var opposite;
      var i = 0;
      var j = 0;

      if (type === 'source') {
        i = 2;
        opposite = 'target';
      } else {
        j = 2;
        opposite = 'source';
      }

      var terminal = this.cell[opposite];
      var cellId = terminal.cell;

      if (cellId) {
        var magnet;
        var view = args[i] = this.graph.renderer.findViewByCell(cellId);

        if (view) {
          magnet = view.getMagnetFromEdgeTerminal(terminal);

          if (magnet === view.container) {
            magnet = undefined;
          }
        }

        args[i + 1] = magnet;
      }

      return function (cellView, magnet) {
        args[j] = cellView;
        args[j + 1] = cellView.container === magnet ? undefined : magnet;
        return args;
      };
    }
  }, {
    key: "beforeArrowheadDragging",
    value: function beforeArrowheadDragging(data) {
      data.zIndex = this.cell.zIndex;
      this.cell.toFront();
      var style = this.container.style;
      data.pointerEvents = style.pointerEvents;
      style.pointerEvents = 'none';

      if (this.graph.options.connecting.highlight) {
        this.highlightAvailableMagnets(data);
      }
    }
  }, {
    key: "afterArrowheadDragging",
    value: function afterArrowheadDragging(data) {
      if (data.zIndex != null) {
        this.cell.setZIndex(data.zIndex, {
          ui: true
        });
        data.zIndex = null;
      }

      var container = this.container;
      container.style.pointerEvents = data.pointerEvents || '';

      if (this.graph.options.connecting.highlight) {
        this.unhighlightAvailableMagnets(data);
      }
    }
  }, {
    key: "arrowheadDragging",
    value: function arrowheadDragging(target, x, y, data) {
      // Checking views right under the pointer
      if (data.currentTarget !== target) {
        // Unhighlight the previous view under pointer if there was one.
        if (data.currentMagnet && data.currentView) {
          data.currentView.unhighlight(data.currentMagnet, {
            type: 'magnetAdsorbed'
          });
        }

        data.currentView = this.graph.renderer.findViewByElem(target);

        if (data.currentView) {
          var _this$graph$hook;

          // If we found a view that is under the pointer, we need to find
          // the closest magnet based on the real target element of the event.
          data.currentMagnet = data.currentView.findMagnet(target);

          if (data.currentMagnet && (_this$graph$hook = this.graph.hook).validateConnection.apply(_this$graph$hook, Object(toConsumableArray["a" /* default */])(data.getValidateConnectionArgs(data.currentView, data.currentMagnet)))) {
            data.currentView.highlight(data.currentMagnet, {
              type: 'magnetAdsorbed'
            });
          } else {
            // This type of connection is not valid. Disregard this magnet.
            data.currentMagnet = null;
          }
        } else {
          // Make sure we'll unset previous magnet.
          data.currentMagnet = null;
        }
      }

      data.currentTarget = target;
      this.cell.prop(data.terminalType, {
        x: x,
        y: y
      }, {
        ui: true
      });
    }
  }, {
    key: "arrowheadDragged",
    value: function arrowheadDragged(data, x, y) {
      var view = data.currentView;
      var magnet = data.currentMagnet;

      if (!magnet || !view) {
        return;
      }

      view.unhighlight(magnet, {
        type: 'magnetAdsorbed'
      });
      var type = data.terminalType;
      var terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);
      this.cell.setTerminal(type, terminal, {
        ui: true
      });
    }
  }, {
    key: "snapArrowhead",
    value: function snapArrowhead(x, y, data) {
      var graph = this.graph;
      var snap = graph.options.connecting.snap;
      var radius = typeof snap === 'object' && snap.radius || 50;
      var views = graph.renderer.findViewsInArea({
        x: x - radius,
        y: y - radius,
        width: 2 * radius,
        height: 2 * radius
      });
      var prevView = data.closestView || null;
      var prevMagnet = data.closestMagnet || null;
      data.closestView = null;
      data.closestMagnet = null;
      var distance;
      var minDistance = Number.MAX_SAFE_INTEGER;
      var pos = new point_Point(x, y);
      views.forEach(function (view) {
        if (view.container.getAttribute('magnet') !== 'false') {
          // Find distance from the center of the cell to pointer coordinates
          distance = view.cell.getBBox().getCenter().distance(pos); // the connection is looked up in a circle area by `distance < r`

          if (distance < radius && distance < minDistance) {
            var _graph$hook;

            if (prevMagnet === view.container || (_graph$hook = graph.hook).validateConnection.apply(_graph$hook, Object(toConsumableArray["a" /* default */])(data.getValidateConnectionArgs(view, null)))) {
              minDistance = distance;
              data.closestView = view;
              data.closestMagnet = view.container;
            }
          }
        }

        view.$('[magnet]').each(function (index, elem) {
          var magnet = elem;
          var bbox = view.getBBoxOfElement(magnet);
          distance = pos.distance(bbox.getCenter());

          if (distance < radius && distance < minDistance) {
            var _graph$hook2;

            if (prevMagnet === magnet || (_graph$hook2 = graph.hook).validateConnection.apply(_graph$hook2, Object(toConsumableArray["a" /* default */])(data.getValidateConnectionArgs(view, magnet)))) {
              minDistance = distance;
              data.closestView = view;
              data.closestMagnet = magnet;
            }
          }
        });
      });
      var terminal;
      var type = data.terminalType;
      var closestView = data.closestView;
      var closestMagnet = data.closestMagnet;
      var changed = prevMagnet !== closestMagnet;

      if (prevView && changed) {
        prevView.unhighlight(prevMagnet, {
          type: 'magnetAdsorbed'
        });
      }

      if (closestView) {
        if (!changed) {
          return;
        }

        closestView.highlight(closestMagnet, {
          type: 'magnetAdsorbed'
        });
        terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);
      } else {
        terminal = {
          x: x,
          y: y
        };
      }

      this.cell.setTerminal(type, terminal, {
        ui: true
      });
    }
  }, {
    key: "snapArrowheadEnd",
    value: function snapArrowheadEnd(data) {
      // Finish off link snapping.
      // Everything except view unhighlighting was already done on pointermove.
      var closestView = data.closestView;
      var closestMagnet = data.closestMagnet;

      if (closestView && closestMagnet) {
        closestView.unhighlight(closestMagnet, {
          type: 'magnetAdsorbed'
        });
        data.currentMagnet = closestView.findMagnet(closestMagnet);
      }

      data.closestView = null;
      data.closestMagnet = null;
    }
  }, {
    key: "finishEmbedding",
    value: function finishEmbedding(data) {
      // Resets parent of the edge if embedding is enabled
      if (this.graph.options.embedding.enabled && this.cell.updateParent()) {
        // Make sure we don't reverse to the original 'z' index
        data.zIndex = null;
      }
    }
  }, {
    key: "fallbackConnection",
    value: function fallbackConnection(data) {
      switch (data.fallbackAction) {
        case 'remove':
          this.cell.remove({
            ui: true
          });
          break;

        case 'revert':
        default:
          this.cell.prop(data.terminalType, data.initialTerminal, {
            ui: true
          });
          break;
      }
    }
  }, {
    key: "notifyConnectionEvent",
    value: function notifyConnectionEvent(data, e) {
      var terminalType = data.terminalType;
      var initialTerminal = data.initialTerminal;
      var currentTerminal = this.cell[terminalType];
      var changed = currentTerminal && !edge_Edge.equalTerminals(initialTerminal, currentTerminal);

      if (changed) {
        var graph = this.graph;
        var previous = initialTerminal;
        var previousCell = previous.cell ? graph.getCellById(previous.cell) : null;
        var previousPort = previous.port;
        var previousView = previousCell ? graph.findViewByCell(previousCell) : null;
        var previousPoint = previousCell ? null : point_Point.create(initialTerminal).toJSON();
        var current = currentTerminal;
        var currentCell = current.cell ? graph.getCellById(current.cell) : null;
        var currentPort = previous.port;
        var currentView = currentCell ? graph.findViewByCell(currentCell) : null;
        var currentPoint = currentCell ? null : point_Point.create(currentTerminal).toJSON();
        this.notify('edge:connected', {
          e: e,
          previousCell: previousCell,
          previousPort: previousPort,
          previousView: previousView,
          previousPoint: previousPoint,
          currentCell: currentCell,
          currentView: currentView,
          currentPort: currentPort,
          currentPoint: currentPoint,
          previousMagnet: data.initialMagnet,
          currentMagnet: data.currentMagnet,
          edge: this.cell,
          view: this,
          type: terminalType,
          isNew: data.isNewEdge
        });
      }
    }
  }, {
    key: "highlightAvailableMagnets",
    value: function highlightAvailableMagnets(data) {
      var graph = this.graph;
      var cells = graph.model.getCells();
      data.marked = {};

      var _loop = function _loop(i, ii) {
        var view = graph.renderer.findViewByCell(cells[i]);

        if (!view) {
          return "continue";
        }

        var magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));

        if (view.container.getAttribute('magnet') !== 'false') {
          magnets.push(view.container);
        }

        var availableMagnets = magnets.filter(function (magnet) {
          var _graph$hook3;

          return (_graph$hook3 = graph.hook).validateConnection.apply(_graph$hook3, Object(toConsumableArray["a" /* default */])(data.getValidateConnectionArgs(view, magnet)));
        });

        if (availableMagnets.length > 0) {
          // highlight all available magnets
          for (var j = 0, jj = availableMagnets.length; j < jj; j += 1) {
            view.highlight(availableMagnets[j], {
              type: 'magnetAvailable'
            });
          } // highlight the entire view


          view.highlight(null, {
            type: 'nodeAvailable'
          });
          data.marked[view.cell.id] = availableMagnets;
        }
      };

      for (var i = 0, ii = cells.length; i < ii; i += 1) {
        var _ret = _loop(i, ii);

        if (_ret === "continue") continue;
      }
    }
  }, {
    key: "unhighlightAvailableMagnets",
    value: function unhighlightAvailableMagnets(data) {
      var _this3 = this;

      var marked = data.marked || {};
      Object.keys(marked).forEach(function (id) {
        var view = _this3.graph.renderer.findViewByCell(id);

        if (view) {
          var magnets = marked[id];
          magnets.forEach(function (magnet) {
            view.unhighlight(magnet, {
              type: 'magnetAvailable'
            });
          });
          view.unhighlight(null, {
            type: 'nodeAvailable'
          });
        }
      });
      data.marked = null;
    }
  }, {
    key: "startArrowheadDragging",
    value: function startArrowheadDragging(e, x, y) {
      if (!this.can('arrowheadMovable')) {
        this.notifyUnhandledMouseDown(e, x, y);
        return;
      }

      var elem = e.target;
      var type = elem.getAttribute('data-terminal');
      var data = this.prepareArrowheadDragging(type);
      this.setEventData(e, data);
    }
  }, {
    key: "dragArrowhead",
    value: function dragArrowhead(e, x, y) {
      var data = this.getEventData(e);

      if (this.graph.options.connecting.snap) {
        this.snapArrowhead(x, y, data);
      } else {
        this.arrowheadDragging(this.getEventTarget(e), x, y, data);
      }
    }
  }, {
    key: "stopArrowheadDragging",
    value: function stopArrowheadDragging(e, x, y) {
      var _this4 = this;

      var graph = this.graph;
      var data = this.getEventData(e);

      if (graph.options.connecting.snap) {
        this.snapArrowheadEnd(data);
      } else {
        this.arrowheadDragged(data, x, y);
      }

      main_namespaceObject.toDeferredBoolean(graph.hook.validateEdge(this.cell, data.terminalType, data.initialTerminal)).then(function (valid) {
        if (valid) {
          _this4.finishEmbedding(data);

          _this4.notifyConnectionEvent(data, e);
        } else {
          // If the changed edge is not allowed, revert to its previous state.
          _this4.fallbackConnection(data);
        }

        _this4.afterArrowheadDragging(data);
      });
    } // #endregion
    // #region drag lable

  }, {
    key: "startLabelDragging",
    value: function startLabelDragging(e, x, y) {
      if (this.can('edgeLabelMovable')) {
        var target = e.currentTarget;
        var index = parseInt(target.getAttribute('data-index'), 10);
        var positionAngle = this.getLabelPositionAngle(index);
        var labelPositionArgs = this.getLabelPositionArgs(index);
        var defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();
        var positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
        this.setEventData(e, {
          index: index,
          positionAngle: positionAngle,
          positionArgs: positionArgs,
          stopPropagation: true,
          action: 'drag-label'
        });
      } else {
        // If labels can't be dragged no default action is triggered.
        this.setEventData(e, {
          stopPropagation: true
        });
      }

      this.graph.view.delegateDragEvents(e, this);
    }
  }, {
    key: "dragLabel",
    value: function dragLabel(e, x, y) {
      var data = this.getEventData(e);
      var label = {
        position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs)
      };
      this.cell.setLabelAt(data.index, label);
    }
  }, {
    key: "stopLabelDragging",
    value: function stopLabelDragging(e, x, y) {} // #endregion
    // #region drag vertex

  }, {
    key: "handleVertexAdding",
    value: function handleVertexAdding(e, x, y) {
      if (!this.can('vertexAddable')) {
        this.notifyUnhandledMouseDown(e, x, y);
        return;
      } // Store the index at which the new vertex has just been placed.
      // We'll be update the very same vertex position in `pointermove()`.


      var index = this.addVertex({
        x: x,
        y: y
      }, {
        ui: true
      });
      this.setEventData(e, {
        index: index,
        action: 'drag-vertex'
      });
    }
  }, {
    key: "handleVertexRemoving",
    value: function handleVertexRemoving(e, x, y) {
      if (!this.can('vertexDeletable')) {
        this.notifyUnhandledMouseDown(e, x, y);
        return;
      }

      var target = e.target;
      var index = parseInt(target.getAttribute('idx'), 10);
      this.cell.removeVertexAt(index);
    }
  }, {
    key: "startVertexDragging",
    value: function startVertexDragging(e, x, y) {
      if (!this.can('vertexMovable')) {
        this.notifyUnhandledMouseDown(e, x, y);
        return;
      }

      var target = e.target;
      var index = parseInt(target.getAttribute('idx'), 10);
      this.setEventData(e, {
        index: index,
        action: 'drag-vertex'
      });
    }
  }, {
    key: "dragVertex",
    value: function dragVertex(e, x, y) {
      var data = this.getEventData(e);
      this.cell.setVertexAt(data.index, {
        x: x,
        y: y
      }, {
        ui: true
      });
    }
  }, {
    key: "stopVertexDragging",
    value: function stopVertexDragging(e, x, y) {}
  }, {
    key: "sourceBBox",
    get: function get() {
      var sourceView = this.sourceView;

      if (!sourceView) {
        var sourceDef = this.cell.getSource();
        return new rectangle_Rectangle(sourceDef.x, sourceDef.y);
      }

      var sourceMagnet = this.sourceMagnet;

      if (sourceView.isEdgeElement(sourceMagnet)) {
        return new rectangle_Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);
      }

      return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);
    }
  }, {
    key: "targetBBox",
    get: function get() {
      var targetView = this.targetView;

      if (!targetView) {
        var targetDef = this.cell.getTarget();
        return new rectangle_Rectangle(targetDef.x, targetDef.y);
      }

      var targetMagnet = this.targetMagnet;

      if (targetView.isEdgeElement(targetMagnet)) {
        return new rectangle_Rectangle(this.targetAnchor.x, this.targetAnchor.y);
      }

      return targetView.getBBoxOfElement(targetMagnet || targetView.container);
    }
  }]);

  return EdgeView;
}(cell_CellView);
edge_EdgeView.config({
  isSvgElement: true,
  priority: 1,
  bootstrap: ['render', 'source', 'target'],
  actions: {
    view: ['render'],
    markup: ['render'],
    attrs: ['update'],
    router: ['update'],
    connector: ['update'],
    smooth: ['update'],
    manhattan: ['update'],
    source: ['source', 'update'],
    target: ['target', 'update'],
    labels: ['labels'],
    defaultLabel: ['labels'],
    vertices: ['vertices', 'update'],
    vertexMarkup: ['vertices'],
    toolMarkup: ['tools']
  },
  shortLength: 105,
  longLength: 155,
  toolsOffset: 40,
  doubleTools: false,
  doubleToolsOffset: 65,
  sampleInterval: 50
});
edge_EdgeView.registry.register('edge', edge_EdgeView, true);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/view/node.js












var node_NodeView = /*#__PURE__*/function (_CellView) {
  Object(inherits["a" /* default */])(NodeView, _CellView);

  var _super = Object(createSuper["a" /* default */])(NodeView);

  function NodeView() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, NodeView);

    _this = _super.apply(this, arguments);
    _this.scalableNode = null;
    _this.rotatableNode = null;
    _this.scalableSelector = 'scalable';
    _this.rotatableSelector = 'rotatable';
    _this.defaultPortMarkup = markup_Markup.getPortMarkup();
    _this.defaultPortLabelMarkup = markup_Markup.getPortLabelMarkup();
    _this.defaultPortContainerMarkup = markup_Markup.getPortContainerMarkup();
    _this.portsCache = {}; // #ednregion

    return _this;
  }

  Object(createClass["a" /* default */])(NodeView, [{
    key: "getContainerClassName",
    value: function getContainerClassName() {
      return [Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "getContainerClassName", this).call(this), this.prefixClassName('node')].join(' ');
    }
  }, {
    key: "isNodeView",
    value: function isNodeView() {
      return true;
    }
  }, {
    key: "confirmUpdate",
    value: function confirmUpdate(flag) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var ret = flag;

      if (this.hasAction(ret, 'ports')) {
        this.removePorts();
        this.cleanPortsCache();
      }

      if (this.hasAction(ret, 'render')) {
        this.render(); // this.updateTools(opt)

        ret = this.removeAction(ret, ['render', 'update', 'resize', 'translate', 'rotate', 'ports']);
      } else {
        ret = this.handleAction(ret, 'resize', function () {
          return _this2.resize(options);
        }, 'update');
        ret = this.handleAction(ret, 'update', function () {
          return _this2.update();
        }, // `update()` will render ports when useCSSSelectors are enabled
        Config.useCSSSelector ? 'ports' : null);
        ret = this.handleAction(ret, 'translate', function () {
          return _this2.translate();
        });
        ret = this.handleAction(ret, 'rotate', function () {
          return _this2.rotate();
        });
        ret = this.handleAction(ret, 'ports', function () {
          return _this2.renderPorts();
        });
      }

      if (this.hasAction(ret, 'tools')) {
        // this.updateTools(options)
        ret = this.removeAction(ret, 'tools');
      }

      return ret;
    }
  }, {
    key: "update",
    value: function update(partialAttrs) {
      this.cleanCache(); // When CSS selector strings are used, make sure no rule matches port nodes.

      if (Config.useCSSSelector) {
        this.removePorts();
      }

      var node = this.cell;
      var size = node.getSize();
      var attrs = node.getAttrs();
      this.updateAttrs(this.container, attrs, {
        attrs: partialAttrs === attrs ? null : partialAttrs,
        rootBBox: new rectangle_Rectangle(0, 0, size.width, size.height),
        selectors: this.selectors,
        scalableNode: this.scalableNode,
        rotatableNode: this.rotatableNode
      });

      if (Config.useCSSSelector) {
        this.renderPorts();
      }
    }
  }, {
    key: "renderMarkup",
    value: function renderMarkup() {
      var markup = this.cell.markup;

      if (markup) {
        if (typeof markup === 'string') {
          return this.renderStringMarkup(markup);
        }

        return this.renderJSONMarkup(markup);
      }

      throw new TypeError('Invalid node markup.');
    }
  }, {
    key: "renderJSONMarkup",
    value: function renderJSONMarkup(markup) {
      var ret = this.parseJSONMarkup(markup, this.container);

      var one = function one(elems) {
        return Array.isArray(elems) ? elems[0] : elems;
      };

      this.selectors = ret.selectors;
      this.rotatableNode = one(this.selectors[this.rotatableSelector]);
      this.scalableNode = one(this.selectors[this.scalableSelector]);
      this.container.appendChild(ret.fragment);
    }
  }, {
    key: "renderStringMarkup",
    value: function renderStringMarkup(markup) {
      dom_main_namespaceObject.append(this.container, dom_main_namespaceObject.toHTMLElements(dom_main_namespaceObject.createVectors(markup)));
      this.rotatableNode = dom_main_namespaceObject.findOne(this.container, ".".concat(this.rotatableSelector));
      this.scalableNode = dom_main_namespaceObject.findOne(this.container, ".".concat(this.scalableSelector));
      this.selectors = {};

      if (this.rootSelector) {
        this.selectors[this.rootSelector] = this.container;
      }
    }
  }, {
    key: "render",
    value: function render() {
      this.empty();
      this.renderMarkup();

      if (this.scalableNode) {
        // Double update is necessary for elements with the scalable group only
        // Note the `resize()` triggers the other `update`.
        this.update();
      }

      this.resize();

      if (this.rotatableNode) {
        this.rotate();
        this.translate();
      } else {
        this.updateTransform();
      }

      if (!Config.useCSSSelector) {
        this.renderPorts();
      }

      return this;
    }
  }, {
    key: "resize",
    value: function resize() {
      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.scalableNode) {
        return this.updateSize(opt);
      }

      if (this.cell.getAngle()) {
        this.rotate();
      }

      this.update();
    }
  }, {
    key: "translate",
    value: function translate() {
      if (this.rotatableNode) {
        return this.updateTranslation();
      }

      this.updateTransform();
    }
  }, {
    key: "rotate",
    value: function rotate() {
      if (this.rotatableNode) {
        this.updateRotation(); // It's necessary to call the update for the nodes outside
        // the rotatable group referencing nodes inside the group

        this.update();
        return;
      }

      this.updateTransform();
    }
  }, {
    key: "getTranslationString",
    value: function getTranslationString() {
      var position = this.cell.getPosition();
      return "translate(".concat(position.x, ",").concat(position.y, ")");
    }
  }, {
    key: "getRotationString",
    value: function getRotationString() {
      var angle = this.cell.getAngle();

      if (angle) {
        var size = this.cell.getSize();
        return "rotate(".concat(angle, ",").concat(size.width / 2, ",").concat(size.height / 2, ")");
      }
    }
  }, {
    key: "updateTransform",
    value: function updateTransform() {
      var transform = this.getTranslationString();
      var rot = this.getRotationString();

      if (rot) {
        transform += " ".concat(rot);
      }

      this.container.setAttribute('transform', transform);
    }
  }, {
    key: "updateRotation",
    value: function updateRotation() {
      if (this.rotatableNode != null) {
        var transform = this.getRotationString();

        if (transform != null) {
          this.rotatableNode.setAttribute('transform', transform);
        } else {
          this.rotatableNode.removeAttribute('transform');
        }
      }
    }
  }, {
    key: "updateTranslation",
    value: function updateTranslation() {
      this.container.setAttribute('transform', this.getTranslationString());
    }
  }, {
    key: "updateSize",
    value: function updateSize() {
      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var cell = this.cell;
      var size = cell.getSize();
      var angle = cell.getAngle();
      var scalableNode = this.scalableNode; // Getting scalable group's bbox.
      // Due to a bug in webkit's native SVG .getBBox implementation, the
      // bbox of groups with path children includes the paths' control points.
      // To work around the issue, we need to check whether there are any path
      // elements inside the scalable group.

      var recursive = false;

      if (scalableNode.getElementsByTagName('path').length > 0) {
        // If scalable has at least one descendant that is a path, we need
        // toswitch to recursive bbox calculation. Otherwise, group bbox
        // calculation works and so we can use the (faster) native function.
        recursive = true;
      }

      var scalableBBox = dom_main_namespaceObject.getBBox(scalableNode, {
        recursive: recursive
      }); // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero
      // which can happen if the element does not have any content.

      var sx = size.width / (scalableBBox.width || 1);
      var sy = size.height / (scalableBBox.height || 1);
      scalableNode.setAttribute('transform', "scale(".concat(sx, ",").concat(sy, ")")); // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`
      // Order of transformations is significant but we want to reconstruct the object always in the order:
      // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,
      // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the
      // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation
      // around the center of the resized object (which is a different origin then the origin of the previous rotation)
      // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.
      // Cancel the rotation but now around a different origin, which is the center of the scaled object.

      var rotatableNode = this.rotatableNode;

      if (rotatableNode != null) {
        var transform = rotatableNode.getAttribute('transform');

        if (transform) {
          rotatableNode.setAttribute('transform', "".concat(transform, " rotate(").concat(-angle, ",").concat(size.width / 2, ",").concat(size.height / 2, ")"));
          var rotatableBBox = dom_main_namespaceObject.getBBox(scalableNode, {
            target: this.graph.view.stage
          }); // Store new x, y and perform rotate() again against the new rotation origin.

          cell.prop('position', {
            x: rotatableBBox.x,
            y: rotatableBBox.y
          }, Object.assign({
            updated: true
          }, opt));
          this.translate();
          this.rotate();
        }
      } // Update must always be called on non-rotated element. Otherwise,
      // relative positioning would work with wrong (rotated) bounding boxes.


      this.update();
    } // #region ports

  }, {
    key: "findPortElem",
    value: function findPortElem(portId, selector) {
      var cache = portId ? this.portsCache[portId] : null;

      if (!cache) {
        return null;
      }

      var portRoot = cache.portContentElement;
      var portSelectors = cache.portContentSelectors || {};
      return this.findOne(selector, portRoot, portSelectors);
    }
  }, {
    key: "initializePorts",
    value: function initializePorts() {
      this.cleanPortsCache();
    }
  }, {
    key: "refreshPorts",
    value: function refreshPorts() {
      this.removePorts();
      this.cleanPortsCache();
      this.renderPorts();
    }
  }, {
    key: "cleanPortsCache",
    value: function cleanPortsCache() {
      this.portsCache = {};
    }
  }, {
    key: "removePorts",
    value: function removePorts() {
      var _this3 = this;

      Object.keys(this.portsCache).forEach(function (portId) {
        var cached = _this3.portsCache[portId];
        dom_main_namespaceObject.remove(cached.portElement);
      });
    }
  }, {
    key: "renderPorts",
    value: function renderPorts() {
      var _this4 = this;

      var container = this.getPortsContainer(); // References to rendered elements without z-index

      var references = [];
      container.childNodes.forEach(function (child) {
        references.push(child);
      });
      var portsGropsByZ = array_namespaceObject.groupBy(this.cell.getParsedPorts(), 'zIndex');
      var autoZIndexKey = 'auto'; // render non-z first

      if (portsGropsByZ[autoZIndexKey]) {
        portsGropsByZ[autoZIndexKey].forEach(function (port) {
          var portElement = _this4.getPortElement(port);

          container.append(portElement);
          references.push(portElement);
        });
      }

      Object.keys(portsGropsByZ).forEach(function (key) {
        if (key !== autoZIndexKey) {
          var zIndex = parseInt(key, 10);

          _this4.appendPorts(portsGropsByZ[key], zIndex, references);
        }
      });
      this.updatePorts();
    }
  }, {
    key: "getPortsContainer",
    value: function getPortsContainer() {
      return this.rotatableNode || this.container;
    }
  }, {
    key: "appendPorts",
    value: function appendPorts(ports, zIndex, refs) {
      var _this5 = this;

      var elems = ports.map(function (p) {
        return _this5.getPortElement(p);
      });

      if (refs[zIndex] || zIndex < 0) {
        dom_main_namespaceObject.before(refs[Math.max(zIndex, 0)], elems);
      } else {
        dom_main_namespaceObject.append(this.getPortsContainer(), elems);
      }
    }
  }, {
    key: "getPortElement",
    value: function getPortElement(port) {
      var cached = this.portsCache[port.id];

      if (cached) {
        return cached.portElement;
      }

      return this.createPortElement(port);
    }
  }, {
    key: "createPortElement",
    value: function createPortElement(port) {
      var renderResult = markup_Markup.renderMarkup(this.getPortContainerMarkup());
      var portElement = renderResult.elem;

      if (portElement == null) {
        throw new Error('Invalid port container markup.');
      }

      renderResult = markup_Markup.renderMarkup(this.getPortMarkup(port));
      var portContentElement = renderResult.elem;
      var portContentSelectors = renderResult.selectors;

      if (portContentElement == null) {
        throw new Error('Invalid port markup.');
      }

      this.setAttrs({
        port: port.id,
        'port-group': port.group
      }, portContentElement);
      renderResult = markup_Markup.renderMarkup(this.getPortLabelMarkup(port.label));
      var portLabelElement = renderResult.elem;
      var portLabelSelectors = renderResult.selectors;

      if (portLabelElement == null) {
        throw new Error('Invalid port label markup.');
      }

      var portSelectors;

      if (portContentSelectors && portLabelSelectors) {
        for (var key in portLabelSelectors) {
          if (portContentSelectors[key] && key !== this.rootSelector) {
            throw new Error('Selectors within port must be unique.');
          }
        }

        portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);
      } else {
        portSelectors = portContentSelectors || portLabelSelectors;
      }

      dom_main_namespaceObject.addClass(portElement, 'x6-port');
      dom_main_namespaceObject.addClass(portContentElement, 'x6-port-body');
      dom_main_namespaceObject.addClass(portLabelElement, 'x6-port-label');
      portElement.appendChild(portContentElement);
      portElement.appendChild(portLabelElement);
      this.portsCache[port.id] = {
        portElement: portElement,
        portSelectors: portSelectors,
        portLabelElement: portLabelElement,
        portLabelSelectors: portLabelSelectors,
        portContentElement: portContentElement,
        portContentSelectors: portContentSelectors
      };
      this.graph.hook.onPortRendered({
        port: port,
        node: this.cell,
        container: portElement,
        selectors: portSelectors,
        labelContainer: portLabelElement,
        labelSelectors: portLabelSelectors,
        contentContainer: portContentElement,
        contentSelectors: portContentSelectors
      });
      return portElement;
    }
  }, {
    key: "updatePorts",
    value: function updatePorts() {
      var _this6 = this;

      // Layout ports without group
      this.updatePortGroup(); // Layout ports with explicit group

      var groups = this.cell.getParsedGroups();
      Object.keys(groups).forEach(function (groupName) {
        return _this6.updatePortGroup(groupName);
      });
    }
  }, {
    key: "updatePortGroup",
    value: function updatePortGroup(groupName) {
      var bbox = rectangle_Rectangle.fromSize(this.cell.getSize());
      var metrics = this.cell.getPortsLayoutByGroup(groupName, bbox);

      for (var i = 0, n = metrics.length; i < n; i += 1) {
        var metric = metrics[i];
        var portId = metric.portId;
        var cached = this.portsCache[portId] || {};
        var portLayout = metric.portLayout;
        this.applyPortTransform(cached.portElement, portLayout);

        if (metric.portAttrs != null) {
          var options = {
            selectors: cached.portSelectors || {}
          };

          if (metric.portSize) {
            options.rootBBox = rectangle_Rectangle.fromSize(metric.portSize);
          }

          this.updateAttrs(cached.portElement, metric.portAttrs, options);
        }

        var labelLayout = metric.labelLayout;

        if (labelLayout) {
          this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));

          if (labelLayout.attrs) {
            var _options = {
              selectors: cached.portLabelSelectors || {}
            };

            if (metric.labelSize) {
              _options.rootBBox = rectangle_Rectangle.fromSize(metric.labelSize);
            }

            this.updateAttrs(cached.portLabelElement, labelLayout.attrs, _options);
          }
        }
      }
    }
  }, {
    key: "applyPortTransform",
    value: function applyPortTransform(element, layout) {
      var initialAngle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var angle = layout.angle;
      var position = layout.position;
      var matrix = dom_main_namespaceObject.createSVGMatrix().rotate(initialAngle).translate(position.x || 0, position.y || 0).rotate(angle || 0);
      dom_main_namespaceObject.transform(element, matrix, {
        absolute: true
      });
    }
  }, {
    key: "getPortContainerMarkup",
    value: function getPortContainerMarkup() {
      return this.cell.getPortContainerMarkup() || this.defaultPortContainerMarkup;
    }
  }, {
    key: "getPortMarkup",
    value: function getPortMarkup(port) {
      return port.markup || this.cell.portMarkup || this.defaultPortMarkup;
    }
  }, {
    key: "getPortLabelMarkup",
    value: function getPortLabelMarkup(label) {
      return label.markup || this.cell.portLabelMarkup || this.defaultPortLabelMarkup;
    }
  }, {
    key: "getEventArgs",
    value: function getEventArgs(e, x, y) {
      var view = this; // tslint:disable-line

      var node = view.cell;
      var cell = node;

      if (x == null || y == null) {
        return {
          e: e,
          view: view,
          node: node,
          cell: cell
        };
      }

      return {
        e: e,
        x: x,
        y: y,
        view: view,
        node: node,
        cell: cell
      };
    }
  }, {
    key: "notifyMouseDown",
    value: function notifyMouseDown(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onMouseDown", this).call(this, e, x, y);

      this.notify('node:mousedown', this.getEventArgs(e, x, y));
    }
  }, {
    key: "notifyMouseMove",
    value: function notifyMouseMove(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onMouseMove", this).call(this, e, x, y);

      this.notify('node:mousemove', this.getEventArgs(e, x, y));
    }
  }, {
    key: "notifyMouseUp",
    value: function notifyMouseUp(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onMouseUp", this).call(this, e, x, y);

      this.notify('node:mouseup', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onClick",
    value: function onClick(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onClick", this).call(this, e, x, y);

      this.notify('node:click', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onDblClick",
    value: function onDblClick(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onDblClick", this).call(this, e, x, y);

      this.notify('node:dblclick', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onContextMenu",
    value: function onContextMenu(e, x, y) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onContextMenu", this).call(this, e, x, y);

      this.notify('node:contextmenu', this.getEventArgs(e, x, y));
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(e, x, y) {
      if (this.isPropagationStopped(e)) {
        return;
      }

      this.notifyMouseDown(e, x, y);
      this.startNodeDragging(e, x, y);
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(e, x, y) {
      var data = this.getEventData(e);
      var action = data.action;

      if (action === 'magnet') {
        this.dragMagnet(e, x, y);
      } else {
        if (action === 'move') {
          var meta = data;
          var view = meta.targetView || this;
          view.dragNode(e, x, y);
        }

        this.notifyMouseMove(e, x, y);
      }

      this.setEventData(e, data);
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(e, x, y) {
      var data = this.getEventData(e);
      var action = data.action;

      if (action === 'magnet') {
        this.stopMagnetDragging(e, x, y);
      } else {
        this.notifyMouseUp(e, x, y);

        if (action === 'move') {
          var meta = data;
          var view = meta.targetView || this;
          view.stopNodeDragging(e, x, y);
        }
      }

      var magnet = data.targetMagnet;

      if (magnet) {
        this.onMagnetClick(e, magnet, x, y);
      }

      this.checkMouseleave(e);
    }
  }, {
    key: "onMouseOver",
    value: function onMouseOver(e) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onMouseOver", this).call(this, e);

      this.notify('node:mouseover', this.getEventArgs(e));
    }
  }, {
    key: "onMouseOut",
    value: function onMouseOut(e) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onMouseOut", this).call(this, e);

      this.notify('node:mouseout', this.getEventArgs(e));
    }
  }, {
    key: "onMouseEnter",
    value: function onMouseEnter(e) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onMouseEnter", this).call(this, e);

      this.notify('node:mouseenter', this.getEventArgs(e));
    }
  }, {
    key: "onMouseLeave",
    value: function onMouseLeave(e) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onMouseLeave", this).call(this, e);

      this.notify('node:mouseleave', this.getEventArgs(e));
    }
  }, {
    key: "onMouseWheel",
    value: function onMouseWheel(e, x, y, delta) {
      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onMouseWheel", this).call(this, e, x, y, delta);

      this.notify('node:mousewheel', Object.assign({
        delta: delta
      }, this.getEventArgs(e, x, y)));
    }
  }, {
    key: "onMagnetClick",
    value: function onMagnetClick(e, magnet, x, y) {
      var count = this.graph.view.getMouseMovedCount(e);

      if (count > this.graph.options.clickThreshold) {
        return;
      }

      this.notify('node:magnet:click', Object.assign({
        magnet: magnet
      }, this.getEventArgs(e, x, y)));
    }
  }, {
    key: "onMagnetDblClick",
    value: function onMagnetDblClick(e, magnet, x, y) {
      this.notify('node:magnet:dblclick', Object.assign({
        magnet: magnet
      }, this.getEventArgs(e, x, y)));
    }
  }, {
    key: "onMagnetContextMenu",
    value: function onMagnetContextMenu(e, magnet, x, y) {
      this.notify('node:magnet:contextmenu', Object.assign({
        magnet: magnet
      }, this.getEventArgs(e, x, y)));
    }
  }, {
    key: "onMagnetMouseDown",
    value: function onMagnetMouseDown(e, magnet, x, y) {
      this.startMagnetDragging(e, x, y);
    }
  }, {
    key: "onCustomEvent",
    value: function onCustomEvent(e, name, x, y) {
      this.notify('node:customevent', Object.assign({
        name: name
      }, this.getEventArgs(e, x, y)));

      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(NodeView.prototype), "onCustomEvent", this).call(this, e, name, x, y);
    }
  }, {
    key: "prepareEmbedding",
    value: function prepareEmbedding(data) {
      var cell = data.cell || this.cell;
      var graph = data.graph || this.graph;
      var model = graph.model;
      model.startBatch('to-front'); // Bring the model to the front with all his embeds.

      cell.toFront({
        deep: true,
        ui: true
      });
      var maxZ = model.getNodes().reduce(function (max, cell) {
        return Math.max(max, cell.getZIndex() || 0);
      }, 0);
      var connectedEdges = model.getConnectedEdges(cell, {
        deep: true,
        enclosed: true
      });
      connectedEdges.forEach(function (edge) {
        var zIndex = edge.getZIndex() || 0;

        if (zIndex <= maxZ) {
          edge.setZIndex(maxZ + 1, {
            ui: true
          });
        }
      });
      model.stopBatch('to-front'); // Before we start looking for suitable parent we remove the current one.

      var parent = cell.getParent();

      if (parent) {
        parent.unembed(cell, {
          ui: true
        });
      }
    }
  }, {
    key: "processEmbedding",
    value: function processEmbedding(data) {
      var _this7 = this;

      var cell = data.cell || this.cell;
      var graph = data.graph || this.graph;
      var options = graph.options.embedding;
      var findParent = options.findParent;
      var candidates = typeof findParent === 'function' ? main_namespaceObject.call(findParent, graph, this).filter(function (cell) {
        return cell instanceof cell_Cell && _this7.cell.id !== cell.id && !cell.isDescendantOf(_this7.cell);
      }) : graph.model.getNodesUnderNode(cell, {
        by: options.findParent
      }); // Picks the element with the highest `z` index

      if (options.frontOnly) {
        candidates = candidates.slice(-1);
      }

      var newCandidateView = null;
      var prevCandidateView = data.candidateEmbedView;
      var validateEmbeding = options.validate; // iterate over all candidates starting from the last one (has the highest z-index).

      for (var i = candidates.length - 1; i >= 0; i -= 1) {
        var candidate = candidates[i];

        if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {
          // candidate remains the same
          newCandidateView = prevCandidateView;
          break;
        } else {
          var view = candidate.findView(graph);

          if (main_namespaceObject.call(validateEmbeding, graph, {
            child: this.cell,
            parent: view.cell,
            childView: this,
            parentView: view
          })) {
            // flip to the new candidate
            newCandidateView = view;
            break;
          }
        }
      } // A new candidate view found. Highlight the new one.


      if (newCandidateView && newCandidateView !== prevCandidateView) {
        this.clearEmbedding(data);
        newCandidateView.highlight(null, {
          type: 'embedding'
        });
        data.candidateEmbedView = newCandidateView;
      } // No candidate view found. Unhighlight the previous candidate.


      if (!newCandidateView && prevCandidateView) {
        this.clearEmbedding(data);
      }
    }
  }, {
    key: "clearEmbedding",
    value: function clearEmbedding(data) {
      var candidateView = data.candidateEmbedView;

      if (candidateView) {
        // No candidate view found. Unhighlight the previous candidate.
        candidateView.unhighlight(null, {
          type: 'embedding'
        });
        data.candidateEmbedView = null;
      }
    }
  }, {
    key: "finalizeEmbedding",
    value: function finalizeEmbedding(data) {
      var cell = data.cell || this.cell;
      var graph = data.graph || this.graph;
      var candidateView = data.candidateEmbedView;

      if (candidateView) {
        // We finished embedding. Candidate view is chosen to become the parent of the model.
        candidateView.cell.insertChild(cell, undefined, {
          ui: true
        });
        candidateView.unhighlight(null, {
          type: 'embedding'
        });
        data.candidateEmbedView = null;
      }

      graph.model.getConnectedEdges(cell, {
        deep: true
      }).forEach(function (edge) {
        edge.updateParent({
          ui: true
        });
      });
    }
  }, {
    key: "getDelegatedView",
    value: function getDelegatedView() {
      var cell = this.cell;
      var view = this; // tslint:disable-line

      while (view) {
        if (cell.isEdge()) {
          break;
        }

        if (!cell.hasParent() || view.can('stopDelegation')) {
          return view;
        }

        cell = cell.getParent();
        view = this.graph.renderer.findViewByCell(cell);
      }

      return null;
    }
  }, {
    key: "startMagnetDragging",
    value: function startMagnetDragging(e, x, y) {
      if (!this.can('magnetConnectable')) {
        return;
      }

      e.stopPropagation();
      var magnet = e.currentTarget;
      var graph = this.graph;
      this.setEventData(e, {
        targetMagnet: magnet
      });

      if (graph.hook.validateMagnet(this, magnet, e)) {
        if (graph.options.magnetThreshold <= 0) {
          this.startConnectting(e, magnet, x, y);
        }

        this.setEventData(e, {
          action: 'magnet'
        });
        this.stopPropagation(e);
      } else {
        this.onMouseDown(e, x, y);
      }

      graph.view.delegateDragEvents(e, this);
    }
  }, {
    key: "startConnectting",
    value: function startConnectting(e, magnet, x, y) {
      this.graph.model.startBatch('add-edge');
      var edgeView = this.createEdgeFromMagnet(magnet, x, y);
      edgeView.notifyMouseDown(e, x, y); // backwards compatibility events

      edgeView.setEventData(e, edgeView.prepareArrowheadDragging('target', {
        isNewEdge: true,
        fallbackAction: 'remove'
      }));
      this.setEventData(e, {
        edgeView: edgeView
      });
    }
  }, {
    key: "createEdgeFromMagnet",
    value: function createEdgeFromMagnet(magnet, x, y) {
      var graph = this.graph;
      var model = graph.model;
      var edge = graph.hook.getDefaultEdge(this, magnet);
      edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, 'source')));
      edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), {
        x: x,
        y: y
      }));
      edge.addTo(model, {
        async: false,
        ui: true
      });
      return edge.findView(graph);
    }
  }, {
    key: "dragMagnet",
    value: function dragMagnet(e, x, y) {
      var data = this.getEventData(e);
      var edgeView = data.edgeView;

      if (edgeView) {
        edgeView.onMouseMove(e, x, y);
      } else {
        var graph = this.graph;
        var magnetThreshold = graph.options.magnetThreshold;
        var currentTarget = this.getEventTarget(e);
        var targetMagnet = data.targetMagnet; // magnetThreshold when the pointer leaves the magnet

        if (magnetThreshold === 'onleave') {
          if (targetMagnet === currentTarget || targetMagnet.contains(currentTarget)) {
            return;
          }
        } else {
          // magnetThreshold defined as a number of movements
          if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {
            return;
          }
        }

        this.startConnectting(e, targetMagnet, x, y);
      }
    }
  }, {
    key: "stopMagnetDragging",
    value: function stopMagnetDragging(e, x, y) {
      var data = this.eventData(e);
      var edgeView = data.edgeView;

      if (edgeView) {
        edgeView.onMouseUp(e, x, y);
        this.graph.model.stopBatch('add-edge');
      }
    }
  }, {
    key: "notifyUnhandledMouseDown",
    value: function notifyUnhandledMouseDown(e, x, y) {
      this.notify('node:unhandled:mousedown', {
        e: e,
        x: x,
        y: y,
        view: this,
        cell: this.cell,
        node: this.cell
      });
    }
  }, {
    key: "startNodeDragging",
    value: function startNodeDragging(e, x, y) {
      var targetView = this.getDelegatedView();

      if (targetView == null || !targetView.can('nodeMovable')) {
        return this.notifyUnhandledMouseDown(e, x, y);
      }

      this.setEventData(e, {
        targetView: targetView,
        action: 'move'
      });
      var position = point_Point.create(targetView.cell.getPosition());
      targetView.setEventData(e, {
        offset: position.diff(x, y),
        restrict: this.graph.getRestrictArea(targetView)
      });
    }
  }, {
    key: "dragNode",
    value: function dragNode(e, x, y) {
      var node = this.cell;
      var graph = this.graph;
      var gridSize = graph.getGridSize();
      var data = this.getEventData(e);
      var offset = data.offset;
      var restrict = data.restrict;
      var embedding = data.embedding;
      var posX = util_Util.snapToGrid(x + offset.x, gridSize);
      var posY = util_Util.snapToGrid(y + offset.y, gridSize);
      var meta = this.getEventData(e);

      if (!meta.moved) {
        meta.moved = true;
      }

      node.setPosition(posX, posY, {
        restrict: restrict,
        deep: true,
        ui: true
      });

      if (graph.options.embedding.enabled) {
        if (!embedding) {
          // Prepare the node for embedding only if the mouse moved.
          // We don't want to do unnecessary action with the element
          // if an user only clicks/dblclicks on it.
          this.prepareEmbedding(data);
          embedding = true;
        }

        this.processEmbedding(data);
      }

      this.setEventData(e, {
        embedding: embedding
      });
    }
  }, {
    key: "stopNodeDragging",
    value: function stopNodeDragging(e, x, y) {
      var meta = this.getEventData(e);

      if (meta.moved) {
        this.notify('node:moved', {
          e: e,
          x: x,
          y: y,
          view: this,
          cell: this.cell,
          node: this.cell
        });
      }

      var data = this.getEventData(e);

      if (data.embedding) {
        this.finalizeEmbedding(data);
      }
    }
  }]);

  return NodeView;
}(cell_CellView);
node_NodeView.config({
  isSvgElement: true,
  priority: 0,
  bootstrap: ['render'],
  actions: {
    view: ['render'],
    markup: ['render'],
    attrs: ['update'],
    size: ['resize', 'ports', 'tools'],
    angle: ['rotate', 'tools'],
    position: ['translate', 'tools'],
    ports: ['ports']
  }
});
node_NodeView.registry.register('node', node_NodeView, true);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/view/index.js






// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/base.js





var base_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



var base_Base = /*#__PURE__*/function (_Node) {
  Object(inherits["a" /* default */])(Base, _Node);

  var _super = Object(createSuper["a" /* default */])(Base);

  function Base() {
    Object(classCallCheck["a" /* default */])(this, Base);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Base, [{
    key: "getLabel",
    value: function getLabel() {
      return this.getAttrByPath('text/text');
    }
  }, {
    key: "setLabel",
    value: function setLabel(label, options) {
      if (label == null) {
        this.removeLabel();
      } else {
        this.setAttrByPath('text/text', label, options);
      }

      return this;
    }
  }, {
    key: "removeLabel",
    value: function removeLabel() {
      this.removeAttrByPath('text/text');
      return this;
    }
  }, {
    key: "label",
    get: function get() {
      return this.getLabel();
    },
    set: function set(val) {
      this.setLabel(val);
    }
  }]);

  return Base;
}(node_Node);

(function (Base) {
  Base.config({
    attrs: {
      text: {
        fontSize: 14,
        fill: '#000000',
        refX: 0.5,
        refY: 0.5,
        textAnchor: 'middle',
        textVerticalAnchor: 'middle',
        fontFamily: 'Arial, helvetica, sans-serif'
      }
    },
    propHooks: function propHooks(metadata) {
      var label = metadata.label,
          others = base_rest(metadata, ["label"]);

      if (label) {
        object_namespaceObject.setByPath(others, 'attrs/text/text', label);
      }

      return others;
    }
  });
})(base_Base || (base_Base = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/html.js











var html_HTML = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(HTML, _Base);

  var _super = Object(createSuper["a" /* default */])(HTML);

  function HTML() {
    Object(classCallCheck["a" /* default */])(this, HTML);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(HTML, [{
    key: "getHTML",
    value: function getHTML() {
      return this.store.get('html');
    }
  }, {
    key: "setHTML",
    value: function setHTML(html) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (html == null) {
        this.removeHTML(options);
      } else {
        this.store.set('html', html, options);
      }

      return this;
    }
  }, {
    key: "removeHTML",
    value: function removeHTML() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.store.remove('html', options);
    }
  }, {
    key: "html",
    get: function get() {
      return this.getHTML();
    },
    set: function set(val) {
      this.setHTML(val);
    }
  }]);

  return HTML;
}(base_Base);

(function (HTML) {
  var View = /*#__PURE__*/function (_NodeView) {
    Object(inherits["a" /* default */])(View, _NodeView);

    var _super2 = Object(createSuper["a" /* default */])(View);

    function View() {
      Object(classCallCheck["a" /* default */])(this, View);

      return _super2.apply(this, arguments);
    }

    Object(createClass["a" /* default */])(View, [{
      key: "render",
      value: function render() {
        Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(View.prototype), "render", this).call(this);

        this.renderHTMLComponent();
        return this;
      }
    }, {
      key: "confirmUpdate",
      value: function confirmUpdate(flag) {
        var _this = this;

        var ret = Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(View.prototype), "confirmUpdate", this).call(this, flag);

        return this.handleAction(ret, View.action, function () {
          return _this.renderHTMLComponent();
        });
      }
    }, {
      key: "renderHTMLComponent",
      value: function renderHTMLComponent() {
        var container = this.selectors.foContent;

        if (container) {
          var $wrap = this.$(container).empty();
          var component = this.graph.hook.getHTMLComponent(this.cell);

          if (component) {
            if (typeof component === 'string') {
              $wrap.html(component);
            } else {
              $wrap.append(component);
            }
          }
        }
      }
    }]);

    return View;
  }(node_NodeView);

  HTML.View = View;

  (function (View) {
    View.action = 'html';
    View.config({
      bootstrap: [View.action],
      actions: {
        html: View.action
      }
    });
    node_NodeView.registry.register('html-view', View);
  })(View = HTML.View || (HTML.View = {}));
})(html_HTML || (html_HTML = {}));

(function (HTML) {
  HTML.config({
    view: 'html-view',
    markup: [{
      tagName: 'rect',
      selector: 'body'
    }, Object.assign({}, markup_Markup.getForeignObjectMarkup()), {
      tagName: 'text',
      selector: 'label'
    }],
    attrs: {
      body: {
        fill: 'none',
        stroke: 'none',
        refWidth: '100%',
        refHeight: '100%'
      },
      fo: {
        refWidth: '100%',
        refHeight: '100%'
      }
    }
  });
  node_Node.registry.register('html', HTML);
})(html_HTML || (html_HTML = {}));

(function (HTML) {
  HTML.componentRegistry = registry_Registry.create({
    type: 'html componnet'
  });
})(html_HTML || (html_HTML = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/base.js





var graph_base_Base = /*#__PURE__*/function (_Disposable) {
  Object(inherits["a" /* default */])(Base, _Disposable);

  var _super = Object(createSuper["a" /* default */])(Base);

  function Base(graph) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Base);

    _this = _super.call(this);
    _this.graph = graph;

    _this.init();

    return _this;
  }

  Object(createClass["a" /* default */])(Base, [{
    key: "init",
    value: function init() {}
  }, {
    key: "options",
    get: function get() {
      return this.graph.options;
    }
  }, {
    key: "model",
    get: function get() {
      return this.graph.model;
    }
  }, {
    key: "view",
    get: function get() {
      return this.graph.view;
    }
  }]);

  return Base;
}(disposable_Disposable);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/view.js








var view_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






var view_GraphView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(GraphView, _View);

  var _super = Object(createSuper["a" /* default */])(GraphView);

  function GraphView(graph) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, GraphView);

    _this = _super.call(this);
    _this.graph = graph;

    var _Markup$parseJSONMark = markup_Markup.parseJSONMarkup(GraphView.markup),
        selectors = _Markup$parseJSONMark.selectors,
        fragment = _Markup$parseJSONMark.fragment;

    _this.background = selectors.background;
    _this.grid = selectors.grid;
    _this.svg = selectors.svg;
    _this.defs = selectors.defs;
    _this.viewport = selectors.viewport;
    _this.primer = selectors.primer;
    _this.stage = selectors.stage;
    _this.decorator = selectors.decorator;
    _this.overlay = selectors.overlay;
    _this.container = _this.options.container;

    _this.$(_this.container).addClass(_this.prefixClassName('graph')).append(fragment);

    _this.delegateEvents();

    return _this;
  }

  Object(createClass["a" /* default */])(GraphView, [{
    key: "delegateEvents",
    value: function delegateEvents() {
      var ctor = this.constructor;

      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(GraphView.prototype), "delegateEvents", this).call(this, ctor.events);

      return this;
    }
    /**
     * Guard the specified event. If the event is not interesting, it
     * returns `true`, otherwise returns `false`.
     */

  }, {
    key: "guard",
    value: function guard(e, view) {
      // handled as `contextmenu` type
      if (e.type === 'mousedown' && e.button === 2) {
        return true;
      }

      if (this.options.guard && this.options.guard(e, view)) {
        return true;
      }

      if (e.data && e.data.guarded !== undefined) {
        return e.data.guarded;
      }

      if (view && view.cell && view.cell instanceof cell_Cell) {
        return false;
      }

      if (this.svg === e.target || this.container === e.target || jquery_default.a.contains(this.svg, e.target)) {
        return false;
      }

      return true;
    }
  }, {
    key: "findView",
    value: function findView(elem) {
      return this.graph.renderer.findViewByElem(elem);
    }
  }, {
    key: "onDblClick",
    value: function onDblClick(evt) {
      evt.preventDefault();
      var e = this.normalizeEvent(evt);
      var view = this.findView(e.target);

      if (this.guard(e, view)) {
        return;
      }

      var localPoint = this.graph.snapToGrid(e.clientX, e.clientY);

      if (view) {
        view.onDblClick(e, localPoint.x, localPoint.y);
      } else {
        this.graph.trigger('blank:dblclick', {
          e: e,
          x: localPoint.x,
          y: localPoint.y
        });
      }
    }
  }, {
    key: "onClick",
    value: function onClick(evt) {
      if (this.getMouseMovedCount(evt) <= this.options.clickThreshold) {
        var e = this.normalizeEvent(evt);
        var view = this.findView(e.target);

        if (this.guard(e, view)) {
          return;
        }

        var localPoint = this.graph.snapToGrid(e.clientX, e.clientY);

        if (view) {
          view.onClick(e, localPoint.x, localPoint.y);
        } else {
          this.graph.trigger('blank:click', {
            e: e,
            x: localPoint.x,
            y: localPoint.y
          });
        }
      }
    }
  }, {
    key: "onContextMenu",
    value: function onContextMenu(evt) {
      if (this.options.preventDefaultContextMenu) {
        evt.preventDefault();
      }

      var e = this.normalizeEvent(evt);
      var view = this.findView(e.target);

      if (this.guard(e, view)) {
        return;
      }

      var localPoint = this.graph.snapToGrid(e.clientX, e.clientY);

      if (view) {
        view.onContextMenu(e, localPoint.x, localPoint.y);
      } else {
        this.graph.trigger('blank:contextmenu', {
          e: e,
          x: localPoint.x,
          y: localPoint.y
        });
      }
    }
  }, {
    key: "delegateDragEvents",
    value: function delegateDragEvents(e, view) {
      if (e.data == null) {
        e.data = {};
      }

      this.setEventData(e, {
        currentView: view || null,
        mouseMovedCount: 0
      });
      var ctor = this.constructor;
      this.delegateDocumentEvents(ctor.documentEvents, e.data);
      this.undelegateEvents();
    }
  }, {
    key: "getMouseMovedCount",
    value: function getMouseMovedCount(e) {
      var data = this.getEventData(e);
      return data.mouseMovedCount || 0;
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(evt) {
      var e = this.normalizeEvent(evt);
      var view = this.findView(e.target);

      if (this.guard(e, view)) {
        return;
      }

      var localPoint = this.graph.snapToGrid(e.clientX, e.clientY);

      if (view) {
        e.preventDefault();
        view.onMouseDown(e, localPoint.x, localPoint.y);
      } else {
        if (this.options.preventDefaultBlankAction) {
          e.preventDefault();
        }

        this.graph.trigger('blank:mousedown', {
          e: e,
          x: localPoint.x,
          y: localPoint.y
        });
      }

      this.delegateDragEvents(e, view);
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(evt) {
      var data = this.getEventData(evt);

      if (data.mouseMovedCount == null) {
        data.mouseMovedCount = 0;
      }

      data.mouseMovedCount += 1;
      var mouseMovedCount = data.mouseMovedCount;

      if (mouseMovedCount <= this.options.moveThreshold) {
        return;
      }

      var e = this.normalizeEvent(evt);
      var localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
      var view = data.currentView;

      if (view) {
        view.onMouseMove(e, localPoint.x, localPoint.y);
      } else {
        this.graph.trigger('blank:mousemove', {
          e: e,
          x: localPoint.x,
          y: localPoint.y
        });
      }

      this.setEventData(e, data);
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(e) {
      this.undelegateDocumentEvents();
      var normalized = this.normalizeEvent(e);
      var localPoint = this.graph.snapToGrid(normalized.clientX, normalized.clientY);
      var data = this.getEventData(e);
      var view = data.currentView;

      if (view) {
        view.onMouseUp(normalized, localPoint.x, localPoint.y);
      } else {
        this.graph.trigger('blank:mouseup', {
          e: normalized,
          x: localPoint.x,
          y: localPoint.y
        });
      }

      if (!e.isPropagationStopped()) {
        this.onClick(jquery_default.a.Event(e, {
          type: 'click',
          data: e.data
        }));
      }

      e.stopImmediatePropagation();
      this.delegateEvents();
    }
  }, {
    key: "onMouseOver",
    value: function onMouseOver(evt) {
      var e = this.normalizeEvent(evt);
      var view = this.findView(e.target);

      if (this.guard(e, view)) {
        return;
      }

      if (view) {
        view.onMouseOver(e);
      } else {
        // prevent border of paper from triggering this
        if (this.container === e.target) {
          return;
        }

        this.graph.trigger('blank:mouseover', {
          e: e
        });
      }
    }
  }, {
    key: "onMouseOut",
    value: function onMouseOut(evt) {
      var e = this.normalizeEvent(evt);
      var view = this.findView(e.target);

      if (this.guard(e, view)) {
        return;
      }

      if (view) {
        view.onMouseOut(e);
      } else {
        if (this.container === e.target) {
          return;
        }

        this.graph.trigger('blank:mouseout', {
          e: e
        });
      }
    }
  }, {
    key: "onMouseEnter",
    value: function onMouseEnter(evt) {
      var e = this.normalizeEvent(evt);
      var view = this.findView(e.target);

      if (this.guard(e, view)) {
        return;
      }

      var relatedView = this.graph.renderer.findViewByElem(e.relatedTarget);

      if (view) {
        if (relatedView === view) {
          // mouse moved from tool to view
          return;
        }

        view.onMouseEnter(e);
      } else {
        if (relatedView) {
          return;
        }

        this.graph.trigger('graph:mouseenter', {
          e: e
        });
      }
    }
  }, {
    key: "onMouseLeave",
    value: function onMouseLeave(evt) {
      var e = this.normalizeEvent(evt);
      var view = this.findView(e.target);

      if (this.guard(e, view)) {
        return;
      }

      var relatedView = this.graph.renderer.findViewByElem(e.relatedTarget);

      if (view) {
        if (relatedView === view) {
          // mouse moved from view to tool
          return;
        }

        view.onMouseLeave(e);
      } else {
        if (relatedView) {
          return;
        }

        this.graph.trigger('graph:mouseleave', {
          e: e
        });
      }
    }
  }, {
    key: "onMouseWheel",
    value: function onMouseWheel(evt) {
      var e = this.normalizeEvent(evt);
      var view = this.findView(e.target);

      if (this.guard(e, view)) {
        return;
      }

      var originalEvent = e.originalEvent;
      var localPoint = this.graph.snapToGrid(originalEvent.clientX, originalEvent.clientY);
      var delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta || -originalEvent.detail));

      if (view) {
        view.onMouseWheel(e, localPoint.x, localPoint.y, delta);
      } else {
        this.graph.trigger('blank:mousewheel', {
          e: e,
          delta: delta,
          x: localPoint.x,
          y: localPoint.y
        });
      }
    }
  }, {
    key: "onCustomEvent",
    value: function onCustomEvent(evt) {
      var elem = evt.currentTarget;
      var event = elem.getAttribute('event') || elem.getAttribute('data-event');

      if (event) {
        var view = this.findView(elem);

        if (view) {
          var e = this.normalizeEvent(evt);

          if (this.guard(e, view)) {
            return;
          }

          var localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
          view.onCustomEvent(e, event, localPoint.x, localPoint.y);
        }
      }
    }
  }, {
    key: "handleMagnetEvent",
    value: function handleMagnetEvent(evt, handler) {
      var magnetElem = evt.currentTarget;
      var magnetValue = magnetElem.getAttribute('magnet');

      if (magnetValue) {
        var view = this.findView(magnetElem);

        if (view) {
          var e = this.normalizeEvent(evt);

          if (this.guard(e, view)) {
            return;
          }

          var localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
          main_namespaceObject.call(handler, this.graph, view, e, magnetElem, localPoint.x, localPoint.y);
        }
      }
    }
  }, {
    key: "onMagnetMouseDown",
    value: function onMagnetMouseDown(e) {
      this.handleMagnetEvent(e, function (view, e, magnet, x, y) {
        view.onMagnetMouseDown(e, magnet, x, y);
      });
    }
  }, {
    key: "onMagnetDblClick",
    value: function onMagnetDblClick(e) {
      this.handleMagnetEvent(e, function (view, e, magnet, x, y) {
        view.onMagnetDblClick(e, magnet, x, y);
      });
    }
  }, {
    key: "onMagnetContextMenu",
    value: function onMagnetContextMenu(e) {
      if (this.options.preventDefaultContextMenu) {
        e.preventDefault();
      }

      this.handleMagnetEvent(e, function (view, e, magnet, x, y) {
        view.onMagnetContextMenu(e, magnet, x, y);
      });
    }
  }, {
    key: "onLabelMouseDown",
    value: function onLabelMouseDown(evt) {
      var labelNode = evt.currentTarget;
      var view = this.findView(labelNode);

      if (view) {
        var e = this.normalizeEvent(evt);

        if (this.guard(e, view)) {
          return;
        }

        var localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        view.onLabelMouseDown(e, localPoint.x, localPoint.y);
      }
    }
  }, {
    key: "onImageDragStart",
    value: function onImageDragStart() {
      // This is the only way to prevent image dragging in Firefox that works.
      // Setting -moz-user-select: none, draggable="false" attribute or
      // user-drag: none didn't help.
      return false;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      var scroller = this.graph.scroller.widget;

      if (scroller) {
        scroller.dispose();
      }

      this.undelegateEvents();
      this.undelegateDocumentEvents();
    }
  }, {
    key: "model",
    get: function get() {
      return this.graph.model;
    }
  }, {
    key: "options",
    get: function get() {
      return this.graph.options;
    }
  }]);

  return GraphView;
}(view_View);

view_decorate([view_View.dispose()], view_GraphView.prototype, "dispose", null);

(function (GraphView) {
  var prefixCls = "".concat(Config.prefixCls, "-graph");
  GraphView.markup = [{
    ns: dom_main_namespaceObject.ns.xhtml,
    tagName: 'div',
    selector: 'background',
    className: "".concat(prefixCls, "-background")
  }, {
    ns: dom_main_namespaceObject.ns.xhtml,
    tagName: 'div',
    selector: 'grid',
    className: "".concat(prefixCls, "-grid")
  }, {
    ns: dom_main_namespaceObject.ns.svg,
    tagName: 'svg',
    selector: 'svg',
    className: "".concat(prefixCls, "-svg"),
    attrs: {
      width: '100%',
      height: '100%',
      'xmlns:xlink': dom_main_namespaceObject.ns.xlink
    },
    children: [{
      tagName: 'defs',
      selector: 'defs'
    }, {
      tagName: 'g',
      selector: 'viewport',
      className: "".concat(prefixCls, "-svg-viewport"),
      children: [{
        tagName: 'g',
        selector: 'primer',
        className: "".concat(prefixCls, "-svg-primer")
      }, {
        tagName: 'g',
        selector: 'stage',
        className: "".concat(prefixCls, "-svg-stage")
      }, {
        tagName: 'g',
        selector: 'decorator',
        className: "".concat(prefixCls, "-svg-decorator")
      }, {
        tagName: 'g',
        selector: 'overlay',
        className: "".concat(prefixCls, "-svg-overlay")
      }]
    }]
  }];
})(view_GraphView || (view_GraphView = {}));

(function (GraphView) {
  var _GraphView$events;

  var prefixCls = Config.prefixCls;
  GraphView.events = (_GraphView$events = {
    dblclick: 'onDblClick',
    contextmenu: 'onContextMenu',
    touchstart: 'onMouseDown',
    mousedown: 'onMouseDown',
    mouseover: 'onMouseOver',
    mouseout: 'onMouseOut',
    mouseenter: 'onMouseEnter',
    mouseleave: 'onMouseLeave',
    mousewheel: 'onMouseWheel',
    DOMMouseScroll: 'onMouseWheel'
  }, Object(defineProperty["a" /* default */])(_GraphView$events, "mouseenter  .".concat(prefixCls, "-cell"), 'onMouseEnter'), Object(defineProperty["a" /* default */])(_GraphView$events, "mouseleave  .".concat(prefixCls, "-cell"), 'onMouseLeave'), Object(defineProperty["a" /* default */])(_GraphView$events, "mouseenter  .".concat(prefixCls, "-cell-tools"), 'onMouseEnter'), Object(defineProperty["a" /* default */])(_GraphView$events, "mouseleave  .".concat(prefixCls, "-cell-tools"), 'onMouseLeave'), Object(defineProperty["a" /* default */])(_GraphView$events, "mousedown   .".concat(prefixCls, "-cell [event]"), 'onCustomEvent'), Object(defineProperty["a" /* default */])(_GraphView$events, "touchstart  .".concat(prefixCls, "-cell [event]"), 'onCustomEvent'), Object(defineProperty["a" /* default */])(_GraphView$events, "mousedown   .".concat(prefixCls, "-cell [data-event]"), 'onCustomEvent'), Object(defineProperty["a" /* default */])(_GraphView$events, "touchstart  .".concat(prefixCls, "-cell [data-event]"), 'onCustomEvent'), Object(defineProperty["a" /* default */])(_GraphView$events, "dblclick    .".concat(prefixCls, "-cell [magnet]"), 'onMagnetDblClick'), Object(defineProperty["a" /* default */])(_GraphView$events, "contextmenu .".concat(prefixCls, "-cell [magnet]"), 'onMagnetContextMenu'), Object(defineProperty["a" /* default */])(_GraphView$events, "mousedown   .".concat(prefixCls, "-cell [magnet]"), 'onMagnetMouseDown'), Object(defineProperty["a" /* default */])(_GraphView$events, "touchstart  .".concat(prefixCls, "-cell [magnet]"), 'onMagnetMouseDown'), Object(defineProperty["a" /* default */])(_GraphView$events, "dblclick    .".concat(prefixCls, "-cell [data-magnet]"), 'onMagnetDblClick'), Object(defineProperty["a" /* default */])(_GraphView$events, "contextmenu .".concat(prefixCls, "-cell [data-magnet]"), 'onMagnetContextMenu'), Object(defineProperty["a" /* default */])(_GraphView$events, "mousedown   .".concat(prefixCls, "-cell [data-magnet]"), 'onMagnetMouseDown'), Object(defineProperty["a" /* default */])(_GraphView$events, "touchstart  .".concat(prefixCls, "-cell [data-magnet]"), 'onMagnetMouseDown'), Object(defineProperty["a" /* default */])(_GraphView$events, "dragstart   .".concat(prefixCls, "-cell image"), 'onImageDragStart'), Object(defineProperty["a" /* default */])(_GraphView$events, "mousedown   .".concat(prefixCls, "-edge .label"), 'onLabelMouseDown'), Object(defineProperty["a" /* default */])(_GraphView$events, "touchstart  .".concat(prefixCls, "-edge .label"), 'onLabelMouseDown'), _GraphView$events);
  GraphView.documentEvents = {
    mousemove: 'onMouseMove',
    touchmove: 'onMouseMove',
    mouseup: 'onMouseUp',
    touchend: 'onMouseUp',
    touchcancel: 'onMouseUp'
  };
})(view_GraphView || (view_GraphView = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/decorator.js
var decorator_Decorator;

(function (Decorator) {
  function checkScroller(err, warning) {
    return function (target, methodName, descriptor) {
      var raw = descriptor.value;

      descriptor.value = function () {
        var scroller = this.scroller.widget;

        if (scroller == null) {
          var msg = "Shoule enable scroller to use method '".concat(methodName, "'");

          if (err !== false) {
            console.error(msg);
            throw new Error(msg);
          }

          if (warning !== false) {
            console.warn(msg);
          }

          return this;
        }

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return raw.call.apply(raw, [this].concat(args));
      };
    };
  }

  Decorator.checkScroller = checkScroller;
})(decorator_Decorator || (decorator_Decorator = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/style/raw.js
/* tslint:disable */

/**
* Auto generated file, do not modify it!
*/
var raw_content = ".x6-graph {\n  position: relative;\n  outline: none;\n}\n.x6-graph-background,\n.x6-graph-grid,\n.x6-graph-svg {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.x6-graph-background-stage,\n.x6-graph-grid-stage,\n.x6-graph-svg-stage {\n  user-select: none;\n}\n.x6-node {\n  cursor: move;\n  /* stylelint-disable-next-line */\n}\n.x6-node * {\n  -webkit-user-drag: none;\n}\n.x6-node .scalable * {\n  vector-effect: non-scaling-stroke;\n}\n.x6-node [magnet='true'] {\n  cursor: crosshair;\n  transition: opacity 0.3s;\n}\n.x6-node [magnet='true']:hover {\n  opacity: 0.7;\n}\n.x6-node foreignobject {\n  display: block;\n  overflow: visible;\n  background-color: transparent;\n}\n.x6-node foreignobject > body {\n  position: static;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  overflow: visible;\n  background-color: transparent;\n}\n.x6-edge .source-marker,\n.x6-edge .target-marker {\n  vector-effect: non-scaling-stroke;\n}\n.x6-edge .connection {\n  stroke-linejoin: round;\n  fill: none;\n}\n.x6-edge .connection-wrap {\n  cursor: move;\n  opacity: 0;\n  fill: none;\n  stroke: #000;\n  stroke-width: 15;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n}\n.x6-edge .connection-wrap:hover {\n  opacity: 0.4;\n  stroke-opacity: 0.4;\n}\n.x6-edge .vertices {\n  cursor: move;\n  opacity: 0;\n}\n.x6-edge .vertices .vertex {\n  fill: #1abc9c;\n}\n.x6-edge .vertices .vertex :hover {\n  fill: #34495e;\n  stroke: none;\n}\n.x6-edge .vertices .vertex-remove {\n  cursor: pointer;\n  fill: #fff;\n}\n.x6-edge .vertices .vertex-remove-area {\n  cursor: pointer;\n  opacity: 0.1;\n}\n.x6-edge .vertices .vertex-group:hover .vertex-remove-area {\n  opacity: 1;\n}\n.x6-edge .arrowheads {\n  cursor: move;\n  opacity: 0;\n}\n.x6-edge .arrowheads .arrowhead {\n  fill: #1abc9c;\n}\n.x6-edge .arrowheads .arrowhead :hover {\n  fill: #f39c12;\n  stroke: none;\n}\n.x6-edge .tools {\n  cursor: pointer;\n  opacity: 0;\n}\n.x6-edge .tools .tool-options {\n  display: none;\n}\n.x6-edge .tools .tool-remove circle {\n  fill: #f00;\n}\n.x6-edge .tools .tool-remove path {\n  fill: #fff;\n}\n.x6-edge:hover .vertices,\n.x6-edge:hover .arrowheads,\n.x6-edge:hover .tools {\n  opacity: 1;\n}\n.x6-highlight-opacity {\n  opacity: 0.3;\n}\n@keyframes halo-pie-visibility {\n  0% {\n    visibility: hidden;\n  }\n  100% {\n    visibility: visible;\n  }\n}\n@keyframes halo-pie-opening {\n  0% {\n    transform: scale(0.4) rotate(-20deg);\n  }\n  100% {\n    transform: scale(1) rotate(0);\n  }\n}\n.x6-widget-handle {\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  background-color: transparent;\n  background-repeat: no-repeat;\n  background-position: 0 0;\n  background-size: 20px 20px;\n  cursor: pointer;\n  user-select: none;\n  pointer-events: auto;\n  -webkit-user-drag: none;\n  user-drag: none;\n  /* stylelint-disable-line */\n}\n.x6-widget-handle.hidden {\n  display: none;\n}\n.x6-widget-handle-selected {\n  background-color: rgba(0, 0, 0, 0.1);\n  border-radius: 3px;\n}\n.x6-widget-handle-remove {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15.386%2C3.365c-3.315-3.314-8.707-3.313-12.021%2C0c-3.314%2C3.315-3.314%2C8.706%2C0%2C12.02%20c3.314%2C3.314%2C8.707%2C3.314%2C12.021%2C0S18.699%2C6.68%2C15.386%2C3.365L15.386%2C3.365z%20M4.152%2C14.598C1.273%2C11.719%2C1.273%2C7.035%2C4.153%2C4.154%20c2.88-2.88%2C7.563-2.88%2C10.443%2C0c2.881%2C2.88%2C2.881%2C7.562%2C0%2C10.443C11.716%2C17.477%2C7.032%2C17.477%2C4.152%2C14.598L4.152%2C14.598z%22%2F%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.157%2C11.371L7.38%2C6.593C7.162%2C6.375%2C6.809%2C6.375%2C6.592%2C6.592c-0.218%2C0.219-0.218%2C0.572%2C0%2C0.79%20l4.776%2C4.776c0.218%2C0.219%2C0.571%2C0.219%2C0.79%2C0C12.375%2C11.941%2C12.375%2C11.588%2C12.157%2C11.371L12.157%2C11.371z%22%2F%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M11.369%2C6.593l-4.777%2C4.778c-0.217%2C0.217-0.217%2C0.568%2C0%2C0.787c0.219%2C0.219%2C0.571%2C0.217%2C0.788%2C0l4.777-4.777%20c0.218-0.218%2C0.218-0.571%2C0.001-0.789C11.939%2C6.375%2C11.587%2C6.375%2C11.369%2C6.593L11.369%2C6.593z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n  cursor: pointer;\n}\n.x6-widget-handle-remove:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15.386%2C3.365c-3.315-3.314-8.707-3.313-12.021%2C0c-3.314%2C3.315-3.314%2C8.706%2C0%2C12.02%20c3.314%2C3.314%2C8.707%2C3.314%2C12.021%2C0S18.699%2C6.68%2C15.386%2C3.365L15.386%2C3.365z%22%2F%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M12.157%2C11.371L7.38%2C6.593C7.162%2C6.375%2C6.809%2C6.375%2C6.592%2C6.592c-0.218%2C0.219-0.218%2C0.572%2C0%2C0.79%20l4.776%2C4.776c0.218%2C0.219%2C0.571%2C0.219%2C0.79%2C0C12.375%2C11.941%2C12.375%2C11.588%2C12.157%2C11.371L12.157%2C11.371z%22%2F%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M11.369%2C6.593l-4.777%2C4.778c-0.217%2C0.217-0.217%2C0.568%2C0%2C0.787c0.219%2C0.219%2C0.571%2C0.217%2C0.788%2C0l4.777-4.777%20c0.218-0.218%2C0.218-0.571%2C0.001-0.789C11.939%2C6.375%2C11.587%2C6.375%2C11.369%2C6.593L11.369%2C6.593z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-rotate {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M9.374%2C17.592c-4.176%2C0-7.57-3.401-7.57-7.575c0-4.175%2C3.395-7.574%2C7.57-7.574c0.28%2C0%2C0.56%2C0.018%2C0.837%2C0.05%20V1.268c0-0.158%2C0.099-0.3%2C0.239-0.36c0.151-0.058%2C0.315-0.026%2C0.428%2C0.086l2.683%2C2.688c0.152%2C0.154%2C0.152%2C0.399%2C0%2C0.553l-2.68%2C2.693%20c-0.115%2C0.112-0.279%2C0.147-0.431%2C0.087c-0.141-0.063-0.239-0.205-0.239-0.361V5.296C9.934%2C5.243%2C9.654%2C5.22%2C9.374%2C5.22%20c-2.646%2C0-4.796%2C2.152-4.796%2C4.797s2.154%2C4.798%2C4.796%2C4.798c2.645%2C0%2C4.798-2.153%2C4.798-4.798c0-0.214%2C0.174-0.391%2C0.391-0.391h1.991%20c0.217%2C0%2C0.394%2C0.177%2C0.394%2C0.391C16.947%2C14.19%2C13.549%2C17.592%2C9.374%2C17.592L9.374%2C17.592z%20M9.374%2C17.592%22%2F%3E%3C%2Fsvg%3E%20');\n  cursor: move;\n}\n.x6-widget-handle-rotate:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M9.374%2C17.592c-4.176%2C0-7.57-3.401-7.57-7.575c0-4.175%2C3.395-7.574%2C7.57-7.574c0.28%2C0%2C0.56%2C0.018%2C0.837%2C0.05%20V1.268c0-0.158%2C0.099-0.3%2C0.239-0.36c0.151-0.058%2C0.315-0.026%2C0.428%2C0.086l2.683%2C2.688c0.152%2C0.154%2C0.152%2C0.399%2C0%2C0.553l-2.68%2C2.693%20c-0.115%2C0.112-0.279%2C0.147-0.431%2C0.087c-0.141-0.063-0.239-0.205-0.239-0.361V5.296C9.934%2C5.243%2C9.654%2C5.22%2C9.374%2C5.22%20c-2.646%2C0-4.796%2C2.152-4.796%2C4.797s2.154%2C4.798%2C4.796%2C4.798c2.645%2C0%2C4.798-2.153%2C4.798-4.798c0-0.214%2C0.174-0.391%2C0.391-0.391h1.991%20c0.217%2C0%2C0.394%2C0.177%2C0.394%2C0.391C16.947%2C14.19%2C13.549%2C17.592%2C9.374%2C17.592L9.374%2C17.592z%20M9.374%2C17.592%22%2F%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-resize {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20height%3D%2224px%22%20version%3D%221.1%22%20viewBox%3D%220%200%2024%2024%22%20width%3D%2224px%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Asketch%3D%22http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch%2Fns%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Ctitle%2F%3E%3Cdesc%2F%3E%3Cdefs%2F%3E%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%20id%3D%22miu%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%3E%3Cg%20id%3D%22Artboard-1%22%20transform%3D%22translate(-251.000000%2C%20-443.000000)%22%3E%3Cg%20id%3D%22slice%22%20transform%3D%22translate(215.000000%2C%20119.000000)%22%2F%3E%3Cpath%20d%3D%22M252%2C448%20L256%2C448%20L256%2C444%20L252%2C444%20L252%2C448%20Z%20M257%2C448%20L269%2C448%20L269%2C446%20L257%2C446%20L257%2C448%20Z%20M257%2C464%20L269%2C464%20L269%2C462%20L257%2C462%20L257%2C464%20Z%20M270%2C444%20L270%2C448%20L274%2C448%20L274%2C444%20L270%2C444%20Z%20M252%2C462%20L252%2C466%20L256%2C466%20L256%2C462%20L252%2C462%20Z%20M270%2C462%20L270%2C466%20L274%2C466%20L274%2C462%20L270%2C462%20Z%20M254%2C461%20L256%2C461%20L256%2C449%20L254%2C449%20L254%2C461%20Z%20M270%2C461%20L272%2C461%20L272%2C449%20L270%2C449%20L270%2C461%20Z%22%20fill%3D%22%236A6C8A%22%20id%3D%22editor-crop-glyph%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E');\n  cursor: se-resize;\n}\n.x6-widget-handle-resize:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20height%3D%2224px%22%20version%3D%221.1%22%20viewBox%3D%220%200%2024%2024%22%20width%3D%2224px%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Asketch%3D%22http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch%2Fns%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Ctitle%2F%3E%3Cdesc%2F%3E%3Cdefs%2F%3E%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%20id%3D%22miu%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%3E%3Cg%20id%3D%22Artboard-1%22%20transform%3D%22translate(-251.000000%2C%20-443.000000)%22%3E%3Cg%20id%3D%22slice%22%20transform%3D%22translate(215.000000%2C%20119.000000)%22%2F%3E%3Cpath%20d%3D%22M252%2C448%20L256%2C448%20L256%2C444%20L252%2C444%20L252%2C448%20Z%20M257%2C448%20L269%2C448%20L269%2C446%20L257%2C446%20L257%2C448%20Z%20M257%2C464%20L269%2C464%20L269%2C462%20L257%2C462%20L257%2C464%20Z%20M270%2C444%20L270%2C448%20L274%2C448%20L274%2C444%20L270%2C444%20Z%20M252%2C462%20L252%2C466%20L256%2C466%20L256%2C462%20L252%2C462%20Z%20M270%2C462%20L270%2C466%20L274%2C466%20L274%2C462%20L270%2C462%20Z%20M254%2C461%20L256%2C461%20L256%2C449%20L254%2C449%20L254%2C461%20Z%20M270%2C461%20L272%2C461%20L272%2C449%20L270%2C449%20L270%2C461%20Z%22%20fill%3D%22%23FD6EB6%22%20id%3D%22editor-crop-glyph%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E');\n}\n.x6-widget-handle-clone {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.852%2C0.875h-9.27c-0.853%2C0-1.547%2C0.694-1.547%2C1.547v10.816h1.547V2.422h9.27V0.875z%20M15.172%2C3.965h-8.5%20c-0.849%2C0-1.547%2C0.698-1.547%2C1.547v10.816c0%2C0.849%2C0.698%2C1.547%2C1.547%2C1.547h8.5c0.85%2C0%2C1.543-0.698%2C1.543-1.547V5.512%20C16.715%2C4.663%2C16.021%2C3.965%2C15.172%2C3.965L15.172%2C3.965z%20M15.172%2C16.328h-8.5V5.512h8.5V16.328z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n  cursor: move;\n}\n.x6-widget-handle-clone:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M12.852%2C0.875h-9.27c-0.853%2C0-1.547%2C0.694-1.547%2C1.547v10.816h1.547V2.422h9.27V0.875z%20M15.172%2C3.965h-8.5%20c-0.849%2C0-1.547%2C0.698-1.547%2C1.547v10.816c0%2C0.849%2C0.698%2C1.547%2C1.547%2C1.547h8.5c0.849%2C0%2C1.543-0.698%2C1.543-1.547V5.512%20C16.715%2C4.663%2C16.021%2C3.965%2C15.172%2C3.965L15.172%2C3.965z%20M15.172%2C16.328h-8.5V5.512h8.5V16.328z%20M15.172%2C16.328%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-link {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M9.884%2C9.838c0.54-0.551%2C1.005-0.955%2C1.384-1.201c0.463-0.308%2C0.749-0.352%2C0.887-0.352h1.34v1.367%20c0%2C0.104%2C0.061%2C0.2%2C0.154%2C0.242s0.204%2C0.027%2C0.284-0.038l3.168-2.669c0.06-0.051%2C0.096-0.125%2C0.096-0.203S17.16%2C6.83%2C17.101%2C6.781%20l-3.168-2.677c-0.08-0.067-0.19-0.081-0.284-0.038c-0.094%2C0.045-0.154%2C0.139-0.154%2C0.242v1.414h-1.343%20c-1.24%2C0.014-2.215%2C0.67-2.927%2C1.242c-0.797%2C0.65-1.533%2C1.447-2.245%2C2.217c-0.361%2C0.391-0.7%2C0.759-1.044%2C1.1%20c-0.541%2C0.549-1.011%2C0.951-1.395%2C1.199c-0.354%2C0.231-0.678%2C0.357-0.921%2C0.357h-1.8c-0.146%2C0-0.266%2C0.12-0.266%2C0.265v2.029%20c0%2C0.148%2C0.12%2C0.268%2C0.266%2C0.268h1.8l0%2C0c1.255-0.014%2C2.239-0.667%2C2.958-1.24c0.82-0.661%2C1.572-1.475%2C2.297-2.256%20C9.225%2C10.524%2C9.555%2C10.169%2C9.884%2C9.838z%22%2F%3E%3C%2Fsvg%3E%20');\n  cursor: move;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n}\n.x6-widget-handle-link:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M9.884%2C9.838c0.54-0.551%2C1.005-0.955%2C1.384-1.201c0.463-0.308%2C0.749-0.352%2C0.887-0.352h1.34v1.367%20c0%2C0.104%2C0.061%2C0.2%2C0.154%2C0.242s0.204%2C0.027%2C0.284-0.038l3.168-2.669c0.06-0.051%2C0.096-0.125%2C0.096-0.203S17.16%2C6.83%2C17.101%2C6.781%20l-3.168-2.677c-0.08-0.067-0.19-0.081-0.284-0.038c-0.094%2C0.045-0.154%2C0.139-0.154%2C0.242v1.414h-1.343%20c-1.24%2C0.014-2.215%2C0.67-2.927%2C1.242c-0.797%2C0.65-1.533%2C1.447-2.245%2C2.217c-0.361%2C0.391-0.7%2C0.759-1.044%2C1.1%20c-0.541%2C0.549-1.011%2C0.951-1.395%2C1.199c-0.354%2C0.231-0.678%2C0.357-0.921%2C0.357h-1.8c-0.146%2C0-0.266%2C0.12-0.266%2C0.265v2.029%20c0%2C0.148%2C0.12%2C0.268%2C0.266%2C0.268h1.8l0%2C0c1.255-0.014%2C2.239-0.667%2C2.958-1.24c0.82-0.661%2C1.572-1.475%2C2.297-2.256%20C9.225%2C10.524%2C9.555%2C10.169%2C9.884%2C9.838z%22%2F%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-fork {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%236A6C8A%22%20d%3D%22M13.307%2C11.593c-0.69%2C0-1.299%2C0.33-1.693%2C0.835l-4.136-2.387%20C7.552%2C9.82%2C7.602%2C9.589%2C7.602%2C9.344c0-0.25-0.051-0.487-0.129-0.71l4.097-2.364c0.393%2C0.536%2C1.022%2C0.888%2C1.737%2C0.888%20c1.193%2C0%2C2.16-0.967%2C2.16-2.159s-0.967-2.159-2.16-2.159c-1.191%2C0-2.158%2C0.967-2.158%2C2.159c0%2C0.076%2C0.014%2C0.149%2C0.021%2C0.223%20L6.848%2C7.716C6.469%2C7.39%2C5.982%2C7.185%2C5.442%2C7.185c-1.191%2C0-2.158%2C0.967-2.158%2C2.159s0.967%2C2.159%2C2.158%2C2.159%20c0.545%2C0%2C1.037-0.208%2C1.417-0.541l4.319%2C2.493c-0.014%2C0.098-0.029%2C0.194-0.029%2C0.296c0%2C1.193%2C0.967%2C2.159%2C2.158%2C2.159%20c1.193%2C0%2C2.16-0.966%2C2.16-2.159C15.467%2C12.559%2C14.5%2C11.593%2C13.307%2C11.593z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n  cursor: move;\n}\n.x6-widget-handle-fork:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%23FD6EB6%22%20d%3D%22M13.307%2C11.593c-0.69%2C0-1.299%2C0.33-1.693%2C0.835l-4.136-2.387%20c0.075-0.22%2C0.125-0.452%2C0.125-0.697c0-0.25-0.051-0.487-0.129-0.71l4.097-2.365c0.394%2C0.536%2C1.022%2C0.888%2C1.737%2C0.888%20c1.193%2C0%2C2.16-0.967%2C2.16-2.159s-0.967-2.159-2.16-2.159c-1.191%2C0-2.158%2C0.967-2.158%2C2.159c0%2C0.076%2C0.015%2C0.148%2C0.022%2C0.223%20L6.848%2C7.716C6.469%2C7.39%2C5.981%2C7.185%2C5.442%2C7.185c-1.191%2C0-2.158%2C0.967-2.158%2C2.159s0.967%2C2.159%2C2.158%2C2.159%20c0.545%2C0%2C1.037-0.208%2C1.417-0.541l4.319%2C2.493c-0.013%2C0.098-0.029%2C0.194-0.029%2C0.296c0%2C1.193%2C0.967%2C2.159%2C2.158%2C2.159%20c1.193%2C0%2C2.16-0.966%2C2.16-2.159C15.467%2C12.559%2C14.5%2C11.593%2C13.307%2C11.593z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-unlink {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.285%2C9.711l-2.104-0.302L9.243%2C8.568L6.669%2C7.095C6.948%2C6.6%2C6.995%2C6.026%2C6.845%2C5.474%20c-0.191-0.698-0.695-1.36-1.438-1.786C4.068%2C2.922%2C2.464%2C3.214%2C1.82%2C4.338C1.536%2C4.836%2C1.489%2C5.414%2C1.64%2C5.97%20c0.189%2C0.698%2C0.694%2C1.36%2C1.438%2C1.787c0.328%2C0.187%2C0.67%2C0.31%2C1.01%2C0.372c0.002%2C0%2C0.006%2C0.002%2C0.008%2C0.004%20c0.027%2C0.004%2C0.057%2C0.009%2C0.088%2C0.011c2.12%2C0.316%2C3.203%2C0.915%2C3.73%2C1.337c-0.527%2C0.424-1.61%2C1.021-3.731%2C1.339%20c-0.029%2C0.003-0.058%2C0.007-0.087%2C0.012c-0.002%2C0.002-0.004%2C0.002-0.007%2C0.003c-0.341%2C0.062-0.684%2C0.187-1.013%2C0.374%20c-0.74%2C0.425-1.246%2C1.089-1.437%2C1.787c-0.149%2C0.555-0.105%2C1.133%2C0.181%2C1.632c0.011%2C0.018%2C0.021%2C0.033%2C0.033%2C0.049l0.883%2C0.783%20c0.765%2C0.366%2C1.775%2C0.328%2C2.67-0.184c0.744-0.425%2C1.248-1.088%2C1.439-1.786c0.148-0.552%2C0.104-1.126-0.176-1.62l2.573-1.473%20c0.573%2C0.287%2C2.299%2C1.292%2C2.299%2C1.292s3.602%2C1.445%2C4.241%2C1.812c0.773%2C0.191%2C0.566-0.151%2C0.566-0.151L12.285%2C9.711z%20M5.571%2C6.482%20C5.279%2C6.993%2C4.425%2C7.076%2C3.705%2C6.664C3.282%2C6.424%2C2.966%2C6.039%2C2.856%2C5.64C2.81%2C5.464%2C2.778%2C5.203%2C2.917%2C4.963%20c0.291-0.51%2C1.146-0.593%2C1.866-0.182C5.21%2C5.027%2C5.521%2C5.4%2C5.632%2C5.807C5.679%2C5.98%2C5.708%2C6.242%2C5.571%2C6.482z%20M5.632%2C13.159%20c-0.111%2C0.406-0.422%2C0.778-0.848%2C1.025c-0.719%2C0.409-1.576%2C0.327-1.867-0.184c-0.137-0.239-0.106-0.499-0.06-0.676%20c0.108-0.398%2C0.426-0.781%2C0.847-1.022c0.72-0.412%2C1.574-0.329%2C1.866%2C0.181C5.708%2C12.723%2C5.679%2C12.983%2C5.632%2C13.159z%20M16.181%2C5.139%20c-0.448%2C0.258-4.435%2C1.9-4.435%2C1.9s-1.556%2C0.855-2.104%2C1.13l0.937%2C0.843l2.057-0.229l4.11-3.638%20C16.745%2C5.146%2C17.013%2C4.664%2C16.181%2C5.139z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-unlink:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M12.285%2C9.711l-2.104-0.302L9.243%2C8.568L6.669%2C7.095C6.948%2C6.6%2C6.995%2C6.026%2C6.845%2C5.474%20c-0.191-0.698-0.695-1.36-1.438-1.786C4.068%2C2.922%2C2.464%2C3.214%2C1.82%2C4.338C1.536%2C4.836%2C1.489%2C5.414%2C1.64%2C5.97%20c0.189%2C0.698%2C0.694%2C1.36%2C1.438%2C1.787c0.328%2C0.187%2C0.67%2C0.31%2C1.01%2C0.372c0.002%2C0%2C0.006%2C0.002%2C0.008%2C0.004%20c0.027%2C0.004%2C0.057%2C0.009%2C0.088%2C0.011c2.12%2C0.316%2C3.203%2C0.915%2C3.73%2C1.337c-0.527%2C0.424-1.61%2C1.021-3.731%2C1.339%20c-0.029%2C0.003-0.058%2C0.007-0.087%2C0.012c-0.002%2C0.002-0.004%2C0.002-0.007%2C0.003c-0.341%2C0.062-0.684%2C0.187-1.013%2C0.374%20c-0.74%2C0.425-1.246%2C1.089-1.437%2C1.787c-0.149%2C0.555-0.105%2C1.133%2C0.181%2C1.632c0.011%2C0.018%2C0.021%2C0.033%2C0.033%2C0.049l0.883%2C0.783%20c0.765%2C0.366%2C1.775%2C0.328%2C2.67-0.184c0.744-0.425%2C1.248-1.088%2C1.439-1.786c0.148-0.552%2C0.104-1.126-0.176-1.62l2.573-1.473%20c0.573%2C0.287%2C2.299%2C1.292%2C2.299%2C1.292s3.602%2C1.445%2C4.241%2C1.812c0.773%2C0.191%2C0.566-0.151%2C0.566-0.151L12.285%2C9.711z%20M5.571%2C6.482%20C5.279%2C6.993%2C4.425%2C7.076%2C3.705%2C6.664C3.282%2C6.424%2C2.966%2C6.039%2C2.856%2C5.64C2.81%2C5.464%2C2.778%2C5.203%2C2.917%2C4.963%20c0.291-0.51%2C1.146-0.593%2C1.866-0.182C5.21%2C5.027%2C5.521%2C5.4%2C5.632%2C5.807C5.679%2C5.98%2C5.708%2C6.242%2C5.571%2C6.482z%20M5.632%2C13.159%20c-0.111%2C0.406-0.422%2C0.778-0.848%2C1.025c-0.719%2C0.409-1.576%2C0.327-1.867-0.184c-0.137-0.239-0.106-0.499-0.06-0.676%20c0.108-0.398%2C0.426-0.781%2C0.847-1.022c0.72-0.412%2C1.574-0.329%2C1.866%2C0.181C5.708%2C12.723%2C5.679%2C12.983%2C5.632%2C13.159z%20M16.181%2C5.139%20c-0.448%2C0.258-4.435%2C1.9-4.435%2C1.9s-1.556%2C0.855-2.104%2C1.13l0.937%2C0.843l2.057-0.229l4.11-3.638%20C16.745%2C5.146%2C17.013%2C4.664%2C16.181%2C5.139z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');\n}\n.x6-widget-handle-direction {\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20%20PUBLIC%20'-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN'%20%20'http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd'%3E%3Csvg%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%20512%20512%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%20512%20512%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cstyle%20type%3D%22text%2Fcss%22%3E%0A%09.st0%7Bfill%3A%236A6C8A%3Bstroke%3A%236A6C8A%3Bstroke-width%3A30%7D%0A%09.dot%7Bfill%3A%236A6C8A%3B%7D%0A%3C%2Fstyle%3E%3Cg%3E%3Cg%20id%3D%22XMLID_475_%22%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M133.1%2C277.1c1.8%2C0%2C3.7-0.6%2C5.4-1.7c4.1-3%2C5-8.7%2C2-12.8c-3-4.1-8.7-5-12.8-2c0%2C0%2C0%2C0%2C0%2C0%20%20%20%20%20c-4.1%2C3-5%2C8.7-2%2C12.8C127.5%2C275.8%2C130.3%2C277.1%2C133.1%2C277.1z%22%20id%3D%22XMLID_489_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M138.5%2C359.6c-4.1-3-9.8-2.1-12.8%2C2c-3%2C4.1-2.1%2C9.8%2C2%2C12.8c1.6%2C1.2%2C3.5%2C1.7%2C5.4%2C1.7%20%20%20%20%20c2.8%2C0%2C5.6-1.3%2C7.4-3.7C143.5%2C368.3%2C142.6%2C362.6%2C138.5%2C359.6z%22%20id%3D%22XMLID_726_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C327.7c-4.8%2C1.6-7.4%2C6.7-5.9%2C11.5c1.3%2C3.9%2C4.8%2C6.3%2C8.7%2C6.3c0.9%2C0%2C1.9-0.1%2C2.8-0.4%20%20%20%20%20c4.8-1.6%2C7.4-6.7%2C5.9-11.5C118%2C328.8%2C112.9%2C326.2%2C108.1%2C327.7z%22%20id%3D%22XMLID_776_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C307.3c0.9%2C0.3%2C1.9%2C0.4%2C2.8%2C0.4c3.8%2C0%2C7.4-2.4%2C8.7-6.3c1.6-4.8-1.1-9.9-5.9-11.5%20%20%20%20%20c-4.8-1.6-9.9%2C1.1-11.5%2C5.9C100.7%2C300.6%2C103.3%2C305.7%2C108.1%2C307.3z%22%20id%3D%22XMLID_777_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M169.2%2C265.4c2.4%2C0%2C4.7-1%2C6.5-2.6c1.7-1.7%2C2.7-4.1%2C2.7-6.5c0-2.4-1-4.8-2.7-6.5%20%20%20%20%20c-1.7-1.7-4.1-2.7-6.5-2.7s-4.7%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.5C164.4%2C264.4%2C166.8%2C265.4%2C169.2%2C265.4z%22%20id%3D%22XMLID_797_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M247.7%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C243.7%2C265.4%2C247.7%2C261.3%2C247.7%2C256.3z%22%20id%3D%22XMLID_798_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M213%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C208.9%2C265.4%2C213%2C261.3%2C213%2C256.3z%22%20id%3D%22XMLID_799_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M317.2%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C313.1%2C265.4%2C317.2%2C261.3%2C317.2%2C256.3z%22%20id%3D%22XMLID_800_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M282.5%2C256.3c0-5-4.1-9.1-9.1-9.1s-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20S282.5%2C261.3%2C282.5%2C256.3z%22%20id%3D%22XMLID_801_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M401.1%2C185.2c0.9%2C0%2C1.9-0.1%2C2.8-0.5c4.8-1.6%2C7.4-6.7%2C5.9-11.5c-1.6-4.8-6.7-7.4-11.5-5.8%20%20%20%20%20c-4.8%2C1.6-7.4%2C6.7-5.8%2C11.5C393.6%2C182.8%2C397.2%2C185.2%2C401.1%2C185.2z%22%20id%3D%22XMLID_802_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M403.9%2C205.2c-4.8-1.6-9.9%2C1-11.5%2C5.9l0%2C0c-1.6%2C4.8%2C1.1%2C9.9%2C5.9%2C11.5%20%20%20%20%20c0.9%2C0.3%2C1.9%2C0.5%2C2.8%2C0.5c3.9%2C0%2C7.4-2.5%2C8.7-6.3c0%2C0%2C0%2C0%2C0%2C0C411.3%2C211.9%2C408.7%2C206.8%2C403.9%2C205.2z%22%20id%3D%22XMLID_803_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C237.2L373.5%2C237.2c-4.1%2C3-5%2C8.7-2%2C12.8c1.8%2C2.4%2C4.6%2C3.7%2C7.4%2C3.7%20%20%20%20%20c1.8%2C0%2C3.7-0.6%2C5.4-1.8c4.1-3%2C4.9-8.7%2C2-12.8C383.3%2C235.1%2C377.6%2C234.2%2C373.5%2C237.2z%22%20id%3D%22XMLID_804_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C152.9c1.6%2C1.2%2C3.5%2C1.8%2C5.4%2C1.8c2.8%2C0%2C5.6-1.3%2C7.4-3.8c3-4.1%2C2.1-9.8-2-12.7%20%20%20%20%20c-4.1-3-9.8-2.1-12.7%2C2C368.5%2C144.2%2C369.4%2C149.9%2C373.5%2C152.9z%22%20id%3D%22XMLID_805_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M342.8%2C247.1c-2.4%2C0-4.8%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.4%20%20%20%20%20c1.7%2C1.7%2C4%2C2.7%2C6.5%2C2.7c2.4%2C0%2C4.7-1%2C6.5-2.7c1.7-1.7%2C2.7-4%2C2.7-6.4c0-2.4-1-4.8-2.7-6.5C347.6%2C248.1%2C345.2%2C247.1%2C342.8%2C247.1z%22%20id%3D%22XMLID_806_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M342.8%2C124.7H206.6l36.4-36.4c3.6-3.6%2C3.6-9.3%2C0-12.9c-3.6-3.6-9.3-3.6-12.9%2C0l-51.5%2C51.5%20%20%20%20%20c-1.9%2C1.9-2.8%2C4.4-2.7%2C6.9c-0.1%2C2.5%2C0.7%2C5%2C2.7%2C6.9l51.5%2C51.5c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7%20%20%20%20%20c3.6-3.6%2C3.6-9.3%2C0-12.9l-36.4-36.4h136.1c0%2C0%2C0.1%2C0%2C0.1%2C0c0.6%2C0%2C1.2-0.1%2C1.8-0.2c0.2%2C0%2C0.4-0.1%2C0.6-0.1c0.1%2C0%2C0.2%2C0%2C0.3-0.1%20%20%20%20%20c3.2-1%2C5.6-3.6%2C6.3-6.9c0.1-0.6%2C0.2-1.2%2C0.2-1.8c0-0.6-0.1-1.2-0.2-1.8C351%2C127.8%2C347.3%2C124.7%2C342.8%2C124.7z%22%20id%3D%22XMLID_807_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M322.1%2C371.3l-51.5-51.5c-3.6-3.6-9.3-3.6-12.9%2C0c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9l36.9%2C36.9H169.2%20%20%20%20%20c-2.8%2C0-5.4%2C1.3-7%2C3.3c-0.1%2C0.1-0.2%2C0.2-0.3%2C0.4c-0.1%2C0.1-0.2%2C0.2-0.2%2C0.3c-0.1%2C0.1-0.1%2C0.2-0.2%2C0.4c-0.1%2C0.1-0.2%2C0.3-0.2%2C0.4%20%20%20%20%20c0%2C0.1-0.1%2C0.2-0.1%2C0.2c-0.1%2C0.2-0.2%2C0.4-0.3%2C0.6c0%2C0%2C0%2C0%2C0%2C0.1c-0.4%2C1.1-0.7%2C2.2-0.7%2C3.4c0%2C1.5%2C0.4%2C2.9%2C1%2C4.2c0%2C0%2C0%2C0.1%2C0.1%2C0.1%20%20%20%20%20c0.1%2C0.1%2C0.1%2C0.2%2C0.2%2C0.3c0.4%2C0.7%2C0.9%2C1.3%2C1.4%2C1.8c0.4%2C0.4%2C0.7%2C0.7%2C1.2%2C1c0.1%2C0.1%2C0.1%2C0.1%2C0.2%2C0.2c0%2C0%2C0.1%2C0%2C0.1%2C0.1%20%20%20%20%20c1.4%2C0.9%2C3.1%2C1.5%2C5%2C1.5h124.4l-36%2C36c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7l51.5-51.5%20%20%20%20%20c1.9-1.9%2C2.8-4.4%2C2.7-6.9C324.8%2C375.7%2C324%2C373.2%2C322.1%2C371.3z%22%20id%3D%22XMLID_808_%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E\");\n}\n.x6-widget-handle-direction:hover {\n  background-image: url(\"data:image/svg+xml;charset=UTF-8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20%20PUBLIC%20'-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN'%20%20'http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd'%3E%3Csvg%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%20512%20512%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%20512%20512%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cstyle%20type%3D%22text%2Fcss%22%3E%0A%09.st0%7Bfill%3A%23FD6EB6%3Bstroke%3A%23FD6EB6%3Bstroke-width%3A30%7D%0A%09.dot%7Bfill%3A%23FD6EB6%3B%7D%0A%3C%2Fstyle%3E%3Cg%3E%3Cg%20id%3D%22XMLID_475_%22%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M133.1%2C277.1c1.8%2C0%2C3.7-0.6%2C5.4-1.7c4.1-3%2C5-8.7%2C2-12.8c-3-4.1-8.7-5-12.8-2c0%2C0%2C0%2C0%2C0%2C0%20%20%20%20%20c-4.1%2C3-5%2C8.7-2%2C12.8C127.5%2C275.8%2C130.3%2C277.1%2C133.1%2C277.1z%22%20id%3D%22XMLID_489_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M138.5%2C359.6c-4.1-3-9.8-2.1-12.8%2C2c-3%2C4.1-2.1%2C9.8%2C2%2C12.8c1.6%2C1.2%2C3.5%2C1.7%2C5.4%2C1.7%20%20%20%20%20c2.8%2C0%2C5.6-1.3%2C7.4-3.7C143.5%2C368.3%2C142.6%2C362.6%2C138.5%2C359.6z%22%20id%3D%22XMLID_726_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C327.7c-4.8%2C1.6-7.4%2C6.7-5.9%2C11.5c1.3%2C3.9%2C4.8%2C6.3%2C8.7%2C6.3c0.9%2C0%2C1.9-0.1%2C2.8-0.4%20%20%20%20%20c4.8-1.6%2C7.4-6.7%2C5.9-11.5C118%2C328.8%2C112.9%2C326.2%2C108.1%2C327.7z%22%20id%3D%22XMLID_776_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C307.3c0.9%2C0.3%2C1.9%2C0.4%2C2.8%2C0.4c3.8%2C0%2C7.4-2.4%2C8.7-6.3c1.6-4.8-1.1-9.9-5.9-11.5%20%20%20%20%20c-4.8-1.6-9.9%2C1.1-11.5%2C5.9C100.7%2C300.6%2C103.3%2C305.7%2C108.1%2C307.3z%22%20id%3D%22XMLID_777_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M169.2%2C265.4c2.4%2C0%2C4.7-1%2C6.5-2.6c1.7-1.7%2C2.7-4.1%2C2.7-6.5c0-2.4-1-4.8-2.7-6.5%20%20%20%20%20c-1.7-1.7-4.1-2.7-6.5-2.7s-4.7%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.5C164.4%2C264.4%2C166.8%2C265.4%2C169.2%2C265.4z%22%20id%3D%22XMLID_797_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M247.7%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C243.7%2C265.4%2C247.7%2C261.3%2C247.7%2C256.3z%22%20id%3D%22XMLID_798_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M213%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C208.9%2C265.4%2C213%2C261.3%2C213%2C256.3z%22%20id%3D%22XMLID_799_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M317.2%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C313.1%2C265.4%2C317.2%2C261.3%2C317.2%2C256.3z%22%20id%3D%22XMLID_800_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M282.5%2C256.3c0-5-4.1-9.1-9.1-9.1s-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20S282.5%2C261.3%2C282.5%2C256.3z%22%20id%3D%22XMLID_801_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M401.1%2C185.2c0.9%2C0%2C1.9-0.1%2C2.8-0.5c4.8-1.6%2C7.4-6.7%2C5.9-11.5c-1.6-4.8-6.7-7.4-11.5-5.8%20%20%20%20%20c-4.8%2C1.6-7.4%2C6.7-5.8%2C11.5C393.6%2C182.8%2C397.2%2C185.2%2C401.1%2C185.2z%22%20id%3D%22XMLID_802_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M403.9%2C205.2c-4.8-1.6-9.9%2C1-11.5%2C5.9l0%2C0c-1.6%2C4.8%2C1.1%2C9.9%2C5.9%2C11.5%20%20%20%20%20c0.9%2C0.3%2C1.9%2C0.5%2C2.8%2C0.5c3.9%2C0%2C7.4-2.5%2C8.7-6.3c0%2C0%2C0%2C0%2C0%2C0C411.3%2C211.9%2C408.7%2C206.8%2C403.9%2C205.2z%22%20id%3D%22XMLID_803_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C237.2L373.5%2C237.2c-4.1%2C3-5%2C8.7-2%2C12.8c1.8%2C2.4%2C4.6%2C3.7%2C7.4%2C3.7%20%20%20%20%20c1.8%2C0%2C3.7-0.6%2C5.4-1.8c4.1-3%2C4.9-8.7%2C2-12.8C383.3%2C235.1%2C377.6%2C234.2%2C373.5%2C237.2z%22%20id%3D%22XMLID_804_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C152.9c1.6%2C1.2%2C3.5%2C1.8%2C5.4%2C1.8c2.8%2C0%2C5.6-1.3%2C7.4-3.8c3-4.1%2C2.1-9.8-2-12.7%20%20%20%20%20c-4.1-3-9.8-2.1-12.7%2C2C368.5%2C144.2%2C369.4%2C149.9%2C373.5%2C152.9z%22%20id%3D%22XMLID_805_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M342.8%2C247.1c-2.4%2C0-4.8%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.4%20%20%20%20%20c1.7%2C1.7%2C4%2C2.7%2C6.5%2C2.7c2.4%2C0%2C4.7-1%2C6.5-2.7c1.7-1.7%2C2.7-4%2C2.7-6.4c0-2.4-1-4.8-2.7-6.5C347.6%2C248.1%2C345.2%2C247.1%2C342.8%2C247.1z%22%20id%3D%22XMLID_806_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M342.8%2C124.7H206.6l36.4-36.4c3.6-3.6%2C3.6-9.3%2C0-12.9c-3.6-3.6-9.3-3.6-12.9%2C0l-51.5%2C51.5%20%20%20%20%20c-1.9%2C1.9-2.8%2C4.4-2.7%2C6.9c-0.1%2C2.5%2C0.7%2C5%2C2.7%2C6.9l51.5%2C51.5c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7%20%20%20%20%20c3.6-3.6%2C3.6-9.3%2C0-12.9l-36.4-36.4h136.1c0%2C0%2C0.1%2C0%2C0.1%2C0c0.6%2C0%2C1.2-0.1%2C1.8-0.2c0.2%2C0%2C0.4-0.1%2C0.6-0.1c0.1%2C0%2C0.2%2C0%2C0.3-0.1%20%20%20%20%20c3.2-1%2C5.6-3.6%2C6.3-6.9c0.1-0.6%2C0.2-1.2%2C0.2-1.8c0-0.6-0.1-1.2-0.2-1.8C351%2C127.8%2C347.3%2C124.7%2C342.8%2C124.7z%22%20id%3D%22XMLID_807_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M322.1%2C371.3l-51.5-51.5c-3.6-3.6-9.3-3.6-12.9%2C0c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9l36.9%2C36.9H169.2%20%20%20%20%20c-2.8%2C0-5.4%2C1.3-7%2C3.3c-0.1%2C0.1-0.2%2C0.2-0.3%2C0.4c-0.1%2C0.1-0.2%2C0.2-0.2%2C0.3c-0.1%2C0.1-0.1%2C0.2-0.2%2C0.4c-0.1%2C0.1-0.2%2C0.3-0.2%2C0.4%20%20%20%20%20c0%2C0.1-0.1%2C0.2-0.1%2C0.2c-0.1%2C0.2-0.2%2C0.4-0.3%2C0.6c0%2C0%2C0%2C0%2C0%2C0.1c-0.4%2C1.1-0.7%2C2.2-0.7%2C3.4c0%2C1.5%2C0.4%2C2.9%2C1%2C4.2c0%2C0%2C0%2C0.1%2C0.1%2C0.1%20%20%20%20%20c0.1%2C0.1%2C0.1%2C0.2%2C0.2%2C0.3c0.4%2C0.7%2C0.9%2C1.3%2C1.4%2C1.8c0.4%2C0.4%2C0.7%2C0.7%2C1.2%2C1c0.1%2C0.1%2C0.1%2C0.1%2C0.2%2C0.2c0%2C0%2C0.1%2C0%2C0.1%2C0.1%20%20%20%20%20c1.4%2C0.9%2C3.1%2C1.5%2C5%2C1.5h124.4l-36%2C36c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7l51.5-51.5%20%20%20%20%20c1.9-1.9%2C2.8-4.4%2C2.7-6.9C324.8%2C375.7%2C324%2C373.2%2C322.1%2C371.3z%22%20id%3D%22XMLID_808_%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E\");\n}\n.x6-widget-handle-surround .x6-widget-handle-animate .x6-widget-handle {\n  transition: background-size 80ms, width 80ms, height 80ms, top 150ms, left 150ms, bottom 150ms, right 150ms;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-se {\n  right: -25px;\n  bottom: -25px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-nw {\n  top: -21px;\n  left: -25px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-n {\n  top: -22px;\n  left: 50%;\n  margin-left: -10px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-e {\n  top: -webkit-calc(40%);\n  top: calc(50% - 10px);\n  right: -25px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-ne {\n  top: -21px;\n  right: -25px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-w {\n  top: 50%;\n  left: -25px;\n  margin-top: -10px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-sw {\n  bottom: -25px;\n  left: -25px;\n}\n.x6-widget-handle-surround .x6-widget-handle-pos-s {\n  bottom: -24px;\n  left: 50%;\n  margin-left: -10px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle {\n  width: 15px;\n  height: 15px;\n  font-size: 15px;\n  background-size: 15px 15px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-se {\n  right: -19px;\n  bottom: -19px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-nw {\n  top: -19px;\n  left: -19px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-n {\n  top: -19px;\n  margin-left: -7.5px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-e {\n  top: -webkit-calc(42%);\n  top: calc(50% - 8px);\n  right: -19px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-ne {\n  top: -19px;\n  right: -19px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-w {\n  left: -19px;\n  margin-top: -8px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-sw {\n  bottom: -19px;\n  left: -19px;\n}\n.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-s {\n  bottom: -19px;\n  margin-left: -7.5px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle {\n  width: 10px;\n  height: 10px;\n  font-size: 10px;\n  background-size: 10px 10px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-se {\n  right: -15px;\n  bottom: -13px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-nw {\n  top: -13px;\n  left: -15px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-n {\n  top: -13px;\n  margin-left: -5px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-e {\n  top: -webkit-calc(45%);\n  top: calc(50% - 5px);\n  right: -15px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-ne {\n  top: -13px;\n  right: -15px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-w {\n  left: -15px;\n  margin-top: -5px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-sw {\n  bottom: -13px;\n  left: -15px;\n}\n.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-s {\n  bottom: -13px;\n  margin-left: -5px;\n}\n.x6-widget-handle-toolbar {\n  position: absolute;\n  top: -50px;\n  display: table-row;\n  padding: 7px 5px;\n}\n.x6-widget-handle-toolbar::after {\n  position: absolute;\n  top: 100%;\n  left: 10px;\n  width: 0;\n  height: 0;\n  margin-top: 4px;\n  border-right: 10px solid transparent;\n  border-left: 10px solid transparent;\n  content: '';\n}\n.x6-widget-handle-toolbar .x6-widget-handle {\n  position: relative;\n  display: table-cell;\n  min-width: 20px;\n  margin: 0 2px;\n  background-position: 3px 3px;\n  background-size: 16px 16px;\n}\n.x6-widget-handle-toolbar .x6-widget-handle::after {\n  position: absolute;\n  bottom: -11px;\n  width: 100%;\n  content: '';\n}\n.x6-widget-handle-pie {\n  position: absolute;\n  top: -webkit-calc(0%);\n  top: calc(50% - 50px);\n  right: -50px;\n  z-index: 1;\n  display: none;\n  width: 100px;\n  height: 100px;\n  margin: -2px -2px 0 0;\n  border-radius: 50%;\n  cursor: default;\n  pointer-events: visiblePainted;\n}\n.x6-widget-handle-pie .x6-widget-handle {\n  width: 1px;\n  height: auto;\n  pointer-events: visiblePainted;\n}\n.x6-widget-handle-pie-slice-svg {\n  width: 100%;\n  height: 100%;\n  overflow: visible !important;\n}\n.x6-widget-handle-pie-slice-img,\n.x6-widget-handle-pie-slice-txt {\n  display: none;\n  pointer-events: none;\n}\n.x6-widget-handle-pie[data-pie-toggle-position='e'] {\n  top: calc(50% - 50px);\n  right: -50px;\n  left: auto;\n}\n.x6-widget-handle-pie[data-pie-toggle-position='w'] {\n  top: calc(50% - 50px);\n  right: auto;\n  left: -52px;\n}\n.x6-widget-handle-pie[data-pie-toggle-position='n'] {\n  top: -50px;\n  right: auto;\n  bottom: auto;\n  left: calc(50% - 52px);\n}\n.x6-widget-handle-pie[data-pie-toggle-position='s'] {\n  top: auto;\n  right: auto;\n  bottom: -52px;\n  left: calc(50% - 52px);\n}\n.x6-widget-handle-pie-opened {\n  display: block;\n  animation: halo-pie-visibility 0.1s, halo-pie-opening 0.1s;\n  animation-timing-function: step-end, ease;\n  animation-delay: 0s, 0.1s;\n}\n.x6-widget-handle-pie-toggle {\n  position: absolute;\n  top: -webkit-calc(35%);\n  top: calc(50% - 15px);\n  right: -15px;\n  z-index: 2;\n  display: block;\n  box-sizing: border-box;\n  width: 30px;\n  height: 30px;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 20px 20px;\n  border-radius: 50%;\n  cursor: pointer;\n  user-select: none;\n  pointer-events: visiblePainted;\n  -webkit-user-drag: none;\n  user-drag: none;\n  /* stylelint-disable-line */\n}\n.x6-widget-handle-pie-toggle-pos-e {\n  top: -webkit-calc(35%);\n  top: calc(50% - 15px);\n  right: -15px;\n  bottom: auto;\n  left: auto;\n}\n.x6-widget-handle-pie-toggle-pos-w {\n  top: -webkit-calc(35%);\n  top: calc(50% - 15px);\n  right: auto;\n  bottom: auto;\n  left: -15px;\n}\n.x6-widget-handle-pie-toggle-pos-n {\n  top: -15px;\n  right: auto;\n  bottom: auto;\n  left: -webkit-calc(35%);\n  left: calc(50% - 15px);\n}\n.x6-widget-handle-pie-toggle-pos-s {\n  top: auto;\n  right: auto;\n  bottom: -15px;\n  left: -webkit-calc(35%);\n  left: calc(50% - 15px);\n}\n.x6-widget-handle-pie-toggle-opened {\n  transition: 0.1s background-image;\n}\n.x6-widget-handle-toolbar {\n  position: static;\n  display: inline-block;\n  margin-top: -50px;\n  margin-left: 45px;\n  white-space: nowrap;\n  vertical-align: top;\n  background-color: #f5f5f5;\n  border-bottom: 3px solid #333;\n  border-radius: 5px;\n  box-shadow: 0 1px 2px #222;\n}\n.x6-widget-handle-toolbar::after {\n  top: -12px;\n  left: 55px;\n  margin-top: 0;\n  border-top: 6px solid #333;\n  border-right: 10px solid transparent;\n  border-left: 10px solid transparent;\n}\n.x6-widget-handle-toolbar .x6-widget-handle {\n  display: inline-block;\n  vertical-align: top;\n}\n.x6-widget-handle-toolbar .x6-widget-handle:hover::after {\n  border-bottom: 4px solid #fc6cb8;\n}\n.x6-widget-handle-toolbar .x6-widget-handle-rotate {\n  position: absolute;\n  top: 100%;\n  right: 100%;\n  margin-top: 3px;\n  margin-right: 6px;\n}\n.x6-widget-handle-toolbar .x6-widget-handle-remove:hover::after,\n.x6-widget-handle-toolbar .x6-widget-handle-rotate:hover::after {\n  border-bottom: none;\n}\n.x6-widget-handle-toolbar .x6-widget-handle + .x6-widget-handle {\n  margin-left: 4px;\n}\n.x6-widget-handle-pie {\n  box-sizing: content-box;\n  background-color: #f5f5f5;\n  border: 2px solid #404040;\n}\n.x6-widget-handle-pie-slice {\n  fill: transparent;\n  stroke: #e9e9e9;\n  stroke-width: 1;\n}\n.x6-widget-handle-pie-slice:hover {\n  fill: #fff;\n}\n.x6-widget-handle-pie-slice-img {\n  display: block;\n}\n.x6-widget-handle-selected .x6-widget-handle-pie-slice {\n  fill: #fff;\n}\n.x6-widget-handle-pie-toggle {\n  background-color: #f6f6f6;\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20height%3D%2216px%22%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%2016%2016%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%2016%2016%22%20width%3D%2216px%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15%2C6h-5V1c0-0.55-0.45-1-1-1H7C6.45%2C0%2C6%2C0.45%2C6%2C1v5H1C0.45%2C6%2C0%2C6.45%2C0%2C7v2c0%2C0.55%2C0.45%2C1%2C1%2C1h5v5c0%2C0.55%2C0.45%2C1%2C1%2C1h2%20c0.55%2C0%2C1-0.45%2C1-1v-5h5c0.55%2C0%2C1-0.45%2C1-1V7C16%2C6.45%2C15.55%2C6%2C15%2C6z%22%2F%3E%3C%2Fsvg%3E');\n  background-size: 16px 16px;\n  border: 2px solid #3b425f;\n}\n.x6-widget-handle-pie-toggle:hover {\n  background-color: #fff;\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20height%3D%2216px%22%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%2016%2016%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%2016%2016%22%20width%3D%2216px%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M15%2C6h-5V1c0-0.55-0.45-1-1-1H7C6.45%2C0%2C6%2C0.45%2C6%2C1v5H1C0.45%2C6%2C0%2C6.45%2C0%2C7v2c0%2C0.55%2C0.45%2C1%2C1%2C1h5v5c0%2C0.55%2C0.45%2C1%2C1%2C1h2%20c0.55%2C0%2C1-0.45%2C1-1v-5h5c0.55%2C0%2C1-0.45%2C1-1V7C16%2C6.45%2C15.55%2C6%2C15%2C6z%22%2F%3E%3C%2Fsvg%3E');\n  border-color: #fd6eb6;\n}\n.x6-widget-handle-pie-toggle-opened {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3Adc%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%22%20xmlns%3Acc%3D%22http%3A%2F%2Fcreativecommons.org%2Fns%23%22%20xmlns%3Ardf%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%22%20xmlns%3Asvg%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20id%3D%22Layer_1%22%20xml%3Aspace%3D%22preserve%22%3E%3Cmetadata%20id%3D%22metadata9%22%3E%3Crdf%3ARDF%3E%3Ccc%3AWork%20rdf%3Aabout%3D%22%22%3E%3Cdc%3Aformat%3Eimage%2Fsvg%2Bxml%3C%2Fdc%3Aformat%3E%3Cdc%3Atype%20rdf%3Aresource%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Fdcmitype%2FStillImage%22%20%2F%3E%3Cdc%3Atitle%3E%3C%2Fdc%3Atitle%3E%3C%2Fcc%3AWork%3E%3C%2Frdf%3ARDF%3E%3C%2Fmetadata%3E%3Cdefs%20id%3D%22defs7%22%20%2F%3E%3Cpath%20d%3D%22M%2015%2C6%2010%2C6%20C%201.0301983%2C6.00505%2015.002631%2C6.011353%206%2C6%20L%201%2C6%20C%200.45%2C6%200%2C6.45%200%2C7%20l%200%2C2%20c%200%2C0.55%200.45%2C1%201%2C1%20l%205%2C0%20c%208.988585%2C-0.019732%20-5.02893401%2C-0.018728%204%2C0%20l%205%2C0%20c%200.55%2C0%201%2C-0.45%201%2C-1%20L%2016%2C7%20C%2016%2C6.45%2015.55%2C6%2015%2C6%20z%22%20id%3D%22path3%22%20style%3D%22fill%3A%236a6c8a%22%20%2F%3E%3C%2Fsvg%3E');\n}\n.x6-widget-handle-pie-toggle-opened:hover {\n  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3Adc%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%22%20xmlns%3Acc%3D%22http%3A%2F%2Fcreativecommons.org%2Fns%23%22%20xmlns%3Ardf%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%22%20xmlns%3Asvg%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20id%3D%22Layer_1%22%20xml%3Aspace%3D%22preserve%22%3E%3Cmetadata%20id%3D%22metadata9%22%3E%3Crdf%3ARDF%3E%3Ccc%3AWork%20rdf%3Aabout%3D%22%22%3E%3Cdc%3Aformat%3Eimage%2Fsvg%2Bxml%3C%2Fdc%3Aformat%3E%3Cdc%3Atype%20rdf%3Aresource%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Fdcmitype%2FStillImage%22%20%2F%3E%3Cdc%3Atitle%3E%3C%2Fdc%3Atitle%3E%3C%2Fcc%3AWork%3E%3C%2Frdf%3ARDF%3E%3C%2Fmetadata%3E%3Cdefs%20id%3D%22defs7%22%20%2F%3E%3Cpath%20d%3D%22M%2015%2C6%2010%2C6%20C%201.0301983%2C6.00505%2015.002631%2C6.011353%206%2C6%20L%201%2C6%20C%200.45%2C6%200%2C6.45%200%2C7%20l%200%2C2%20c%200%2C0.55%200.45%2C1%201%2C1%20l%205%2C0%20c%208.988585%2C-0.019732%20-5.02893401%2C-0.018728%204%2C0%20l%205%2C0%20c%200.55%2C0%201%2C-0.45%201%2C-1%20L%2016%2C7%20C%2016%2C6.45%2015.55%2C6%2015%2C6%20z%22%20id%3D%22path3%22%20style%3D%22fill%3A%23FD6EB6%22%20%2F%3E%3C%2Fsvg%3E');\n}\n.x6-widget-dnd {\n  position: absolute;\n  top: -10000px;\n  left: -10000px;\n  z-index: 100;\n  display: none;\n  cursor: move;\n  opacity: 0.7;\n  pointer-events: 'cursor';\n}\n.x6-widget-dnd.dragging {\n  display: inline-block;\n}\n.x6-widget-dnd.dragging * {\n  pointer-events: none !important;\n}\n.x6-widget-dnd .x6-graph {\n  background: transparent;\n  box-shadow: none;\n}\n.x6-widget-halo {\n  position: absolute;\n  pointer-events: none;\n}\n.x6-widget-halo-content {\n  position: absolute;\n  top: 100%;\n  padding: 6px;\n  font-size: 10px;\n  line-height: 14px;\n  text-align: center;\n  border-radius: 6px;\n}\n.x6-widget-halo-handles + .x6-widget-halo-content {\n  right: -20px;\n  left: -20px;\n  margin-top: 30px;\n}\n.x6-widget-halo-handles.x6-widget-handle-small + .x6-widget-halo-content {\n  margin-top: 25px;\n}\n.x6-widget-halo-handles.x6-widget-handle-small + .x6-widget-halo-content {\n  margin-top: 20px;\n}\n.x6-widget-halo-handles.x6-widget-handle-pie + .x6-widget-halo-content {\n  right: 0;\n  left: 0;\n  margin-top: 10px;\n}\n.x6-widget-halo-content {\n  color: #fff;\n  background-color: #6a6b8a;\n}\n.x6-widget-halo.type-node .x6-widget-handle-toolbar .x6-widget-handle-remove {\n  position: absolute;\n  right: 100%;\n  bottom: 100%;\n  margin-right: 6px;\n  margin-bottom: 3px;\n}\n.x6-widget-halo.type-edge .x6-widget-handle-surround .x6-widget-handle-remove {\n  background-color: #fff;\n  border-radius: 50%;\n}\n.x6-widget-halo.type-edge .x6-widget-handle-toolbar {\n  margin-top: -60px;\n  margin-left: -18px;\n}\n.x6-widget-halo.type-edge .x6-widget-handle-toolbar::after {\n  top: -22px;\n  left: -9px;\n}\n.x6-widget-minimap {\n  position: relative;\n  display: table-cell;\n  box-sizing: border-box;\n  overflow: hidden;\n  text-align: center;\n  vertical-align: middle;\n  background-color: #fff;\n  user-select: none;\n}\n.x6-widget-minimap .x6-graph {\n  display: inline-block;\n  box-shadow: 0 0 4px 0 #eee;\n  cursor: pointer;\n}\n.x6-widget-minimap .x6-graph > svg {\n  pointer-events: none;\n  shape-rendering: optimizeSpeed;\n}\n.x6-widget-minimap .x6-graph .x6-node * {\n  /* stylelint-disable-next-line */\n  vector-effect: initial;\n}\n.x6-widget-minimap-viewport {\n  position: absolute;\n  box-sizing: content-box;\n  margin: -2px 0 0 -2px;\n  border: 2px solid #31d0c6;\n  cursor: move;\n}\n.x6-widget-minimap-viewport-zoom {\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  width: 12px;\n  height: 12px;\n  margin: 0 -6px -6px 0;\n  background-color: #fff;\n  border: 2px solid #31d0c6;\n  border-radius: 50%;\n  cursor: nwse-resize;\n}\n.x6-path-drawer {\n  cursor: crosshair;\n}\n.x6-path-drawer .start-point {\n  fill: #fff;\n  stroke: #000;\n  stroke-width: 2px;\n}\n.x6-path-drawer .start-point:hover {\n  fill: #000;\n}\n.x6-path-drawer .control-path {\n  pointer-events: none;\n  fill: none;\n  stroke: #000;\n  stroke-width: 1px;\n  stroke-linecap: round;\n}\n.x6-graph-scroller {\n  position: relative;\n  box-sizing: border-box;\n  overflow: scroll;\n  outline: none;\n}\n.x6-graph-scroller-content {\n  position: relative;\n}\n.x6-graph-scroller-background {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.x6-graph-scroller .x6-graph {\n  position: absolute;\n  display: inline-block;\n  margin: 0;\n  box-shadow: none;\n}\n.x6-graph-scroller .x6-graph > svg {\n  display: block;\n}\n.x6-graph-scroller.x6-graph-scroller-paged .x6-graph {\n  box-shadow: 0 0 4px 0 #eee;\n}\n.x6-graph-scroller-panning {\n  user-select: none;\n}\n.x6-graph-pagebreak {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.x6-graph-pagebreak-vertical {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  width: 1px;\n  border-left: 1px dashed #bdbdbd;\n}\n.x6-graph-pagebreak-horizontal {\n  position: absolute;\n  right: 0;\n  left: 0;\n  box-sizing: border-box;\n  height: 1px;\n  border-top: 1px dashed #bdbdbd;\n}\n.x6-widget-selection {\n  position: absolute;\n  display: none;\n  width: 0;\n  height: 0;\n  touch-action: none;\n}\n.x6-widget-selection-rubberband {\n  display: block;\n  overflow: visible;\n  opacity: 0.3;\n}\n.x6-widget-selection-selected {\n  display: block;\n}\n.x6-widget-selection-box {\n  cursor: move;\n}\n.x6-widget-selection-inner[data-selection-length='0'],\n.x6-widget-selection-inner[data-selection-length='1'] {\n  display: none;\n}\n.x6-widget-selection-content {\n  position: absolute;\n  top: 100%;\n  right: -20px;\n  left: -20px;\n  margin-top: 30px;\n  padding: 6px;\n  line-height: 14px;\n  text-align: center;\n  border-radius: 6px;\n}\n.x6-widget-selection-content:empty {\n  display: none;\n}\n.x6-widget-selection-rubberband {\n  background-color: #3498db;\n  border: 2px solid #2980b9;\n}\n.x6-widget-selection-box {\n  box-sizing: content-box;\n  margin-top: -4px;\n  margin-left: -4px;\n  padding-right: 4px;\n  padding-bottom: 4px;\n  border: 2px dashed #feb663;\n  box-shadow: 2px 2px 5px #d3d3d3;\n}\n.x6-widget-selection-inner {\n  box-sizing: content-box;\n  margin-top: -8px;\n  margin-left: -8px;\n  padding-right: 12px;\n  padding-bottom: 12px;\n  border: 2px solid #feb663;\n  box-shadow: 2px 2px 5px #d3d3d3;\n}\n.x6-widget-selection-content {\n  color: #fff;\n  font-size: 10px;\n  background-color: #6a6b8a;\n}\n.x6-widget-snapline {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.x6-widget-snapline-vertical,\n.x6-widget-snapline-horizontal {\n  position: absolute;\n  opacity: 1;\n  pointer-events: none;\n}\n.x6-widget-snapline-horizontal {\n  border-bottom: 1px solid #2ecc71;\n}\n.x6-widget-snapline-vertical {\n  border-right: 1px solid #2ecc71;\n}\n.x6-widget-stencil {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.x6-widget-stencil::after {\n  position: absolute;\n  top: 0;\n  display: block;\n  width: 100%;\n  height: 20px;\n  padding: 8px 0;\n  line-height: 20px;\n  text-align: center;\n  opacity: 0;\n  transition: top 0.1s linear, opacity 0.1s linear;\n  content: ' ';\n  pointer-events: none;\n}\n.x6-widget-stencil-content {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  height: auto;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.x6-widget-stencil .x6-node [magnet]:not([magnet='passive']) {\n  pointer-events: none;\n}\n.x6-widget-stencil-group {\n  padding: 0;\n  padding-bottom: 8px;\n  overflow: hidden;\n  user-select: none;\n}\n.x6-widget-stencil-group.collapsed {\n  height: auto;\n  padding-bottom: 0;\n}\n.x6-widget-stencil-group-title {\n  position: relative;\n  margin-top: 0;\n  margin-bottom: 0;\n  padding: 4px;\n  cursor: pointer;\n}\n.x6-widget-stencil-title,\n.x6-widget-stencil-group > .x6-widget-stencil-group-title {\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  user-select: none;\n}\n.x6-widget-stencil .unmatched {\n  opacity: 0.3;\n}\n.x6-widget-stencil .x6-node.unmatched {\n  display: none;\n}\n.x6-widget-stencil-group.unmatched {\n  display: none;\n}\n.x6-widget-stencil-search-text {\n  position: relative;\n  z-index: 1;\n  box-sizing: border-box;\n  width: 100%;\n  height: 30px;\n  max-height: 30px;\n  line-height: 30px;\n  outline: 0;\n}\n.x6-widget-stencil.not-found::after {\n  opacity: 1;\n  content: 'No matches found';\n}\n.x6-widget-stencil.not-found.searchable::after {\n  top: 30px;\n}\n.x6-widget-stencil.not-found.searchable.collapsable::after {\n  top: 50px;\n}\n.x6-widget-stencil {\n  color: #333;\n  background: #f5f5f5;\n}\n.x6-widget-stencil-content {\n  position: absolute;\n}\n.x6-widget-stencil.collapsable > .x6-widget-stencil-content {\n  top: 32px;\n}\n.x6-widget-stencil.searchable > .x6-widget-stencil-content {\n  top: 80px;\n}\n.x6-widget-stencil.not-found::after {\n  position: absolute;\n}\n.x6-widget-stencil.not-found.searchable.collapsable::after {\n  top: 80px;\n}\n.x6-widget-stencil.not-found.searchable::after {\n  top: 60px;\n}\n.x6-widget-stencil-group {\n  height: auto;\n  margin-bottom: 1px;\n  padding: 0;\n  transition: none;\n}\n.x6-widget-stencil-group .x6-graph {\n  background: transparent;\n  box-shadow: none;\n}\n.x6-widget-stencil-group.collapsed {\n  height: auto;\n  max-height: 31px;\n}\n.x6-widget-stencil-title,\n.x6-widget-stencil-group > .x6-widget-stencil-group-title {\n  position: relative;\n  left: 0;\n  box-sizing: border-box;\n  width: 100%;\n  height: 32px;\n  padding: 0 5px 0 8px;\n  color: #666;\n  font-weight: 700;\n  font-size: 12px;\n  line-height: 32px;\n  cursor: default;\n  transition: all 0.3;\n}\n.x6-widget-stencil-title:hover,\n.x6-widget-stencil-group > .x6-widget-stencil-group-title:hover {\n  color: #444;\n}\n.x6-widget-stencil-title {\n  background: #e9e9e9;\n}\n.x6-widget-stencil-group > .x6-widget-stencil-group-title {\n  background: #ededed;\n}\n.x6-widget-stencil.collapsable > .x6-widget-stencil-title,\n.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title {\n  padding-left: 32px;\n  cursor: pointer;\n}\n.x6-widget-stencil.collapsable > .x6-widget-stencil-title::before,\n.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title::before {\n  position: absolute;\n  top: 6px;\n  left: 8px;\n  display: block;\n  width: 18px;\n  height: 18px;\n  margin: 0;\n  padding: 0;\n  background-color: transparent;\n  background-repeat: no-repeat;\n  background-position: 0 0;\n  border: none;\n  content: ' ';\n}\n.x6-widget-stencil.collapsable > .x6-widget-stencil-title::before,\n.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title::before {\n  background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBkPSJNOS4zNzUuNUM0LjY4Ny41Ljg3NSA0LjMxMy44NzUgOWMwIDQuNjg4IDMuODEyIDguNSA4LjUgOC41IDQuNjg3IDAgOC41LTMuODEyIDguNS04LjUgMC00LjY4Ny0zLjgxMy04LjUtOC41LTguNXptMCAxNS44ODZDNS4zMDMgMTYuMzg2IDEuOTkgMTMuMDcyIDEuOTkgOXMzLjMxMi03LjM4NSA3LjM4NS03LjM4NVMxNi43NiA0LjkyOCAxNi43NiA5YzAgNC4wNzItMy4zMTMgNy4zODYtNy4zODUgNy4zODZ6Ii8+PHBhdGggZD0iTTEyLjc1MyA4LjQ0M0g1Ljk5N2EuNTU4LjU1OCAwIDAwMCAxLjExNmg2Ljc1NmEuNTU4LjU1OCAwIDAwMC0xLjExNnoiLz48L2c+PC9zdmc+');\n  opacity: 0.4;\n  transition: all 0.3s;\n}\n.x6-widget-stencil.collapsable > .x6-widget-stencil-title:hover::before,\n.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title:hover::before {\n  opacity: 0.6;\n}\n.x6-widget-stencil.collapsable.collapsed > .x6-widget-stencil-title::before,\n.x6-widget-stencil-group.collapsable.collapsed > .x6-widget-stencil-group-title::before {\n  background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBkPSJNOS4zNzUuNUM0LjY4Ny41Ljg3NSA0LjMxMy44NzUgOWMwIDQuNjg4IDMuODEyIDguNSA4LjUgOC41IDQuNjg3IDAgOC41LTMuODEyIDguNS04LjUgMC00LjY4Ny0zLjgxMy04LjUtOC41LTguNXptMCAxNS44ODZDNS4zMDMgMTYuMzg2IDEuOTkgMTMuMDcyIDEuOTkgOXMzLjMxMi03LjM4NSA3LjM4NS03LjM4NVMxNi43NiA0LjkyOCAxNi43NiA5YzAgNC4wNzItMy4zMTMgNy4zODYtNy4zODUgNy4zODZ6Ii8+PHBhdGggZD0iTTEyLjc1MyA4LjQ0M0g1Ljk5N2EuNTU4LjU1OCAwIDAwMCAxLjExNmg2Ljc1NmEuNTU4LjU1OCAwIDAwMC0xLjExNnoiLz48cGF0aCBkPSJNOC44MTcgNS42MjN2Ni43NTZhLjU1OC41NTggMCAwMDEuMTE2IDBWNS42MjNhLjU1OC41NTggMCAxMC0xLjExNiAweiIvPjwvZz48L3N2Zz4=');\n  opacity: 0.4;\n}\n.x6-widget-stencil.collapsable.collapsed > .x6-widget-stencil-title:hover::before,\n.x6-widget-stencil-group.collapsable.collapsed > .x6-widget-stencil-group-title:hover::before {\n  opacity: 0.6;\n}\n.x6-widget-stencil input[type='search'] {\n  -webkit-appearance: textfield;\n}\n.x6-widget-stencil input[type='search']::-webkit-search-cancel-button,\n.x6-widget-stencil input[type='search']::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n.x6-widget-stencil-search-text {\n  display: block;\n  width: 90%;\n  margin: 8px 5%;\n  padding-left: 8px;\n  color: #333;\n  background: #fff;\n  border: 1px solid #e9e9e9;\n  border-radius: 12px;\n  outline: 0;\n}\n.x6-widget-stencil-search-text:focus {\n  outline: 0;\n}\n.x6-widget-stencil::after {\n  color: #808080;\n  font-weight: 600;\n  font-size: 12px;\n  background: 0 0;\n}\n.x6-widget-transform {\n  position: absolute;\n  box-sizing: content-box;\n  margin: -5px 0 0 -5px;\n  padding: 4px;\n  border: 1px dashed #000;\n  border-radius: 5px;\n  user-select: none;\n  pointer-events: none;\n}\n.x6-widget-transform > div {\n  position: absolute;\n  box-sizing: border-box;\n  background-color: #fff;\n  border: 1px solid #000;\n  transition: background-color 0.2s;\n  pointer-events: auto;\n  -webkit-user-drag: none;\n  user-drag: none;\n  /* stylelint-disable-line */\n}\n.x6-widget-transform > div:hover {\n  background-color: #d3d3d3;\n}\n.x6-widget-transform-cursor-n {\n  cursor: n-resize;\n}\n.x6-widget-transform-cursor-s {\n  cursor: s-resize;\n}\n.x6-widget-transform-cursor-e {\n  cursor: e-resize;\n}\n.x6-widget-transform-cursor-w {\n  cursor: w-resize;\n}\n.x6-widget-transform-cursor-ne {\n  cursor: ne-resize;\n}\n.x6-widget-transform-cursor-nw {\n  cursor: nw-resize;\n}\n.x6-widget-transform-cursor-se {\n  cursor: se-resize;\n}\n.x6-widget-transform-cursor-sw {\n  cursor: sw-resize;\n}\n.x6-widget-transform-resize {\n  width: 10px;\n  height: 10px;\n  border-radius: 6px;\n}\n.x6-widget-transform-resize[data-position='top-left'] {\n  top: -5px;\n  left: -5px;\n}\n.x6-widget-transform-resize[data-position='top-right'] {\n  top: -5px;\n  right: -5px;\n}\n.x6-widget-transform-resize[data-position='bottom-left'] {\n  bottom: -5px;\n  left: -5px;\n}\n.x6-widget-transform-resize[data-position='bottom-right'] {\n  right: -5px;\n  bottom: -5px;\n}\n.x6-widget-transform-resize[data-position='top'] {\n  top: -5px;\n  left: 50%;\n  margin-left: -5px;\n}\n.x6-widget-transform-resize[data-position='bottom'] {\n  bottom: -5px;\n  left: 50%;\n  margin-left: -5px;\n}\n.x6-widget-transform-resize[data-position='left'] {\n  top: 50%;\n  left: -5px;\n  margin-top: -5px;\n}\n.x6-widget-transform-resize[data-position='right'] {\n  top: 50%;\n  right: -5px;\n  margin-top: -5px;\n}\n.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='top'],\n.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='bottom'],\n.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='left'],\n.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='right'] {\n  display: none;\n}\n.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='bottom'],\n.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='left'],\n.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='right'],\n.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='top'] {\n  display: none;\n}\n.x6-widget-transform.no-resize .x6-widget-transform-resize {\n  display: none;\n}\n.x6-widget-transform-rotate {\n  top: -20px;\n  left: -20px;\n  width: 12px;\n  height: 12px;\n  border-radius: 6px;\n  cursor: crosshair;\n}\n.x6-widget-transform.no-rotate .x6-widget-transform-rotate {\n  display: none;\n}\n.x6-widget-transform-active {\n  pointer-events: all;\n}\n.x6-widget-transform-active > div {\n  display: none;\n}\n.x6-widget-transform-active > .x6-widget-transform-active-handle {\n  display: block;\n  background-color: #808080;\n}\n.x6-graph-print {\n  position: relative;\n}\n.x6-graph-print .x6-graph-print-ready {\n  display: none;\n}\n.x6-graph-print .x6-graph-print-preview {\n  overflow: hidden !important;\n  background: #fff !important;\n}\n@media print {\n  html,\n  html > body.x6-graph-printing {\n    position: relative !important;\n    width: 100% !important;\n    height: 100% !important;\n    margin: 0 !important;\n    padding: 0 !important;\n  }\n  html > body.x6-graph-printing > * {\n    display: none !important;\n  }\n  html > body.x6-graph-printing > .x6-graph-print {\n    display: block !important;\n  }\n  .x6-graph-print {\n    top: 0 !important;\n    left: 0 !important;\n    margin: 0 !important;\n    padding: 0 !important;\n    overflow: hidden !important;\n    page-break-after: always;\n    background: #fff !important;\n  }\n  .x6-graph-print .x6-graph-print-ready {\n    display: none;\n  }\n}\n";

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/css.js








var css_CSSManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(CSSManager, _Base);

  var _super = Object(createSuper["a" /* default */])(CSSManager);

  function CSSManager() {
    Object(classCallCheck["a" /* default */])(this, CSSManager);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(CSSManager, [{
    key: "init",
    value: function init() {
      if (Config.autoInsertCSS) {
        CSSManager.ensure();
      }
    }
  }]);

  return CSSManager;
}(graph_base_Base);

(function (CSSManager) {
  var styleElement;

  function ensure() {
    if (styleElement == null && !platform["a" /* Platform */].isApplyingHMR()) {
      styleElement = document.createElement('style');
      styleElement.setAttribute('type', 'text/css');
      styleElement.textContent = raw_content;
      var head = document.querySelector('head');

      if (head) {
        head.insertBefore(styleElement, head.firstChild);
      }
    }
  }

  CSSManager.ensure = ensure;
})(css_CSSManager || (css_CSSManager = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/minimap/index.js









var ClassName;

(function (ClassName) {
  ClassName.root = 'widget-minimap';
  ClassName.viewport = "".concat(ClassName.root, "-viewport");
  ClassName.zoom = "".concat(ClassName.viewport, "-zoom");
})(ClassName || (ClassName = {}));

var minimap_MiniMap = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(MiniMap, _View);

  var _super = Object(createSuper["a" /* default */])(MiniMap);

  function MiniMap(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, MiniMap);

    _this = _super.call(this);
    _this.options = Object.assign(Object.assign({}, minimap_Util.defaultOptions), options);
    _this.updateViewport = main_namespaceObject.debounce(_this.updateViewport.bind(Object(assertThisInitialized["a" /* default */])(_this)), 0);
    _this.container = document.createElement('div');
    _this.$container = _this.$(_this.container).addClass(_this.prefixClassName(ClassName.root));
    var graphContainer = document.createElement('div');

    _this.container.appendChild(graphContainer);

    _this.$viewport = _this.$('<div>').addClass(_this.prefixClassName(ClassName.viewport));

    if (_this.options.scalable) {
      _this.zoomHandle = _this.$('<div>').addClass(_this.prefixClassName(ClassName.zoom)).appendTo(_this.$viewport).get(0);
    }

    _this.$container.append(_this.$viewport).css({
      width: _this.options.width,
      height: _this.options.height,
      padding: _this.options.padding
    });

    if (_this.options.container) {
      _this.options.container.appendChild(_this.container);
    }

    _this.sourceGraph = _this.scroller.graph;
    var targetGraphOptions = Object.assign(Object.assign({}, _this.options.graphOptions), {
      container: graphContainer,
      model: _this.sourceGraph.model,
      frozen: true,
      interacting: false,
      grid: false,
      background: false,
      rotating: false,
      resizing: false,
      embedding: false,
      selecting: false,
      snapline: false,
      clipboard: false,
      history: false,
      scroller: false
    });
    _this.targetGraph = _this.options.createGraph ? _this.options.createGraph(targetGraphOptions) : new graph_Graph(targetGraphOptions);

    _this.targetGraph.renderer.unfreeze();

    _this.updatePaper(_this.sourceGraph.options.width, _this.sourceGraph.options.height);

    _this.startListening();

    return _this;
  }

  Object(createClass["a" /* default */])(MiniMap, [{
    key: "startListening",
    value: function startListening() {
      var _this$delegateEvents;

      this.scroller.$container.on("scroll".concat(this.getEventNamespace()), this.updateViewport);
      this.sourceGraph.on('resize', this.updatePaper, this);
      this.delegateEvents((_this$delegateEvents = {
        mousedown: 'startAction',
        touchstart: 'startAction'
      }, Object(defineProperty["a" /* default */])(_this$delegateEvents, "mousedown .".concat(this.prefixClassName('graph')), 'scrollTo'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "touchstart .".concat(this.prefixClassName('graph')), 'scrollTo'), _this$delegateEvents));
    }
  }, {
    key: "stopListening",
    value: function stopListening() {
      this.scroller.$container.off(this.getEventNamespace());
      this.sourceGraph.off('resize', this.updatePaper, this);
      this.undelegateEvents();
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.targetGraph.view.remove();
      this.stopListening();
    }
  }, {
    key: "updatePaper",
    value: function updatePaper(w, h) {
      var width;
      var height;

      if (typeof w === 'object') {
        width = w.width;
        height = w.height;
      } else {
        width = w;
        height = h;
      }

      var origin = this.sourceGraph.options;
      var scale = this.sourceGraph.scale();
      var maxWidth = this.options.width - 2 * this.options.padding;
      var maxHeight = this.options.height - 2 * this.options.padding;
      width = width / scale.sx; // tslint:disable-line

      height = height / scale.sy; // tslint:disable-line

      this.ratio = Math.min(maxWidth / width, maxHeight / height);
      var ratio = this.ratio;
      var x = origin.x * ratio / scale.sx;
      var y = origin.y * ratio / scale.sy;
      width = width * ratio; // tslint:disable-line

      height = height * ratio; // tslint:disable-line

      this.targetGraph.resizeGraph(width, height);
      this.targetGraph.setOrigin(x, y);
      this.targetGraph.scale(ratio, ratio);
      this.updateViewport();
      return this;
    }
  }, {
    key: "updateViewport",
    value: function updateViewport() {
      var ratio = this.ratio;
      var scale = this.sourceGraph.scale();
      var scroller = this.scroller;
      var origin = scroller.clientToLocalPoint(0, 0);
      var position = this.$(this.targetGraph.container).position();
      var translation = this.targetGraph.translate();
      translation.ty = translation.ty || 0;
      this.geometry = {
        top: position.top + origin.y * ratio + translation.ty,
        left: position.left + origin.x * ratio + translation.tx,
        width: scroller.$container.innerWidth() * ratio / scale.sx,
        height: scroller.$container.innerHeight() * ratio / scale.sy
      };
      this.$viewport.css(this.geometry);
    }
  }, {
    key: "startAction",
    value: function startAction(evt) {
      var e = this.normalizeEvent(evt);
      var action = e.target === this.zoomHandle ? 'zooming' : 'panning';
      var eventData = {
        action: action,
        clientX: e.clientX,
        clientY: e.clientY,
        scrollLeft: this.scroller.container.scrollLeft,
        scrollTop: this.scroller.container.scrollTop,
        zoom: this.scroller.zoom(),
        scale: this.sourceGraph.scale(),
        geometry: this.geometry
      };
      this.delegateDocumentEvents(minimap_Util.documentEvents, eventData);
    }
  }, {
    key: "doAction",
    value: function doAction(evt) {
      var _this2 = this;

      var e = this.normalizeEvent(evt);
      var clientX = e.clientX;
      var clientY = e.clientY;
      var data = e.data;

      switch (data.action) {
        case 'panning':
          {
            var scale = this.sourceGraph.scale();
            var rx = (clientX - data.clientX) * scale.sx;
            var ry = (clientY - data.clientY) * scale.sy;
            this.scroller.container.scrollLeft = data.scrollLeft + rx / this.ratio;
            this.scroller.container.scrollTop = data.scrollTop + ry / this.ratio;
            break;
          }

        case 'zooming':
          {
            var startScale = data.scale;
            var startGeometry = data.geometry;
            var delta = 1 + (data.clientX - clientX) / startGeometry.width / startScale.sx;

            if (data.frameId) {
              cancelAnimationFrame(data.frameId);
            }

            data.frameId = requestAnimationFrame(function () {
              _this2.scroller.zoom(delta * data.zoom, {
                absolute: true,
                minScale: _this2.options.minScale,
                maxScale: _this2.options.maxScale
              });
            });
            break;
          }
      }
    }
  }, {
    key: "stopAction",
    value: function stopAction() {
      this.undelegateDocumentEvents();
    }
  }, {
    key: "scrollTo",
    value: function scrollTo(evt) {
      var e = this.normalizeEvent(evt);
      var x;
      var y;
      var ts = this.targetGraph.translate();
      ts.ty = ts.ty || 0;

      if (e.offsetX == null) {
        var offset = this.$(this.targetGraph.container).offset();
        x = e.pageX - offset.left;
        y = e.pageY - offset.top;
      } else {
        x = e.offsetX;
        y = e.offsetY;
      }

      var cx = (x - ts.tx) / this.ratio;
      var cy = (y - ts.ty) / this.ratio;
      this.scroller.centerPoint(cx, cy);
    }
  }, {
    key: "scroller",
    get: function get() {
      return this.options.scroller;
    }
  }]);

  return MiniMap;
}(view_View);
var minimap_Util;

(function (Util) {
  Util.defaultOptions = {
    width: 300,
    height: 200,
    padding: 10,
    scalable: true,
    minScale: 0.01,
    maxScale: 16,
    graphOptions: {},
    createGraph: function createGraph(options) {
      return new graph_Graph(options);
    }
  };
  Util.documentEvents = {
    mousemove: 'doAction',
    touchmove: 'doAction',
    mouseup: 'stopAction',
    touchend: 'stopAction'
  };
})(minimap_Util || (minimap_Util = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/snapline/index.js





var snapline_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var snapline_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




var snapline_Snapline = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(Snapline, _View);

  var _super = Object(createSuper["a" /* default */])(Snapline);

  function Snapline(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Snapline);

    _this = _super.call(this);

    var graph = options.graph,
        others = snapline_rest(options, ["graph"]);

    _this.graph = graph;
    _this.options = Object.assign({
      tolerance: 10
    }, others);

    _this.render();

    _this.parseFilter();

    if (!_this.disabled) {
      _this.startListening();
    }

    return _this;
  }

  Object(createClass["a" /* default */])(Snapline, [{
    key: "enable",
    value: function enable() {
      if (this.disabled) {
        this.options.enabled = true;
        this.graph.options.snapline.enabled = true;
        this.startListening();
      }
    }
  }, {
    key: "disable",
    value: function disable() {
      if (!this.disabled) {
        this.options.enabled = false;
        this.graph.options.snapline.enabled = false;
        this.stopListening();
      }
    }
  }, {
    key: "setFilter",
    value: function setFilter(filter) {
      this.options.filter = filter;
      this.parseFilter();
    }
  }, {
    key: "render",
    value: function render() {
      this.container = document.createElement('div');
      this.$container = this.$(this.container);
      this.$horizontal = this.$(document.createElement('div')).addClass(this.horizontalClassName);
      this.$vertical = this.$(document.createElement('div')).addClass(this.verticalClassName);
      this.$container.hide().addClass(this.containerClassName).append([this.$horizontal, this.$vertical]);

      if (this.options.className) {
        this.$container.addClass(this.options.className);
      }
    }
  }, {
    key: "startListening",
    value: function startListening() {
      this.stopListening();
      this.graph.on('node:mousedown', this.captureCursorOffset, this);
      this.graph.on('node:mousemove', this.snapOnMoving, this);
      this.model.on('batch:stop', this.onBatchStop, this);
      this.delegateDocumentEvents({
        mouseup: 'hide',
        touchend: 'hide'
      });
    }
  }, {
    key: "stopListening",
    value: function stopListening() {
      this.graph.off('node:mousedown', this.captureCursorOffset, this);
      this.graph.off('node:mousemove', this.snapOnMoving, this);
      this.model.off('batch:stop', this.onBatchStop, this);
      this.undelegateDocumentEvents();
    }
  }, {
    key: "parseFilter",
    value: function parseFilter() {
      var _this2 = this;

      this.filterShapes = {};
      this.filterCells = {};
      this.filterFunction = null;
      var filter = this.options.filter;

      if (Array.isArray(filter)) {
        filter.forEach(function (item) {
          if (typeof item === 'string') {
            _this2.filterShapes[item] = true;
          } else {
            _this2.filterCells[item.id] = true;
          }
        });
      } else {
        if (typeof filter === 'function') {
          this.filterFunction = filter;
        }
      }
    }
  }, {
    key: "onBatchStop",
    value: function onBatchStop(_ref) {
      var name = _ref.name,
          data = _ref.data;

      if ('resize' === name) {
        this.snapOnResizing(data.cell, data);
      }
    }
  }, {
    key: "captureCursorOffset",
    value: function captureCursorOffset(_ref2) {
      var view = _ref2.view,
          x = _ref2.x,
          y = _ref2.y;
      var targetView = view.getDelegatedView();

      if (targetView && this.isNodeMovable(targetView)) {
        var pos = view.cell.getPosition();
        this.offset = {
          x: x - pos.x,
          y: y - pos.y
        };
      }
    }
  }, {
    key: "isNodeMovable",
    value: function isNodeMovable(view) {
      return view && view.cell.isNode() && view.can('nodeMovable');
    }
  }, {
    key: "snapOnResizing",
    value: function snapOnResizing(node, options) {
      var _this3 = this;

      if (this.options.resizing && !options.snapped && options.ui && options.direction && options.trueDirection) {
        var view = this.graph.renderer.findViewByCell(node);

        if (view && view.cell.isNode()) {
          var nodeBbox = node.getBBox();
          var nodeBBoxRotated = nodeBbox.bbox(node.getAngle());
          var nodeTopLeft = nodeBBoxRotated.getTopLeft();
          var nodeBottomRight = nodeBBoxRotated.getBottomRight();
          var angle = Angle.normalize(node.getAngle());
          var tolerance = this.options.tolerance || 0;
          var verticalLeft;
          var verticalTop;
          var verticalHeight;
          var horizontalTop;
          var horizontalLeft;
          var horizontalWidth;
          var snapOrigin = {
            vertical: 0,
            horizontal: 0
          };
          var direction = options.direction;
          var trueDirection = options.trueDirection;
          var relativeDirection = options.relativeDirection;

          if (trueDirection.indexOf('right') !== -1) {
            snapOrigin.vertical = nodeBottomRight.x;
          } else {
            snapOrigin.vertical = nodeTopLeft.x;
          }

          if (trueDirection.indexOf('bottom') !== -1) {
            snapOrigin.horizontal = nodeBottomRight.y;
          } else {
            snapOrigin.horizontal = nodeTopLeft.y;
          }

          this.model.getNodes().some(function (cell) {
            if (_this3.isIgnored(node, cell)) {
              return false;
            }

            var snapBBox = cell.getBBox().bbox(cell.getAngle());
            var snapTopLeft = snapBBox.getTopLeft();
            var snapBottomRight = snapBBox.getBottomRight();
            var groups = {
              vertical: [snapTopLeft.x, snapBottomRight.x],
              horizontal: [snapTopLeft.y, snapBottomRight.y]
            };
            var distances = {};
            Object.keys(groups).forEach(function (k) {
              var key = k;
              var list = groups[key].map(function (value) {
                return {
                  position: value,
                  distance: Math.abs(value - snapOrigin[key])
                };
              }).filter(function (item) {
                return item.distance <= tolerance;
              });
              distances[key] = array_namespaceObject.sortBy(list, function (item) {
                return item.distance;
              });
            });

            if (verticalLeft == null && distances.vertical.length > 0) {
              verticalLeft = distances.vertical[0].position;
              verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);
              verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;
            }

            if (horizontalTop == null && distances.horizontal.length > 0) {
              horizontalTop = distances.horizontal[0].position;
              horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);
              horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;
            }

            return verticalLeft != null && horizontalTop != null;
          });
          this.hide();
          var dx = 0;
          var dy = 0;

          if (horizontalTop != null || verticalLeft != null) {
            if (verticalLeft != null) {
              dx = trueDirection.indexOf('right') !== -1 ? verticalLeft - nodeBottomRight.x : nodeTopLeft.x - verticalLeft;
            }

            if (horizontalTop != null) {
              dy = trueDirection.indexOf('bottom') !== -1 ? horizontalTop - nodeBottomRight.y : nodeTopLeft.y - horizontalTop;
            }
          }

          var dWidth = 0;
          var dHeight = 0;

          if (angle % 90 === 0) {
            if (90 === angle || 270 === angle) {
              dWidth = dy;
              dHeight = dx;
            } else {
              dWidth = dx;
              dHeight = dy;
            }
          } else {
            var quadrant = 0 <= angle && angle < 90 ? 1 : 90 <= angle && angle < 180 ? 4 : 180 <= angle && angle < 270 ? 3 : 2;

            if (horizontalTop != null && verticalLeft != null) {
              if (dx < dy) {
                dy = 0;
                horizontalTop = undefined;
              } else {
                dx = 0;
                verticalLeft = undefined;
              }
            }

            var rad = Angle.toRad(angle % 90);

            if (dx) {
              dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad);
            }

            if (dy) {
              dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad);
            }

            var quadrant13 = 1 === quadrant || 3 === quadrant;

            switch (relativeDirection) {
              case 'top':
              case 'bottom':
                dHeight = dy ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad));
                break;

              case 'left':
              case 'right':
                dWidth = dx ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad));
            }
          }

          switch (relativeDirection) {
            case 'top':
            case 'bottom':
              dWidth = 0;
              break;

            case 'left':
            case 'right':
              dHeight = 0;
          }

          var gridSize = this.graph.getGridSize();
          var newWidth = Math.max(nodeBbox.width + dWidth, gridSize);
          var newHeight = Math.max(nodeBbox.height + dHeight, gridSize);

          if (options.minWidth && options.minWidth > gridSize) {
            newWidth = Math.max(newWidth, options.minWidth);
          }

          if (options.minHeight && options.minHeight > gridSize) {
            newHeight = Math.max(newHeight, options.minHeight);
          }

          if (options.maxWidth) {
            newWidth = Math.min(newWidth, options.maxWidth);
          }

          if (options.maxHeight) {
            newHeight = Math.min(newHeight, options.maxHeight);
          }

          if (options.preserveAspectRatio) {
            if (dHeight < dWidth) {
              newHeight = newWidth * (nodeBbox.height / nodeBbox.width);
            } else {
              newWidth = newHeight * (nodeBbox.width / nodeBbox.height);
            }
          }

          if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {
            node.resize(newWidth, newHeight, {
              direction: direction,
              relativeDirection: relativeDirection,
              trueDirection: trueDirection,
              snapped: true,
              snaplines: this.cid,
              restrict: this.graph.getRestrictArea(view)
            });

            if (verticalHeight) {
              verticalHeight += newHeight - nodeBbox.height;
            }

            if (horizontalWidth) {
              horizontalWidth += newWidth - nodeBbox.width;
            }
          }

          var newRotatedBBox = node.getBBox().bbox(angle);

          if (verticalLeft && Math.abs(newRotatedBBox.x - verticalLeft) > 1 && Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1) {
            verticalLeft = undefined;
          }

          if (horizontalTop && Math.abs(newRotatedBBox.y - horizontalTop) > 1 && Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1) {
            horizontalTop = undefined;
          }

          this.update({
            verticalLeft: verticalLeft,
            verticalTop: verticalTop,
            verticalHeight: verticalHeight,
            horizontalTop: horizontalTop,
            horizontalLeft: horizontalLeft,
            horizontalWidth: horizontalWidth
          });
        }
      }
    }
  }, {
    key: "snapOnMoving",
    value: function snapOnMoving(_ref3) {
      var _this4 = this;

      var view = _ref3.view,
          e = _ref3.e,
          x = _ref3.x,
          y = _ref3.y;
      var targetView = view.getEventData(e).delegatedView || view;

      if (!this.isNodeMovable(targetView)) {
        return;
      }

      var node = targetView.cell;
      var size = node.getSize();
      var position = node.getPosition();
      var cellBBox = new rectangle_Rectangle(x - this.offset.x, y - this.offset.y, size.width, size.height);
      var angle = node.getAngle();
      var nodeCenter = cellBBox.getCenter();
      var nodeBBoxRotated = cellBBox.bbox(angle);
      var nodeTopLeft = nodeBBoxRotated.getTopLeft();
      var nodeBottomRight = nodeBBoxRotated.getBottomRight();
      var distance = this.options.tolerance || 0;
      var verticalLeft;
      var verticalTop;
      var verticalHeight;
      var horizontalTop;
      var horizontalLeft;
      var horizontalWidth;
      var verticalFix = 0;
      var horizontalFix = 0;
      this.model.getNodes().some(function (targetNode) {
        if (_this4.isIgnored(node, targetNode)) {
          return false;
        }

        var snapBBox = targetNode.getBBox().bbox(targetNode.getAngle());
        var snapCenter = snapBBox.getCenter();
        var snapTopLeft = snapBBox.getTopLeft();
        var snapBottomRight = snapBBox.getBottomRight();

        if (verticalLeft == null) {
          if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {
            verticalLeft = snapCenter.x;
            verticalFix = 0.5;
          } else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {
            verticalLeft = snapTopLeft.x;
            verticalFix = 0;
          } else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {
            verticalLeft = snapTopLeft.x;
            verticalFix = 1;
          } else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {
            verticalLeft = snapBottomRight.x;
            verticalFix = 1;
          } else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {
            verticalLeft = snapBottomRight.x;
          }

          if (verticalLeft != null) {
            verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);
            verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;
          }
        }

        if (horizontalTop == null) {
          if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {
            horizontalTop = snapCenter.y;
            horizontalFix = 0.5;
          } else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {
            horizontalTop = snapTopLeft.y;
          } else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {
            horizontalTop = snapTopLeft.y;
            horizontalFix = 1;
          } else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {
            horizontalTop = snapBottomRight.y;
            horizontalFix = 1;
          } else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {
            horizontalTop = snapBottomRight.y;
          }

          if (horizontalTop != null) {
            horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);
            horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;
          }
        }

        return verticalLeft != null && horizontalTop != null;
      });
      this.hide();

      if (horizontalTop != null || verticalLeft != null) {
        if (horizontalTop != null) {
          nodeBBoxRotated.y = horizontalTop - horizontalFix * nodeBBoxRotated.height;
        }

        if (verticalLeft != null) {
          nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width;
        }

        var newCenter = nodeBBoxRotated.getCenter();
        var newX = newCenter.x - cellBBox.width / 2;
        var newY = newCenter.y - cellBBox.height / 2;
        var dx = newX - position.x;
        var dy = newY - position.y;

        if (dx !== 0 || dy !== 0) {
          node.translate(dx, dy, {
            snapped: true,
            restrict: this.graph.getRestrictArea(targetView)
          });

          if (horizontalWidth) {
            horizontalWidth += dx;
          }

          if (verticalHeight) {
            verticalHeight += dy;
          }
        }

        this.update({
          verticalLeft: verticalLeft,
          verticalTop: verticalTop,
          verticalHeight: verticalHeight,
          horizontalTop: horizontalTop,
          horizontalLeft: horizontalLeft,
          horizontalWidth: horizontalWidth
        });
      }
    }
  }, {
    key: "isIgnored",
    value: function isIgnored(snapNode, targetNode) {
      return targetNode.id === snapNode.id || targetNode.isDescendantOf(snapNode) || this.filterShapes[targetNode.shape] || this.filterCells[targetNode.id] || this.filterFunction && main_namespaceObject.call(this.filterFunction, this.graph, targetNode);
    }
  }, {
    key: "update",
    value: function update(metadata) {
      var ctm = this.graph.matrix();
      var sx = ctm.a;
      var sy = ctm.d;
      var tx = ctm.e;
      var ty = ctm.f;
      var sharp = this.options.sharp;
      var hasScroller = this.graph.scroller.widget != null;

      if (metadata.horizontalTop) {
        this.$horizontal.css({
          top: metadata.horizontalTop * sy + ty,
          left: sharp ? metadata.horizontalLeft * sx + tx : hasScroller ? '-300%' : 0,
          width: sharp ? metadata.horizontalWidth * sx : hasScroller ? '700%' : '100%'
        }).show();
      } else {
        this.$horizontal.hide();
      }

      if (metadata.verticalLeft) {
        this.$vertical.css({
          left: metadata.verticalLeft * sx + tx,
          top: sharp ? metadata.verticalTop * sy + ty : hasScroller ? '-300%' : 0,
          height: sharp ? metadata.verticalHeight * sy : hasScroller ? '700%' : '100%'
        }).show();
      } else {
        this.$vertical.hide();
      }

      this.show();
    }
  }, {
    key: "resetTimer",
    value: function resetTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: "show",
    value: function show() {
      this.$container.show();
      this.resetTimer();

      if (this.container.parentNode == null) {
        this.graph.container.appendChild(this.container);
      }

      return this;
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this5 = this;

      this.$container.hide();
      this.resetTimer();
      var clean = this.options.clean;
      var delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0;

      if (delay > 0) {
        this.timer = window.setTimeout(function () {
          _this5.unmount();
        }, delay);
      }

      return this;
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.stopListening();
      this.hide();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.remove();
    }
  }, {
    key: "model",
    get: function get() {
      return this.graph.model;
    }
  }, {
    key: "containerClassName",
    get: function get() {
      return this.prefixClassName('widget-snapline');
    }
  }, {
    key: "verticalClassName",
    get: function get() {
      return "".concat(this.containerClassName, "-vertical");
    }
  }, {
    key: "horizontalClassName",
    get: function get() {
      return "".concat(this.containerClassName, "-horizontal");
    }
  }, {
    key: "disabled",
    get: function get() {
      return this.options.enabled !== true || this.graph.options.snapline.enabled !== true;
    }
  }]);

  return Snapline;
}(view_View);

snapline_decorate([view_View.dispose()], snapline_Snapline.prototype, "dispose", null);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/background.js





var background_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





var background_BackgroundManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(BackgroundManager, _Base);

  var _super = Object(createSuper["a" /* default */])(BackgroundManager);

  function BackgroundManager() {
    Object(classCallCheck["a" /* default */])(this, BackgroundManager);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(BackgroundManager, [{
    key: "init",
    value: function init() {
      this.graph.on('scale', this.update, this);
      this.graph.on('translate', this.update, this);

      if (this.options.background) {
        this.draw(this.options.background);
      }
    }
  }, {
    key: "updateBackgroundImage",
    value: function updateBackgroundImage() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var backgroundSize = options.size || 'auto auto';
      var backgroundPosition = options.position || 'center';
      var scale = this.graph.scale();
      var ts = this.graph.translate(); // backgroundPosition

      if (typeof backgroundPosition === 'object') {
        var x = ts.tx + scale.sx * (backgroundPosition.x || 0);
        var y = ts.ty + scale.sy * (backgroundPosition.y || 0);
        backgroundPosition = "".concat(x, "px ").concat(y, "px");
      } // backgroundSize


      if (typeof backgroundSize === 'object') {
        backgroundSize = rectangle_Rectangle.fromSize(backgroundSize).scale(scale.sx, scale.sy);
        backgroundSize = "".concat(backgroundSize.width, "px ").concat(backgroundSize.height, "px");
      }

      this.view.$(this.elem).css({
        backgroundSize: backgroundSize,
        backgroundPosition: backgroundPosition
      });
    }
  }, {
    key: "drawBackgroundImage",
    value: function drawBackgroundImage(img) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!(img instanceof HTMLImageElement)) {
        this.elem.style.backgroundImage = '';
        return;
      }

      var uri;
      var opacity = options.opacity || 1;
      var backgroundSize = options.size;
      var backgroundRepeat = options.repeat || 'no-repeat';
      var pattern = background_Background.registry.get(backgroundRepeat);

      if (typeof pattern === 'function') {
        var quality = options.quality || 1;
        img.width *= quality;
        img.height *= quality;
        var canvas = pattern(img, options);

        if (!(canvas instanceof HTMLCanvasElement)) {
          throw new Error('Background pattern must return an HTML Canvas instance');
        }

        uri = canvas.toDataURL('image/png'); // `repeat` was changed in pattern function

        if (options.repeat && backgroundRepeat !== options.repeat) {
          backgroundRepeat = options.repeat;
        } else {
          backgroundRepeat = 'repeat';
        }

        if (typeof backgroundSize === 'object') {
          // recalculate the tile size if an object passed in
          backgroundSize.width *= canvas.width / img.width;
          backgroundSize.height *= canvas.height / img.height;
        } else if (backgroundSize === undefined) {
          // calcule the tile size if no provided
          options.size = {
            width: canvas.width / quality,
            height: canvas.height / quality
          };
        }
      } else {
        uri = img.src;

        if (backgroundSize === undefined) {
          options.size = {
            width: img.width,
            height: img.height
          };
        }
      }

      this.view.$(this.elem).css({
        opacity: opacity,
        backgroundRepeat: backgroundRepeat,
        backgroundImage: "url(".concat(uri, ")")
      });
      this.updateBackgroundImage(options);
    }
  }, {
    key: "updateBackgroundColor",
    value: function updateBackgroundColor(color) {
      this.container.style.backgroundColor = color || '';
    }
  }, {
    key: "update",
    value: function update() {
      if (this.optionCache) {
        this.updateBackgroundImage(this.optionCache);
      }
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.updateBackgroundColor(options.color);

      if (options.image) {
        var img = document.createElement('img');

        img.onload = function () {
          return _this.drawBackgroundImage(img, options);
        };

        img.setAttribute('crossorigin', 'anonymous');
        img.src = options.image;
        this.optionCache = object_namespaceObject.clone(options);
      } else {
        this.drawBackgroundImage(null);
        this.optionCache = null;
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this.draw();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.graph.off('scale', this.update, this);
      this.graph.off('translate', this.update, this);
      this.clear();
    }
  }, {
    key: "container",
    get: function get() {
      return this.view.container;
    }
  }, {
    key: "elem",
    get: function get() {
      return this.view.background;
    }
  }]);

  return BackgroundManager;
}(graph_base_Base);

background_decorate([graph_base_Base.dispose()], background_BackgroundManager.prototype, "dispose", null);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/scroller/index.js






var scroller_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var scroller_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};






var scroller_Scroller = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(Scroller, _View);

  var _super = Object(createSuper["a" /* default */])(Scroller);

  function Scroller(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Scroller);

    _this = _super.call(this);
    _this.padding = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    _this.options = scroller_Util.getOptions(options);

    var scale = _this.graph.scale();

    _this.sx = scale.sx;
    _this.sy = scale.sy;
    var width = _this.options.width || _this.graph.options.width;
    var height = _this.options.height || _this.graph.options.height;
    _this.container = document.createElement('div');
    _this.$container = _this.$(_this.container).addClass(_this.prefixClassName(scroller_Util.containerClass)).css({
      width: width,
      height: height
    });

    if (_this.options.pageVisible) {
      _this.$container.addClass(_this.prefixClassName(scroller_Util.pagedClass));
    }

    if (_this.options.className) {
      _this.$container.addClass(_this.options.className);
    }

    var graph = _this.graph;
    var graphContaoner = graph.container;

    if (graphContaoner.parentNode) {
      _this.$container.insertBefore(graphContaoner);
    }

    _this.content = document.createElement('div');
    _this.$content = _this.$(_this.content).addClass(_this.prefixClassName(scroller_Util.contentClass)).css({
      width: graph.options.width,
      height: graph.options.height
    }); // custom background

    if (_this.options.background) {
      _this.background = document.createElement('div');
      _this.$background = _this.$(_this.background).addClass(_this.prefixClassName(scroller_Util.backgroundClass));

      _this.$content.append(_this.background);
    }

    if (!_this.options.pageVisible) {
      _this.$content.append(_this.graph.view.background);

      _this.$content.append(_this.graph.view.grid);
    }

    _this.$content.append(graphContaoner);

    _this.$content.appendTo(_this.container);

    _this.startListening();

    _this.setCursor(_this.options.cursor);

    if (!_this.options.pageVisible) {
      _this.graph.grid.update();

      _this.graph.background.update();
    }

    _this.backgroundManager = new Scroller.Background(Object(assertThisInitialized["a" /* default */])(_this));
    return _this;
  }

  Object(createClass["a" /* default */])(Scroller, [{
    key: "startListening",
    value: function startListening() {
      var graph = this.graph;
      var model = this.model;
      graph.on('scale', this.onScale, this);
      graph.on('resize', this.onResize, this);
      graph.on('before:print', this.storeScrollPosition, this);
      graph.on('before:export', this.storeScrollPosition, this);
      graph.on('after:print', this.restoreScrollPosition, this);
      graph.on('after:export', this.restoreScrollPosition, this);

      if (this.options.autoResize) {
        if (graph.renderer.isAsync()) {
          graph.on('render:done', this.onRenderDone, this);
        } else {
          graph.on('unfreeze', this.update, this);
          model.on('reseted', this.update, this);
          model.on('cell:added', this.update, this);
          model.on('cell:removed', this.update, this);
          model.on('cell:changed', this.update, this);
        }
      }

      this.delegateBackgroundEvents();
    }
  }, {
    key: "stopListening",
    value: function stopListening() {
      var graph = this.graph;
      var model = this.model;
      graph.off('scale', this.onScale, this);
      graph.off('resize', this.onResize, this);
      graph.off('beforeprint', this.storeScrollPosition, this);
      graph.off('beforeexport', this.storeScrollPosition, this);
      graph.off('afterprint', this.restoreScrollPosition, this);
      graph.off('afterexport', this.restoreScrollPosition, this);
      graph.off('render:done', this.onRenderDone, this);
      graph.off('unfreeze', this.update, this);
      model.off('reseted', this.update, this);
      model.off('cell:added', this.update, this);
      model.off('cell:removed', this.update, this);
      model.off('cell:changed', this.update, this);
      this.undelegateBackgroundEvents();
    }
  }, {
    key: "delegateBackgroundEvents",
    value: function delegateBackgroundEvents(events) {
      var _this2 = this;

      var evts = events || view_GraphView.events;
      this.delegatedHandlers = Object.keys(evts).reduce(function (memo, name) {
        var handler = evts[name];

        if (name.indexOf(' ') === -1) {
          if (typeof handler === 'function') {
            memo[name] = handler;
          } else {
            var method = _this2.graph.view[handler];

            if (typeof method === 'function') {
              method = method.bind(_this2.graph.view);
              memo[name] = method;
            }
          }
        }

        return memo;
      }, {});
      this.onBackgroundEvent = this.onBackgroundEvent.bind(this);
      Object.keys(this.delegatedHandlers).forEach(function (name) {
        _this2.delegateEvent(name, {
          guarded: false
        }, _this2.onBackgroundEvent);
      });
    }
  }, {
    key: "undelegateBackgroundEvents",
    value: function undelegateBackgroundEvents() {
      var _this3 = this;

      Object.keys(this.delegatedHandlers).forEach(function (name) {
        _this3.undelegateEvent(name, _this3.onBackgroundEvent);
      });
    }
  }, {
    key: "onBackgroundEvent",
    value: function onBackgroundEvent(e) {
      var shouldHnadleEvent = false;
      var target = e.target;

      if (!this.options.pageVisible) {
        shouldHnadleEvent = this.graph.view.background === target || this.graph.view.grid === target;
      } else if (this.options.background) {
        shouldHnadleEvent = this.background === target;
      } else {
        shouldHnadleEvent = this.content === target;
      }

      if (shouldHnadleEvent) {
        var handler = this.delegatedHandlers[e.type];

        if (typeof handler === 'function') {
          handler.apply(this.graph, arguments);
        }
      }
    }
  }, {
    key: "onRenderDone",
    value: function onRenderDone(_ref) {
      var stats = _ref.stats;

      if (stats.priority < 2) {
        this.update();
      }
    }
  }, {
    key: "onResize",
    value: function onResize() {
      if (this.cachedCenterPoint) {
        this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y);
        this.updatePageBreak();
      }
    }
  }, {
    key: "onScale",
    value: function onScale(_ref2) {
      var sx = _ref2.sx,
          sy = _ref2.sy,
          ox = _ref2.ox,
          oy = _ref2.oy;
      this.updateScale(sx, sy);
      this.sx = sx;
      this.sy = sy;

      if (ox || oy) {
        this.centerPoint(ox, oy);
        this.updatePageBreak();
      }

      if (typeof this.options.fitTocontentOptions === 'function') {
        this.update();
      }
    }
  }, {
    key: "storeScrollPosition",
    value: function storeScrollPosition() {
      this.cachedScrollLeft = this.container.scrollLeft;
      this.cachedScrollTop = this.container.scrollTop;
    }
  }, {
    key: "restoreScrollPosition",
    value: function restoreScrollPosition() {
      this.container.scrollLeft = this.cachedScrollLeft;
      this.container.scrollTop = this.cachedScrollTop;
      this.cachedScrollLeft = null;
      this.cachedScrollTop = null;
    }
  }, {
    key: "beforeManipulation",
    value: function beforeManipulation() {
      if (platform["a" /* Platform */].IS_IE || platform["a" /* Platform */].IS_EDGE) {
        this.$container.css('visibility', 'hidden');
      }
    }
  }, {
    key: "afterManipulation",
    value: function afterManipulation() {
      if (platform["a" /* Platform */].IS_IE || platform["a" /* Platform */].IS_EDGE) {
        this.$container.css('visibility', 'visible');
      }
    }
  }, {
    key: "updatePageBreak",
    value: function updatePageBreak() {
      if (this.pageBreak && this.pageBreak.parentNode) {
        this.pageBreak.parentNode.removeChild(this.pageBreak);
      }

      var options = this.options;

      if (options.pageVisible && options.pageBreak) {
        var graphWidth = this.graph.options.width;
        var graphHeight = this.graph.options.height;
        var pageWidth = options.pageWidth || graphWidth;
        var pageHeight = options.pageHeight || graphHeight;

        if (graphWidth > pageWidth || graphHeight > pageHeight) {
          this.pageBreak = document.createElement('div');
          dom_main_namespaceObject.addClass(this.pageBreak, this.prefixClassName('graph-pagebreak'));
          this.$(this.graph.view.grid).after(this.pageBreak);

          for (var i = 1, l = Math.floor(graphWidth / pageWidth); i < l; i += 1) {
            this.$('<div/>').addClass(this.prefixClassName("graph-pagebreak-vertical")).css({
              left: i * pageWidth
            }).appendTo(this.pageBreak);
          }

          for (var _i = 1, _l = Math.floor(graphHeight / pageHeight); _i < _l; _i += 1) {
            this.$('<div/>').addClass(this.prefixClassName("graph-pagebreak-horizontal")).css({
              top: _i * pageHeight
            }).appendTo(this.pageBreak);
          }
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      var size = this.getClientSize();
      this.cachedCenterPoint = this.clientToLocalPoint(size.width / 2, size.height / 2);
      var fitTocontentOptions = this.options.fitTocontentOptions;

      if (typeof fitTocontentOptions === 'function') {
        fitTocontentOptions = main_namespaceObject.call(fitTocontentOptions, this, this);
      }

      var options = Object.assign({
        gridWidth: this.options.pageWidth,
        gridHeight: this.options.pageHeight,
        allowNewOrigin: 'negative'
      }, fitTocontentOptions);
      this.graph.fitToContent(this.getFitToContentOptions(options));
    }
  }, {
    key: "getFitToContentOptions",
    value: function getFitToContentOptions(options) {
      var sx = this.sx;
      var sy = this.sy;
      options.gridWidth && (options.gridWidth *= sx);
      options.gridHeight && (options.gridHeight *= sy);
      options.minWidth && (options.minWidth *= sx);
      options.minHeight && (options.minHeight *= sy);

      if (typeof options.padding === 'object') {
        options.padding = {
          left: (options.padding.left || 0) * sx,
          right: (options.padding.right || 0) * sx,
          top: (options.padding.top || 0) * sy,
          bottom: (options.padding.bottom || 0) * sy
        };
      } else if (typeof options.padding === 'number') {
        options.padding = options.padding * sx;
      }

      return options;
    }
  }, {
    key: "updateScale",
    value: function updateScale(sx, sy) {
      var options = this.graph.options;
      var dx = sx / this.sx;
      var dy = sy / this.sy;
      this.graph.setOrigin(options.x * dx, options.y * dy);
      this.graph.resizeGraph(options.width * dx, options.height * dy);
    }
  }, {
    key: "scrollbarPosition",
    value: function scrollbarPosition(left, top, options) {
      if (left == null && top == null) {
        return {
          left: this.container.scrollLeft,
          top: this.container.scrollTop
        };
      }

      var prop = {};

      if (typeof left === 'number') {
        prop.scrollLeft = left;
      }

      if (typeof top === 'number') {
        prop.scrollTop = top;
      }

      if (options && options.animation) {
        this.$container.animate(prop, options.animation);
      } else {
        this.$container.prop(prop);
      }

      return this;
    }
    /**
     * Try to scroll to ensure that the position (x,y) on the graph (in local
     * coordinates) is at the center of the viewport. If only one of the
     * coordinates is specified, only scroll in the specified dimension and
     * keep the other coordinate unchanged.
     */

  }, {
    key: "scrollToPoint",
    value: function scrollToPoint(x, y, options) {
      var size = this.getClientSize();
      var ctm = this.graph.matrix();
      var prop = {};

      if (typeof x === 'number') {
        prop.scrollLeft = x - size.width / 2 + ctm.e + (this.padding.left || 0);
      }

      if (typeof y === 'number') {
        prop.scrollTop = y - size.height / 2 + ctm.f + (this.padding.top || 0);
      }

      if (options && options.animation) {
        this.$container.animate(prop, options.animation);
      } else {
        this.$container.prop(prop);
      }

      return this;
    }
    /**
     * Try to scroll to ensure that the center of graph content is at the
     * center of the viewport.
     */

  }, {
    key: "scrollToContent",
    value: function scrollToContent(options) {
      var sx = this.sx;
      var sy = this.sy;
      var center = this.graph.getContentArea().getCenter();
      return this.scrollToPoint(center.x * sx, center.y * sy, options);
    }
    /**
     * Try to scroll to ensure that the center of cell is at the center of
     * the viewport.
     */

  }, {
    key: "scrollToCell",
    value: function scrollToCell(cell, options) {
      var sx = this.sx;
      var sy = this.sy;
      var center = cell.getBBox().getCenter();
      return this.scrollToPoint(center.x * sx, center.y * sy, options);
    }
    /**
     * The center methods are more aggressive than the scroll methods. These
     * methods position the graph so that a specific point on the graph lies
     * at the center of the viewport, adding paddings around the paper if
     * necessary (e.g. if the requested point lies in a corner of the paper).
     * This means that the requested point will always move into the center
     * of the viewport. (Use the scroll functions to avoid adding paddings
     * and only scroll the viewport as far as the graph boundary.)
     */

    /**
     * Position the center of graph to the center of the viewport.
     */

  }, {
    key: "center",
    value: function center(optons) {
      return this.centerPoint(optons);
    }
  }, {
    key: "centerPoint",
    value: function centerPoint(x, y, options) {
      var ctm = this.graph.matrix();
      var sx = ctm.a;
      var sy = ctm.d;
      var tx = -ctm.e;
      var ty = -ctm.f;
      var tWidth = tx + this.graph.options.width;
      var tHeight = ty + this.graph.options.height;
      var localOptions;

      if (typeof x === 'number' || typeof y === 'number') {
        localOptions = options;
        var visibleCenter = this.getVisibleArea().getCenter();

        if (typeof x === 'number') {
          x = x * sx; // tslint:disable-line
        } else {
          x = visibleCenter.x; // tslint:disable-line
        }

        if (typeof y === 'number') {
          y = y * sy; // tslint:disable-line
        } else {
          y = visibleCenter.y; // tslint:disable-line
        }
      } else {
        localOptions = x;
        x = (tx + tWidth) / 2; // tslint:disable-line

        y = (ty + tHeight) / 2; // tslint:disable-line
      }

      if (localOptions && localOptions.padding) {
        return this.positionPoint({
          x: x,
          y: y
        }, '50%', '50%', localOptions);
      }

      var padding = this.getPadding();
      var clientSize = this.getClientSize();
      var cx = clientSize.width / 2;
      var cy = clientSize.height / 2;
      var left = cx - padding.left - x + tx;
      var right = cx - padding.right + x - tWidth;
      var top = cy - padding.top - y + ty;
      var bottom = cy - padding.bottom + y - tHeight;
      this.addPadding(Math.max(left, 0), Math.max(right, 0), Math.max(top, 0), Math.max(bottom, 0));
      return this.scrollToPoint(x, y, localOptions || undefined);
    }
  }, {
    key: "centerContent",
    value: function centerContent(options) {
      return this.positionContent('center', options);
    }
  }, {
    key: "centerCell",
    value: function centerCell(cell, options) {
      return this.positionCell(cell, 'center', options);
    }
    /**
     * The position methods are a more general version of the center methods.
     * They position the graph so that a specific point on the graph lies at
     * requested coordinates inside the viewport.
     */

    /**
     *
     */

  }, {
    key: "positionContent",
    value: function positionContent(pos, options) {
      var rect = this.graph.getContentArea(options);
      return this.positionRect(rect, pos, options);
    }
  }, {
    key: "positionCell",
    value: function positionCell(cell, pos, options) {
      var bbox = cell.getBBox();
      return this.positionRect(bbox, pos, options);
    }
  }, {
    key: "positionRect",
    value: function positionRect(rect, pos, options) {
      var bbox = rectangle_Rectangle.create(rect);

      switch (pos) {
        case 'center':
          return this.positionPoint(bbox.getCenter(), '50%', '50%', options);

        case 'top':
          return this.positionPoint(bbox.getTopCenter(), '50%', 0, options);

        case 'top-right':
          return this.positionPoint(bbox.getTopRight(), '100%', 0, options);

        case 'right':
          return this.positionPoint(bbox.getRightMiddle(), '100%', '50%', options);

        case 'bottom-right':
          return this.positionPoint(bbox.getBottomRight(), '100%', '100%', options);

        case 'bottom':
          return this.positionPoint(bbox.getBottomCenter(), '50%', '100%', options);

        case 'bottom-left':
          return this.positionPoint(bbox.getBottomLeft(), 0, '100%', options);

        case 'left':
          return this.positionPoint(bbox.getLeftMiddle(), 0, '50%', options);

        case 'top-left':
          return this.positionPoint(bbox.getTopLeft(), 0, 0, options);

        default:
          return this;
      }
    }
  }, {
    key: "positionPoint",
    value: function positionPoint(point, x, y) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      var pad = options.padding,
          localOptions = scroller_rest(options, ["padding"]);

      var padding = number_namespaceObject.normalizeSides(pad);
      var clientRect = rectangle_Rectangle.fromSize(this.getClientSize());
      var targetRect = clientRect.clone().moveAndExpand({
        x: padding.left,
        y: padding.top,
        width: -padding.right - padding.left,
        height: -padding.top - padding.bottom
      }); // tslint:disable-next-line

      x = number_namespaceObject.normalizePercentage(x, Math.max(0, targetRect.width));

      if (x < 0) {
        x = targetRect.width + x; // tslint:disable-line
      } // tslint:disable-next-line


      y = number_namespaceObject.normalizePercentage(y, Math.max(0, targetRect.height));

      if (y < 0) {
        y = targetRect.height + y; // tslint:disable-line
      }

      var origin = targetRect.getTopLeft().translate(x, y);
      var diff = clientRect.getCenter().diff(origin);
      var scale = this.zoom();
      var rawDiff = diff.scale(1 / scale, 1 / scale);
      var result = point_Point.create(point).translate(rawDiff);
      return this.centerPoint(result.x, result.y, localOptions);
    }
  }, {
    key: "zoom",
    value: function zoom(factor, options) {
      if (factor == null) {
        return this.sx;
      }

      options = options || {}; // tslint:disable-line

      var cx;
      var cy;
      var clientSize = this.getClientSize();
      var center = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);
      var sx = factor;
      var sy = factor;

      if (!options.absolute) {
        sx = sx + this.sx;
        sy = sy + this.sy;
      }

      if (options.scaleGrid) {
        sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;
        sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;
      }

      if (options.maxScale) {
        sx = Math.min(options.maxScale, sx);
        sy = Math.min(options.maxScale, sy);
      }

      if (options.minScale) {
        sx = Math.max(options.minScale, sx);
        sy = Math.max(options.minScale, sy);
      }

      sx = this.graph.transform.clampScale(sx);
      sy = this.graph.transform.clampScale(sy);

      if (options.center) {
        var fx = sx / this.sx;
        var fy = sy / this.sy;
        cx = options.center.x - (options.center.x - center.x) / fx;
        cy = options.center.y - (options.center.y - center.y) / fy;
      } else {
        cx = center.x;
        cy = center.y;
      }

      this.beforeManipulation();
      this.graph.transform.scale(sx, sy);
      this.centerPoint(cx, cy);
      this.afterManipulation();
      return this;
    }
  }, {
    key: "zoomToRect",
    value: function zoomToRect(rect) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var area = rectangle_Rectangle.create(rect);
      var graph = this.graph;
      var origin = {
        x: graph.options.x,
        y: graph.options.y
      };
      options.contentArea = area;

      if (options.fittingBBox == null) {
        options.fittingBBox = Object.assign(Object.assign({}, origin), {
          width: this.$container.width(),
          height: this.$container.height()
        });
      }

      this.beforeManipulation();
      graph.scaleContentToFit(options);
      var center = area.getCenter();
      this.centerPoint(center.x, center.y);
      this.afterManipulation();
      return this;
    }
  }, {
    key: "zoomToFit",
    value: function zoomToFit() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.zoomToRect(this.graph.getContentArea(options), options);
    }
  }, {
    key: "transitionToPoint",
    value: function transitionToPoint(x, y, options) {
      var _this4 = this;

      if (typeof x === 'object') {
        options = y; // tslint:disable-line

        y = x.y; // tslint:disable-line

        x = x.x; // tslint:disable-line
      } else {
        y = y; // tslint:disable-line
      }

      if (options == null) {
        options = {}; // tslint:disable-line
      }

      var transform;
      var transformOrigin;
      var scale = this.sx;
      var targetScale = Math.max(options.scale || scale, 0.000001);
      var clientSize = this.getClientSize();
      var targetPoint = new point_Point(x, y);
      var localPoint = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);

      if (scale === targetScale) {
        var translate = localPoint.diff(targetPoint).scale(scale, scale).round();
        transform = "translate(".concat(translate.x, "px,").concat(translate.y, "px)");
      } else {
        var delta = targetScale / (scale - targetScale) * targetPoint.distance(localPoint);
        var range = localPoint.clone().move(targetPoint, delta);
        var origin = this.localToBackgroundPoint(range).round();
        transform = "scale(".concat(targetScale / scale, ")");
        transformOrigin = "".concat(origin.x, "px ").concat(origin.y, "px");
      }

      var onTransitionEnd = options.onTransitionEnd;
      this.$container.addClass(scroller_Util.transitionClassName);
      this.$content.off(scroller_Util.transitionEventName).on(scroller_Util.transitionEventName, function (e) {
        _this4.syncTransition(targetScale, {
          x: x,
          y: y
        });

        if (typeof onTransitionEnd === 'function') {
          main_namespaceObject.call(onTransitionEnd, _this4, e.originalEvent);
        }
      }).css({
        transform: transform,
        transformOrigin: transformOrigin,
        transition: 'transform',
        transitionDuration: options.duration || '1s',
        transitionDelay: options.delay,
        transitionTimingFunction: options.timingFunction
      });
      return this;
    }
  }, {
    key: "syncTransition",
    value: function syncTransition(scale, p) {
      this.beforeManipulation();
      this.graph.scale(scale);
      this.removeTransition();
      this.centerPoint(p.x, p.y);
      this.afterManipulation();
      return this;
    }
  }, {
    key: "removeTransition",
    value: function removeTransition() {
      this.$container.removeClass(scroller_Util.transitionClassName);
      this.$content.off(scroller_Util.transitionEventName).css({
        transform: '',
        transformOrigin: '',
        transition: '',
        transitionDuration: '',
        transitionDelay: '',
        transitionTimingFunction: ''
      });
      return this;
    }
  }, {
    key: "transitionToRect",
    value: function transitionToRect(rectangle) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rect = rectangle_Rectangle.create(rectangle);
      var maxScale = options.maxScale || Infinity;
      var minScale = options.minScale || Number.MIN_VALUE;
      var scaleGrid = options.scaleGrid || null;
      var PIXEL_SIZE = options.visibility || 1;
      var center = options.center ? point_Point.create(options.center) : rect.getCenter();
      var clientSize = this.getClientSize();
      var w = clientSize.width * PIXEL_SIZE;
      var h = clientSize.height * PIXEL_SIZE;
      var scale = new rectangle_Rectangle(center.x - w / 2, center.y - h / 2, w, h).maxRectUniformScaleToFit(rect, center);
      scale = Math.min(scale, maxScale);

      if (scaleGrid) {
        scale = Math.floor(scale / scaleGrid) * scaleGrid;
      }

      scale = Math.max(minScale, scale);
      return this.transitionToPoint(center, Object.assign({
        scale: scale
      }, options));
    }
  }, {
    key: "startPanning",
    value: function startPanning(evt) {
      var e = this.normalizeEvent(evt);
      this.clientX = e.clientX;
      this.clientY = e.clientY;
      this.$container.addClass(this.prefixClassName(scroller_Util.panningClass));
      this.trigger('pan:start', {
        e: e
      });
      this.$(document.body).on({
        'mousemove.panning touchmove.panning': this.pan.bind(this),
        'mouseup.panning touchend.panning': this.stopPanning.bind(this)
      });
      this.$(window).on('mouseup.panning', this.stopPanning.bind(this));
    }
  }, {
    key: "pan",
    value: function pan(evt) {
      var e = this.normalizeEvent(evt);
      var dx = e.clientX - this.clientX;
      var dy = e.clientY - this.clientY;
      this.container.scrollTop -= dy;
      this.container.scrollLeft -= dx;
      this.clientX = e.clientX;
      this.clientY = e.clientY;
    }
  }, {
    key: "stopPanning",
    value: function stopPanning(e) {
      this.$(document.body).off('.panning');
      this.$(window).off('.panning');
      this.$container.removeClass(this.prefixClassName(scroller_Util.panningClass));
      this.trigger('pan:stop', {
        e: e
      });
    }
  }, {
    key: "clientToLocalPoint",
    value: function clientToLocalPoint(a, b) {
      var x = typeof a === 'object' ? a.x : a;
      var y = typeof a === 'object' ? a.y : b;
      var ctm = this.graph.matrix();
      x += this.container.scrollLeft - this.padding.left - ctm.e;
      y += this.container.scrollTop - this.padding.top - ctm.f;
      return new point_Point(x / ctm.a, y / ctm.d);
    }
  }, {
    key: "localToBackgroundPoint",
    value: function localToBackgroundPoint(x, y) {
      var p = typeof x === 'object' ? point_Point.create(x) : new point_Point(x, y);
      var ctm = this.graph.matrix();
      var padding = this.padding;
      return dom_main_namespaceObject.transformPoint(p, ctm).translate(padding.left, padding.top);
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      var w = width != null ? width : this.container.clientWidth;
      var h = height != null ? height : this.container.clientHeight;

      if (typeof w === 'number') {
        w = Math.round(w);
      }

      if (typeof h === 'number') {
        h = Math.round(h);
      }

      this.options.width = w;
      this.options.height = h;
      this.$container.css({
        width: w,
        height: h
      });
      this.update();
    }
  }, {
    key: "getClientSize",
    value: function getClientSize() {
      return {
        width: this.container.clientWidth,
        height: this.container.clientHeight
      };
    }
  }, {
    key: "addPadding",
    value: function addPadding(left, right, top, bottom) {
      var padding = this.getPadding();
      this.padding = {
        left: Math.round(padding.left + (left || 0)),
        top: Math.round(padding.top + (top || 0)),
        bottom: Math.round(padding.bottom + (bottom || 0)),
        right: Math.round(padding.right + (right || 0))
      };
      padding = this.padding;
      this.$content.css({
        width: padding.left + this.graph.options.width + padding.right,
        height: padding.top + this.graph.options.height + padding.bottom
      });
      var container = this.graph.container;
      container.style.left = "".concat(this.padding.left, "px");
      container.style.top = "".concat(this.padding.top, "px");
      return this;
    }
  }, {
    key: "getPadding",
    value: function getPadding() {
      var padding = this.options.padding;

      if (typeof padding === 'function') {
        return number_namespaceObject.normalizeSides(main_namespaceObject.call(padding, this));
      }

      return number_namespaceObject.normalizeSides(padding);
    }
    /**
     * Returns the untransformed size and origin of the current viewport.
     */

  }, {
    key: "getVisibleArea",
    value: function getVisibleArea() {
      var ctm = this.graph.matrix();
      var size = this.getClientSize();
      var box = {
        x: this.container.scrollLeft || 0,
        y: this.container.scrollTop || 0,
        width: size.width,
        height: size.height
      };
      var area = dom_main_namespaceObject.transformRectangle(box, ctm.inverse());
      area.x -= (this.padding.left || 0) / this.sx;
      area.y -= (this.padding.top || 0) / this.sy;
      return area;
    }
  }, {
    key: "isCellVisible",
    value: function isCellVisible(cell) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var bbox = cell.getBBox();
      var area = this.getVisibleArea();
      return options.strict ? area.containsRect(bbox) : area.isIntersectWith(bbox);
    }
  }, {
    key: "isPointVisible",
    value: function isPointVisible(point) {
      return this.getVisibleArea().containsPoint(point);
    }
    /**
     * Lock the current viewport by disabling user scrolling.
     */

  }, {
    key: "lock",
    value: function lock() {
      this.$container.css('overflow', 'hidden');
      return this;
    }
    /**
     * Enable user scrolling if previously locked.
     */

  }, {
    key: "unlock",
    value: function unlock() {
      this.$container.css('overflow', 'scroll');
      return this;
    }
  }, {
    key: "setCursor",
    value: function setCursor(value) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.$container.css('cursor', value || '');

      if (options.silent !== true) {
        this.options.cursor = value;
      }
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.stopListening();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.$(this.graph.container).insertBefore(this.$container);
      this.remove();
    }
  }, {
    key: "graph",
    get: function get() {
      return this.options.graph;
    }
  }, {
    key: "model",
    get: function get() {
      return this.graph.model;
    }
  }]);

  return Scroller;
}(view_View);

scroller_decorate([view_View.dispose()], scroller_Scroller.prototype, "dispose", null);

(function (Scroller) {
  var Background = /*#__PURE__*/function (_BackgroundManager) {
    Object(inherits["a" /* default */])(Background, _BackgroundManager);

    var _super2 = Object(createSuper["a" /* default */])(Background);

    function Background(scroller) {
      var _this5;

      Object(classCallCheck["a" /* default */])(this, Background);

      _this5 = _super2.call(this, scroller.graph);
      _this5.scroller = scroller;

      if (scroller.options.background) {
        _this5.draw(scroller.options.background);
      }

      return _this5;
    }

    Object(createClass["a" /* default */])(Background, [{
      key: "init",
      value: function init() {
        this.graph.on('scale', this.update, this);
        this.graph.on('translate', this.update, this);
      }
    }, {
      key: "elem",
      get: function get() {
        return this.scroller.background;
      }
    }, {
      key: "container",
      get: function get() {
        return this.scroller.content;
      }
    }]);

    return Background;
  }(background_BackgroundManager);

  Scroller.Background = Background;
})(scroller_Scroller || (scroller_Scroller = {}));

var scroller_Util;

(function (Util) {
  Util.containerClass = 'graph-scroller';
  Util.panningClass = "".concat(Util.containerClass, "-panning");
  Util.pagedClass = "".concat(Util.containerClass, "-paged");
  Util.contentClass = "".concat(Util.containerClass, "-content");
  Util.backgroundClass = "".concat(Util.containerClass, "-background");
  Util.transitionClassName = 'transition-in-progress';
  Util.transitionEventName = 'transitionend.graph-scroller-transition';
  Util.defaultOptions = {
    padding: function padding() {
      var size = this.getClientSize();
      var minWidth = Math.max(this.options.minVisibleWidth || 0, 1) || 1;
      var minHeight = Math.max(this.options.minVisibleHeight || 0, 1) || 1;
      var left = Math.max(size.width - minWidth, 0);
      var top = Math.max(size.height - minHeight, 0);
      return {
        left: left,
        top: top,
        right: left,
        bottom: top
      };
    },
    minVisibleWidth: 50,
    minVisibleHeight: 50,
    pageVisible: false,
    pageBreak: false,
    autoResize: true
  };

  function getOptions(options) {
    var merged = object_namespaceObject.merge({}, Util.defaultOptions, options);
    var graph = options.graph;

    if (merged.pageWidth == null) {
      merged.pageWidth = graph.options.width;
    }

    if (merged.pageHeight == null) {
      merged.pageHeight = graph.options.height;
    }

    return merged;
  }

  Util.getOptions = getOptions;
})(scroller_Util || (scroller_Util = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/transform/util.js
function notify(name, evt, view) {
  if (view) {
    var graph = view.graph;
    var e = graph.view.normalizeEvent(evt);
    var localPoint = graph.snapToGrid(e.clientX, e.clientY);
    view.notify(name, {
      e: e,
      view: view,
      x: localPoint.x,
      y: localPoint.y,
      node: view.cell,
      cell: view.cell
    });
  }
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/common/handle.js




var handle_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




var handle_Handle = /*#__PURE__*/function () {
  function Handle() {
    Object(classCallCheck["a" /* default */])(this, Handle);
  }

  Object(createClass["a" /* default */])(Handle, [{
    key: "initHandles",
    value: function initHandles() {
      var _this = this,
          _this$delegateEvents;

      this.handles = [];

      if (this.handleOptions.handles) {
        this.handleOptions.handles.forEach(function (handle) {
          return _this.addHandle(handle);
        });
      }

      if (this.handleOptions.type === 'pie') {
        if (this.pie.toggles) {
          var className = handle_ClassNames.pieToggle;
          this.$pieToggles = {};
          this.pie.toggles.forEach(function (item) {
            var $elem = _this.$('<div/>');

            _this.applyAttrs($elem, item.attrs);

            $elem.addClass(className).addClass("".concat(className, "-pos-").concat(item.position || 'e')).attr('data-name', item.name).appendTo(_this.container);
            _this.$pieToggles[item.name] = $elem;
          });
        }

        this.setPieIcons();
      }

      if (this.$handleContainer) {
        var type = this.handleOptions.type || 'surround';
        this.$handleContainer.addClass(handle_ClassNames.wrap).addClass(handle_ClassNames.animate).addClass("".concat(handle_ClassNames.handle, "-").concat(type));
      }

      this.delegateEvents((_this$delegateEvents = {}, Object(defineProperty["a" /* default */])(_this$delegateEvents, "mousedown .".concat(handle_ClassNames.handle), 'onHandleMouseDown'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "touchstart .".concat(handle_ClassNames.handle), 'onHandleMouseDown'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "mousedown .".concat(handle_ClassNames.pieToggle), 'onPieToggleMouseDown'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "touchstart .".concat(handle_ClassNames.pieToggle), 'onPieToggleMouseDown'), _this$delegateEvents));
    }
  }, {
    key: "onHandleMouseDown",
    value: function onHandleMouseDown(evt) {
      var action = this.$(evt.currentTarget).closest(".".concat(handle_ClassNames.handle)).attr('data-action');

      if (action) {
        evt.preventDefault();
        evt.stopPropagation();
        this.setEventData(evt, {
          action: action,
          clientX: evt.clientX,
          clientY: evt.clientY,
          startX: evt.clientX,
          startY: evt.clientY
        });

        if (evt.type === 'mousedown' && 2 === evt.button) {
          this.triggerHandleAction(action, 'contextmenu', evt);
        } else {
          this.triggerHandleAction(action, 'mousedown', evt);
          this.delegateDocumentEvents({
            mousemove: 'onHandleMouseMove',
            touchmove: 'onHandleMouseMove',
            mouseup: 'onHandleMouseUp',
            touchend: 'onHandleMouseUp',
            touchcancel: 'onHandleMouseUp'
          }, evt.data);
        }
      }
    }
  }, {
    key: "onHandleMouseMove",
    value: function onHandleMouseMove(evt) {
      var data = this.getEventData(evt);
      var action = data.action;

      if (action) {
        this.triggerHandleAction(action, 'mousemove', evt);
      }
    }
  }, {
    key: "onHandleMouseUp",
    value: function onHandleMouseUp(evt) {
      var data = this.getEventData(evt);
      var action = data.action;

      if (action) {
        this.triggerHandleAction(action, 'mouseup', evt);
        this.undelegateDocumentEvents();
      }
    }
  }, {
    key: "triggerHandleAction",
    value: function triggerHandleAction(action, eventName, evt, args) {
      evt.preventDefault();
      evt.stopPropagation();
      var e = this.normalizeEvent(evt);
      var data = this.getEventData(e);
      var local = this.graph.snapToGrid(e.clientX, e.clientY);
      var origin = this.graph.snapToGrid(data.clientX, data.clientY);
      var dx = local.x - origin.x;
      var dy = local.y - origin.y;
      this.trigger("action:".concat(action, ":").concat(eventName), Object.assign({
        e: e,
        dx: dx,
        dy: dy,
        x: local.x,
        y: local.y,
        offsetX: evt.clientX - data.startX,
        offsetY: evt.clientY - data.startY
      }, args));
      data.clientX = evt.clientX;
      data.clientY = evt.clientY;
    }
  }, {
    key: "onPieToggleMouseDown",
    value: function onPieToggleMouseDown(evt) {
      evt.stopPropagation();
      var name = this.$(evt.target).closest(".".concat(handle_ClassNames.pieToggle)).attr('data-name');

      if (!this.isOpen(name)) {
        if (this.isOpen()) {
          this.toggleState();
        }
      }

      this.toggleState(name);
    }
  }, {
    key: "setPieIcons",
    value: function setPieIcons() {
      var _this2 = this;

      if ('pie' === this.handleOptions.type) {
        this.$handleContainer.find(".".concat(handle_ClassNames.handle)).each(function (_, elem) {
          var $elem = _this2.$(elem);

          var action = $elem.attr('data-action');
          var className = handle_ClassNames.pieSlice;

          var handle = _this2.getHandle(action);

          if (!handle || !handle.icon) {
            var contect = window.getComputedStyle(elem, ':before').getPropertyValue('content');

            if (contect && 'none' !== contect) {
              var $icons = $elem.find(".".concat(className, "-txt"));

              if ($icons.length) {
                dom_main_namespaceObject.createVector($icons[0]).text(contect.replace(/['"]/g, ''));
              }
            }

            var bgImg = $elem.css('background-image');

            if (bgImg) {
              var matches = bgImg.match(/url\(['"]?([^'"]+)['"]?\)/);

              if (matches) {
                var href = matches[1];
                var $imgs = $elem.find(".".concat(className, "-img"));

                if ($imgs.length > 0) {
                  dom_main_namespaceObject.createVector($imgs[0]).attr('xlink:href', href);
                }
              }
            }
          }
        });
      }
    }
  }, {
    key: "getHandleIdx",
    value: function getHandleIdx(name) {
      return this.handles.findIndex(function (item) {
        return item.name === name;
      });
    }
  }, {
    key: "hasHandle",
    value: function hasHandle(name) {
      return this.getHandleIdx(name) >= 0;
    }
  }, {
    key: "getHandle",
    value: function getHandle(name) {
      return this.handles.find(function (item) {
        return item.name === name;
      });
    }
  }, {
    key: "renderHandle",
    value: function renderHandle(handle) {
      var $handle = this.$('<div/>').addClass("".concat(handle_ClassNames.handle, " ").concat(handle_ClassNames.handle, "-").concat(handle.name)).attr('data-action', handle.name).prop('draggable', false);

      if (this.handleOptions.type === 'pie') {
        var index = this.getHandleIdx(handle.name);
        var pie = this.pie;
        var outerRadius = pie.outerRadius;
        var innerRadius = pie.innerRadius;
        var offset = (outerRadius + innerRadius) / 2;
        var ratio = new point_Point(outerRadius, outerRadius);
        var delta = Angle.toRad(pie.sliceAngle);
        var curRad = index * delta + Angle.toRad(pie.startAngle);
        var nextRad = curRad + delta;
        var pathData = dom_main_namespaceObject.createSlicePathData(innerRadius, outerRadius, curRad, nextRad);
        var vSvg = dom_main_namespaceObject.createVector('svg').addClass("".concat(handle_ClassNames.pieSlice, "-svg"));
        var vPath = dom_main_namespaceObject.createVector('path').addClass(handle_ClassNames.pieSlice).attr('d', pathData).translate(outerRadius, outerRadius);
        var pos = point_Point.fromPolar(offset, -curRad - delta / 2, ratio).toJSON();
        var iconSize = pie.iconSize;
        var vImg = dom_main_namespaceObject.createVector('image').attr(pos).addClass("".concat(handle_ClassNames.pieSlice, "-img"));
        pos.y = pos.y + iconSize - 2;
        var vText = dom_main_namespaceObject.createVector('text', {
          'font-size': iconSize
        }).attr(pos).addClass("".concat(handle_ClassNames.pieSlice, "-txt"));
        vImg.attr({
          width: iconSize,
          height: iconSize
        });
        vImg.translate(-iconSize / 2, -iconSize / 2);
        vText.translate(-iconSize / 2, -iconSize / 2);
        vSvg.append([vPath, vImg, vText]);
        $handle.append(vSvg.node);
      } else {
        $handle.addClass("".concat(handle_ClassNames.handle, "-pos-").concat(handle.position));

        if (handle.content) {
          if (typeof handle.content === 'string') {
            $handle.html(handle.content);
          } else {
            $handle.append(handle.content);
          }
        }
      }

      this.updateHandleIcon($handle, handle.icon);
      this.applyAttrs($handle, handle.attrs);
      return $handle;
    }
  }, {
    key: "addHandle",
    value: function addHandle(handle) {
      var _this3 = this;

      if (!this.hasHandle(handle.name)) {
        this.handles.push(handle);
        var events = handle.events;

        if (events) {
          Object.keys(events).forEach(function (action) {
            var callback = events[action];
            var name = "action:".concat(handle.name, ":").concat(action);

            if (typeof callback === 'string') {
              _this3.on(name, _this3[callback], _this3);
            } else {
              _this3.on(name, callback);
            }
          });
        }

        if (this.$handleContainer) {
          this.$handleContainer.append(this.renderHandle(handle));
        }
      }

      return this;
    }
  }, {
    key: "addHandles",
    value: function addHandles(handles) {
      var _this4 = this;

      handles.forEach(function (handle) {
        return _this4.addHandle(handle);
      });
      return this;
    }
  }, {
    key: "removeHandles",
    value: function removeHandles() {
      while (this.handles.length) {
        this.removeHandle(this.handles[0].name);
      }

      return this;
    }
  }, {
    key: "removeHandle",
    value: function removeHandle(name) {
      var _this5 = this;

      var index = this.getHandleIdx(name);
      var handle = this.handles[index];

      if (handle) {
        if (handle.events) {
          Object.keys(handle.events).forEach(function (event) {
            _this5.off("action:".concat(name, ":").concat(event));
          });
        }

        this.getHandleElem(name).remove();
        this.handles.splice(index, 1);
      }

      return this;
    }
  }, {
    key: "changeHandle",
    value: function changeHandle(name, newHandle) {
      var handle = this.getHandle(name);

      if (handle) {
        this.removeHandle(name);
        this.addHandle(Object.assign(Object.assign({}, handle), newHandle));
      }

      return this;
    }
  }, {
    key: "toggleHandle",
    value: function toggleHandle(name, selected) {
      var handle = this.getHandle(name);

      if (handle) {
        var $handle = this.getHandleElem(name);
        var className = "".concat(handle_ClassNames.handle, "-selected");

        if (selected === undefined) {
          selected = !$handle.hasClass(className); // tslint:disable-line
        }

        $handle.toggleClass(className, selected);
        var icon = selected ? handle.iconSelected : handle.icon;

        if (icon) {
          this.updateHandleIcon($handle, icon);
        }
      }

      return this;
    }
  }, {
    key: "selectHandle",
    value: function selectHandle(name) {
      return this.toggleHandle(name, true);
    }
  }, {
    key: "deselectHandle",
    value: function deselectHandle(name) {
      return this.toggleHandle(name, false);
    }
  }, {
    key: "deselectAllHandles",
    value: function deselectAllHandles() {
      var _this6 = this;

      this.handles.forEach(function (handle) {
        return _this6.deselectHandle(handle.name);
      });
      return this;
    }
  }, {
    key: "getHandleElem",
    value: function getHandleElem(name) {
      return this.$handleContainer.find(".".concat(handle_ClassNames.handle, "-").concat(name));
    }
  }, {
    key: "updateHandleIcon",
    value: function updateHandleIcon($handle, icon) {
      if (this.handleOptions.type === 'pie') {
        var $icons = $handle.find(".".concat(handle_ClassNames.pieSliceImg));
        this.$($icons[0]).attr('xlink:href', icon || '');
      } else {
        $handle.css('background-image', icon ? "url(".concat(icon, ")") : '');
      }
    }
  }, {
    key: "isRendered",
    value: function isRendered() {
      return this.$handleContainer != null;
    }
  }, {
    key: "isOpen",
    value: function isOpen(name) {
      if (this.isRendered()) {
        return name ? this.$pieToggles[name].hasClass(handle_ClassNames.pieToggleOpened) : this.$handleContainer.hasClass("".concat(handle_ClassNames.pieOpended));
      }

      return false;
    }
  }, {
    key: "toggleState",
    value: function toggleState(name) {
      var _this7 = this;

      if (this.isRendered()) {
        var $handleContainer = this.$handleContainer;
        Object.keys(this.$pieToggles).forEach(function (key) {
          var $toggle = _this7.$pieToggles[key];
          $toggle.removeClass(handle_ClassNames.pieToggleOpened);
        });

        if (this.isOpen()) {
          this.trigger('pie:close', {
            name: name
          });
          $handleContainer.removeClass(handle_ClassNames.pieOpended);
        } else {
          this.trigger('pie:open', {
            name: name
          });

          if (name) {
            var toggles = this.pie.toggles;
            var toggle = toggles && toggles.find(function (i) {
              return i.name === name;
            });

            if (toggle) {
              $handleContainer.attr({
                'data-pie-toggle-name': toggle.name,
                'data-pie-toggle-position': toggle.position
              });
            }

            this.$pieToggles[name].addClass(handle_ClassNames.pieToggleOpened);
          }

          $handleContainer.addClass(handle_ClassNames.pieOpended);
        }
      }
    }
  }, {
    key: "applyAttrs",
    value: function applyAttrs(elem, attrs) {
      if (attrs) {
        var $elem = view_View.$(elem);
        Object.keys(attrs).forEach(function (selector) {
          var $element = $elem.find(selector).addBack().filter(selector);

          var _a = attrs[selector],
              cls = _a.class,
              attr = handle_rest(_a, ["class"]);

          if (cls) {
            $element.addClass(cls);
          }

          $element.attr(attr);
        });
      }
    }
  }, {
    key: "handleClassName",
    get: function get() {
      return handle_ClassNames.handle;
    }
  }, {
    key: "pie",
    get: function get() {
      return Object.assign(Object.assign({}, Handle.defaultPieOptions), this.handleOptions.pie);
    }
  }]);

  return Handle;
}();

(function (Handle) {
  Handle.defaultPieOptions = {
    innerRadius: 20,
    outerRadius: 50,
    sliceAngle: 45,
    startAngle: 0,
    iconSize: 14,
    toggles: [{
      name: 'default',
      position: 'e'
    }]
  };
})(handle_Handle || (handle_Handle = {}));

var handle_ClassNames;

(function (ClassNames) {
  ClassNames.handle = view_View.prototype.prefixClassName('widget-handle');
  ClassNames.wrap = "".concat(ClassNames.handle, "-wrap");
  ClassNames.animate = "".concat(ClassNames.handle, "-animate");
  ClassNames.pieOpended = "".concat(ClassNames.handle, "-pie-opened");
  ClassNames.pieToggle = "".concat(ClassNames.handle, "-pie-toggle");
  ClassNames.pieToggleOpened = "".concat(ClassNames.handle, "-pie-toggle-opened");
  ClassNames.pieSlice = "".concat(ClassNames.handle, "-pie-slice");
  ClassNames.pieSliceImg = "".concat(ClassNames.handle, "-pie-slice-img");
})(handle_ClassNames || (handle_ClassNames = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/common/widget.js








var widget_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var widget_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};


var widget_Widget = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(Widget, _View);

  var _super = Object(createSuper["a" /* default */])(Widget);

  function Widget(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Widget);

    _this = _super.call(this);

    var _a = options,
        view = _a.view,
        cell = _a.cell,
        node = _a.node,
        edge = _a.edge,
        graph = _a.graph,
        localOptions = widget_rest(_a, ["view", "cell", "node", "edge", "graph"]);

    if (view) {
      _this.view = view;
      _this.cell = view.cell;
      _this.graph = view.graph;
      _this.model = _this.graph.model;
    } else if ((cell || edge || node) && graph) {
      _this.cell = node || edge || cell;
      _this.view = graph.renderer.findViewByCell(_this.cell);
      _this.graph = graph;
      _this.model = _this.graph.model;
    }

    var ctor = _this.constructor;

    if (options.clearAll !== false) {
      ctor.removeInstances(_this.graph);
    }

    ctor.register(Object(assertThisInitialized["a" /* default */])(_this));

    _this.init(localOptions);

    return _this;
  }

  Object(createClass["a" /* default */])(Widget, [{
    key: "init",
    value: function init(options) {}
  }, {
    key: "render",
    value: function render() {
      return this;
    }
  }, {
    key: "startListening",
    value: function startListening() {
      if (this.options.clearOnBlankMouseDown !== false) {
        this.graph.on('blank:mousedown', this.remove, this);
      }
    }
  }, {
    key: "stopListening",
    value: function stopListening() {
      if (this.options.clearOnBlankMouseDown !== false) {
        this.graph.off('blank:mousedown', this.remove, this);
      }
    }
  }, {
    key: "remove",
    value: function remove() {
      this.stopListening();
      var ctor = this.constructor;
      ctor.unregister(this);
      return Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(Widget.prototype), "remove", this).call(this);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.remove();
    }
  }], [{
    key: "ensureCache",
    value: function ensureCache() {
      if (!this.instanceCache.has(this)) {
        this.instanceCache.set(this, {});
      }

      return this.instanceCache.get(this);
    }
  }, {
    key: "register",
    value: function register(instance, graph) {
      if (graph == null) {
        // tslint:disable-next-line
        graph = instance.graph;
      }

      var dic = this.ensureCache();
      var cache = dic[graph.view.cid];

      if (cache == null) {
        cache = dic[graph.view.cid] = {};
      }

      cache[instance.cid] = instance;
    }
  }, {
    key: "unregister",
    value: function unregister(instance, graph) {
      if (graph == null) {
        // tslint:disable-next-line
        graph = instance.graph;
      }

      var dic = this.ensureCache();

      if (dic[graph.view.cid]) {
        delete dic[graph.view.cid][instance.cid];
      }
    }
  }, {
    key: "removeInstances",
    value: function removeInstances(graph) {
      var dic = this.ensureCache();
      var cache = dic[graph.view.cid];

      if (cache) {
        Object.keys(cache).forEach(function (cid) {
          var instance = cache[cid];

          if (instance) {
            instance.remove();
          }
        });
      }
    }
  }, {
    key: "getInstances",
    value: function getInstances(graph) {
      var dic = this.ensureCache();
      return dic[graph.view.cid] || {};
    }
  }]);

  return Widget;
}(view_View); // #region static

widget_Widget.instanceCache = new WeakMap();

widget_decorate([view_View.dispose()], widget_Widget.prototype, "dispose", null);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/common/index.js


// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/selection/index.js













var selection_Selection = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(Selection, _View);

  var _super = Object(createSuper["a" /* default */])(Selection);

  function Selection(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Selection);

    _this = _super.call(this);
    _this.options = object_namespaceObject.merge({}, selection_Private.defaultOptions, options);

    if (_this.options.model) {
      _this.options.collection = _this.options.model.collection;
    }

    if (_this.options.collection) {
      _this.collection = _this.options.collection;
    } else {
      _this.collection = new collection_Collection([], {
        comparator: selection_Private.depthComparator
      });
      _this.options.collection = _this.collection;
    }

    _this.boxCount = 0;

    _this.createContainer();

    _this.initHandles();

    _this.startListening();

    return _this;
  }

  Object(createClass["a" /* default */])(Selection, [{
    key: "startListening",
    value: function startListening() {
      var _this$delegateEvents;

      var graph = this.graph;
      var collection = this.collection;
      this.delegateEvents((_this$delegateEvents = {}, Object(defineProperty["a" /* default */])(_this$delegateEvents, "mousedown .".concat(this.boxClassName), 'onSelectionBoxMouseDown'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "touchstart .".concat(this.boxClassName), 'onSelectionBoxMouseDown'), _this$delegateEvents), true);
      graph.on('scale', this.onTransformed, this);
      graph.on('translate', this.onTransformed, this);
      graph.model.on('updated', this.onModelUpdated, this);
      collection.on('added', this.onCellAdded, this);
      collection.on('removed', this.onCellRemoved, this);
      collection.on('reseted', this.onReseted, this);
      collection.on('updated', this.onCollectionUpdated, this);
      collection.on('cell:change:*', this.onCellChanged, this);
    }
  }, {
    key: "stopListening",
    value: function stopListening() {
      var graph = this.graph;
      var collection = this.collection;
      this.undelegateEvents();
      graph.off('scale', this.onTransformed, this);
      graph.off('translate', this.onTransformed, this);
      graph.model.off('updated', this.onModelUpdated, this);
      collection.off('added', this.onCellAdded, this);
      collection.off('removed', this.onCellRemoved, this);
      collection.off('reseted', this.onReseted, this);
      collection.off('updated', this.onCollectionUpdated, this);
      collection.off('cell:change:*', this.onCellChanged, this);
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.stopListening();
    }
  }, {
    key: "onTransformed",
    value: function onTransformed() {
      this.updateSelectionBoxes({
        async: false
      });
    }
  }, {
    key: "onCellChanged",
    value: function onCellChanged() {
      this.updateSelectionBoxes();
    }
  }, {
    key: "onModelUpdated",
    value: function onModelUpdated(_ref) {
      var removed = _ref.removed;

      if (removed && removed.length) {
        this.unselect(removed);
      }
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.length <= 0;
    }
  }, {
    key: "isSelected",
    value: function isSelected(cell) {
      return this.collection.has(cell);
    }
  }, {
    key: "select",
    value: function select(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      options.dryrun = true;
      this.collection.add(cells, options);
      return this;
    }
  }, {
    key: "unselect",
    value: function unselect(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // dryrun to prevent cell be removed from graph
      options.dryrun = true;
      this.collection.remove(Array.isArray(cells) ? cells : [cells], options);
      return this;
    }
  }, {
    key: "reset",
    value: function reset(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (cells) {
        this.collection.reset(Array.isArray(cells) ? cells : [cells], Object.assign(Object.assign({}, options), {
          ui: true
        }));
        return this;
      }

      return this.clean(options);
    }
  }, {
    key: "clean",
    value: function clean() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.length) {
        this.collection.reset([], Object.assign(Object.assign({}, options), {
          ui: true
        }));
      }

      return this;
    }
  }, {
    key: "setFilter",
    value: function setFilter(filter) {
      this.options.filter = filter;
    }
  }, {
    key: "setContent",
    value: function setContent(content) {
      this.options.content = content;
    }
  }, {
    key: "startSelecting",
    value: function startSelecting(evt) {
      // Flow: startSelecting => adjustSelection => stopSelecting
      evt = this.normalizeEvent(evt); // tslint:disable-line

      this.clean();
      var x;
      var y;
      var graphContainer = this.graph.container;

      if (null != evt.offsetX && null != evt.offsetY && graphContainer.contains(evt.target)) {
        x = evt.offsetX;
        y = evt.offsetY;
      } else {
        var offset = this.$(graphContainer).offset();
        var scrollLeft = graphContainer.scrollLeft;
        var scrollTop = graphContainer.scrollTop;
        x = evt.clientX - offset.left + window.pageXOffset + scrollLeft;
        y = evt.clientY - offset.top + window.pageYOffset + scrollTop;
      }

      this.$container.css({
        top: y,
        left: x,
        width: 1,
        height: 1
      });
      this.setEventData(evt, {
        action: 'selecting',
        clientX: evt.clientX,
        clientY: evt.clientY,
        offsetX: x,
        offsetY: y
      });
      this.delegateDocumentEvents(selection_Private.documentEvents, evt.data);
    }
  }, {
    key: "stopSelecting",
    value: function stopSelecting(evt) {
      var _this2 = this;

      var graph = this.graph;
      var action = this.getEventData(evt).action;

      switch (action) {
        case 'selecting':
          {
            var width = this.$container.width();
            var height = this.$container.height();
            var offset = this.$container.offset();
            var origin = graph.pageToLocalPoint(offset.left, offset.top);
            var scale = graph.scale();
            width = width / scale.sx;
            height = height / scale.sy;
            var rect = new rectangle_Rectangle(origin.x, origin.y, width, height);
            var views = this.getNodesInArea(rect);
            var filter = this.options.filter;

            if (Array.isArray(filter)) {
              views = views.filter(function (view) {
                return !filter.includes(view.cell) && !filter.includes(view.cell.shape);
              });
            } else {
              if (typeof filter === 'function') {
                views = views.filter(function (view) {
                  return !main_namespaceObject.call(filter, _this2.graph, view.cell);
                });
              }
            }

            var cells = views.map(function (view) {
              return view.cell;
            });
            this.collection.reset(cells, {
              ui: true
            });
            break;
          }

        case 'translating':
          {
            this.graph.model.stopBatch('move-selection');
            var client = graph.snapToGrid(evt.clientX, evt.clientY);
            this.notifyBoxEvent('box:mouseup', evt, client.x, client.y);
            break;
          }

        default:
          {
            if (!action) {
              this.clean();
            }
          }
      }
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(evt) {
      var action = this.getEventData(evt).action;

      if (action) {
        this.stopSelecting(evt);
        this.undelegateDocumentEvents();
      }
    }
  }, {
    key: "onSelectionBoxMouseDown",
    value: function onSelectionBoxMouseDown(evt) {
      evt.stopPropagation();
      var e = this.normalizeEvent(evt);

      if (this.options.movable) {
        this.startTranslating(e);
      }

      var activeView = this.getCellViewFromElem(e.target);
      this.setEventData(e, {
        activeView: activeView
      });
      var client = this.graph.snapToGrid(e.clientX, e.clientY);
      this.notifyBoxEvent('box:mousedown', e, client.x, client.y);
      this.delegateDocumentEvents(selection_Private.documentEvents, e.data);
    }
  }, {
    key: "startTranslating",
    value: function startTranslating(evt) {
      this.graph.model.startBatch('move-selection');
      var client = this.graph.snapToGrid(evt.clientX, evt.clientY);
      this.setEventData(evt, {
        action: 'translating',
        clientX: client.x,
        clientY: client.y
      });
    }
  }, {
    key: "adjustSelection",
    value: function adjustSelection(evt) {
      var e = this.normalizeEvent(evt);
      var eventData = this.getEventData(e);
      var action = eventData.action;

      switch (action) {
        case 'selecting':
          {
            var data = eventData;

            if (data.moving !== true) {
              this.$container.appendTo(this.graph.container);
              this.showRubberband();
              data.moving = true;
            }

            var dx = e.clientX - data.clientX;
            var dy = e.clientY - data.clientY;
            var left = parseInt(this.$container.css('left'), 10);
            var top = parseInt(this.$container.css('top'), 10);
            this.$container.css({
              left: dx < 0 ? data.offsetX + dx : left,
              top: dy < 0 ? data.offsetY + dy : top,
              width: Math.abs(dx),
              height: Math.abs(dy)
            });
            break;
          }

        case 'translating':
          {
            var _data = eventData;
            var client = this.graph.snapToGrid(e.clientX, e.clientY);

            var _dx = client.x - _data.clientX;

            var _dy = client.y - _data.clientY;

            var restrict = this.graph.getRestrictArea();

            if (restrict) {
              var cells = this.collection.toArray();
              var totalBBox = cell_Cell.getCellsBBox(cells);
              var minDx = restrict.x - totalBBox.x;
              var minDy = restrict.y - totalBBox.y;
              var maxDx = restrict.x + restrict.width - (totalBBox.x + totalBBox.width);
              var maxDy = restrict.y + restrict.height - (totalBBox.y + totalBBox.height);

              if (_dx < minDx) {
                _dx = minDx;
              }

              if (_dy < minDy) {
                _dy = minDy;
              }

              if (maxDx < _dx) {
                _dx = maxDx;
              }

              if (maxDy < _dy) {
                _dy = maxDy;
              }
            }

            if (_dx || _dy) {
              if (this.translateSelectedNodes(_dx, _dy), this.boxesUpdated) {
                if (this.collection.length > 1) {
                  this.updateSelectionBoxes();
                }
              } else {
                var scale = this.graph.scale();
                this.$boxes.add(this.$selectionContainer).css({
                  left: "+=".concat(_dx * scale.sx),
                  top: "+=".concat(_dy * scale.sy)
                });
              }

              _data.clientX = client.x;
              _data.clientY = client.y;
            }

            this.notifyBoxEvent('box:mousemove', evt, client.x, client.y);
            break;
          }
      }

      this.boxesUpdated = false;
    }
  }, {
    key: "translateSelectedNodes",
    value: function translateSelectedNodes(dx, dy) {
      var _this3 = this;

      var map = {};
      this.collection.toArray().forEach(function (cell) {
        if (!map[cell.id]) {
          var options = {
            selection: _this3.cid
          };
          cell.translate(dx, dy, options);
          cell.getDescendants({
            deep: true
          }).forEach(function (child) {
            map[child.id] = true;
          });

          _this3.graph.model.getConnectedEdges(cell).forEach(function (edge) {
            if (!map[edge.id]) {
              edge.translate(dx, dy, options);
              map[edge.id] = true;
            }
          });
        }
      });
    }
  }, {
    key: "getNodesInArea",
    value: function getNodesInArea(rect) {
      var graph = this.graph;
      var options = {
        strict: this.options.strict
      };
      return this.options.useCellGeometry ? graph.model.getNodesInArea(rect, options).map(function (node) {
        return graph.renderer.findViewByCell(node);
      }).filter(function (view) {
        return view != null;
      }) : graph.renderer.findViewsInArea(rect, options);
    }
  }, {
    key: "notifyBoxEvent",
    value: function notifyBoxEvent(name, e, x, y) {
      var data = this.getEventData(e);
      var view = data.activeView;
      this.trigger(name, {
        e: e,
        view: view,
        x: x,
        y: y,
        cell: view.cell
      });
    }
  }, {
    key: "getSelectedClassName",
    value: function getSelectedClassName(cell) {
      return this.prefixClassName("".concat(cell.isNode() ? 'node' : 'edge', "-selected"));
    }
  }, {
    key: "addCellSelectedClassName",
    value: function addCellSelectedClassName(cell) {
      var view = this.graph.renderer.findViewByCell(cell);

      if (view) {
        view.addClass(this.getSelectedClassName(cell));
      }
    }
  }, {
    key: "removeCellUnSelectedClassName",
    value: function removeCellUnSelectedClassName(cell) {
      var view = this.graph.renderer.findViewByCell(cell);

      if (view) {
        view.removeClass(this.getSelectedClassName(cell));
      }
    }
  }, {
    key: "destroySelectionBox",
    value: function destroySelectionBox(cell) {
      this.removeCellUnSelectedClassName(cell);

      if (this.canShowSelectionBox(cell)) {
        this.$container.find("[data-cell=\"".concat(cell.id, "\"]")).remove();

        if (this.$boxes.length === 0) {
          this.hide();
        }

        this.boxCount = Math.max(0, this.boxCount - 1);
      }
    }
  }, {
    key: "destroyAllSelectionBoxes",
    value: function destroyAllSelectionBoxes(cells) {
      var _this4 = this;

      cells.forEach(function (cell) {
        return _this4.removeCellUnSelectedClassName(cell);
      });
      this.hide();
      this.$boxes.remove();
      this.boxCount = 0;
    }
  }, {
    key: "hide",
    value: function hide() {
      this.$container.removeClass(this.prefixClassName(selection_Private.classNames.rubberband)).removeClass(this.prefixClassName(selection_Private.classNames.selected));
    }
  }, {
    key: "showRubberband",
    value: function showRubberband() {
      this.$container.addClass(this.prefixClassName(selection_Private.classNames.rubberband));
    }
  }, {
    key: "showSelected",
    value: function showSelected() {
      this.$container.removeAttr('style').addClass(this.prefixClassName(selection_Private.classNames.selected));
    }
  }, {
    key: "createContainer",
    value: function createContainer() {
      this.container = document.createElement('div');
      this.$container = this.$(this.container);
      this.$container.addClass(this.prefixClassName(selection_Private.classNames.root));

      if (this.options.className) {
        this.$container.addClass(this.options.className);
      }

      this.$selectionContainer = this.$('<div/>').addClass(this.prefixClassName(selection_Private.classNames.inner));
      this.$selectionContent = this.$('<div/>').addClass(this.prefixClassName(selection_Private.classNames.content));
      this.$selectionContainer.append(this.$selectionContent);
      this.$selectionContainer.attr('data-selection-length', this.collection.length);
      this.$container.prepend(this.$selectionContainer);
      this.$handleContainer = this.$selectionContainer;
    }
  }, {
    key: "updateContainer",
    value: function updateContainer() {
      var _this5 = this;

      var origin = {
        x: Infinity,
        y: Infinity
      };
      var corner = {
        x: 0,
        y: 0
      };
      var cells = this.collection.toArray().filter(function (cell) {
        return _this5.canShowSelectionBox(cell);
      });
      cells.forEach(function (cell) {
        var view = _this5.graph.renderer.findViewByCell(cell);

        if (view) {
          var bbox = view.getBBox({
            useCellGeometry: _this5.options.useCellGeometry
          });
          origin.x = Math.min(origin.x, bbox.x);
          origin.y = Math.min(origin.y, bbox.y);
          corner.x = Math.max(corner.x, bbox.x + bbox.width);
          corner.y = Math.max(corner.y, bbox.y + bbox.height);
        }
      });
      this.$selectionContainer.css({
        position: 'absolute',
        pointerEvents: 'none',
        left: origin.x,
        top: origin.y,
        width: corner.x - origin.x,
        height: corner.y - origin.y
      }).attr('data-selection-length', this.collection.length);
      var boxContent = this.options.content;

      if (boxContent) {
        if (typeof boxContent === 'function') {
          var content = main_namespaceObject.call(boxContent, this.graph, this, this.$selectionContent[0]);

          if (content) {
            this.$selectionContent.html(content);
          }
        } else {
          this.$selectionContent.html(boxContent);
        }
      }

      if (this.collection.length > 0 && !this.container.parentNode) {
        this.$container.appendTo(this.graph.container);
      } else if (this.collection.length <= 0 && this.container.parentNode) {
        this.container.parentNode.removeChild(this.container);
      }
    }
  }, {
    key: "canShowSelectionBox",
    value: function canShowSelectionBox(cell) {
      return cell.isNode() && this.options.showNodeSelectionBox === true || cell.isEdge() && this.options.showEdgeSelectionBox === true;
    }
  }, {
    key: "createSelectionBox",
    value: function createSelectionBox(cell) {
      this.addCellSelectedClassName(cell);

      if (this.canShowSelectionBox(cell)) {
        var view = this.graph.renderer.findViewByCell(cell);

        if (view) {
          var bbox = view.getBBox({
            useCellGeometry: this.options.useCellGeometry
          });
          var className = this.boxClassName;
          this.$('<div/>').addClass(className).addClass("".concat(className, "-").concat(cell.isNode() ? 'node' : 'edge')).attr('data-cell', cell.id).css({
            position: 'absolute',
            left: bbox.x,
            top: bbox.y,
            width: bbox.width,
            height: bbox.height
          }).appendTo(this.container);
          this.showSelected();
          this.boxCount += 1;
        }
      }
    }
  }, {
    key: "updateSelectionBoxes",
    value: function updateSelectionBoxes() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.collection.length > 0) {
        this.boxesUpdated = true;
        this.graph.renderer.requestViewUpdate(this, 1, 2, options);
      }
    }
  }, {
    key: "confirmUpdate",
    value: function confirmUpdate() {
      var _this6 = this;

      if (this.boxCount) {
        this.hide();
        this.$boxes.each(function (_, elem) {
          var cellId = _this6.$(elem).remove().attr('data-cell');

          var cell = _this6.collection.get(cellId);

          if (cell) {
            _this6.createSelectionBox(cell);
          }
        });
        this.updateContainer();
      }

      return 0;
    }
  }, {
    key: "getCellViewFromElem",
    value: function getCellViewFromElem(elem) {
      var id = elem.getAttribute('data-cell');

      if (id) {
        var cell = this.collection.get(id);

        if (cell) {
          return this.graph.renderer.findViewByCell(cell);
        }
      }

      return null;
    }
  }, {
    key: "onCellRemoved",
    value: function onCellRemoved(_ref2) {
      var cell = _ref2.cell;
      this.destroySelectionBox(cell);
      this.updateContainer();
    }
  }, {
    key: "onReseted",
    value: function onReseted(_ref3) {
      var _this7 = this;

      var previous = _ref3.previous,
          current = _ref3.current;
      this.destroyAllSelectionBoxes(previous);
      current.forEach(function (cell) {
        _this7.listenCellRemoveEvent(cell);

        _this7.createSelectionBox(cell);
      });
      this.updateContainer();
    }
  }, {
    key: "onCellAdded",
    value: function onCellAdded(_ref4) {
      var cell = _ref4.cell;
      // The collection do not known the cell was removed when cell was
      // removed by interaction(such as, by "delete" shortcut), so we should
      // manually listen to cell's remove evnet.
      this.listenCellRemoveEvent(cell);
      this.createSelectionBox(cell);
      this.updateContainer();
    }
  }, {
    key: "listenCellRemoveEvent",
    value: function listenCellRemoveEvent(cell) {
      cell.off('removed', this.onCellRemoved, this);
      cell.on('removed', this.onCellRemoved, this);
    }
  }, {
    key: "onCollectionUpdated",
    value: function onCollectionUpdated(_ref5) {
      var _this8 = this;

      var added = _ref5.added,
          removed = _ref5.removed,
          options = _ref5.options;
      added.forEach(function (cell) {
        _this8.trigger('cell:selected', {
          cell: cell,
          options: options
        });

        _this8.graph.trigger('cell:selected', {
          cell: cell,
          options: options
        });

        if (cell.isNode()) {
          _this8.trigger('node:selected', {
            cell: cell,
            options: options,
            node: cell
          });

          _this8.graph.trigger('node:selected', {
            cell: cell,
            options: options,
            node: cell
          });
        } else if (cell.isEdge()) {
          _this8.trigger('edge:selected', {
            cell: cell,
            options: options,
            edge: cell
          });

          _this8.graph.trigger('edge:selected', {
            cell: cell,
            options: options,
            edge: cell
          });
        }
      });
      removed.forEach(function (cell) {
        _this8.trigger('cell:unselected', {
          cell: cell,
          options: options
        });

        _this8.graph.trigger('cell:unselected', {
          cell: cell,
          options: options
        });

        if (cell.isNode()) {
          _this8.trigger('node:unselected', {
            cell: cell,
            options: options,
            node: cell
          });

          _this8.graph.trigger('node:unselected', {
            cell: cell,
            options: options,
            node: cell
          });
        } else if (cell.isEdge()) {
          _this8.trigger('edge:unselected', {
            cell: cell,
            options: options,
            edge: cell
          });

          _this8.graph.trigger('edge:unselected', {
            cell: cell,
            options: options,
            edge: cell
          });
        }
      });
      var args = {
        added: added,
        removed: removed,
        options: options,
        selected: this.cells
      };
      this.trigger('selection:changed', args);
      this.graph.trigger('selection:changed', args);
    } // #region handle

  }, {
    key: "deleteSelectedCells",
    value: function deleteSelectedCells() {
      var cells = this.collection.toArray();
      this.clean();
      this.graph.model.removeCells(cells, {
        selection: this.cid
      });
    }
  }, {
    key: "startRotate",
    value: function startRotate(_ref6) {
      var e = _ref6.e;
      var cells = this.collection.toArray();
      var center = cell_Cell.getCellsBBox(cells).getCenter();
      var client = this.graph.snapToGrid(e.clientX, e.clientY);
      var angles = cells.reduce(function (memo, cell) {
        memo[cell.id] = Angle.normalize(cell.getAngle());
        return memo;
      }, {});
      this.setEventData(e, {
        center: center,
        angles: angles,
        start: client.theta(center)
      });
    }
  }, {
    key: "doRotate",
    value: function doRotate(_ref7) {
      var _this9 = this;

      var e = _ref7.e;
      var data = this.getEventData(e);
      var grid = this.graph.options.rotating.grid;
      var gridSize = typeof grid === 'function' ? main_namespaceObject.call(grid, this.graph, null) : grid;
      var client = this.graph.snapToGrid(e.clientX, e.clientY);
      var delta = data.start - client.theta(data.center);

      if (!data.rotated) {
        data.rotated = true;
      }

      if (Math.abs(delta) > 0.001) {
        this.collection.toArray().forEach(function (node) {
          var angle = util_Util.snapToGrid(data.angles[node.id] + delta, gridSize || 15);
          node.rotate(angle, {
            absolute: true,
            center: data.center,
            selection: _this9.cid
          });
        });
        this.updateSelectionBoxes();
      }
    }
  }, {
    key: "stopRotate",
    value: function stopRotate(_ref8) {
      var _this10 = this;

      var e = _ref8.e;
      var data = this.getEventData(e);

      if (data.rotated) {
        data.rotated = false;
        this.collection.toArray().forEach(function (node) {
          notify('node:rotated', e, _this10.graph.findViewByCell(node));
        });
      }
    }
  }, {
    key: "startResize",
    value: function startResize(_ref9) {
      var e = _ref9.e;
      var gridSize = this.graph.getGridSize();
      var cells = this.collection.toArray();
      var bbox = cell_Cell.getCellsBBox(cells);
      var bboxes = cells.map(function (cell) {
        return cell.getBBox();
      });
      var maxWidth = bboxes.reduce(function (maxWidth, bbox) {
        return bbox.width < maxWidth ? bbox.width : maxWidth;
      }, Infinity);
      var maxHeight = bboxes.reduce(function (maxHeight, bbox) {
        return bbox.height < maxHeight ? bbox.height : maxHeight;
      }, Infinity);
      this.setEventData(e, {
        bbox: bbox,
        cells: this.graph.model.getSubGraph(cells),
        minWidth: gridSize * bbox.width / maxWidth,
        minHeight: gridSize * bbox.height / maxHeight
      });
    }
  }, {
    key: "doResize",
    value: function doResize(_ref10) {
      var e = _ref10.e,
          dx = _ref10.dx,
          dy = _ref10.dy;
      var data = this.eventData(e);
      var bbox = data.bbox;
      var width = bbox.width;
      var height = bbox.height;
      var newWidth = Math.max(width + dx, data.minWidth);
      var newHeight = Math.max(height + dy, data.minHeight);

      if (!data.resized) {
        data.resized = true;
      }

      if (0.001 < Math.abs(width - newWidth) || 0.001 < Math.abs(height - newHeight)) {
        this.graph.model.resizeCells(newWidth, newHeight, data.cells, {
          selection: this.cid
        });
        bbox.width = newWidth;
        bbox.height = newHeight;
        this.updateSelectionBoxes();
      }
    }
  }, {
    key: "stopResize",
    value: function stopResize(_ref11) {
      var _this11 = this;

      var e = _ref11.e;
      var data = this.eventData(e);

      if (data.resized) {
        data.resized = false;
        this.collection.toArray().forEach(function (node) {
          notify('node:resized', e, _this11.graph.findViewByCell(node));
        });
      }
    }
  }, {
    key: "graph",
    get: function get() {
      return this.options.graph;
    }
  }, {
    key: "boxClassName",
    get: function get() {
      return this.prefixClassName(selection_Private.classNames.box);
    }
  }, {
    key: "$boxes",
    get: function get() {
      return this.$container.children(".".concat(this.boxClassName));
    }
  }, {
    key: "handleOptions",
    get: function get() {
      return this.options;
    }
  }, {
    key: "length",
    get: function get() {
      return this.collection.length;
    }
  }, {
    key: "cells",
    get: function get() {
      return this.collection.toArray();
    }
  }]);

  return Selection;
}(view_View);
object_namespaceObject.applyMixins(selection_Selection, handle_Handle); // private
// -------

var selection_Private;

(function (Private) {
  var base = 'widget-selection';
  Private.classNames = {
    root: base,
    inner: "".concat(base, "-inner"),
    box: "".concat(base, "-box"),
    content: "".concat(base, "-content"),
    rubberband: "".concat(base, "-rubberband"),
    selected: "".concat(base, "-selected")
  };
  Private.documentEvents = {
    mousemove: 'adjustSelection',
    touchmove: 'adjustSelection',
    mouseup: 'onMouseUp',
    touchend: 'onMouseUp',
    touchcancel: 'onMouseUp'
  };
  Private.defaultOptions = {
    movable: true,
    strict: false,
    useCellGeometry: false,
    content: function content(selection) {
      return string_namespaceObject.template('<%= length %> node<%= length > 1 ? "s":"" %> selected.')({
        length: selection.length
      });
    },
    handles: [{
      name: 'remove',
      position: 'nw',
      events: {
        mousedown: 'deleteSelectedCells'
      }
    }, {
      name: 'rotate',
      position: 'sw',
      events: {
        mousedown: 'startRotate',
        mousemove: 'doRotate',
        mouseup: 'stopRotate'
      }
    }, {
      name: 'resize',
      position: 'se',
      events: {
        mousedown: 'startResize',
        mousemove: 'doResize',
        mouseup: 'stopResize'
      }
    }]
  };

  function depthComparator(cell) {
    return cell.getAncestors().length;
  }

  Private.depthComparator = depthComparator;
})(selection_Private || (selection_Private = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/clipboard/index.js






var clipboard_Clipboard = /*#__PURE__*/function () {
  function Clipboard() {
    Object(classCallCheck["a" /* default */])(this, Clipboard);

    this.cells = [];
  }

  Object(createClass["a" /* default */])(Clipboard, [{
    key: "copy",
    value: function copy(cells, graph) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.options = Object.assign({}, options);
      var model = graph instanceof model_Model ? graph : graph.model;
      var cloned = model.cloneSubGraph(cells, options); // sort asc by cell type

      this.cells = array_namespaceObject.sortBy(Object.keys(cloned).map(function (key) {
        return cloned[key];
      }), function (cell) {
        return cell.isEdge() ? 2 : 1;
      });
      this.serialize(options);
    }
  }, {
    key: "cut",
    value: function cut(cells, graph) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.copy(cells, graph, options);
      var model = graph instanceof graph_Graph ? graph.model : graph;
      model.batchUpdate('cut', function () {
        cells.forEach(function (cell) {
          return cell.remove();
        });
      });
    }
  }, {
    key: "paste",
    value: function paste(graph) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localOptions = Object.assign(Object.assign({}, options), this.options);
      var offset = localOptions.offset,
          edgeProps = localOptions.edgeProps,
          nodeProps = localOptions.nodeProps;
      var dx = 20;
      var dy = 20;

      if (offset) {
        dx = typeof offset === 'number' ? offset : offset.dx;
        dy = typeof offset === 'number' ? offset : offset.dy;
      }

      this.deserialize(localOptions);
      var cells = this.cells;
      cells.map(function (cell) {
        cell.model = null;
        cell.removeProp('zIndex');

        if (dx || dy) {
          cell.translate(dx, dy);
        }

        if (nodeProps && cell.isNode()) {
          cell.prop(nodeProps);
        }

        if (edgeProps && cell.isEdge()) {
          cell.prop(edgeProps);
        }
      });
      var model = graph instanceof graph_Graph ? graph.model : graph;
      model.batchUpdate('paste', function () {
        model.addCells(_this.cells);
      });
      this.copy(cells, graph, options);
      return cells;
    }
  }, {
    key: "serialize",
    value: function serialize(options) {
      if (options.useLocalStorage !== false) {
        clipboard_Storage.save(this.cells);
      }
    }
  }, {
    key: "deserialize",
    value: function deserialize(options) {
      if (options.useLocalStorage) {
        var cells = clipboard_Storage.fetch();

        if (cells) {
          this.cells = cells;
        }
      }
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.cells.length <= 0;
    }
  }, {
    key: "clean",
    value: function clean() {
      this.options = {};
      this.cells = [];
      clipboard_Storage.clean();
    }
  }]);

  return Clipboard;
}();
var clipboard_Storage;

(function (Storage) {
  var LOCAL_STORAGE_KEY = "".concat(Config.prefixCls, ".clipboard.cells");

  function save(cells) {
    if (window.localStorage) {
      var data = cells.map(function (cell) {
        return cell.toJSON();
      });
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
    }
  }

  Storage.save = save;

  function fetch() {
    if (window.localStorage) {
      var raw = localStorage.getItem(LOCAL_STORAGE_KEY);
      var cells = raw ? JSON.parse(raw) : [];

      if (cells) {
        return model_Model.fromJSON(cells);
      }
    }
  }

  Storage.fetch = fetch;

  function clean() {
    if (window.localStorage) {
      localStorage.removeItem(LOCAL_STORAGE_KEY);
    }
  }

  Storage.clean = clean;
})(clipboard_Storage || (clipboard_Storage = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/transform/index.js











var transform_Transform = /*#__PURE__*/function (_Widget) {
  Object(inherits["a" /* default */])(Transform, _Widget);

  var _super = Object(createSuper["a" /* default */])(Transform);

  function Transform() {
    Object(classCallCheck["a" /* default */])(this, Transform);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Transform, [{
    key: "init",
    value: function init(options) {
      this.options = Object.assign(Object.assign({}, transform_Private.defaultOptions), options);
      this.render();
      this.startListening();
    }
  }, {
    key: "startListening",
    value: function startListening() {
      var _this$delegateEvents;

      this.delegateEvents((_this$delegateEvents = {}, Object(defineProperty["a" /* default */])(_this$delegateEvents, "mousedown .".concat(this.resizeClassName), 'startResizing'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "touchstart .".concat(this.resizeClassName), 'startResizing'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "mousedown .".concat(this.rotateClassName), 'startRotating'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "touchstart .".concat(this.rotateClassName), 'startRotating'), _this$delegateEvents));
      this.model.on('*', this.update, this);
      this.model.on('reseted', this.remove, this);
      this.node.on('removed', this.remove, this);
      this.graph.on('scale', this.update, this);
      this.graph.on('translate', this.update, this);

      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(Transform.prototype), "startListening", this).call(this);
    }
  }, {
    key: "stopListening",
    value: function stopListening() {
      this.undelegateEvents();
      this.model.off('*', this.update, this);
      this.model.off('reseted', this.remove, this);
      this.node.off('removed', this.remove, this);
      this.graph.off('scale', this.update, this);
      this.graph.off('translate', this.update, this);

      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(Transform.prototype), "stopListening", this).call(this);
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.stopListening();
    }
  }, {
    key: "renderHandles",
    value: function renderHandles() {
      var _this = this;

      this.container = document.createElement('div');
      this.$container = this.$(this.container);
      var $knob = this.$('<div/>').prop('draggable', false);
      var $rotate = $knob.clone().addClass(this.rotateClassName);
      var $resizes = transform_Private.POSITIONS.map(function (pos) {
        return $knob.clone().addClass(_this.resizeClassName).attr('data-position', pos);
      });
      this.empty();
      this.$container.append($resizes, $rotate);
    }
  }, {
    key: "render",
    value: function render() {
      this.renderHandles();
      this.$container.addClass(this.containerClassName).toggleClass('no-orth-resize', this.options.preserveAspectRatio || !this.options.orthogonalResizing).toggleClass('no-resize', !this.options.resizable).toggleClass('no-rotate', !this.options.rotatable);

      if (this.options.className) {
        this.$container.addClass(this.options.className);
      }

      this.graph.container.appendChild(this.container);
      return this.update();
    }
  }, {
    key: "update",
    value: function update() {
      var ctm = this.graph.matrix();
      var bbox = this.node.getBBox();
      bbox.x *= ctm.a;
      bbox.x += ctm.e;
      bbox.y *= ctm.d;
      bbox.y += ctm.f;
      bbox.width *= ctm.a;
      bbox.height *= ctm.d;
      var angle = Angle.normalize(this.node.getAngle());
      var transform = angle !== 0 ? "rotate(".concat(angle, "deg)") : '';
      this.$container.css({
        transform: transform,
        width: bbox.width,
        height: bbox.height,
        left: bbox.x,
        top: bbox.y
      });
      this.updateResizerDirections();
      return this;
    }
  }, {
    key: "updateResizerDirections",
    value: function updateResizerDirections() {
      var _this2 = this;

      // Update the directions on the resizer divs while the node being rotated.
      // The directions are represented by cardinal points (N,S,E,W). For example
      // the div originally pointed to north needs to be changed to point to south
      // if the node was rotated by 180 degrees.
      var angle = Angle.normalize(this.node.getAngle());
      var shift = Math.floor(angle * (transform_Private.DIRECTIONS.length / 360));

      if (shift !== this.prevShift) {
        // Create the current directions array based on the calculated shift.
        var directions = transform_Private.DIRECTIONS.slice(shift).concat(transform_Private.DIRECTIONS.slice(0, shift));

        var className = function className(dir) {
          return "".concat(_this2.containerClassName, "-cursor-").concat(dir);
        };

        this.$container.find(".".concat(this.resizeClassName)).removeClass(transform_Private.DIRECTIONS.map(function (dir) {
          return className(dir);
        }).join(' ')).each(function (index, elem) {
          _this2.$(elem).addClass(className(directions[index]));
        });
        this.prevShift = shift;
      }
    }
  }, {
    key: "getTrueDirection",
    value: function getTrueDirection(dir) {
      var angle = Angle.normalize(this.node.getAngle());
      var index = transform_Private.POSITIONS.indexOf(dir);
      index = index + Math.floor(angle * (transform_Private.POSITIONS.length / 360));
      index = index % transform_Private.POSITIONS.length;
      return transform_Private.POSITIONS[index];
    }
  }, {
    key: "toValidResizeDirection",
    value: function toValidResizeDirection(dir) {
      return {
        top: 'top-left',
        bottom: 'bottom-right',
        left: 'bottom-left',
        right: 'top-right'
      }[dir] || dir;
    }
  }, {
    key: "startResizing",
    value: function startResizing(evt) {
      evt.stopPropagation();
      this.model.startBatch('resize', {
        cid: this.cid
      });
      var relativeDirection = this.$(evt.target).attr('data-position');
      this.prepareResizing(evt, relativeDirection);
      this.startAction(evt);
    }
  }, {
    key: "prepareResizing",
    value: function prepareResizing(evt, relativeDirection) {
      var trueDirection = this.getTrueDirection(relativeDirection);
      var rx = 0;
      var ry = 0;
      relativeDirection.split('-').forEach(function (direction) {
        rx = {
          left: -1,
          right: 1
        }[direction] || rx;
        ry = {
          top: -1,
          bottom: 1
        }[direction] || ry;
      });
      var direction = this.toValidResizeDirection(relativeDirection);
      var selector = {
        'top-right': 'bottomLeft',
        'top-left': 'bottomRight',
        'bottom-left': 'topRight',
        'bottom-right': 'topLeft'
      }[direction];
      this.setEventData(evt, {
        selector: selector,
        direction: direction,
        trueDirection: trueDirection,
        relativeDirection: relativeDirection,
        resizeX: rx,
        resizeY: ry,
        angle: Angle.normalize(this.node.getAngle()),
        action: 'resizing'
      });
    }
  }, {
    key: "startRotating",
    value: function startRotating(evt) {
      evt.stopPropagation();
      this.model.startBatch('rotate', {
        cid: this.cid
      });
      var center = this.node.getBBox().getCenter();
      var client = this.graph.snapToGrid(evt.clientX, evt.clientY);
      this.setEventData(evt, {
        center: center,
        action: 'rotating',
        angle: Angle.normalize(this.node.getAngle()),
        start: point_Point.create(client).theta(center)
      });
      this.startAction(evt);
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(evt) {
      var data = this.getEventData(evt);

      if (data.action) {
        var e = this.normalizeEvent(evt);
        var pos = this.graph.snapToGrid(e.clientX, e.clientY);
        var gridSize = this.graph.getGridSize();
        var node = this.node;
        var options = this.options;

        if (data.action === 'resizing') {
          data = data;

          if (!data.resized) {
            data.resized = true;
          }

          var currentBBox = node.getBBox();
          var requestedSize = point_Point.create(pos).rotate(data.angle, currentBBox.getCenter()).diff(currentBBox[data.selector]);
          var width = data.resizeX ? requestedSize.x * data.resizeX : currentBBox.width;
          var height = data.resizeY ? requestedSize.y * data.resizeY : currentBBox.height;
          var rawWidth = width;
          var rawHeight = height;
          width = util_Util.snapToGrid(width, gridSize);
          height = util_Util.snapToGrid(height, gridSize);
          width = Math.max(width, options.minWidth || gridSize);
          height = Math.max(height, options.minHeight || gridSize);
          width = Math.min(width, options.maxWidth || Infinity);
          height = Math.min(height, options.maxHeight || Infinity);

          if (options.preserveAspectRatio) {
            var candidateWidth = currentBBox.width * height / currentBBox.height;
            var candidateHeight = currentBBox.height * width / currentBBox.width;

            if (width < candidateWidth) {
              height = candidateHeight;
            } else {
              width = candidateWidth;
            }
          }

          var relativeDirection = data.relativeDirection;

          if (rawWidth <= -width || rawHeight <= -height) {
            var reverted;

            if (relativeDirection === 'left') {
              if (rawWidth <= -width) {
                reverted = 'right';
              }
            } else if (relativeDirection === 'right') {
              if (rawWidth <= -width) {
                reverted = 'left';
              }
            } else if (relativeDirection === 'top') {
              if (rawHeight <= -height) {
                reverted = 'bottom';
              }
            } else if (relativeDirection === 'bottom') {
              if (rawHeight <= -height) {
                reverted = 'top';
              }
            } else if (relativeDirection === 'top-left') {
              if (rawWidth <= -width && rawHeight <= -height) {
                reverted = 'bottom-right';
              } else if (rawWidth <= -width) {
                reverted = 'top-right';
              } else if (rawHeight <= -height) {
                reverted = 'bottom-left';
              }
            } else if (relativeDirection === 'top-right') {
              if (rawWidth <= -width && rawHeight <= -height) {
                reverted = 'bottom-left';
              } else if (rawWidth <= -width) {
                reverted = 'top-left';
              } else if (rawHeight <= -height) {
                reverted = 'bottom-right';
              }
            } else if (relativeDirection === 'bottom-left') {
              if (rawWidth <= -width && rawHeight <= -height) {
                reverted = 'top-right';
              } else if (rawWidth <= -width) {
                reverted = 'bottom-right';
              } else if (rawHeight <= -height) {
                reverted = 'top-left';
              }
            } else if (relativeDirection === 'bottom-right') {
              if (rawWidth <= -width && rawHeight <= -height) {
                reverted = 'top-left';
              } else if (rawWidth <= -width) {
                reverted = 'bottom-left';
              } else if (rawHeight <= -height) {
                reverted = 'top-right';
              }
            }

            var revertedDir = reverted;
            this.stopHandle();
            var $handle = this.$container.find(".".concat(this.resizeClassName, "[data-position=\"").concat(revertedDir, "\"]"));
            this.startHandle($handle[0]);
            this.prepareResizing(evt, revertedDir);
            this.onMouseMove(evt);
          }

          if (currentBBox.width !== width || currentBBox.height !== height) {
            var resizeOptions = {
              ui: true,
              direction: data.direction,
              relativeDirection: data.relativeDirection,
              trueDirection: data.trueDirection,
              minWidth: options.minWidth,
              minHeight: options.minHeight,
              maxWidth: options.maxWidth,
              maxHeight: options.maxHeight,
              preserveAspectRatio: options.preserveAspectRatio === true
            };
            node.resize(width, height, resizeOptions);
          }
        } else if (data.action === 'rotating') {
          data = data;

          if (!data.rotated) {
            data.rotated = true;
          }

          var theta = data.start - point_Point.create(pos).theta(data.center);
          var target = data.angle + theta;

          if (options.rotateGrid) {
            target = util_Util.snapToGrid(target, options.rotateGrid);
          }

          node.rotate(target, {
            absolute: true
          });
        }
      }
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp(evt) {
      var data = this.getEventData(evt);

      if (data.action) {
        this.stopAction(evt);
        this.model.stopBatch(data.action === 'resizing' ? 'resize' : 'rotate', {
          cid: this.cid
        });

        if (data.action === 'resizing') {
          data = data;

          if (data.resized) {
            notify('node:resized', evt, this.graph.findViewByCell(this.cell));
          }
        } else {
          data = data;

          if (data.rotated) {
            notify('node:rotated', evt, this.graph.findViewByCell(this.cell));
          }
        }
      }
    }
  }, {
    key: "startHandle",
    value: function startHandle(handle) {
      this.handle = handle;
      this.$(handle).addClass("".concat(this.containerClassName, "-active-handle"));
      this.$container.addClass("".concat(this.containerClassName, "-active"));
      var pos = handle.getAttribute('data-position');

      if (pos) {
        var dir = transform_Private.DIRECTIONS[transform_Private.POSITIONS.indexOf(pos)];
        this.$container.addClass("".concat(this.containerClassName, "-cursor-").concat(dir));
      }
    }
  }, {
    key: "stopHandle",
    value: function stopHandle() {
      if (this.handle) {
        this.$(this.handle).removeClass("".concat(this.containerClassName, "-active-handle"));
        this.$container.removeClass("".concat(this.containerClassName, "-active"));
        var pos = this.handle.getAttribute('data-position');

        if (pos) {
          var dir = transform_Private.DIRECTIONS[transform_Private.POSITIONS.indexOf(pos)];
          this.$container.removeClass("".concat(this.containerClassName, "-cursor-").concat(dir));
        }

        this.handle = null;
      }
    }
  }, {
    key: "startAction",
    value: function startAction(evt) {
      var elem = evt.target;
      this.startHandle(elem);
      this.graph.view.undelegateEvents();
      this.delegateDocumentEvents(transform_Private.documentEvents, evt.data); // const data = this.getEventData<EventData.Resizing | EventData.Rotating>(evt)
      // if (data.action === 'resizing') {
      //   this.node.notify('node:resize', { node: this.node })
      // } else if (data.action === 'rotating') {
      //   this.node.notify('node:rotate', { node: this.node })
      // }
    }
  }, {
    key: "stopAction",
    value: function stopAction(evt) {
      this.stopHandle();
      this.undelegateDocumentEvents();
      this.graph.view.delegateEvents(); // const data = this.getEventData<EventData.Resizing | EventData.Rotating>(evt)
      // if (data.action === 'resizing') {
      //   this.node.notify('node:resized', { node: this.node })
      // } else if (data.action === 'rotating') {
      //   this.node.notify('node:rotated', { node: this.node })
      // }
    }
  }, {
    key: "node",
    get: function get() {
      return this.cell;
    }
  }, {
    key: "containerClassName",
    get: function get() {
      return this.prefixClassName('widget-transform');
    }
  }, {
    key: "resizeClassName",
    get: function get() {
      return "".concat(this.containerClassName, "-resize");
    }
  }, {
    key: "rotateClassName",
    get: function get() {
      return "".concat(this.containerClassName, "-rotate");
    }
  }]);

  return Transform;
}(widget_Widget);
var transform_Private;

(function (Private) {
  Private.DIRECTIONS = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
  Private.POSITIONS = ['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];
  Private.documentEvents = {
    mousemove: 'onMouseMove',
    touchmove: 'onMouseMove',
    mouseup: 'onMouseUp',
    touchend: 'onMouseUp'
  };
  Private.defaultOptions = {
    minWidth: 0,
    minHeight: 0,
    maxWidth: Infinity,
    maxHeight: Infinity,
    rotateGrid: 15,
    rotatable: true,
    preserveAspectRatio: false,
    orthogonalResizing: true
  };
})(transform_Private || (transform_Private = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/edge.js

var standard_edge_Edge = edge_Edge.define({
  shape: 'edge',
  markup: [{
    tagName: 'path',
    selector: 'wrap',
    attrs: {
      fill: 'none',
      cursor: 'pointer',
      stroke: 'transparent',
      strokeLinecap: 'round'
    }
  }, {
    tagName: 'path',
    selector: 'line',
    attrs: {
      fill: 'none',
      pointerEvents: 'none'
    }
  }],
  attrs: {
    wrap: {
      connection: true,
      strokeWidth: 10,
      strokeLinejoin: 'round'
    },
    line: {
      connection: true,
      stroke: '#333333',
      strokeWidth: 2,
      strokeLinejoin: 'round',
      targetMarker: {
        tagName: 'path',
        d: 'M 10 -5 0 0 10 5 z'
      }
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/options.js
var options_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};





var options_Options;

(function (Options) {
  function parseOptionGroup(graph, arg, options) {
    var result = {};
    Object.keys(options || {}).forEach(function (key) {
      var val = options[key];
      result[key] = typeof val === 'function' ? val.call(graph, arg) : val;
    });
    return result;
  }

  Options.parseOptionGroup = parseOptionGroup;
})(options_Options || (options_Options = {}));

(function (Options) {
  function get(options) {
    var grid = options.grid,
        selecting = options.selecting,
        embedding = options.embedding,
        snapline = options.snapline,
        resizing = options.resizing,
        rotating = options.rotating,
        clipboard = options.clipboard,
        history = options.history,
        scroller = options.scroller,
        minimap = options.minimap,
        keyboard = options.keyboard,
        mousewheel = options.mousewheel,
        others = options_rest(options // size
    // ----
    , ["grid", "selecting", "embedding", "snapline", "resizing", "rotating", "clipboard", "history", "scroller", "minimap", "keyboard", "mousewheel"]); // size
    // ----


    var container = options.container;

    if (container != null) {
      if (others.width == null) {
        others.width = container.clientWidth;
      }

      if (others.height == null) {
        others.height = container.clientHeight;
      }
    } else {
      throw new Error("Ensure the container of the graph is specified and vliad");
    }

    var result = object_namespaceObject.merge({}, Options.defaults, others); // grid
    // ----

    var defaultGrid = {
      size: 10,
      visible: false
    };

    if (typeof grid === 'number') {
      result.grid = {
        size: grid,
        visible: false
      };
    } else if (typeof grid === 'boolean') {
      result.grid = Object.assign(Object.assign({}, defaultGrid), {
        visible: grid
      });
    } else {
      result.grid = Object.assign(Object.assign({}, defaultGrid), grid);
    } // booleas
    // -------


    var booleas = ['selecting', 'embedding', 'snapline', 'resizing', 'rotating', 'clipboard', 'history', 'scroller', 'minimap', 'keyboard', 'mousewheel'];
    booleas.forEach(function (key) {
      var val = options[key];

      if (typeof val === 'boolean') {
        result[key].enabled = val;
      } else {
        result[key] = Object.assign(Object.assign({}, result[key]), val);
      }
    }); // background
    // ----------

    if (result.background && result.scroller.enabled && result.scroller.background == null) {
      result.scroller.background = result.background;
      delete result.background;
    }

    return result;
  }

  Options.get = get;
})(options_Options || (options_Options = {}));

(function (Options) {
  Options.defaults = {
    x: 0,
    y: 0,
    grid: {
      size: 10,
      visible: false
    },
    scaling: {
      min: 0.01,
      max: 16
    },
    background: false,
    highlighting: {
      default: {
        name: 'stroke',
        args: {
          padding: 3
        }
      },
      nodeAvailable: {
        name: 'className',
        args: {
          className: util_Util.prefix('available-node')
        }
      },
      magnetAvailable: {
        name: 'className',
        args: {
          className: util_Util.prefix('available-magnet')
        }
      }
    },
    connecting: {
      snap: false,
      multi: true,
      dangling: true,
      highlight: false,
      anchor: 'center',
      edgeAnchor: 'ratio',
      connectionPoint: 'boundary',
      strategy: null,
      router: 'normal',
      connector: 'normal',
      validateConnection: function validateConnection(_ref) {
        var type = _ref.type,
            sourceView = _ref.sourceView,
            targetView = _ref.targetView;
        var view = type === 'target' ? targetView : sourceView;
        return view instanceof node_NodeView;
      },
      createEdge: function createEdge() {
        return new standard_edge_Edge();
      }
    },
    transforming: {
      clearAll: true,
      clearOnBlankMouseDown: true
    },
    resizing: {
      enabled: false,
      minWidth: 0,
      minHeight: 0,
      maxWidth: Number.MAX_SAFE_INTEGER,
      maxHeight: Number.MAX_SAFE_INTEGER,
      orthogonal: true,
      preserveAspectRatio: false
    },
    rotating: {
      enabled: false,
      grid: 15
    },
    translating: {
      restrict: false
    },
    embedding: {
      enabled: false,
      findParent: 'bbox',
      frontOnly: true,
      validate: function validate() {
        return true;
      }
    },
    selecting: {
      enabled: false,
      rubberband: false,
      multiple: true,
      movable: true,
      strict: false,
      useCellGeometry: false,
      content: null,
      handles: null
    },
    snapline: {
      enabled: false
    },
    clipboard: {
      enabled: false
    },
    history: {
      enabled: false
    },
    scroller: {
      enabled: false
    },
    keyboard: {
      enabled: false
    },
    mousewheel: {
      enabled: false,
      factor: 1.2,
      zoomAtMousePosition: true
    },
    async: false,
    frozen: false,
    sorting: 'exact',
    moveThreshold: 0,
    clickThreshold: 0,
    magnetThreshold: 0,
    preventDefaultContextMenu: true,
    preventDefaultBlankAction: true,
    interacting: {
      edgeLabelMovable: false
    },
    guard: function guard() {
      return false;
    }
  };
})(options_Options || (options_Options = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/renderer.js





var renderer_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






var renderer_Renderer = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(Renderer, _Base);

  var _super = Object(createSuper["a" /* default */])(Renderer);

  function Renderer() {
    Object(classCallCheck["a" /* default */])(this, Renderer);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Renderer, [{
    key: "init",
    value: function init() {
      this.resetUpdates();
      this.setup(); // Renders existing cells in the model.

      this.resetViews(this.model.getCells()); // Starts rendering loop.

      if (!this.isFrozen() && this.isAsync()) {
        this.updateViewsAsync();
      }
    }
  }, {
    key: "setup",
    value: function setup() {
      var _this = this;

      var model = this.model;
      model.on('sorted', function () {
        return _this.onSortModel();
      });
      model.on('reseted', function (_ref) {
        var options = _ref.options;
        return _this.onModelReseted(options);
      });
      model.on('batch:stop', function (_ref2) {
        var name = _ref2.name,
            data = _ref2.data;
        return _this.onBatchStop(name, data);
      });
      model.on('cell:added', function (_ref3) {
        var cell = _ref3.cell,
            options = _ref3.options;
        return _this.onCellAdded(cell, options);
      });
      model.on('cell:removed', function (_ref4) {
        var cell = _ref4.cell,
            options = _ref4.options;
        return _this.onCellRemoved(cell, options);
      });
      model.on('cell:change:zIndex', function (_ref5) {
        var cell = _ref5.cell,
            options = _ref5.options;
        return _this.onCellZIndexChanged(cell, options);
      });
      model.on('cell:change:visible', function (_ref6) {
        var cell = _ref6.cell,
            current = _ref6.current,
            options = _ref6.options;

        _this.onCellVisibleChanged(cell, current !== false, options);
      });
    }
  }, {
    key: "resetUpdates",
    value: function resetUpdates() {
      this.updates = {
        priorities: [{}, {}, {}],
        mounted: {},
        mountedCids: [],
        unmounted: {},
        unmountedCids: [],
        count: 0,
        sort: false,
        frozen: false,
        freezeKey: null,
        animationId: null
      };
    }
  }, {
    key: "onSortModel",
    value: function onSortModel() {
      if (this.model.hasActiveBatch(Renderer.SORT_DELAYING_BATCHES)) {
        return;
      }

      this.sortViews();
    }
  }, {
    key: "onModelReseted",
    value: function onModelReseted(options) {
      this.removeZPivots();
      this.resetViews(this.model.getCells(), options);
    }
  }, {
    key: "onCellAdded",
    value: function onCellAdded(cell, options) {
      var position = options.position;

      if (this.isAsync() || typeof position !== 'number') {
        this.renderView(cell, options);
      } else {
        if (options.maxPosition === position) {
          this.freeze({
            key: 'addCells'
          });
        }

        this.renderView(cell, options);

        if (position === 0) {
          this.unfreeze({
            key: 'addCells'
          });
        }
      }
    }
  }, {
    key: "onCellRemoved",
    value: function onCellRemoved(cell, options) {
      var view = this.findViewByCell(cell);

      if (view) {
        this.requestViewUpdate(view, Renderer.FLAG_REMOVE, view.priority, options);
      }
    }
  }, {
    key: "onCellZIndexChanged",
    value: function onCellZIndexChanged(cell, options) {
      if (this.options.sorting === 'approx') {
        var view = this.findViewByCell(cell);

        if (view) {
          this.requestViewUpdate(view, Renderer.FLAG_INSERT, view.priority, options);
        }
      }
    }
  }, {
    key: "onCellVisibleChanged",
    value: function onCellVisibleChanged(cell, visible, options) {
      // Hide connected edges before cell
      if (!visible) {
        this.processEdgeOnTerminalVisibleChanged(cell, false);
      }

      var view = this.findViewByCell(cell);

      if (!visible && view) {
        this.removeView(cell);
      } else if (visible && view == null) {
        this.renderView(cell, options);
      } // Show connected edges after cell rendered


      if (visible) {
        this.processEdgeOnTerminalVisibleChanged(cell, true);
      }
    }
  }, {
    key: "processEdgeOnTerminalVisibleChanged",
    value: function processEdgeOnTerminalVisibleChanged(node, visible) {
      var getOpposite = function getOpposite(edge, currentTerminal) {
        var sourceId = edge.getSourceCellId();

        if (sourceId !== currentTerminal.id) {
          return edge.getSourceCell();
        }

        var targetId = edge.getTargetCellId();

        if (targetId !== currentTerminal.id) {
          return edge.getTargetCell();
        }

        return null;
      };

      this.model.getConnectedEdges(node).forEach(function (edge) {
        var opposite = getOpposite(edge, node);

        if (opposite == null || opposite.isVisible()) {
          visible ? edge.show() : edge.hide();
        }
      });
    }
  }, {
    key: "onBatchStop",
    value: function onBatchStop(name, data) {
      if (this.isFrozen()) {
        return;
      }

      var model = this.model;

      if (!this.isAsync()) {
        // UPDATE_DELAYING_BATCHES: ['translate'],
        var updateDelayingBatches = Renderer.UPDATE_DELAYING_BATCHES;

        if (updateDelayingBatches.includes(name) && !model.hasActiveBatch(updateDelayingBatches)) {
          this.updateViews(data);
        }
      } // SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],


      var sortDelayingBatches = Renderer.SORT_DELAYING_BATCHES;

      if (sortDelayingBatches.includes(name) && !model.hasActiveBatch(sortDelayingBatches)) {
        this.sortViews();
      }
    }
  }, {
    key: "requestConnectedEdgesUpdate",
    value: function requestConnectedEdgesUpdate(view) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (view instanceof cell_CellView) {
        var cell = view.cell;
        var edges = this.model.getConnectedEdges(cell);

        for (var j = 0, n = edges.length; j < n; j += 1) {
          var edge = edges[j];
          var edgeView = this.findViewByCell(edge);

          if (!edgeView) {
            continue;
          }

          var flagLabels = ['update'];

          if (edge.getTargetCell() === cell) {
            flagLabels.push('target');
          }

          if (edge.getSourceCell() === cell) {
            flagLabels.push('source');
          }

          this.scheduleViewUpdate(edgeView, edgeView.getFlag(flagLabels), edgeView.priority, options);
        }
      }
    }
  }, {
    key: "forcePostponedViewUpdate",
    value: function forcePostponedViewUpdate(view, flag) {
      if (!view || !(view instanceof cell_CellView)) {
        return false;
      }

      var cell = view.cell;

      if (cell.isNode()) {
        return false;
      }

      var edgeView = view;

      if (cell.isEdge() && (flag & view.getFlag(['source', 'target'])) === 0) {
        // EdgeView is waiting for the source/target cellView to be rendered.
        // This can happen when the cells are not in the viewport.
        var sourceFlag = 0;
        var sourceView = this.findViewByCell(cell.getSourceCell());

        if (sourceView && !this.isViewMounted(sourceView)) {
          sourceFlag = this.dumpView(sourceView);
          edgeView.updateTerminalMagnet('source');
        }

        var targetFlag = 0;
        var targetView = this.findViewByCell(cell.getTargetCell());

        if (targetView && !this.isViewMounted(targetView)) {
          targetFlag = this.dumpView(targetView);
          edgeView.updateTerminalMagnet('target');
        }

        if (sourceFlag === 0 && targetFlag === 0) {
          // If leftover flag is 0, all view updates were done.
          return !this.dumpView(edgeView);
        }
      }

      return false;
    }
  }, {
    key: "scheduleViewUpdate",
    value: function scheduleViewUpdate(view, flag, priority) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var cid = view.cid;
      var updates = this.updates;
      var cache = updates.priorities[priority];

      if (!cache) {
        cache = updates.priorities[priority] = {};
      }

      var currentFlag = cache[cid] || 0;

      if ((currentFlag & flag) === flag) {
        return;
      }

      if (!currentFlag) {
        updates.count += 1;
      }

      if (flag & Renderer.FLAG_REMOVE && currentFlag & Renderer.FLAG_INSERT) {
        // When a view is removed we need to remove the
        // insert flag as this is a reinsert.
        cache[cid] ^= Renderer.FLAG_INSERT;
      } else if (flag & Renderer.FLAG_INSERT && currentFlag & Renderer.FLAG_REMOVE) {
        // When a view is added we need to remove the remove
        // flag as this is view was previously removed.
        cache[cid] ^= Renderer.FLAG_REMOVE;
      }

      cache[cid] |= flag;
      this.graph.hook.onViewUpdated(view, flag, options);
    }
  }, {
    key: "requestViewUpdate",
    value: function requestViewUpdate(view, flag, priority) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      this.scheduleViewUpdate(view, flag, priority, options);
      var isAsync = this.isAsync();

      if (this.isFrozen() || isAsync && options.async !== false || // UPDATE_DELAYING_BATCHES = ['translate']
      this.model.hasActiveBatch(Renderer.UPDATE_DELAYING_BATCHES)) {
        return;
      }

      var stats = this.updateViews(options);

      if (isAsync) {
        this.graph.trigger('render:done', {
          stats: stats,
          options: options
        });
      }
    }
    /**
     * Adds view into the DOM and update it.
     */

  }, {
    key: "dumpView",
    value: function dumpView(view) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (view == null) {
        return 0;
      }

      var cid = view.cid;
      var updates = this.updates;
      var cache = updates.priorities[view.priority];
      var flag = this.registerMountedView(view) | cache[cid];
      delete cache[cid];

      if (!flag) {
        return 0;
      }

      return this.updateView(view, flag, options);
    }
    /**
     * Adds all views into the DOM and update them.
     */

  }, {
    key: "dumpViews",
    value: function dumpViews() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.checkView(options);
      this.updateViews(options);
    }
    /**
     * Ensure the view associated with the cell is attached
     * to the DOM and updated.
     */

  }, {
    key: "requireView",
    value: function requireView(cell) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var view = this.findViewByCell(cell);

      if (view == null) {
        return null;
      }

      this.dumpView(view, options);
      return view;
    }
  }, {
    key: "updateView",
    value: function updateView(view, flag) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (view == null) {
        return 0;
      }

      if (view instanceof cell_CellView) {
        if (flag & Renderer.FLAG_REMOVE) {
          this.removeView(view.cell);
          return 0;
        }

        if (flag & Renderer.FLAG_INSERT) {
          this.insertView(view);
          flag ^= Renderer.FLAG_INSERT; // tslint:disable-line
        }
      }

      if (!flag) {
        return 0;
      }

      return view.confirmUpdate(flag, options);
    }
  }, {
    key: "updateViews",
    value: function updateViews() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var result;
      var batchCount = 0;
      var updatedCount = 0;
      var priority = Renderer.MIN_PRIORITY;

      do {
        result = this.updateViewsBatch(options);
        batchCount += 1;
        updatedCount += result.updatedCount;
        priority = Math.min(result.priority, priority);
      } while (!result.empty);

      return {
        priority: priority,
        batchCount: batchCount,
        updatedCount: updatedCount
      };
    }
  }, {
    key: "updateViewsBatch",
    value: function updateViewsBatch() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var updates = this.updates;
      var priorities = updates.priorities;
      var batchSize = options.batchSize || Renderer.UPDATE_BATCH_SIZE;
      var empty = true;
      var priority = Renderer.MIN_PRIORITY;
      var mountedCount = 0;
      var unmountedCount = 0;
      var updatedCount = 0;
      var postponedCount = 0;
      var checkView = options.checkView || this.options.checkView;

      if (typeof checkView !== 'function') {
        checkView = null;
      }

      main: for (var p = 0, n = priorities.length; p < n; p += 1) {
        var cache = priorities[p];

        for (var cid in cache) {
          if (updatedCount >= batchSize) {
            empty = false; // goto next batch

            break main;
          }

          var view = view_View.views[cid];

          if (!view) {
            delete cache[cid];
            continue;
          }

          var currentFlag = cache[cid]; // Do not check a view for viewport if we are about to remove the view.

          if ((currentFlag & Renderer.FLAG_REMOVE) === 0) {
            var isUnmounted = (cid in updates.unmounted);

            if (checkView && !main_namespaceObject.call(checkView, this.graph, {
              view: view,
              unmounted: isUnmounted
            })) {
              // Unmount view
              if (!isUnmounted) {
                this.registerUnmountedView(view);
                view.unmount();
              }

              updates.unmounted[cid] |= currentFlag;
              delete cache[cid];
              unmountedCount += 1;
              continue;
            } // Mount view


            if (isUnmounted) {
              currentFlag |= Renderer.FLAG_INSERT;
              mountedCount += 1;
            }

            currentFlag |= this.registerMountedView(view);
          }

          var leftoverFlag = this.updateView(view, currentFlag, options);

          if (leftoverFlag > 0) {
            // update has not finished
            cache[cid] = leftoverFlag;

            if (!this.graph.hook.onViewPostponed(view, leftoverFlag, options) || cache[cid]) {
              postponedCount += 1;
              empty = false;
              continue;
            }
          }

          if (priority > p) {
            priority = p;
          }

          updatedCount += 1;
          delete cache[cid];
        }
      }

      return {
        empty: empty,
        priority: priority,
        mountedCount: mountedCount,
        unmountedCount: unmountedCount,
        updatedCount: updatedCount,
        postponedCount: postponedCount
      };
    }
  }, {
    key: "updateViewsAsync",
    value: function updateViewsAsync() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        processed: 0,
        priority: Renderer.MIN_PRIORITY
      };
      var updates = this.updates;
      var animationId = updates.animationId;

      if (animationId) {
        dom_main_namespaceObject.cancelAnimationFrame(animationId);

        if (data.processed === 0) {
          var beforeFn = options.before;

          if (typeof beforeFn === 'function') {
            main_namespaceObject.call(beforeFn, this.graph, this.graph);
          }
        }

        var stats = this.updateViewsBatch(options);
        var checkout = this.checkViewImpl({
          checkView: options.checkView,
          mountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.mountedCount,
          unmountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.unmountedCount
        });
        var processed = data.processed;
        var total = updates.count;
        var mountedCount = checkout.mountedCount;
        var unmountedCount = checkout.unmountedCount;

        if (stats.updatedCount > 0) {
          // Some updates have been just processed
          processed += stats.updatedCount + stats.unmountedCount;
          data.priority = Math.min(stats.priority, data.priority);

          if (stats.empty && mountedCount === 0) {
            stats.priority = data.priority;
            stats.mountedCount += mountedCount;
            stats.unmountedCount += unmountedCount;
            this.graph.trigger('render:done', {
              stats: stats,
              options: options
            });
            data.processed = 0;
            updates.count = 0;
          } else {
            data.processed = processed;
          }
        } // Progress callback


        var progressFn = options.progress;

        if (total && typeof progressFn === 'function') {
          main_namespaceObject.call(progressFn, this.graph, stats.empty, processed, total);
        } // The current frame could have been canceled in a callback


        if (updates.animationId !== animationId) {
          return;
        }
      }

      updates.animationId = dom_main_namespaceObject.requestAnimationFrame(function () {
        _this2.updateViewsAsync(options, data);
      });
    }
  }, {
    key: "registerMountedView",
    value: function registerMountedView(view) {
      var cid = view.cid;
      var updates = this.updates;

      if (cid in updates.mounted) {
        return 0;
      }

      updates.mounted[cid] = true;
      updates.mountedCids.push(cid);
      var flag = updates.unmounted[cid] || 0;
      delete updates.unmounted[cid];
      return flag;
    }
  }, {
    key: "registerUnmountedView",
    value: function registerUnmountedView(view) {
      var cid = view.cid;
      var updates = this.updates;

      if (cid in updates.unmounted) {
        return 0;
      }

      updates.unmounted[cid] |= Renderer.FLAG_INSERT;
      var flag = updates.unmounted[cid];
      updates.unmountedCids.push(cid);
      delete updates.mounted[cid];
      return flag;
    }
  }, {
    key: "isViewMounted",
    value: function isViewMounted(view) {
      if (view == null) {
        return false;
      }

      var cid = view.cid;
      return cid in this.updates.mounted;
    }
  }, {
    key: "getMountedViews",
    value: function getMountedViews() {
      return Object.keys(this.updates.mounted).map(function (cid) {
        return cell_CellView.views[cid];
      });
    }
  }, {
    key: "getUnmountedViews",
    value: function getUnmountedViews() {
      return Object.keys(this.updates.unmounted).map(function (cid) {
        return cell_CellView.views[cid];
      });
    }
  }, {
    key: "checkMountedViews",
    value: function checkMountedViews(viewportFn, batchSize) {
      var unmountCount = 0;

      if (typeof viewportFn !== 'function') {
        return unmountCount;
      }

      var updates = this.updates;
      var mounted = updates.mounted;
      var mountedCids = updates.mountedCids;
      var size = batchSize == null ? mountedCids.length : Math.min(mountedCids.length, batchSize);

      for (var i = 0; i < size; i += 1) {
        var cid = mountedCids[i];

        if (!(cid in mounted)) {
          continue;
        }

        var view = cell_CellView.views[cid];

        if (view == null) {
          continue;
        }

        var shouldMount = main_namespaceObject.call(viewportFn, this.graph, {
          view: view,
          unmounted: true
        });

        if (shouldMount) {
          // Push at the end of all mounted ids
          mountedCids.push(cid);
          continue;
        }

        unmountCount += 1;
        var flag = this.registerUnmountedView(view);

        if (flag) {
          view.unmount();
        }
      } // Get rid of views, that have been unmounted


      mountedCids.splice(0, size);
      return unmountCount;
    }
  }, {
    key: "checkUnmountedViews",
    value: function checkUnmountedViews(checkView, batchSize) {
      var mountCount = 0;

      if (typeof checkView !== 'function') {
        checkView = null; // tslint:disable-line
      }

      var updates = this.updates;
      var unmounted = updates.unmounted;
      var unmountedCids = updates.unmountedCids;
      var size = batchSize == null ? unmountedCids.length : Math.min(unmountedCids.length, batchSize);

      for (var i = 0; i < size; i += 1) {
        var cid = unmountedCids[i];

        if (!(cid in unmounted)) {
          continue;
        }

        var view = cell_CellView.views[cid];

        if (view == null) {
          continue;
        }

        if (checkView && !main_namespaceObject.call(checkView, this.graph, {
          view: view,
          unmounted: false
        })) {
          unmountedCids.push(cid);
          continue;
        }

        mountCount += 1;
        var flag = this.registerMountedView(view);

        if (flag) {
          this.scheduleViewUpdate(view, flag, view.priority, {
            mounting: true
          });
        }
      } // Get rid of views, that have been mounted


      unmountedCids.splice(0, size);
      return mountCount;
    }
  }, {
    key: "checkViewImpl",
    value: function checkViewImpl() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        mountedBatchSize: Number.MAX_SAFE_INTEGER,
        unmountedBatchSize: Number.MAX_SAFE_INTEGER
      };
      var checkView = options.checkView || this.options.checkView;
      var unmountedCount = this.checkMountedViews(checkView, options.unmountedBatchSize);
      var mountedCount = this.checkUnmountedViews(checkView, // Do not check views, that have been just unmounted
      // and pushed at the end of the cids array
      unmountedCount > 0 ? Math.min(this.updates.unmountedCids.length - unmountedCount, options.mountedBatchSize) : options.mountedBatchSize);
      return {
        mountedCount: mountedCount,
        unmountedCount: unmountedCount
      };
    }
    /**
     * Determine every view in the graph should be attached/detached.
     */

  }, {
    key: "checkView",
    value: function checkView() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.checkViewImpl(options);
    }
  }, {
    key: "isFrozen",
    value: function isFrozen() {
      return !!this.options.frozen;
    }
    /**
     * Freeze the graph then the graph does not automatically re-render upon
     * changes in the graph. This is useful when adding large numbers of cells.
     */

  }, {
    key: "freeze",
    value: function freeze() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var key = options.key;
      var updates = this.updates;
      var frozen = this.options.frozen;
      var freezeKey = updates.freezeKey;

      if (key && key !== freezeKey) {
        if (frozen && freezeKey) {
          // key passed, but the graph is already freezed with another key
          return;
        }

        updates.frozen = frozen;
        updates.freezeKey = key;
      }

      this.options.frozen = true;
      var animationId = updates.animationId;
      updates.animationId = null;

      if (this.isAsync() && animationId != null) {
        dom_main_namespaceObject.cancelAnimationFrame(animationId);
      }

      this.graph.trigger('freeze', {
        key: key
      });
    }
  }, {
    key: "unfreeze",
    value: function unfreeze() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var key = options.key;
      var updates = this.updates;
      var freezeKey = updates.freezeKey; // key passed, but the graph is already freezed with another key

      if (key && freezeKey && key !== freezeKey) {
        return;
      }

      updates.freezeKey = null; // key passed, but the graph is already freezed

      if (key && key === freezeKey && updates.frozen) {
        return;
      }

      var callback = function callback() {
        _this3.options.frozen = updates.frozen = false;

        if (updates.sort) {
          _this3.sortViews();

          updates.sort = false;
        }

        _this3.graph.trigger('unfreeze', {
          key: key
        });
      };

      if (this.isAsync()) {
        this.freeze();
        var onProgress = options.progress;
        this.updateViewsAsync(Object.assign(Object.assign({}, options), {
          progress: function progress(done, process, total) {
            if (onProgress) {
              main_namespaceObject.call(onProgress, _this3.graph, done, process, total);
            } // sort views after async render


            if (done) {
              callback();
            }
          }
        }));
      } else {
        this.updateViews(options);
        callback();
      }
    }
  }, {
    key: "isAsync",
    value: function isAsync() {
      return !!this.options.async;
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.freeze();
      this.removeViews();
    }
  }, {
    key: "resetViews",
    value: function resetViews() {
      var cells = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.resetUpdates();
      this.removeViews();
      this.freeze({
        key: 'reset'
      });

      for (var i = 0, n = cells.length; i < n; i += 1) {
        this.renderView(cells[i], options);
      }

      this.unfreeze({
        key: 'reset'
      });
      this.sortViews();
    }
  }, {
    key: "removeView",
    value: function removeView(cell) {
      var view = this.views[cell.id];

      if (view) {
        var cid = view.cid;
        var updates = this.updates;
        var mounted = updates.mounted;
        var unmounted = updates.unmounted;
        view.remove();
        delete this.views[cell.id];
        delete mounted[cid];
        delete unmounted[cid];
      }

      return view;
    }
  }, {
    key: "removeViews",
    value: function removeViews() {
      var _this4 = this;

      if (this.views) {
        Object.keys(this.views).forEach(function (id) {
          var view = _this4.views[id];

          if (view) {
            _this4.removeView(view.cell);
          }
        });
      }

      this.views = {};
    }
  }, {
    key: "renderView",
    value: function renderView(cell) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var id = cell.id;
      var views = this.views;
      var flag = 0;
      var view = views[id];

      if (view) {
        flag = Renderer.FLAG_INSERT;
      } else {
        var tmp = this.graph.hook.createCellView(cell);

        if (tmp) {
          view = views[cell.id] = tmp;
          view.graph = this.graph;
          flag = this.registerUnmountedView(view) | view.getBootstrapFlag();
        }
      }

      if (view) {
        this.requestViewUpdate(view, flag, view.priority, options);
      }

      return view;
    }
  }, {
    key: "isExactSorting",
    value: function isExactSorting() {
      return this.options.sorting === 'exact';
    }
  }, {
    key: "sortViews",
    value: function sortViews() {
      if (!this.isExactSorting()) {
        return;
      }

      if (this.isFrozen()) {
        // sort views once unfrozen
        this.updates.sort = true;
        return;
      }

      this.sortViewsExact();
    }
  }, {
    key: "sortElements",
    value: function sortElements(elems, comparator) {
      // Highly inspired by the jquery.sortElements plugin by Padolsey.
      // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.
      var placements = elems.map(function (elem) {
        var parentNode = elem.parentNode; // Since the element itself will change position, we have
        // to have some way of storing it's original position in
        // the DOM. The easiest way is to have a 'flag' node:

        var nextSibling = parentNode.insertBefore(document.createTextNode(''), elem.nextSibling);
        return function (targetNode) {
          if (parentNode === targetNode) {
            throw new Error("You can't sort elements if any one is a descendant of another.");
          } // Insert before flag


          parentNode.insertBefore(targetNode, nextSibling); // Remove flag

          parentNode.removeChild(nextSibling);
        };
      });
      elems.sort(comparator).forEach(function (elem, index) {
        return placements[index](elem);
      });
    }
  }, {
    key: "sortViewsExact",
    value: function sortViewsExact() {
      // Run insertion sort algorithm in order to efficiently sort DOM
      // elements according to their associated cell `zIndex` attribute.
      var elems = this.view.$(this.view.stage).children('[data-cell-id]').toArray();
      var model = this.model;
      this.sortElements(elems, function (a, b) {
        var cellA = model.getCell(a.getAttribute('data-cell-id') || '');
        var cellB = model.getCell(b.getAttribute('data-cell-id') || '');
        var z1 = cellA.getZIndex() || 0;
        var z2 = cellB.getZIndex() || 0;
        return z1 === z2 ? 0 : z1 < z2 ? -1 : 1;
      });
    }
  }, {
    key: "addZPivot",
    value: function addZPivot() {
      var zIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.zPivots == null) {
        this.zPivots = {};
      }

      var pivots = this.zPivots;
      var pivot = pivots[zIndex];

      if (pivot) {
        return pivot;
      }

      pivot = pivots[zIndex] = document.createComment("z-index:".concat(zIndex + 1));
      var neighborZ = -Infinity;

      for (var key in pivots) {
        var currentZ = +key;

        if (currentZ < zIndex && currentZ > neighborZ) {
          neighborZ = currentZ;

          if (neighborZ === zIndex - 1) {
            continue;
          }
        }
      }

      var layer = this.view.stage;

      if (neighborZ !== -Infinity) {
        var neighborPivot = pivots[neighborZ];
        layer.insertBefore(pivot, neighborPivot.nextSibling);
      } else {
        layer.insertBefore(pivot, layer.firstChild);
      }

      return pivot;
    }
  }, {
    key: "removeZPivots",
    value: function removeZPivots() {
      var _this5 = this;

      if (this.zPivots) {
        Object.keys(this.zPivots).forEach(function (z) {
          var elem = _this5.zPivots[z];

          if (elem && elem.parentNode) {
            elem.parentNode.removeChild(elem);
          }
        });
      }

      this.zPivots = {};
    }
  }, {
    key: "insertView",
    value: function insertView(view) {
      var stage = this.view.stage;

      switch (this.options.sorting) {
        case 'approx':
          var zIndex = view.cell.getZIndex();
          var pivot = this.addZPivot(zIndex);
          stage.insertBefore(view.container, pivot);
          break;

        case 'exact':
        default:
          stage.appendChild(view.container);
          break;
      }
    }
  }, {
    key: "findViewByCell",
    value: function findViewByCell(cell) {
      if (cell == null) {
        return null;
      }

      var id = cell instanceof cell_Cell ? cell.id : cell;
      return this.views[id];
    }
  }, {
    key: "findViewByElem",
    value: function findViewByElem(elem) {
      if (elem == null) {
        return null;
      }

      var target = typeof elem === 'string' ? this.view.stage.querySelector(elem) : elem instanceof Element ? elem : elem[0];

      if (target) {
        var id = this.view.findAttr('data-cell-id', target);

        if (id) {
          return this.views[id];
        }
      }

      return null;
    }
  }, {
    key: "findViewsFromPoint",
    value: function findViewsFromPoint(p) {
      var _this6 = this;

      var ref = {
        x: p.x,
        y: p.y
      };
      return this.model.getCells().map(function (cell) {
        return _this6.findViewByCell(cell);
      }).filter(function (view) {
        if (view != null) {
          return dom_main_namespaceObject.getBBox(view.container, {
            target: _this6.view.stage
          }).containsPoint(ref);
        }
      });
    }
  }, {
    key: "findViewsInArea",
    value: function findViewsInArea(rect) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var area = rectangle_Rectangle.create(rect);
      return this.model.getNodes().map(function (node) {
        return _this7.findViewByCell(node);
      }).filter(function (view) {
        if (view) {
          var bbox = dom_main_namespaceObject.getBBox(view.container, {
            target: _this7.view.stage
          });
          return options.strict ? area.containsRect(bbox) : area.isIntersectWith(bbox);
        }
      });
    }
  }, {
    key: "dispose",
    value: function dispose() {}
  }]);

  return Renderer;
}(graph_base_Base);

renderer_decorate([graph_base_Base.dispose()], renderer_Renderer.prototype, "dispose", null);

(function (Renderer) {
  Renderer.FLAG_INSERT = 1 << 30;
  Renderer.FLAG_REMOVE = 1 << 29;
  Renderer.MOUNT_BATCH_SIZE = 1000;
  Renderer.UPDATE_BATCH_SIZE = Infinity;
  Renderer.MIN_PRIORITY = 2;
  Renderer.SORT_DELAYING_BATCHES = ['add', 'to-front', 'to-back'];
  Renderer.UPDATE_DELAYING_BATCHES = ['translate'];
})(renderer_Renderer || (renderer_Renderer = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/defs.js





var defs_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};





var defs_DefsManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(DefsManager, _Base);

  var _super = Object(createSuper["a" /* default */])(DefsManager);

  function DefsManager() {
    Object(classCallCheck["a" /* default */])(this, DefsManager);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(DefsManager, [{
    key: "isDefined",
    value: function isDefined(id) {
      return this.svg.getElementById(id) != null;
    }
  }, {
    key: "filter",
    value: function filter(options) {
      var filterId = options.id;
      var name = options.name;

      if (!filterId) {
        filterId = "filter-".concat(name, "-").concat(this.cid, "-").concat(string_namespaceObject.hashcode(JSON.stringify(options)));
      }

      if (!this.isDefined(filterId)) {
        var fn = filter_Filter.registry.get(name);

        if (fn == null) {
          return filter_Filter.registry.onNotFound(name);
        }

        var markup = fn(options.args || {}); // Set the filter area to be 3x the bounding box of the cell
        // and center the filter around the cell.

        var attrs = Object.assign(Object.assign({
          x: -1,
          y: -1,
          width: 3,
          height: 3,
          filterUnits: 'objectBoundingBox'
        }, options.attrs), {
          id: filterId
        });
        dom_main_namespaceObject.createVector(markup_Markup.sanitize(markup), attrs).appendTo(this.elem);
      }

      return filterId;
    }
  }, {
    key: "gradient",
    value: function gradient(options) {
      var id = options.id;
      var type = options.type;

      if (!id) {
        id = "gradient-".concat(type, "-").concat(this.cid, "-").concat(string_namespaceObject.hashcode(JSON.stringify(options)));
      }

      if (!this.isDefined(id)) {
        var stops = options.stops;
        var arr = stops.map(function (stop) {
          var opacity = stop.opacity != null && Number.isFinite(stop.opacity) ? stop.opacity : 1;
          return "<stop offset=\"".concat(stop.offset, "\" stop-color=\"").concat(stop.color, "\" stop-opacity=\"").concat(opacity, "\"/>");
        });
        var markup = "<".concat(type, ">").concat(arr.join(''), "</").concat(type, ">");
        var attrs = Object.assign({
          id: id
        }, options.attrs);
        dom_main_namespaceObject.createVector(markup, attrs).appendTo(this.elem);
      }

      return id;
    }
  }, {
    key: "marker",
    value: function marker(options) {
      var _this = this;

      var id = options.id,
          tagName = options.tagName,
          markerUnits = options.markerUnits,
          children = options.children,
          attrs = defs_rest(options, ["id", "tagName", "markerUnits", "children"]);

      var markerId = id;

      if (!markerId) {
        markerId = "marker-".concat(this.cid, "-").concat(string_namespaceObject.hashcode(JSON.stringify(options)));
      }

      if (!this.isDefined(markerId)) {
        if (tagName !== 'path') {
          // remove unnecessary d attribute inherit from standard edge.
          delete attrs.d;
        }

        var pathMarker = dom_main_namespaceObject.createVector('marker', {
          id: markerId,
          orient: 'auto',
          overflow: 'visible',
          markerUnits: markerUnits || 'userSpaceOnUse'
        }, children ? children.map(function (_a) {
          var tagName = _a.tagName,
              other = defs_rest(_a, ["tagName"]);

          return dom_main_namespaceObject.createVector("".concat(tagName) || 'path', _this.normalizeAttrs(Object.assign(Object.assign({}, attrs), other)));
        }) : [dom_main_namespaceObject.createVector(tagName || 'path', this.normalizeAttrs(attrs))]);
        this.elem.appendChild(pathMarker.node);
      }

      return markerId;
    }
  }, {
    key: "normalizeAttrs",
    value: function normalizeAttrs(attrs) {
      var result = {};
      Object.keys(attrs).forEach(function (key) {
        // xlink:href
        if (key.indexOf(':') > 0) {
          result[key] = attrs[key];
        } else {
          result[string_namespaceObject.kebabCase(key)] = attrs[key];
        }
      });
      return result;
    }
  }, {
    key: "cid",
    get: function get() {
      return this.graph.view.cid;
    }
  }, {
    key: "svg",
    get: function get() {
      return this.view.svg;
    }
  }, {
    key: "elem",
    get: function get() {
      return this.view.defs;
    }
  }]);

  return DefsManager;
}(graph_base_Base);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/grid.js





var grid_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var grid_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




var grid_GridManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(GridManager, _Base);

  var _super = Object(createSuper["a" /* default */])(GridManager);

  function GridManager() {
    Object(classCallCheck["a" /* default */])(this, GridManager);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(GridManager, [{
    key: "init",
    value: function init() {
      this.graph.on('scale', this.update, this);
      this.graph.on('translate', this.update, this);
      this.draw(this.grid);
    }
  }, {
    key: "setVisible",
    value: function setVisible(visible) {
      if (this.grid.visible !== visible) {
        this.grid.visible = visible;
        this.update();
      }
    }
  }, {
    key: "getGridSize",
    value: function getGridSize() {
      return this.grid.size;
    }
  }, {
    key: "setGridSize",
    value: function setGridSize(size) {
      this.grid.size = Math.max(size, 1);
      this.update();
    }
  }, {
    key: "show",
    value: function show() {
      this.setVisible(true);
      this.update();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.setVisible(false);
      this.update();
    }
  }, {
    key: "clear",
    value: function clear() {
      this.elem.style.backgroundImage = '';
    }
  }, {
    key: "draw",
    value: function draw(options) {
      this.clear();
      this.instance = null;
      this.patterns = this.resolveGrid(options);
      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var gridSize = this.grid.size;

      if (gridSize <= 1 || !this.grid.visible) {
        return this.clear();
      }

      var ctm = this.graph.matrix();
      var grid = this.getInstance();
      var items = Array.isArray(options) ? options : [options];
      this.patterns.forEach(function (settings, index) {
        var id = "pattern_".concat(index);
        var sx = ctm.a || 1;
        var sy = ctm.d || 1;

        var update = settings.update,
            markup = settings.markup,
            others = grid_rest(settings, ["update", "markup"]);

        var options = Object.assign(Object.assign(Object.assign({}, others), items[index]), {
          sx: sx,
          sy: sy,
          ox: ctm.e || 0,
          oy: ctm.f || 0,
          width: gridSize * sx,
          height: gridSize * sy
        });

        if (!grid.has(id)) {
          grid.add(id, dom_main_namespaceObject.createVector('pattern', {
            id: id,
            patternUnits: 'userSpaceOnUse'
          }, dom_main_namespaceObject.createVectors(markup)).node);
        }

        var patternElem = grid.get(id);

        if (typeof update === 'function') {
          update(patternElem.childNodes[0], options);
        }

        var x = options.ox % options.width;

        if (x < 0) {
          x += options.width;
        }

        var y = options.oy % options.height;

        if (y < 0) {
          y += options.height;
        }

        dom_main_namespaceObject.attr(patternElem, {
          x: x,
          y: y,
          width: options.width,
          height: options.height
        });
      });
      var base64 = new XMLSerializer().serializeToString(grid.root);
      var url = "url(data:image/svg+xml;base64,".concat(btoa(base64), ")");
      this.elem.style.backgroundImage = url;
    }
  }, {
    key: "getInstance",
    value: function getInstance() {
      if (!this.instance) {
        this.instance = new grid_Grid();
      }

      return this.instance;
    }
  }, {
    key: "resolveGrid",
    value: function resolveGrid(options) {
      if (!options) {
        return [];
      }

      var type = options.type;

      if (type == null) {
        return [Object.assign(Object.assign({}, grid_Grid.presets.dot), options.args)];
      }

      var items = grid_Grid.registry.get(type);

      if (items) {
        var args = options.args || [];

        if (!Array.isArray(args)) {
          args = [args];
        }

        return Array.isArray(items) ? items.map(function (item, index) {
          return Object.assign(Object.assign({}, item), args[index]);
        }) : [Object.assign(Object.assign({}, items), args[0])];
      }

      return grid_Grid.registry.onNotFound(type);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.graph.off('scale', this.update, this);
      this.graph.off('translate', this.update, this);
    }
  }, {
    key: "elem",
    get: function get() {
      return this.view.grid;
    }
  }, {
    key: "grid",
    get: function get() {
      return this.options.grid;
    }
  }]);

  return GridManager;
}(graph_base_Base);

grid_decorate([graph_base_Base.dispose()], grid_GridManager.prototype, "dispose", null);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/coord.js







var coord_CoordManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(CoordManager, _Base);

  var _super = Object(createSuper["a" /* default */])(CoordManager);

  function CoordManager() {
    Object(classCallCheck["a" /* default */])(this, CoordManager);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(CoordManager, [{
    key: "getClientMatrix",
    value: function getClientMatrix() {
      return dom_main_namespaceObject.createSVGMatrix(this.view.stage.getScreenCTM());
    }
    /**
     * Returns coordinates of the graph viewport, relative to the window.
     */

  }, {
    key: "getClientOffset",
    value: function getClientOffset() {
      // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
      var rect = this.view.svg.getBoundingClientRect();
      return new point_Point(rect.left, rect.top);
    }
    /**
     * Returns coordinates of the graph viewport, relative to the document.
     */

  }, {
    key: "getPageOffset",
    value: function getPageOffset() {
      // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
      return this.getClientOffset().translate(window.scrollX, window.scrollY);
    }
  }, {
    key: "snapToGrid",
    value: function snapToGrid(x, y) {
      var p = typeof x === 'number' ? this.clientToLocalPoint(x, y) : this.clientToLocalPoint(x.x, x.y);
      return p.snapToGrid(this.graph.getGridSize());
    }
  }, {
    key: "localToGraphPoint",
    value: function localToGraphPoint(x, y) {
      var localPoint = point_Point.create(x, y);
      return dom_main_namespaceObject.transformPoint(localPoint, this.graph.matrix());
    }
  }, {
    key: "localToClientPoint",
    value: function localToClientPoint(x, y) {
      var localPoint = point_Point.create(x, y);
      return dom_main_namespaceObject.transformPoint(localPoint, this.getClientMatrix());
    }
  }, {
    key: "localToPagePoint",
    value: function localToPagePoint(x, y) {
      var p = typeof x === 'number' ? this.localToGraphPoint(x, y) : this.localToGraphPoint(x);
      return p.translate(this.getPageOffset());
    }
  }, {
    key: "localToGraphRect",
    value: function localToGraphRect(x, y, width, height) {
      var localRect = rectangle_Rectangle.create(x, y, width, height);
      return dom_main_namespaceObject.transformRectangle(localRect, this.graph.matrix());
    }
  }, {
    key: "localToClientRect",
    value: function localToClientRect(x, y, width, height) {
      var localRect = rectangle_Rectangle.create(x, y, width, height);
      var clientRect = dom_main_namespaceObject.transformRectangle(localRect, this.getClientMatrix());
      return clientRect;
    }
  }, {
    key: "localToPageRect",
    value: function localToPageRect(x, y, width, height) {
      var rect = typeof x === 'number' ? this.localToGraphRect(x, y, width, height) : this.localToGraphRect(x);
      return rect.translate(this.getPageOffset());
    }
  }, {
    key: "graphToLocalPoint",
    value: function graphToLocalPoint(x, y) {
      var graphPoint = point_Point.create(x, y);
      return dom_main_namespaceObject.transformPoint(graphPoint, this.graph.matrix().inverse());
    }
  }, {
    key: "clientToLocalPoint",
    value: function clientToLocalPoint(x, y) {
      var clientPoint = point_Point.create(x, y);
      return dom_main_namespaceObject.transformPoint(clientPoint, this.getClientMatrix().inverse());
    }
  }, {
    key: "pageToLocalPoint",
    value: function pageToLocalPoint(x, y) {
      var pagePoint = point_Point.create(x, y);
      var graphPoint = pagePoint.diff(this.getPageOffset());
      return this.graphToLocalPoint(graphPoint);
    }
  }, {
    key: "graphToLocalRect",
    value: function graphToLocalRect(x, y, width, height) {
      var graphRect = rectangle_Rectangle.create(x, y, width, height);
      return dom_main_namespaceObject.transformRectangle(graphRect, this.graph.matrix().inverse());
    }
  }, {
    key: "clientToLocalRect",
    value: function clientToLocalRect(x, y, width, height) {
      var clientRect = rectangle_Rectangle.create(x, y, width, height);
      return dom_main_namespaceObject.transformRectangle(clientRect, this.getClientMatrix().inverse());
    }
  }, {
    key: "pageToLocalRect",
    value: function pageToLocalRect(x, y, width, height) {
      var graphRect = rectangle_Rectangle.create(x, y, width, height);
      var pageOffset = this.getPageOffset();
      graphRect.x -= pageOffset.x;
      graphRect.y -= pageOffset.y;
      return this.graphToLocalRect(graphRect);
    }
  }]);

  return CoordManager;
}(graph_base_Base);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/snapline.js




var snapline_SnaplineManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(SnaplineManager, _Base);

  var _super = Object(createSuper["a" /* default */])(SnaplineManager);

  function SnaplineManager() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, SnaplineManager);

    _this = _super.apply(this, arguments);
    _this.widget = _this.graph.hook.createSnapline();
    return _this;
  }

  return SnaplineManager;
}(graph_base_Base);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/types/common.js

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/types/modifier.js

var modifier_ModifierKey;

(function (ModifierKey) {
  function parse(modifiers) {
    var or = [];
    var and = [];

    if (Array.isArray(modifiers)) {
      or.push.apply(or, Object(toConsumableArray["a" /* default */])(modifiers));
    } else {
      modifiers.split('|').forEach(function (item) {
        if (item.indexOf('&') === -1) {
          or.push(item);
        } else {
          and.push.apply(and, Object(toConsumableArray["a" /* default */])(item.split('&')));
        }
      });
    }

    return {
      or: or,
      and: and
    };
  }

  ModifierKey.parse = parse;

  function equals(modifiers1, modifiers2) {
    if (modifiers1 != null && modifiers2 != null) {
      var m1 = parse(modifiers1);
      var m2 = parse(modifiers2);
      var or1 = m1.or.sort();
      var or2 = m2.or.sort();
      var and1 = m1.and.sort();
      var and2 = m2.and.sort();

      var equal = function equal(a1, a2) {
        return a1.length === a2.length && (a1.length === 0 || a1.every(function (a, i) {
          return a === a2[i];
        }));
      };

      return equal(or1, or2) && equal(and1, and2);
    }

    if (modifiers1 == null && modifiers2 == null) {
      return true;
    }

    return false;
  }

  ModifierKey.equals = equals;

  function test(e, modifiers) {
    if (modifiers == null) {
      return true;
    }

    var _parse = parse(modifiers),
        or = _parse.or,
        and = _parse.and;

    return or.some(function (key) {
      return e["".concat(key.toLowerCase(), "Key")];
    }) && and.every(function (key) {
      return e["".concat(key.toLowerCase(), "Key")];
    });
  }

  ModifierKey.test = test;
})(modifier_ModifierKey || (modifier_ModifierKey = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/types/index.js


// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/scroller.js






var scroller_ScrollerManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(ScrollerManager, _Base);

  var _super = Object(createSuper["a" /* default */])(ScrollerManager);

  function ScrollerManager() {
    Object(classCallCheck["a" /* default */])(this, ScrollerManager);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ScrollerManager, [{
    key: "init",
    value: function init() {
      this.widget = this.graph.hook.createScroller();
      this.autoSetCursor();
      this.graph.on('blank:mousedown', this.preparePanning, this);
      this.graph.on('node:unhandled:mousedown', this.preparePanning, this);
      this.graph.on('edge:unhandled:mousedown', this.preparePanning, this);

      if (this.widget) {
        this.widget.center();
      }
    }
  }, {
    key: "preparePanning",
    value: function preparePanning(_ref) {
      var e = _ref.e;

      if (this.widget && this.pannable && modifier_ModifierKey.test(e, this.widgetOptions.modifiers) && this.graph.hook.allowPanning(e)) {
        this.widget.startPanning(e);
      }
    }
  }, {
    key: "autoSetCursor",
    value: function autoSetCursor() {
      var _a;

      var options = this.widgetOptions;

      if (options.cursor == null) {
        var cursor = options.pannable ? 'grab' : '';
        (_a = this.widget) === null || _a === void 0 ? void 0 : _a.setCursor(cursor, {
          silent: true
        });
      }
    }
  }, {
    key: "enablePanning",
    value: function enablePanning() {
      if (!this.pannable) {
        this.widgetOptions.pannable = true;

        if (modifier_ModifierKey.equals(this.graph.options.scroller.modifiers, this.graph.options.selecting.modifiers)) {
          this.graph.selection.disableRubberband();
        }
      }

      this.autoSetCursor();
    }
  }, {
    key: "disablePanning",
    value: function disablePanning() {
      if (this.pannable) {
        this.widgetOptions.pannable = false;
      }

      this.autoSetCursor();
    }
  }, {
    key: "lock",
    value: function lock() {
      if (this.widget) {
        this.widget.lock();
      }
    }
  }, {
    key: "unlock",
    value: function unlock() {
      if (this.widget) {
        this.widget.unlock();
      }
    }
  }, {
    key: "update",
    value: function update() {
      if (this.widget) {
        this.widget.update();
      }
    }
  }, {
    key: "setCursor",
    value: function setCursor(cursor) {
      if (this.widget) {
        this.widget.setCursor(cursor);
      }
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      if (this.widget) {
        this.widget.resize(width, height);
      }
    }
  }, {
    key: "widgetOptions",
    get: function get() {
      return this.options.scroller;
    }
  }, {
    key: "pannable",
    get: function get() {
      return this.widgetOptions && this.widgetOptions.pannable === true;
    }
  }]);

  return ScrollerManager;
}(graph_base_Base);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/clipboard.js





var clipboard_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var clipboard_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};


var clipboard_ClipboardManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(ClipboardManager, _Base);

  var _super = Object(createSuper["a" /* default */])(ClipboardManager);

  function ClipboardManager() {
    Object(classCallCheck["a" /* default */])(this, ClipboardManager);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ClipboardManager, [{
    key: "init",
    value: function init() {
      this.widget = this.graph.hook.createClipboard();
      this.widget.deserialize(this.instanceOptions);
    }
  }, {
    key: "enable",
    value: function enable() {
      if (this.disabled) {
        this.instanceOptions.enabled = true;
      }
    }
  }, {
    key: "disable",
    value: function disable() {
      if (!this.disabled) {
        this.instanceOptions.enabled = false;
      }
    }
  }, {
    key: "copy",
    value: function copy(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this.disabled) {
        this.widget.copy(cells, this.graph, Object.assign(Object.assign({}, this.commonOptions), options));
      }
    }
  }, {
    key: "cut",
    value: function cut(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this.disabled) {
        this.widget.cut(cells, this.graph, Object.assign(Object.assign({}, this.commonOptions), options));
      }
    }
  }, {
    key: "paste",
    value: function paste() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var graph = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.graph;

      if (!this.disabled) {
        return this.widget.paste(graph, Object.assign(Object.assign({}, this.commonOptions), options));
      }

      return [];
    }
  }, {
    key: "clean",
    value: function clean() {
      if (!this.disabled) {
        this.widget.clean();
      }
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.widget.isEmpty();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.clean();
    }
  }, {
    key: "commonOptions",
    get: function get() {
      var _a = this.instanceOptions,
          enabled = _a.enabled,
          others = clipboard_rest(_a, ["enabled"]);

      return others;
    }
  }, {
    key: "instanceOptions",
    get: function get() {
      return this.options.clipboard;
    }
  }, {
    key: "cells",
    get: function get() {
      return this.widget.cells;
    }
  }, {
    key: "disabled",
    get: function get() {
      return this.instanceOptions.enabled !== true;
    }
  }]);

  return ClipboardManager;
}(graph_base_Base);

clipboard_decorate([graph_base_Base.dispose()], clipboard_ClipboardManager.prototype, "dispose", null);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/highlight.js







var highlight_HighlightManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(HighlightManager, _Base);

  var _super = Object(createSuper["a" /* default */])(HighlightManager);

  function HighlightManager() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, HighlightManager);

    _this = _super.apply(this, arguments);
    _this.highlights = {};
    return _this;
  }

  Object(createClass["a" /* default */])(HighlightManager, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      this.graph.on('cell:highlight', function (_ref) {
        var view = _ref.view,
            magnet = _ref.magnet,
            options = _ref.options;
        return _this2.onCellHighlight(view, magnet, options);
      });
      this.graph.on('cell:unhighlight', function (_ref2) {
        var view = _ref2.view,
            magnet = _ref2.magnet,
            options = _ref2.options;
        return _this2.onCellUnhighlight(view, magnet, options);
      });
    }
  }, {
    key: "onCellHighlight",
    value: function onCellHighlight(cellView, magnet) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var resolved = this.resolveHighlighter(options);

      if (!resolved) {
        return;
      }

      var key = this.getHighlighterId(magnet, resolved);

      if (!this.highlights[key]) {
        var highlighter = resolved.highlighter;
        highlighter.highlight(cellView, magnet, Object.assign({}, resolved.args));
        this.highlights[key] = {
          cellView: cellView,
          magnet: magnet,
          highlighter: highlighter,
          args: resolved.args
        };
      }
    }
  }, {
    key: "onCellUnhighlight",
    value: function onCellUnhighlight(cellView, magnet) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var resolved = this.resolveHighlighter(options);

      if (!resolved) {
        return;
      }

      var key = this.getHighlighterId(magnet, resolved);
      var highlight = this.highlights[key];

      if (highlight) {
        // Use the cellView and magnetEl that were used by the highlighter.highlight() method.
        highlight.highlighter.unhighlight(highlight.cellView, highlight.magnet, highlight.args);
        delete this.highlights[key];
      }
    }
  }, {
    key: "resolveHighlighter",
    value: function resolveHighlighter(options) {
      var graphOptions = this.options;
      var highlighterDef = options.highlighter;

      if (highlighterDef == null) {
        // check for built-in types
        var type = options.type;
        highlighterDef = type && graphOptions.highlighting[type] || graphOptions.highlighting.default;
      }

      if (highlighterDef == null) {
        return null;
      }

      var def = typeof highlighterDef === 'string' ? {
        name: highlighterDef
      } : highlighterDef;
      var name = def.name;
      var highlighter = highlighter_Highlighter.registry.get(name);

      if (highlighter == null) {
        return highlighter_Highlighter.registry.onNotFound(name);
      }

      highlighter_Highlighter.check(name, highlighter);
      return {
        name: name,
        highlighter: highlighter,
        args: def.args || {}
      };
    }
  }, {
    key: "getHighlighterId",
    value: function getHighlighterId(magnet, options) {
      dom_main_namespaceObject.ensureId(magnet);
      return options.name + magnet.id + JSON.stringify(options.args);
    }
  }]);

  return HighlightManager;
}(graph_base_Base);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/transform.js







var transform_TransformManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(TransformManager, _Base);

  var _super = Object(createSuper["a" /* default */])(TransformManager);

  function TransformManager() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, TransformManager);

    _this = _super.apply(this, arguments);
    _this.widgets = new WeakMap();
    return _this;
  }

  Object(createClass["a" /* default */])(TransformManager, [{
    key: "init",
    value: function init() {
      this.setup();
      this.resize();
    }
  }, {
    key: "setup",
    value: function setup() {
      var _this2 = this;

      this.graph.on('node:mouseup', function (_ref) {
        var node = _ref.node;

        if (!_this2.isSelectionEnabled) {
          var widget = _this2.graph.hook.createTransform(node, {
            clearAll: true
          });

          if (widget) {
            _this2.widgets.set(node, widget);
          }
        }
      });
      this.graph.on('node:selected', function (_ref2) {
        var node = _ref2.node;

        if (_this2.isSelectionEnabled) {
          var widget = _this2.graph.hook.createTransform(node, {
            clearAll: false
          });

          if (widget) {
            _this2.widgets.set(node, widget);
          }
        }
      });
      this.graph.on('node:unselected', function (_ref3) {
        var node = _ref3.node;

        if (_this2.isSelectionEnabled) {
          var widget = _this2.widgets.get(node);

          if (widget) {
            widget.dispose();
          }

          _this2.widgets.delete(node);
        }
      });
    }
    /**
     * Returns the current transformation matrix of the graph.
     */

  }, {
    key: "getMatrix",
    value: function getMatrix() {
      var transform = this.viewport.getAttribute('transform');

      if (transform !== this.viewportTransformString) {
        // `getCTM`: top-left relative to the SVG element
        // `getScreenCTM`: top-left relative to the document
        this.viewportMatrix = this.viewport.getCTM();
        this.viewportTransformString = transform;
      } // Clone the cached current transformation matrix.
      // If no matrix previously stored the identity matrix is returned.


      return dom_main_namespaceObject.createSVGMatrix(this.viewportMatrix);
    }
    /**
     * Sets new transformation with the given `matrix`
     */

  }, {
    key: "setMatrix",
    value: function setMatrix(matrix) {
      var ctm = dom_main_namespaceObject.createSVGMatrix(matrix);
      var transform = dom_main_namespaceObject.matrixToTransformString(ctm);
      this.viewport.setAttribute('transform', transform);
      this.viewportMatrix = ctm;
      this.viewportTransformString = transform;
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      var options = this.options;
      var w = width === undefined ? options.width : width;
      var h = height === undefined ? options.height : height;
      options.width = w;
      options.height = h;

      if (typeof w === 'number') {
        w = Math.round(w);
      }

      if (typeof h === 'number') {
        h = Math.round(h);
      }

      this.container.style.width = w == null ? '' : "".concat(w, "px");
      this.container.style.height = h == null ? '' : "".concat(h, "px");
      var size = this.getComputedSize();
      this.graph.trigger('resize', Object.assign({}, size));
    }
  }, {
    key: "getComputedSize",
    value: function getComputedSize() {
      var options = this.options;
      var w = options.width;
      var h = options.height;

      if (!number_namespaceObject.isNumber(w)) {
        w = this.container.clientWidth;
      }

      if (!number_namespaceObject.isNumber(h)) {
        h = this.container.clientHeight;
      }

      return {
        width: w,
        height: h
      };
    }
  }, {
    key: "getScale",
    value: function getScale() {
      return dom_main_namespaceObject.matrixToScale(this.getMatrix());
    }
  }, {
    key: "scale",
    value: function scale(sx) {
      var sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sx;
      var ox = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var oy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      sx = this.clampScale(sx); // tslint:disable-line

      sy = this.clampScale(sy); // tslint:disable-line

      if (ox || oy) {
        var ts = this.getTranslation();
        var tx = ts.tx - ox * (sx - 1);
        var ty = ts.ty - oy * (sy - 1);

        if (tx !== ts.tx || ty !== ts.ty) {
          this.translate(tx, ty);
        }
      }

      var matrix = this.getMatrix();
      matrix.a = sx;
      matrix.d = sy;
      this.setMatrix(matrix);
      this.graph.trigger('scale', {
        sx: sx,
        sy: sy,
        ox: ox,
        oy: oy
      });
      return this;
    }
  }, {
    key: "clampScale",
    value: function clampScale(scale) {
      var range = this.graph.options.scaling;
      return number_namespaceObject.clamp(scale, range.min || 0.01, range.max || 16);
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      return dom_main_namespaceObject.matrixToRotation(this.getMatrix());
    }
  }, {
    key: "rotate",
    value: function rotate(angle, cx, cy) {
      if (cx == null || cy == null) {
        var bbox = dom_main_namespaceObject.getBBox(this.graph.view.stage);
        cx = bbox.width / 2; // tslint:disable-line

        cy = bbox.height / 2; // tslint:disable-line
      }

      var ctm = this.getMatrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);
      this.setMatrix(ctm);
      return this;
    }
  }, {
    key: "getTranslation",
    value: function getTranslation() {
      return dom_main_namespaceObject.matrixToTranslation(this.getMatrix());
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      var matrix = this.getMatrix();
      matrix.e = tx || 0;
      matrix.f = ty || 0;
      this.setMatrix(matrix);
      var ts = this.getTranslation();
      var origin = this.options;
      origin.x = ts.tx;
      origin.y = ts.ty;
      this.graph.trigger('translate', Object.assign({}, ts));
      return this;
    }
  }, {
    key: "setOrigin",
    value: function setOrigin(ox, oy) {
      return this.translate(ox || 0, oy || 0);
    }
  }, {
    key: "fitToContent",
    value: function fitToContent(gridWidth, gridHeight, padding, options) {
      if (typeof gridWidth === 'object') {
        var opts = gridWidth;
        gridWidth = opts.gridWidth || 1; // tslint:disable-line

        gridHeight = opts.gridHeight || 1; // tslint:disable-line

        padding = opts.padding || 0; // tslint:disable-line

        options = opts; // tslint:disable-line
      } else {
        gridWidth = gridWidth || 1; // tslint:disable-line

        gridHeight = gridHeight || 1; // tslint:disable-line

        padding = padding || 0; // tslint:disable-line

        if (options == null) {
          options = {}; // tslint:disable-line
        }
      }

      var paddingValues = number_namespaceObject.normalizeSides(padding);
      var area = options.contentArea ? rectangle_Rectangle.create(options.contentArea) : this.getContentArea(options);
      var scale = this.getScale();
      var translate = this.getTranslation();
      var sx = scale.sx;
      var sy = scale.sy;
      area.x *= sx;
      area.y *= sy;
      area.width *= sx;
      area.height *= sy;
      var width = Math.max(Math.ceil((area.width + area.x) / gridWidth), 1) * gridWidth;
      var height = Math.max(Math.ceil((area.height + area.y) / gridHeight), 1) * gridHeight;
      var tx = 0;
      var ty = 0;

      if (options.allowNewOrigin === 'negative' && area.x < 0 || options.allowNewOrigin === 'positive' && area.x >= 0 || options.allowNewOrigin === 'any') {
        tx = Math.ceil(-area.x / gridWidth) * gridWidth;
        tx += paddingValues.left;
        width += tx;
      }

      if (options.allowNewOrigin === 'negative' && area.y < 0 || options.allowNewOrigin === 'positive' && area.y >= 0 || options.allowNewOrigin === 'any') {
        ty = Math.ceil(-area.y / gridHeight) * gridHeight;
        ty += paddingValues.top;
        height += ty;
      }

      width += paddingValues.right;
      height += paddingValues.bottom; // Make sure the resulting width and height are greater than minimum.

      width = Math.max(width, options.minWidth || 0);
      height = Math.max(height, options.minHeight || 0); // Make sure the resulting width and height are lesser than maximum.

      width = Math.min(width, options.maxWidth || Number.MAX_SAFE_INTEGER);
      height = Math.min(height, options.maxHeight || Number.MAX_SAFE_INTEGER);
      var size = this.getComputedSize();
      var sizeChanged = width !== size.width || height !== size.height;
      var originChanged = tx !== translate.tx || ty !== translate.ty; // Change the dimensions only if there is a size discrepency or an origin change

      if (originChanged) {
        this.translate(tx, ty);
      }

      if (sizeChanged) {
        this.resize(width, height);
      }

      return new rectangle_Rectangle(-tx / sx, -ty / sy, width / sx, height / sy);
    }
  }, {
    key: "scaleContentToFit",
    value: function scaleContentToFit() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var contentBBox; // let contentLocalOrigin

      if (options.contentArea) {
        var contentArea = options.contentArea;
        contentBBox = this.graph.localToGraphRect(contentArea); // contentLocalOrigin = Point.create(contentArea)
      } else {
        contentBBox = this.getContentBBox(options); // contentLocalOrigin = this.graph.graphToLocalPoint(contentBBox)
      }

      if (!contentBBox.width || !contentBBox.height) {
        return;
      }

      var padding = options.padding || 0;
      var minScale = options.minScale || 0;
      var maxScale = options.maxScale || Number.MAX_SAFE_INTEGER;
      var minScaleX = options.minScaleX || minScale;
      var maxScaleX = options.maxScaleX || maxScale;
      var minScaleY = options.minScaleY || minScale;
      var maxScaleY = options.maxScaleY || maxScale;
      var fittingBBox;

      if (options.fittingBBox) {
        fittingBBox = options.fittingBBox;
      } else {
        var computedSize = this.getComputedSize();
        var currentTranslate = this.getTranslation();
        fittingBBox = {
          x: currentTranslate.tx,
          y: currentTranslate.ty,
          width: computedSize.width,
          height: computedSize.height
        };
      }

      fittingBBox = rectangle_Rectangle.create(fittingBBox).inflate(-padding);
      var currentScale = this.getScale();
      var newSx = fittingBBox.width / contentBBox.width * currentScale.sx;
      var newSy = fittingBBox.height / contentBBox.height * currentScale.sy;

      if (options.preserveAspectRatio !== false) {
        newSx = newSy = Math.min(newSx, newSy);
      } // snap scale to a grid


      var gridSize = options.scaleGrid;

      if (gridSize) {
        newSx = gridSize * Math.floor(newSx / gridSize);
        newSy = gridSize * Math.floor(newSy / gridSize);
      } // scale min/max boundaries


      newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));
      newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy)); // const origin = this.options
      // const newOX = fittingBBox.x - contentLocalOrigin.x * newSx - origin.x
      // const newOY = fittingBBox.y - contentLocalOrigin.y * newSy - origin.y

      this.scale(newSx, newSy); // this.translate(newOX, newOY)
    }
  }, {
    key: "getContentArea",
    value: function getContentArea() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.useCellGeometry) {
        return this.model.getAllCellsBBox() || new rectangle_Rectangle();
      }

      return dom_main_namespaceObject.getBBox(this.graph.view.stage);
    }
  }, {
    key: "getContentBBox",
    value: function getContentBBox() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.graph.localToGraphRect(this.getContentArea(options));
    }
  }, {
    key: "getArea",
    value: function getArea() {
      var rect = rectangle_Rectangle.fromSize(this.getComputedSize());
      return this.graph.graphToLocalRect(rect);
    }
  }, {
    key: "getRestrictArea",
    value: function getRestrictArea(view) {
      var restrict = this.options.translating.restrict;
      var area;

      if (typeof restrict === 'function') {
        area = main_namespaceObject.call(restrict, this.graph, view);
      } else if (restrict === true) {
        area = this.getArea();
      } else {
        area = restrict || null;
      }

      return area;
    }
  }, {
    key: "container",
    get: function get() {
      return this.graph.view.container;
    }
  }, {
    key: "viewport",
    get: function get() {
      return this.graph.view.viewport;
    }
  }, {
    key: "isSelectionEnabled",
    get: function get() {
      return this.options.selecting.enabled === true;
    }
  }]);

  return TransformManager;
}(graph_base_Base);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/selection.js







var selection_SelectionManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(SelectionManager, _Base);

  var _super = Object(createSuper["a" /* default */])(SelectionManager);

  function SelectionManager() {
    Object(classCallCheck["a" /* default */])(this, SelectionManager);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(SelectionManager, [{
    key: "init",
    value: function init() {
      var _this = this;

      this.widget = this.graph.hook.createSelection();
      this.graph.on('blank:mousedown', function (_ref) {
        var e = _ref.e;

        if (!_this.rubberbandDisabled && modifier_ModifierKey.test(e, _this.widgetOptions.modifiers) && _this.graph.hook.allowRubberband(e)) {
          _this.startRubberband(e);
        } else {
          _this.clean();
        }
      });
      var movedDic = new dictionary_Dictionary();
      this.graph.on('cell:mousemove', function (_ref2) {
        var cell = _ref2.cell;
        movedDic.set(cell, true);
      });
      this.graph.on('cell:mouseup', function (_ref3) {
        var e = _ref3.e,
            cell = _ref3.cell;
        var options = _this.widgetOptions;
        var disabled = _this.disabled;

        if (!disabled && movedDic.has(cell)) {
          disabled = options.selectCellOnMoved === false;

          if (!disabled) {
            disabled = options.selectNodeOnMoved === false && cell.isNode();
          }

          if (!disabled) {
            disabled = options.selectEdgeOnMoved === false && cell.isEdge();
          }
        }

        if (!disabled) {
          if (options.multiple === false || !e.ctrlKey && !e.metaKey) {
            _this.clean();
          }

          _this.select(cell);
        }

        movedDic.delete(cell);
      });
      this.widget.on('box:mousedown', function (_ref4) {
        var cell = _ref4.cell,
            e = _ref4.e;

        if (!_this.disabled) {
          if (_this.widgetOptions.multiple !== false && (e.ctrlKey || e.metaKey)) {
            _this.unselect(cell);
          }
        }
      });
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.length <= 0;
    }
  }, {
    key: "isSelected",
    value: function isSelected(cell) {
      return this.widget.isSelected(cell);
    }
  }, {
    key: "getCells",
    value: function getCells(cells) {
      var _this2 = this;

      return (Array.isArray(cells) ? cells : [cells]).map(function (cell) {
        return typeof cell === 'string' ? _this2.graph.getCellById(cell) : cell;
      }).filter(function (cell) {
        return cell != null;
      });
    }
  }, {
    key: "select",
    value: function select(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var selected = this.getCells(cells);

      if (!this.isMultiple() && selected.length > 0) {
        this.clean();

        if (selected.length > 1) {
          selected = selected.slice(0, 1);
        }
      }

      this.widget.select(selected, options);
      return this;
    }
  }, {
    key: "unselect",
    value: function unselect(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.widget.unselect(this.getCells(cells), options);
      return this;
    }
  }, {
    key: "reset",
    value: function reset(cells) {
      this.widget.reset(cells ? this.getCells(cells) : []);
      return this;
    }
  }, {
    key: "clean",
    value: function clean() {
      this.widget.clean();
      return this;
    }
  }, {
    key: "enable",
    value: function enable() {
      if (this.disabled) {
        this.widgetOptions.enabled = true;
      }

      return this;
    }
  }, {
    key: "disable",
    value: function disable() {
      if (!this.disabled) {
        this.widgetOptions.enabled = false;
      }

      return this;
    }
  }, {
    key: "startRubberband",
    value: function startRubberband(e) {
      if (!this.rubberbandDisabled) {
        this.widget.startSelecting(e);
      }

      return this;
    }
  }, {
    key: "enableRubberband",
    value: function enableRubberband() {
      if (this.rubberbandDisabled) {
        this.widgetOptions.rubberband = true;

        if (modifier_ModifierKey.equals(this.graph.options.scroller.modifiers, this.graph.options.selecting.modifiers)) {
          this.graph.scroller.disablePanning();
        }
      }

      return this;
    }
  }, {
    key: "disableRubberband",
    value: function disableRubberband() {
      if (!this.rubberbandDisabled) {
        this.widgetOptions.rubberband = false;
      }

      return this;
    }
  }, {
    key: "isMultiple",
    value: function isMultiple() {
      return this.widgetOptions.multiple !== false;
    }
  }, {
    key: "enableMultiple",
    value: function enableMultiple() {
      this.widgetOptions.multiple = true;
      return this;
    }
  }, {
    key: "disableMultiple",
    value: function disableMultiple() {
      this.widgetOptions.multiple = false;
      return this;
    }
  }, {
    key: "setModifiers",
    value: function setModifiers(modifiers) {
      this.widgetOptions.modifiers = modifiers;
      return this;
    }
  }, {
    key: "setContent",
    value: function setContent(content) {
      this.widget.setContent(content);
      return this;
    }
  }, {
    key: "setFilter",
    value: function setFilter(filter) {
      this.widget.setFilter(filter);
      return this;
    }
  }, {
    key: "widgetOptions",
    get: function get() {
      return this.options.selecting;
    }
  }, {
    key: "rubberbandDisabled",
    get: function get() {
      return this.widgetOptions.enabled !== true || this.widgetOptions.rubberband !== true;
    }
  }, {
    key: "disabled",
    get: function get() {
      return this.widgetOptions.enabled !== true;
    }
  }, {
    key: "length",
    get: function get() {
      return this.widget.length;
    }
  }, {
    key: "cells",
    get: function get() {
      return this.widget.cells;
    }
  }]);

  return SelectionManager;
}(graph_base_Base);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/history.js






var history_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var history_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




var history_HistoryManager = /*#__PURE__*/function (_Basecoat) {
  Object(inherits["a" /* default */])(HistoryManager, _Basecoat);

  var _super = Object(createSuper["a" /* default */])(HistoryManager);

  function HistoryManager(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, HistoryManager);

    _this = _super.call(this);
    _this.batchCommands = null;
    _this.batchLevel = 0;
    _this.lastBatchIndex = -1;
    _this.freezed = false;
    _this.handlers = [];
    _this.model = options.graph.model;
    _this.options = history_Util.getOptions(options);
    _this.validator = new HistoryManager.Validator({
      history: Object(assertThisInitialized["a" /* default */])(_this),
      cancelInvalid: _this.options.cancelInvalid
    });

    _this.clean();

    _this.startListening();

    return _this;
  }

  Object(createClass["a" /* default */])(HistoryManager, [{
    key: "enable",
    value: function enable() {
      if (this.disabled) {
        this.options.enabled = true;
      }
    }
  }, {
    key: "disable",
    value: function disable() {
      if (!this.disabled) {
        this.options.enabled = false;
      }
    }
  }, {
    key: "undo",
    value: function undo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.disabled) {
        var cmd = this.undoStack.pop();

        if (cmd) {
          this.revertCommand(cmd, options);
          this.redoStack.push(cmd);
          this.notify('undo', cmd, options);
        }
      }

      return this;
    }
  }, {
    key: "redo",
    value: function redo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.disabled) {
        var cmd = this.redoStack.pop();

        if (cmd) {
          this.applyCommand(cmd, options);
          this.undoStack.push(cmd);
          this.notify('redo', cmd, options);
        }
      }

      return this;
    }
    /**
     * Same as `undo()` but does not store the undo-ed command to the
     * `redoStack`. Canceled command therefore cannot be redo-ed.
     */

  }, {
    key: "cancel",
    value: function cancel() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.disabled) {
        var cmd = this.undoStack.pop();

        if (cmd) {
          this.revertCommand(cmd, options);
          this.redoStack = [];
          this.notify('cancel', cmd, options);
        }
      }

      return this;
    }
  }, {
    key: "clean",
    value: function clean() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.undoStack = [];
      this.redoStack = [];
      this.notify('clean', null, options);
      return this;
    }
  }, {
    key: "canUndo",
    value: function canUndo() {
      return !this.disabled && this.undoStack.length > 0;
    }
  }, {
    key: "canRedo",
    value: function canRedo() {
      return !this.disabled && this.redoStack.length > 0;
    }
  }, {
    key: "validate",
    value: function validate(events) {
      var _this$validator;

      for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        callbacks[_key - 1] = arguments[_key];
      }

      (_this$validator = this.validator).validate.apply(_this$validator, [events].concat(callbacks));

      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.validator.dispose();
      this.clean();
      this.stopListening();
    }
  }, {
    key: "startListening",
    value: function startListening() {
      var _this2 = this;

      this.model.on('batch:start', this.initBatchCommand, this);
      this.model.on('batch:stop', this.storeBatchCommand, this);

      if (this.options.eventNames) {
        this.options.eventNames.forEach(function (name, index) {
          _this2.handlers[index] = _this2.addCommand.bind(_this2, name);

          _this2.model.on(name, _this2.handlers[index]);
        });
      }

      this.validator.on('invalid', function (args) {
        return _this2.trigger('invalid', args);
      });
    }
  }, {
    key: "stopListening",
    value: function stopListening() {
      var _this3 = this;

      this.model.off('batch:start', this.initBatchCommand, this);
      this.model.off('batch:stop', this.storeBatchCommand, this);

      if (this.options.eventNames) {
        this.options.eventNames.forEach(function (name, index) {
          _this3.model.off(name, _this3.handlers[index]);
        });
        this.handlers.length = 0;
      }

      this.validator.off('invalid');
    }
  }, {
    key: "createCommand",
    value: function createCommand(options) {
      return {
        batch: options ? options.batch : false,
        data: {}
      };
    }
  }, {
    key: "revertCommand",
    value: function revertCommand(cmd, options) {
      this.freezed = true;
      var cmds = Array.isArray(cmd) ? history_Util.sortBatchCommands(cmd) : [cmd];

      for (var i = cmds.length - 1; i >= 0; i -= 1) {
        var _cmd = cmds[i];
        var localOptions = Object.assign(Object.assign({}, options), object_namespaceObject.pick(_cmd.options, this.options.revertOptionsList || []));
        this.executeCommand(_cmd, true, localOptions);
      }

      this.freezed = false;
    }
  }, {
    key: "applyCommand",
    value: function applyCommand(cmd, options) {
      this.freezed = true;
      var cmds = Array.isArray(cmd) ? history_Util.sortBatchCommands(cmd) : [cmd];

      for (var i = 0; i < cmds.length; i += 1) {
        var _cmd2 = cmds[i];
        var localOptions = Object.assign(Object.assign({}, options), object_namespaceObject.pick(_cmd2.options, this.options.applyOptionsList || []));
        this.executeCommand(_cmd2, false, localOptions);
      }

      this.freezed = false;
    }
  }, {
    key: "executeCommand",
    value: function executeCommand(cmd, revert, options) {
      var model = this.model; // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)

      var cell = model.getCell(cmd.data.id);
      var event = cmd.event;

      if (history_Util.isAddEvent(event) && revert || history_Util.isRemoveEvent(event) && !revert) {
        cell.remove(options);
      } else if (history_Util.isAddEvent(event) && !revert || history_Util.isRemoveEvent(event) && revert) {
        var data = cmd.data;

        if (data.node) {
          model.addNode(data.props, options);
        } else if (data.edge) {
          model.addEdge(data.props, options);
        }
      } else if (history_Util.isChangeEvent(event)) {
        var _data = cmd.data;
        var key = _data.key;

        if (key) {
          var value = revert ? _data.prev[key] : _data.next[key];
          cell.prop(key, value, options);
        }
      } else {
        var executeCommand = this.options.executeCommand;

        if (executeCommand) {
          main_namespaceObject.call(executeCommand, this, cmd, revert, options);
        }
      }
    }
  }, {
    key: "addCommand",
    value: function addCommand(event, args) {
      if (this.freezed || this.disabled) {
        return;
      }

      var eventArgs = args;
      var options = eventArgs.options || {};

      if (options.dryrun) {
        return;
      }

      if (history_Util.isAddEvent(event) && this.options.ignoreAdd || history_Util.isRemoveEvent(event) && this.options.ignoreRemove || history_Util.isChangeEvent(event) && this.options.ignoreChange) {
        return;
      } // before
      // ------


      var before = this.options.beforeAddCommand;

      if (before != null && main_namespaceObject.call(before, this, event, args) === false) {
        return;
      }

      if (event === 'cell:change:*') {
        // tslint:disable-next-line
        event = "cell:change:".concat(eventArgs.key);
      }

      var cell = eventArgs.cell;
      var isModelChange = cell instanceof model_Model;
      var cmd;

      if (this.batchCommands) {
        // In most cases we are working with same object, doing
        // same action etc. translate an object piece by piece.
        cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)]; // Check if we are start working with new object or performing different
        // action with it. Note, that command is uninitialized when lastCmdIndex
        // equals -1. In that case we are done, command we were looking for is
        // already set

        var diffId = isModelChange && !cmd.modelChange || cmd.data.id !== cell.id;
        var diffName = cmd.event !== event;

        if (this.lastBatchIndex >= 0 && (diffId || diffName)) {
          // Trying to find command first, which was performing same
          // action with the object as we are doing now with cell.
          var index = this.batchCommands.findIndex(function (cmd) {
            return (isModelChange && cmd.modelChange || cmd.data.id === cell.id) && cmd.event === event;
          });

          if (index < 0 || history_Util.isAddEvent(event) || history_Util.isRemoveEvent(event)) {
            cmd = this.createCommand({
              batch: true
            });
          } else {
            cmd = this.batchCommands[index];
            this.batchCommands.splice(index, 1);
          }

          this.batchCommands.push(cmd);
          this.lastBatchIndex = this.batchCommands.length - 1;
        }
      } else {
        cmd = this.createCommand({
          batch: false
        });
      } // add & remove
      // ------------


      if (history_Util.isAddEvent(event) || history_Util.isRemoveEvent(event)) {
        var data = cmd.data;
        cmd.event = event;
        cmd.options = options;
        data.id = cell.id;
        data.props = object_namespaceObject.cloneDeep(cell.toJSON());

        if (cell.isEdge()) {
          data.edge = true;
        } else if (cell.isNode()) {
          data.node = true;
        }

        return this.push(cmd, options);
      } // change:*
      // --------


      if (history_Util.isChangeEvent(event)) {
        var key = args.key;
        var _data2 = cmd.data;

        if (!cmd.batch || !cmd.event) {
          // Do this only once. Set previous data and action (also
          // serves as a flag so that we don't repeat this branche).
          cmd.event = event;
          cmd.options = options;
          _data2.key = key;

          if (_data2.prev == null) {
            _data2.prev = {};
          }

          _data2.prev[key] = object_namespaceObject.clone(cell.previous(key));

          if (isModelChange) {
            cmd.modelChange = true;
          } else {
            _data2.id = cell.id;
          }
        }

        if (_data2.next == null) {
          _data2.next = {};
        }

        _data2.next[key] = object_namespaceObject.clone(cell.prop(key));
        return this.push(cmd, options);
      } // others
      // ------


      var afterAddCommand = this.options.afterAddCommand;

      if (afterAddCommand) {
        main_namespaceObject.call(afterAddCommand, this, event, args, cmd);
      }

      this.push(cmd, options);
    }
    /**
     * Gather multiple changes into a single command. These commands could
     * be reverted with single `undo()` call. From the moment the function
     * is called every change made on model is not stored into the undoStack.
     * Changes are temporarily kept until `storeBatchCommand()` is called.
     */

  }, {
    key: "initBatchCommand",
    value: function initBatchCommand(options) {
      if (this.batchCommands) {
        this.batchLevel += 1;
      } else {
        this.batchCommands = [this.createCommand({
          batch: true
        })];
        this.batchLevel = 0;
        this.lastBatchIndex = -1;
      }
    }
    /**
     * Store changes temporarily kept in the undoStack. You have to call this
     * function as many times as `initBatchCommand()` been called.
     */

  }, {
    key: "storeBatchCommand",
    value: function storeBatchCommand(options) {
      if (this.batchCommands && this.batchLevel <= 0) {
        var cmds = this.filterBatchCommand(this.batchCommands);

        if (0 < cmds.length) {
          this.redoStack = [];
          this.undoStack.push(cmds);
          this.notify('add', cmds, options);
        }

        this.batchCommands = null;
        this.lastBatchIndex = -1;
        this.batchLevel = 0;
      } else {
        if (this.batchCommands && this.batchLevel > 0) {
          this.batchLevel -= 1;
        }
      }
    }
  }, {
    key: "filterBatchCommand",
    value: function filterBatchCommand(batchCommands) {
      var cmds = batchCommands.slice();
      var result = [];

      var _loop = function _loop() {
        var cmd = cmds.shift();
        var evt = cmd.event;
        var id = cmd.data.id;

        if (null != evt && (null != id || cmd.modelChange)) {
          if (history_Util.isAddEvent(evt)) {
            var index = cmds.findIndex(function (c) {
              return history_Util.isRemoveEvent(c.event) && c.data.id === id;
            });

            if (index >= 0) {
              cmds = cmds.filter(function (c, i) {
                return index < i || c.data.id !== id;
              });
              return "continue";
            }
          } else if (history_Util.isRemoveEvent(evt)) {
            var _index = cmds.findIndex(function (c) {
              return history_Util.isAddEvent(c.event) && c.data.id === id;
            });

            if (_index >= 0) {
              cmds.splice(_index, 1);
              return "continue";
            }
          } else if (history_Util.isChangeEvent(evt)) {
            var data = cmd.data;

            if (object_namespaceObject.isEqual(data.prev, data.next)) {
              return "continue";
            }
          } else {}

          result.push(cmd);
        }
      };

      while (0 < cmds.length) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }

      return result;
    }
  }, {
    key: "notify",
    value: function notify(event, cmd, options) {
      var cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd];
      this.emit(event, {
        cmds: cmds,
        options: options
      });
      this.emit('change', {
        cmds: cmds,
        options: options
      });
    }
  }, {
    key: "push",
    value: function push(cmd, options) {
      this.redoStack = [];

      if (cmd.batch) {
        this.lastBatchIndex = Math.max(this.lastBatchIndex, 0);
        this.emit('batch', {
          cmd: cmd,
          options: options
        });
      } else {
        this.undoStack.push(cmd);
        this.notify('add', cmd, options);
      }
    }
  }, {
    key: "disabled",
    get: function get() {
      return this.options.enabled !== true;
    }
  }]);

  return HistoryManager;
}(basecoat_Basecoat);

history_decorate([basecoat_Basecoat.dispose()], history_HistoryManager.prototype, "dispose", null);

(function (HistoryManager) {
  /**
   * Runs a set of callbacks to determine if a command is valid. This is
   * useful for checking if a certain action in your application does
   * lead to an invalid state of the graph.
   */
  var Validator = /*#__PURE__*/function (_Basecoat2) {
    Object(inherits["a" /* default */])(Validator, _Basecoat2);

    var _super2 = Object(createSuper["a" /* default */])(Validator);

    function Validator(options) {
      var _this4;

      Object(classCallCheck["a" /* default */])(this, Validator);

      _this4 = _super2.call(this);
      _this4.map = {};
      _this4.command = options.history;
      _this4.cancelInvalid = options.cancelInvalid !== false;

      _this4.command.on('add', _this4.onCommandAdded, Object(assertThisInitialized["a" /* default */])(_this4));

      return _this4;
    }

    Object(createClass["a" /* default */])(Validator, [{
      key: "onCommandAdded",
      value: function onCommandAdded(_ref) {
        var _this5 = this;

        var cmds = _ref.cmds;
        return Array.isArray(cmds) ? cmds.every(function (cmd) {
          return _this5.isValidCommand(cmd);
        }) : this.isValidCommand(cmds);
      }
    }, {
      key: "isValidCommand",
      value: function isValidCommand(cmd) {
        if (cmd.options && cmd.options.validation === false) {
          return true;
        }

        var callbacks = cmd.event && this.map[cmd.event] || [];
        var handoverErr = null;
        callbacks.forEach(function (routes) {
          var i = 0;

          var rollup = function rollup(err) {
            var fn = routes[i];
            i += 1;

            try {
              if (fn) {
                fn(err, cmd, rollup);
              } else {
                handoverErr = err;
                return;
              }
            } catch (err) {
              rollup(err);
            }
          };

          rollup(handoverErr);
        });

        if (handoverErr) {
          if (this.cancelInvalid) {
            this.command.cancel();
          }

          this.emit('invalid', {
            err: handoverErr
          });
          return false;
        }

        return true;
      }
    }, {
      key: "validate",
      value: function validate(events) {
        var _this6 = this;

        for (var _len2 = arguments.length, callbacks = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          callbacks[_key2 - 1] = arguments[_key2];
        }

        var evts = Array.isArray(events) ? events : events.split(/\s+/);
        callbacks.forEach(function (callback) {
          if (typeof callback !== 'function') {
            throw new Error("".concat(evts.join(' '), " requires callback functions."));
          }
        });
        evts.forEach(function (event) {
          if (_this6.map[event] == null) {
            _this6.map[event] = [];
          }

          _this6.map[event].push(callbacks);
        });
        return this;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.command.off('add', this.onCommandAdded, this);
      }
    }]);

    return Validator;
  }(basecoat_Basecoat);

  history_decorate([basecoat_Basecoat.dispose()], Validator.prototype, "dispose", null);

  HistoryManager.Validator = Validator;
})(history_HistoryManager || (history_HistoryManager = {}));

var history_Util;

(function (Util) {
  function isAddEvent(event) {
    return event === 'cell:added';
  }

  Util.isAddEvent = isAddEvent;

  function isRemoveEvent(event) {
    return event === 'cell:removed';
  }

  Util.isRemoveEvent = isRemoveEvent;

  function isChangeEvent(event) {
    return event != null && event.startsWith('cell:change:');
  }

  Util.isChangeEvent = isChangeEvent;

  function getOptions(options) {
    var graph = options.graph,
        others = history_rest(options, ["graph"]);

    var reservedNames = ['cell:added', 'cell:removed', 'cell:change:*'];
    var batchEvents = ['batch:start', 'batch:stop'];
    var eventNames = options.eventNames ? options.eventNames.filter(function (event) {
      return !(Util.isChangeEvent(event) || reservedNames.includes(event) || batchEvents.includes(event));
    }) : reservedNames;
    return Object.assign(Object.assign({}, others), {
      eventNames: eventNames,
      applyOptionsList: options.applyOptionsList || ['propertyPath'],
      revertOptionsList: options.revertOptionsList || ['propertyPath']
    });
  }

  Util.getOptions = getOptions;

  function sortBatchCommands(cmds) {
    var results = [];

    for (var i = 0, ii = cmds.length; i < ii; i += 1) {
      var cmd = cmds[i];
      var index = null;

      if (Util.isAddEvent(cmd.event)) {
        var id = cmd.data.id;

        for (var j = 0; j < i; j += 1) {
          if (cmds[j].data.id === id) {
            index = j;
            break;
          }
        }
      }

      if (null !== index) {
        results.splice(index, 0, cmd);
      } else {
        results.push(cmd);
      }
    }

    return results;
  }

  Util.sortBatchCommands = sortBatchCommands;
})(history_Util || (history_Util = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/minimap.js





var minimap_MiniMapManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(MiniMapManager, _Base);

  var _super = Object(createSuper["a" /* default */])(MiniMapManager);

  function MiniMapManager() {
    Object(classCallCheck["a" /* default */])(this, MiniMapManager);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(MiniMapManager, [{
    key: "init",
    value: function init() {
      this.widget = this.graph.hook.createMiniMap();
    }
  }, {
    key: "widgetOptions",
    get: function get() {
      return this.options.minimap;
    }
  }]);

  return MiniMapManager;
}(graph_base_Base);
// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/mousetrap/mousetrap.js
var mousetrap = __webpack_require__(164);
var mousetrap_default = /*#__PURE__*/__webpack_require__.n(mousetrap);

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/keyboard.js








var keyboard_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




var keyboard_Keyboard = /*#__PURE__*/function (_Disposable) {
  Object(inherits["a" /* default */])(Keyboard, _Disposable);

  var _super = Object(createSuper["a" /* default */])(Keyboard);

  function Keyboard(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Keyboard);

    _this = _super.call(this);
    _this.options = options;
    var scroller = _this.graph.scroller.widget;
    _this.container = scroller ? scroller.container : _this.graph.container;

    if (options.global) {
      _this.target = document;
    } else {
      _this.target = _this.container;

      if (!_this.disabled) {
        // ensure the container focusable
        _this.target.setAttribute('tabindex', '-1');
      }

      _this.graph.on('cell:mousedown', _this.focus, Object(assertThisInitialized["a" /* default */])(_this));

      _this.graph.on('blank:mousedown', _this.focus, Object(assertThisInitialized["a" /* default */])(_this));
    }

    _this.mousetrap = new Keyboard.Mousetrap(_this.target, Object(assertThisInitialized["a" /* default */])(_this));
    return _this;
  }

  Object(createClass["a" /* default */])(Keyboard, [{
    key: "enable",
    value: function enable() {
      if (this.disabled) {
        this.options.enabled = true;
        this.graph.options.keyboard.enabled = true;

        if (this.target instanceof HTMLElement) {
          this.target.setAttribute('tabindex', '-1');
        }
      }
    }
  }, {
    key: "disable",
    value: function disable() {
      if (!this.disabled) {
        this.options.enabled = false;
        this.graph.options.keyboard.enabled = false;

        if (this.target instanceof HTMLElement) {
          this.target.removeAttribute('tabindex');
        }
      }
    }
  }, {
    key: "on",
    value: function on(keys, callback, action) {
      this.mousetrap.bind(this.getKeys(keys), callback, action);
    }
  }, {
    key: "off",
    value: function off(keys, action) {
      this.mousetrap.unbind(this.getKeys(keys), action);
    }
  }, {
    key: "focus",
    value: function focus() {
      var target = this.target;
      target.focus();
    }
  }, {
    key: "getKeys",
    value: function getKeys(keys) {
      var _this2 = this;

      return (Array.isArray(keys) ? keys : [keys]).map(function (key) {
        return _this2.formatkey(key);
      });
    }
  }, {
    key: "formatkey",
    value: function formatkey(key) {
      var formated = key.toLowerCase().replace(/\s/g, '').replace('delete', 'del').replace('cmd', 'command');
      var formatFn = this.options.format;

      if (formatFn) {
        return main_namespaceObject.call(formatFn, this.graph, formated);
      }

      return formated;
    }
  }, {
    key: "isGraphEvent",
    value: function isGraphEvent(e) {
      var target = e.srcElement || e.target;

      if (target) {
        if (target === this.target || target.parentElement === this.target) {
          return true;
        }

        return dom_main_namespaceObject.contains(this.container, target);
      }

      return false;
    }
  }, {
    key: "isEnabledForEvent",
    value: function isEnabledForEvent(e) {
      var allowed = !this.disabled && this.isGraphEvent(e);

      if (allowed) {
        if (this.options.guard) {
          return main_namespaceObject.call(this.options.guard, this.graph, e);
        }
      }

      return allowed;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.mousetrap.reset();
    }
  }, {
    key: "graph",
    get: function get() {
      return this.options.graph;
    }
  }, {
    key: "disabled",
    get: function get() {
      return this.options.enabled !== true;
    }
  }]);

  return Keyboard;
}(disposable_Disposable);

keyboard_decorate([disposable_Disposable.dispose()], keyboard_Keyboard.prototype, "dispose", null);

(function (Keyboard) {
  var Mousetrap = /*#__PURE__*/function (_MousetrapNative) {
    Object(inherits["a" /* default */])(Mousetrap, _MousetrapNative);

    var _super2 = Object(createSuper["a" /* default */])(Mousetrap);

    function Mousetrap(elem, keyboard) {
      var _this3;

      Object(classCallCheck["a" /* default */])(this, Mousetrap);

      _this3 = _super2.call(this, elem);
      _this3.keyboard = keyboard;
      return _this3;
    }

    Object(createClass["a" /* default */])(Mousetrap, [{
      key: "stopCallback",
      value: function stopCallback(e, elem, combo) {
        if (this.keyboard.isEnabledForEvent(e)) {
          return Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(Mousetrap.prototype), "stopCallback", this).call(this, e, elem, combo);
        }

        return false;
      }
    }]);

    return Mousetrap;
  }(mousetrap_default.a);

  Keyboard.Mousetrap = Mousetrap;
})(keyboard_Keyboard || (keyboard_Keyboard = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/mousewheel.js






var mousewheel_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





var mousewheel_MouseWheel = /*#__PURE__*/function (_Disposable) {
  Object(inherits["a" /* default */])(MouseWheel, _Disposable);

  var _super = Object(createSuper["a" /* default */])(MouseWheel);

  function MouseWheel(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, MouseWheel);

    _this = _super.call(this);
    _this.options = options;
    _this.cumulatedFactor = 1;
    var scroller = _this.graph.scroller.widget;
    _this.container = scroller ? scroller.container : _this.graph.container;
    _this.target = _this.options.global ? document : _this.container;
    _this.handler = _this.onMouseWheel.bind(Object(assertThisInitialized["a" /* default */])(_this));

    if (_this.options.enabled) {
      _this.enable(true);
    }

    return _this;
  }

  Object(createClass["a" /* default */])(MouseWheel, [{
    key: "enable",
    value: function enable(force) {
      if (this.disabled || force) {
        this.options.enabled = true;
        this.graph.options.mousewheel.enabled = true;

        if (platform["a" /* Platform */].SUPPORT_PASSIVE) {
          this.target.addEventListener('mousewheel', this.handler, {
            passive: false
          });
        } else {
          jquery_default()(this.target).on('mousewheel', this.handler);
        }
      }
    }
  }, {
    key: "disable",
    value: function disable() {
      if (!this.disabled) {
        this.options.enabled = false;
        this.graph.options.mousewheel.enabled = false;

        if (platform["a" /* Platform */].SUPPORT_PASSIVE) {
          this.target.removeEventListener('mousewheel', this.handler);
        } else {
          jquery_default()(this.target).off('mousewheel');
        }
      }
    }
  }, {
    key: "onMouseWheel",
    value: function onMouseWheel(evt) {
      var _this2 = this;

      var e = evt.originalEvent || evt;

      if (modifier_ModifierKey.test(e, this.options.modifiers)) {
        evt.preventDefault();
        evt.stopPropagation();

        if (this.frameId) {
          dom_main_namespaceObject.cancelAnimationFrame(this.frameId);
          this.frameId = null;
        }

        var factor = this.options.factor || 1.2;

        if (this.currentScale == null) {
          this.startPos = {
            x: evt.clientX,
            y: evt.clientY
          };
          this.currentScale = this.graph.scroller.widget ? this.graph.scroller.widget.zoom() : this.graph.scale().sx;
        }

        var delta = evt.deltaY;

        if (delta > 0) {
          // zoomin
          // ------
          // Switches to 1% zoom steps below 15%
          if (this.currentScale * this.cumulatedFactor < 0.15) {
            this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale;
          } else {
            // Uses to 5% zoom steps for better grid rendering in
            // webkit and to avoid rounding errors for zoom steps
            this.cumulatedFactor *= factor;
          }
        } else {
          // zoomout
          // -------
          // Switches to 1% zoom steps below 15%
          if (this.currentScale * this.cumulatedFactor <= 0.15) {
            this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale;
          } else {
            // Uses to 5% zoom steps for better grid rendering in
            // webkit and to avoid rounding errors for zoom steps
            this.cumulatedFactor /= factor;
          }
        }

        this.cumulatedFactor = Math.round(this.currentScale * this.cumulatedFactor * 20) / 20 / this.currentScale;
        this.cumulatedFactor = Math.max(0.01, Math.min(this.currentScale * this.cumulatedFactor, 160) / this.currentScale);
        this.frameId = dom_main_namespaceObject.requestAnimationFrame(function () {
          var scroller = _this2.graph.scroller.widget;
          var currentScale = _this2.currentScale;

          var targetScale = _this2.graph.transform.clampScale(currentScale * _this2.cumulatedFactor);

          if (targetScale !== currentScale) {
            if (scroller) {
              if (_this2.options.zoomAtMousePosition) {
                var origin = _this2.graph.coord.clientToLocalPoint(_this2.startPos);

                scroller.zoom(targetScale, {
                  absolute: true,
                  center: origin.clone()
                });
              } else {
                scroller.zoom(targetScale, {
                  absolute: true
                });
              }
            } else {
              _this2.graph.scale(targetScale, targetScale);

              if (_this2.options.zoomAtMousePosition) {
                var _origin = _this2.graph.coord.clientToLocalPoint(_this2.startPos);

                _this2.graph.translate(_origin.x * (1 - targetScale), _origin.y * (1 - targetScale));
              }
            }
          }

          _this2.frameId = null;
          _this2.currentScale = null;
          _this2.cumulatedFactor = 1;
        });
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.disable();
    }
  }, {
    key: "graph",
    get: function get() {
      return this.options.graph;
    }
  }, {
    key: "disabled",
    get: function get() {
      return this.options.enabled !== true;
    }
  }]);

  return MouseWheel;
}(disposable_Disposable);

mousewheel_decorate([disposable_Disposable.dispose()], mousewheel_MouseWheel.prototype, "dispose", null);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/print.js







var print_PrintManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(PrintManager, _Base);

  var _super = Object(createSuper["a" /* default */])(PrintManager);

  function PrintManager() {
    Object(classCallCheck["a" /* default */])(this, PrintManager);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(PrintManager, [{
    key: "show",
    value: function show() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var localOptions = Object.assign(Object.assign({}, PrintManager.defaultOptions), options);
      var $pages = this.createPrintPages(localOptions);
      localOptions.ready($pages, function ($pages) {
        return _this.showPrintWindow($pages, localOptions);
      }, {
        sheetSize: this.getSheetSize(localOptions)
      });
    }
  }, {
    key: "showPrintWindow",
    value: function showPrintWindow($pages, options) {
      var _this2 = this;

      if ($pages) {
        var $body = jquery_default()(document.body);
        var $container = jquery_default()(this.view.container);
        var bodyClassName = this.view.prefixClassName('graph-printing');
        $body.addClass(bodyClassName);
        var $detached = $container.children().detach();
        $pages.forEach(function ($page) {
          $page.removeClass("".concat(_this2.className, "-preview")).addClass("".concat(_this2.className, "-ready")).appendTo($body);
        });
        var ret = false;

        var cb = function cb() {
          if (!ret) {
            ret = true;
            $body.removeClass(bodyClassName);
            $pages.forEach(function ($page) {
              return $page.remove();
            });
            $container.append($detached);
            jquery_default()("#".concat(_this2.styleSheetId)).remove();

            _this2.graph.trigger('after:print', options);

            jquery_default()(window).off('afterprint', cb);
          }
        };

        jquery_default()(window).one('afterprint', cb);
        setTimeout(cb, 200);
        window.print();
      }
    }
  }, {
    key: "createPrintPage",
    value: function createPrintPage(pageArea, options) {
      this.graph.trigger('before:print', options);
      var $page = jquery_default()('<div/>').addClass(this.className);
      var $wrap = jquery_default()('<div/>').addClass(this.view.prefixClassName('graph-print-inner')).css('position', 'relative');

      if (options.size) {
        $page.addClass("".concat(this.className, "-size-").concat(options.size));
      }

      var vSVG = dom_main_namespaceObject.createVector(this.view.svg).clone();
      var vStage = vSVG.findOne(".".concat(this.view.prefixClassName('graph-svg-stage')));
      $wrap.append(vSVG.node);
      var sheetSize = this.getSheetSize(options);
      var graphArea = this.graph.getArea();
      var s = this.graph.scale();
      var ts = this.graph.translate();
      var matrix = dom_main_namespaceObject.createSVGMatrix().translate(ts.tx / s.sx, ts.ty / s.sy);
      var info = this.getPageInfo(graphArea, pageArea, sheetSize);
      var scale = info.scale;
      var bbox = info.bbox;
      $wrap.css({
        left: 0,
        top: 0
      });
      vSVG.attr({
        width: bbox.width * scale,
        height: bbox.height * scale,
        style: 'position:relative',
        viewBox: [bbox.x, bbox.y, bbox.width, bbox.height].join(' ')
      });
      vStage.attr('transform', dom_main_namespaceObject.matrixToTransformString(matrix));
      $page.append($wrap);
      $page.addClass("".concat(this.className, "-preview"));
      return {
        $page: $page,
        sheetSize: sheetSize
      };
    }
  }, {
    key: "createPrintPages",
    value: function createPrintPages(options) {
      var _this3 = this;

      var ret;
      var area = this.getPrintArea(options);
      var $pages = [];

      if (options.page) {
        var pageSize = this.getPageSize(area, options.page);
        var pageAreas = this.getPageAreas(area, pageSize);
        pageAreas.forEach(function (pageArea) {
          ret = _this3.createPrintPage(pageArea, options);
          $pages.push(ret.$page);
        });
      } else {
        ret = this.createPrintPage(area, options);
        $pages.push(ret.$page);
      }

      if (ret) {
        var size = {
          width: ret.sheetSize.cssWidth,
          height: ret.sheetSize.cssHeight
        };
        this.updatePrintStyle(size, options);
      }

      return $pages;
    }
  }, {
    key: "updatePrintStyle",
    value: function updatePrintStyle(size, options) {
      var sizeCSS = Object.keys(size).reduce(function (memo, key) {
        return "".concat(memo, " ").concat(key, ":").concat(size[key], ";");
      }, '');
      var margin = number_namespaceObject.normalizeSides(options.margin);
      var marginUnit = options.marginUnit || '';
      var sheetUnit = options.sheetUnit || '';
      var css = "\n      @media print {\n        .".concat(this.className, ".").concat(this.className, "-ready {\n          ").concat(sizeCSS, "\n        }\n\n        @page {\n          margin:\n          ").concat([margin.top + marginUnit, margin.right + marginUnit, margin.bottom + marginUnit, margin.left + marginUnit].join(' '), ";\n          size: ").concat(options.sheet.width + sheetUnit, " ").concat(options.sheet.height + sheetUnit, ";\n\n        .").concat(this.className, ".").concat(this.className, "-preview {\n          ").concat(sizeCSS, "\n        }\n      }");
      var id = this.styleSheetId;
      var $style = jquery_default()("#".concat(id));

      if ($style.length) {
        $style.html(css);
      } else {
        jquery_default()('head').append("'<style type=\"text/css\" id=\"".concat(id, "\">").concat(css, "</style>'"));
      }
    }
  }, {
    key: "getPrintArea",
    value: function getPrintArea(options) {
      var area = options.area;

      if (!area) {
        var padding = number_namespaceObject.normalizeSides(options.padding);
        area = this.graph.getContentArea().moveAndExpand({
          x: -padding.left,
          y: -padding.top,
          width: padding.left + padding.right,
          height: padding.top + padding.bottom
        });
      }

      return area;
    }
  }, {
    key: "getPageSize",
    value: function getPageSize(area, poster) {
      if (typeof poster === 'object') {
        var raw = poster;
        var page = {
          width: raw.width,
          height: raw.height
        };

        if (page.width == null) {
          page.width = Math.ceil(area.width / (raw.columns || 1));
        }

        if (page.height == null) {
          page.height = Math.ceil(area.height / (raw.rows || 1));
        }

        return page;
      }

      return {
        width: area.width,
        height: area.height
      };
    }
  }, {
    key: "getPageAreas",
    value: function getPageAreas(area, pageSize) {
      var pages = [];
      var width = pageSize.width;
      var height = pageSize.height;

      for (var w = 0, n = 0; w < area.height && n < 200; w += height, n += 1) {
        for (var h = 0, m = 0; h < area.width && m < 200; h += width, m += 1) {
          pages.push(new rectangle_Rectangle(area.x + h, area.y + w, width, height));
        }
      }

      return pages;
    }
  }, {
    key: "getSheetSize",
    value: function getSheetSize(options) {
      var sheet = options.sheet;
      var margin = number_namespaceObject.normalizeSides(options.margin);
      var marginUnit = options.marginUnit || '';
      var sheetUnit = options.sheetUnit || '';
      var cssWidth = // tslint:disable-next-line
      'calc(' + sheet.width + sheetUnit + ' - ' + (margin.left + margin.right) + marginUnit + ')';
      var cssHeight = // tslint:disable-next-line
      'calc(' + sheet.height + sheetUnit + ' - ' + (margin.top + margin.bottom) + marginUnit + ')';
      var ret = unit_Unit.measure(cssWidth, cssHeight);
      return {
        cssWidth: cssWidth,
        cssHeight: cssHeight,
        width: ret.width,
        height: ret.height
      };
    }
  }, {
    key: "getPageInfo",
    value: function getPageInfo(graphArea, pageArea, sheetSize) {
      var bbox = new rectangle_Rectangle(pageArea.x - graphArea.x, pageArea.y - graphArea.y, pageArea.width, pageArea.height);
      var pageRatio = bbox.width / bbox.height;
      var graphRatio = sheetSize.width / sheetSize.height;
      return {
        bbox: bbox,
        scale: graphRatio < pageRatio ? sheetSize.width / bbox.width : sheetSize.height / bbox.height,
        fitHorizontal: graphRatio < pageRatio
      };
    }
  }, {
    key: "className",
    get: function get() {
      return this.view.prefixClassName('graph-print');
    }
  }, {
    key: "styleSheetId",
    get: function get() {
      return this.view.prefixClassName('graph-print-style');
    }
  }]);

  return PrintManager;
}(graph_base_Base);

(function (PrintManager) {
  PrintManager.defaultOptions = {
    page: false,
    sheet: {
      width: 210,
      height: 297
    },
    sheetUnit: 'mm',
    margin: 0.4,
    marginUnit: 'in',
    padding: 5,
    ready: function ready($pages, readyToPrint) {
      return readyToPrint($pages);
    }
  };
})(print_PrintManager || (print_PrintManager = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/format.js







var format_FormatManager = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(FormatManager, _Base);

  var _super = Object(createSuper["a" /* default */])(FormatManager);

  function FormatManager() {
    Object(classCallCheck["a" /* default */])(this, FormatManager);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(FormatManager, [{
    key: "toSVG",
    value: function toSVG(callback) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.graph.trigger('before:export', options);
      var rawSVG = this.view.svg;
      var vSVG = dom_main_namespaceObject.createVector(rawSVG).clone();
      var clonedSVG = vSVG.node;
      var vStage = vSVG.findOne(".".concat(this.view.prefixClassName('graph-svg-stage')));
      var viewBox = options.viewBox || this.graph.graphToLocalRect(this.graph.getContentBBox());
      var dimension = options.preserveDimensions;

      if (dimension) {
        var size = typeof dimension === 'boolean' ? viewBox : dimension;
        vSVG.attr({
          width: size.width,
          height: size.height
        });
      }

      vSVG.removeAttribute('style').attr('viewBox', [viewBox.x, viewBox.y, viewBox.width, viewBox.height].join(' '));
      vStage.removeAttribute('transform'); // Stores all the CSS declarations from external stylesheets to the
      // `style` attribute of the SVG document nodes.
      // This is achieved in three steps.
      // -----------------------------------
      // 1. Disabling all the stylesheets in the page and therefore collecting
      //    only default style values. This, together with the step 2, makes it
      //    possible to discard default CSS property values and store only those
      //    that differ.
      //
      // 2. Enabling back all the stylesheets in the page and collecting styles
      //    that differ from the default values.
      //
      // 3. Applying the difference between default values and the ones set by
      //    custom stylesheets onto the `style` attribute of each of the nodes
      //    in SVG.

      if (options.copyStyles !== false) {
        var _document = rawSVG.ownerDocument;
        var raws = Array.from(rawSVG.querySelectorAll('*'));
        var clones = Array.from(clonedSVG.querySelectorAll('*'));
        var styleSheetCount = _document.styleSheets.length;
        var styleSheetsCopy = [];

        for (var k = styleSheetCount - 1; 0 <= k; k -= 1) {
          // There is a bug (bugSS) in Chrome 14 and Safari. When you set
          // `stylesheet.disable = true` it will also remove it from
          // `document.styleSheets`. So we need to store all stylesheets before
          // we disable them. Later on we put them back to `document.styleSheets`
          // if needed.
          // See the bug `https://code.google.com/p/chromium/issues/detail?id=88310`.
          styleSheetsCopy[k] = _document.styleSheets[k];
          _document.styleSheets[k].disabled = true;
        }

        var defaultComputedStyles = {};
        raws.forEach(function (elem, index) {
          var computedStyle = window.getComputedStyle(elem, null); // We're making a deep copy of the `computedStyle` so that it's not affected
          // by that next step when all the stylesheets are re-enabled again.

          var defaultComputedStyle = {};
          Object.keys(computedStyle).forEach(function (property) {
            defaultComputedStyle[property] = computedStyle.getPropertyValue(property);
          });
          defaultComputedStyles[index] = defaultComputedStyle;
        }); // Copy all stylesheets back

        if (styleSheetCount !== _document.styleSheets.length) {
          styleSheetsCopy.forEach(function (copy, index) {
            _document.styleSheets[index] = copy;
          });
        }

        for (var i = 0; i < styleSheetCount; i += 1) {
          _document.styleSheets[i].disabled = false;
        }

        var customStyles = {};
        raws.forEach(function (elem, index) {
          var computedStyle = window.getComputedStyle(elem, null);
          var defaultComputedStyle = defaultComputedStyles[index];
          var customStyle = {};
          Object.keys(computedStyle).forEach(function (property) {
            if (computedStyle.getPropertyValue(property) !== defaultComputedStyle[property]) {
              customStyle[property] = computedStyle.getPropertyValue(property);
            }
          });
          customStyles[index] = customStyle;
        });
        clones.forEach(function (elem, index) {
          jquery_default()(elem).css(customStyles[index]);
        });
      }

      var stylesheet = options.stylesheet;

      if (typeof stylesheet === 'string') {
        var cDATASection = rawSVG.ownerDocument.implementation.createDocument(null, 'xml', null).createCDATASection(stylesheet);
        vSVG.prepend(dom_main_namespaceObject.createVector('style', {
          type: 'text/css'
        }, [cDATASection]));
      }

      var format = function format() {
        var beforeSerialize = options.beforeSerialize;

        if (typeof beforeSerialize === 'function') {
          var ret = main_namespaceObject.call(beforeSerialize, _this.graph, clonedSVG);

          if (ret instanceof SVGSVGElement) {
            clonedSVG = ret;
          }
        }

        var dataUri = new XMLSerializer().serializeToString(clonedSVG).replace(/&nbsp;/g, "\xA0");

        _this.graph.trigger('after:export', options);

        callback(dataUri);
      };

      if (options.serializeImages) {
        var deferrals = vSVG.find('image').map(function (vImage) {
          return new Promise(function (resolve) {
            var url = vImage.attr('xlink:href') || vImage.attr('href');
            DataUri.imageToDataUri(url, function (err, dataUri) {
              if (!err && dataUri) {
                vImage.attr('xlink:href', dataUri);
              }

              resolve();
            });
          });
        });
        Promise.all(deferrals).then(format);
      } else {
        format();
      }
    }
  }, {
    key: "toDataURL",
    value: function toDataURL(callback, options) {
      var viewBox = options.viewBox || this.graph.graphToLocalRect(this.graph.getContentBBox());
      var padding = number_namespaceObject.normalizeSides(options.padding);

      if (options.width && options.height) {
        if (padding.left + padding.right >= options.width) {
          padding.left = padding.right = 0;
        }

        if (padding.top + padding.bottom >= options.height) {
          padding.top = padding.bottom = 0;
        }
      }

      var expanding = new rectangle_Rectangle(-padding.left, -padding.top, padding.left + padding.right, padding.top + padding.bottom);

      if (options.width && options.height) {
        var width = viewBox.width + padding.left + padding.right;
        var height = viewBox.height + padding.top + padding.bottom;
        expanding.scale(width / options.width, height / options.height);
      }

      viewBox = rectangle_Rectangle.create(viewBox).moveAndExpand(expanding);
      var rawSize = typeof options.width === 'number' && typeof options.height === 'number' ? {
        width: options.width,
        height: options.height
      } : viewBox;
      var scale = options.ratio ? parseFloat(options.ratio) : 1;

      if (!isFinite(scale) || scale === 0) {
        scale = 1;
      }

      var size = {
        width: Math.max(Math.round(rawSize.width * scale), 1),
        height: Math.max(Math.round(rawSize.height * scale), 1)
      };
      {
        var imgDataCanvas = document.createElement('canvas');
        var context2D = imgDataCanvas.getContext('2d');
        imgDataCanvas.width = size.width;
        imgDataCanvas.height = size.height;
        var x = size.width - 1;
        var y = size.height - 1;
        context2D.fillStyle = 'rgb(1,1,1)';
        context2D.fillRect(x, y, 1, 1);
        var data = context2D.getImageData(x, y, 1, 1).data;

        if (1 !== data[0] || 1 !== data[1] || 1 !== data[2]) {
          throw new Error('size exceeded');
        }
      }
      var img = new Image();

      img.onload = function () {
        var canvas = document.createElement('canvas');
        canvas.width = size.width;
        canvas.height = size.height;
        var context = canvas.getContext('2d');
        context.fillStyle = options.backgroundColor || 'white';
        context.fillRect(0, 0, size.width, size.height);

        try {
          context.drawImage(img, 0, 0, size.width, size.height);
          var dataUri = canvas.toDataURL(options.type, options.quality);
          callback(dataUri);
        } catch (error) {}
      };

      this.toSVG(function (dataUri) {
        img.src = "data:image/svg+xml,".concat(encodeURIComponent(dataUri));
      }, Object.assign(Object.assign({}, options), {
        viewBox: viewBox,
        serializeImages: true,
        preserveDimensions: Object.assign({}, size)
      }));
    }
  }, {
    key: "toPNG",
    value: function toPNG(callback) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.toDataURL(callback, Object.assign(Object.assign({}, options), {
        type: 'image/png'
      }));
    }
  }, {
    key: "toJPEG",
    value: function toJPEG(callback) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.toDataURL(callback, Object.assign(Object.assign({}, options), {
        type: 'image/jpeg'
      }));
    }
  }]);

  return FormatManager;
}(graph_base_Base);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/hook.js





var hook_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var hook_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};


































var hook_Decorator;

(function (Decorator) {
  function hook(nullable, hookName) {
    return function (target, methodName, descriptor) {
      var raw = descriptor.value;
      var name = hookName || methodName;

      descriptor.value = function () {
        var hook = this.options[name];

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (hook != null) {
          this.getNativeValue = raw.bind.apply(raw, [this].concat(args));
          var ret = main_namespaceObject.call.apply(main_namespaceObject, [hook, this.graph].concat(args));
          this.getNativeValue = null;

          if (ret != null || nullable === true && ret === null) {
            return ret;
          }
        }

        return raw.call.apply(raw, [this].concat(args));
      };
    };
  }

  Decorator.hook = hook;

  function after(hookName) {
    return function (target, methodName, descriptor) {
      var raw = descriptor.value;
      var name = hookName || methodName;

      descriptor.value = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var ret = raw.call.apply(raw, [this].concat(args));
        var hook = this.options[name];

        if (hook != null) {
          ret = main_namespaceObject.call.apply(main_namespaceObject, [hook, this.graph].concat(args)) && ret;
        }

        return ret;
      };
    };
  }

  Decorator.after = after;
})(hook_Decorator || (hook_Decorator = {}));

var hook_Hook = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(Hook, _Base);

  var _super = Object(createSuper["a" /* default */])(Hook);

  function Hook() {
    Object(classCallCheck["a" /* default */])(this, Hook);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Hook, [{
    key: "createModel",
    value: function createModel() {
      if (this.options.model) {
        return this.options.model;
      }

      var model = new model_Model();
      model.graph = this.graph;
      return model;
    }
  }, {
    key: "createView",
    value: function createView() {
      return new view_GraphView(this.graph);
    }
  }, {
    key: "createRenderer",
    value: function createRenderer() {
      return new renderer_Renderer(this.graph);
    }
  }, {
    key: "createDefsManager",
    value: function createDefsManager() {
      return new defs_DefsManager(this.graph);
    }
  }, {
    key: "createGridManager",
    value: function createGridManager() {
      return new grid_GridManager(this.graph);
    }
  }, {
    key: "createCoordManager",
    value: function createCoordManager() {
      return new coord_CoordManager(this.graph);
    }
  }, {
    key: "createTransform",
    value: function createTransform(node, widgetOptions) {
      var options = this.getTransformOptions(node);

      if (options.resizable || options.rotatable) {
        return new transform_Transform(Object.assign(Object.assign({
          node: node,
          graph: this.graph
        }, options), widgetOptions));
      }

      return null;
    }
  }, {
    key: "getTransformOptions",
    value: function getTransformOptions(node) {
      var resizing = options_Options.parseOptionGroup(this.graph, node, this.options.resizing);
      var rotating = options_Options.parseOptionGroup(this.graph, node, this.options.rotating);
      var transforming = options_Options.parseOptionGroup(this.graph, node, this.options.transforming);
      var options = Object.assign(Object.assign({}, transforming), {
        resizable: resizing.enabled,
        minWidth: resizing.minWidth,
        maxWidth: resizing.maxWidth,
        minHeight: resizing.minHeight,
        maxHeight: resizing.maxHeight,
        orthogonalResizing: resizing.orthogonal,
        preserveAspectRatio: resizing.preserveAspectRatio,
        rotatable: rotating.enabled,
        rotateGrid: rotating.grid
      });
      return options;
    }
  }, {
    key: "createTransformManager",
    value: function createTransformManager() {
      return new transform_TransformManager(this.graph);
    }
  }, {
    key: "createHighlightManager",
    value: function createHighlightManager() {
      return new highlight_HighlightManager(this.graph);
    }
  }, {
    key: "createBackgroundManager",
    value: function createBackgroundManager() {
      return new background_BackgroundManager(this.graph);
    }
  }, {
    key: "createClipboard",
    value: function createClipboard() {
      return new clipboard_Clipboard();
    }
  }, {
    key: "createClipboardManager",
    value: function createClipboardManager() {
      return new clipboard_ClipboardManager(this.graph);
    }
  }, {
    key: "createSnapline",
    value: function createSnapline() {
      return new snapline_Snapline(Object.assign({
        graph: this.graph
      }, this.options.snapline));
    }
  }, {
    key: "createSnaplineManager",
    value: function createSnaplineManager() {
      return new snapline_SnaplineManager(this.graph);
    }
  }, {
    key: "createSelection",
    value: function createSelection() {
      return new selection_Selection(Object.assign({
        graph: this.graph
      }, this.options.selecting));
    }
  }, {
    key: "createSelectionManager",
    value: function createSelectionManager() {
      return new selection_SelectionManager(this.graph);
    }
  }, {
    key: "allowRubberband",
    value: function allowRubberband(e) {
      return true;
    }
  }, {
    key: "createHistoryManager",
    value: function createHistoryManager() {
      return new history_HistoryManager(Object.assign({
        graph: this.graph
      }, this.options.history));
    }
  }, {
    key: "createScroller",
    value: function createScroller() {
      if (this.options.scroller.enabled) {
        return new scroller_Scroller(Object.assign({
          graph: this.graph
        }, this.options.scroller));
      }

      return null;
    }
  }, {
    key: "createScrollerManager",
    value: function createScrollerManager() {
      return new scroller_ScrollerManager(this.graph);
    }
  }, {
    key: "allowPanning",
    value: function allowPanning(e) {
      return true;
    }
  }, {
    key: "createMiniMap",
    value: function createMiniMap() {
      var _a = this.options.minimap,
          enabled = _a.enabled,
          options = hook_rest(_a, ["enabled"]);

      if (enabled) {
        var scroller = this.graph.scroller.widget;

        if (scroller == null) {
          throw new Error('Minimap requires scroller be enabled.');
        } else {
          return new minimap_MiniMap(Object.assign({
            scroller: scroller
          }, options));
        }
      }

      return null;
    }
  }, {
    key: "createMiniMapManager",
    value: function createMiniMapManager() {
      return new minimap_MiniMapManager(this.graph);
    }
  }, {
    key: "createKeyboard",
    value: function createKeyboard() {
      return new keyboard_Keyboard(Object.assign({
        graph: this.graph
      }, this.options.keyboard));
    }
  }, {
    key: "createMouseWheel",
    value: function createMouseWheel() {
      return new mousewheel_MouseWheel(Object.assign({
        graph: this.graph
      }, this.options.mousewheel));
    }
  }, {
    key: "createPrintManager",
    value: function createPrintManager() {
      return new print_PrintManager(this.graph);
    }
  }, {
    key: "createFormatManager",
    value: function createFormatManager() {
      return new format_FormatManager(this.graph);
    }
  }, {
    key: "allowMultiEdges",
    value: function allowMultiEdges(edge) {
      var multi = this.options.connecting.multi;

      if (typeof multi !== 'function') {
        return !!multi;
      }

      return main_namespaceObject.call(multi, this.graph, {
        edge: edge,
        sourceCell: edge.getSourceCell(),
        targetCell: edge.getTargetCell(),
        sourcePort: edge.getSourcePortId(),
        targetPort: edge.getTargetPortId()
      });
    }
  }, {
    key: "allowDanglingEdge",
    value: function allowDanglingEdge(edge) {
      var dangling = this.options.connecting.dangling;

      if (typeof dangling !== 'function') {
        return !!dangling;
      }

      return main_namespaceObject.call(dangling, this.graph, {
        edge: edge,
        sourceCell: edge.getSourceCell(),
        targetCell: edge.getTargetCell(),
        sourcePort: edge.getSourcePortId(),
        targetPort: edge.getTargetPortId()
      });
    }
  }, {
    key: "validateEdge",
    value: function validateEdge(edge, type, initialTerminal) {
      if (!this.allowMultiEdges(edge)) {
        var source = edge.getSource();
        var target = edge.getTarget();

        if (source.cell && target.cell) {
          var sourceCell = edge.getSourceCell();

          if (sourceCell) {
            var connectedEdges = this.model.getConnectedEdges(sourceCell, {
              outgoing: true
            });
            var sameEdges = connectedEdges.filter(function (link) {
              var s = link.getSource();
              var t = link.getTarget();
              return s && s.cell === source.cell && (!s.port || s.port === source.port) && t && t.cell === target.cell && (!t.port || t.port === target.port);
            });

            if (sameEdges.length > 1) {
              return false;
            }
          }
        }
      }

      if (!this.allowDanglingEdge(edge)) {
        var sourceId = edge.getSourceCellId();
        var targetId = edge.getTargetCellId();

        if (!(sourceId && targetId)) {
          return false;
        }
      }

      var validate = this.options.connecting.validateEdge;

      if (validate) {
        return main_namespaceObject.call(validate, this.graph, {
          edge: edge,
          type: type,
          previous: initialTerminal
        });
      }

      return true;
    }
  }, {
    key: "validateMagnet",
    value: function validateMagnet(cellView, magnet, e) {
      if (magnet.getAttribute('magnet') !== 'passive') {
        var validate = this.options.connecting.validateMagnet;

        if (validate) {
          return main_namespaceObject.call(validate, this.graph, {
            e: e,
            magnet: magnet,
            view: cellView,
            cell: cellView.cell
          });
        }

        return true;
      }

      return false;
    }
  }, {
    key: "getDefaultEdge",
    value: function getDefaultEdge(sourceView, sourceMagnet) {
      var edge;
      var create = this.options.connecting.createEdge;

      if (create) {
        edge = main_namespaceObject.call(create, this.graph, {
          sourceMagnet: sourceMagnet,
          sourceView: sourceView,
          sourceCell: sourceView.cell
        });
      }

      if (edge == null) {
        edge = new standard_edge_Edge();
      }

      return edge;
    }
  }, {
    key: "validateConnection",
    value: function validateConnection(sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView) {
      var validate = this.options.connecting.validateConnection;
      return validate ? main_namespaceObject.call(validate, this.graph, {
        edgeView: edgeView,
        sourceView: sourceView,
        sourceMagnet: sourceMagnet,
        targetView: targetView,
        targetMagnet: targetMagnet,
        sourceCell: sourceView ? sourceView.cell : null,
        targetCell: targetView ? targetView.cell : null,
        edge: edgeView ? edgeView.cell : null,
        type: terminalType
      }) : true;
    }
  }, {
    key: "onViewUpdated",
    value: function onViewUpdated(view, flag, options) {
      if (flag & renderer_Renderer.FLAG_INSERT || options.mounting) {
        return;
      }

      this.graph.renderer.requestConnectedEdgesUpdate(view, options);
    }
  }, {
    key: "onViewPostponed",
    value: function onViewPostponed(view, flag, options) {
      return this.graph.renderer.forcePostponedViewUpdate(view, flag);
    }
  }, {
    key: "getCellView",
    value: function getCellView(cell) {
      return null;
    }
  }, {
    key: "createCellView",
    value: function createCellView(cell) {
      var options = {
        interacting: this.options.interacting
      };
      var ctor = this.getCellView(cell);

      if (ctor) {
        return new ctor(cell, options);
      }

      var view = cell.view;

      if (view != null && typeof view === 'string') {
        var def = cell_CellView.registry.get(view);

        if (def) {
          return new def(cell, options);
        }

        return cell_CellView.registry.onNotFound(view);
      }

      if (cell.isNode()) {
        return new node_NodeView(cell, options);
      }

      if (cell.isEdge()) {
        return new edge_EdgeView(cell, options);
      }

      return null;
    }
  }, {
    key: "getHTMLComponent",
    value: function getHTMLComponent(node) {
      var ret = node.getHTML();

      if (typeof ret === 'string') {
        ret = html_HTML.componentRegistry.get(ret) || ret;
      }

      if (typeof ret === 'function') {
        return main_namespaceObject.call(ret, this.graph, node);
      }

      return ret;
    }
  }, {
    key: "onEdgeLabelRendered",
    value: function onEdgeLabelRendered(args) {}
  }, {
    key: "onPortRendered",
    value: function onPortRendered(args) {}
  }]);

  return Hook;
}(graph_base_Base);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createModel", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createView", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createRenderer", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createDefsManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createGridManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createCoordManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createTransform", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createTransformManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createHighlightManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createBackgroundManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createClipboard", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createClipboardManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createSnapline", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createSnaplineManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createSelection", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createSelectionManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "allowRubberband", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createHistoryManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createScroller", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createScrollerManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "allowPanning", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createMiniMap", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createMiniMapManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createKeyboard", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createMouseWheel", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createPrintManager", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "createFormatManager", null);

hook_decorate([hook_Decorator.after()], hook_Hook.prototype, "onViewUpdated", null);

hook_decorate([hook_Decorator.after()], hook_Hook.prototype, "onViewPostponed", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "getCellView", null);

hook_decorate([hook_Decorator.hook(true)], hook_Hook.prototype, "createCellView", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "getHTMLComponent", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "onEdgeLabelRendered", null);

hook_decorate([hook_Decorator.hook()], hook_Hook.prototype, "onPortRendered", null);
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/graph.js






var graph_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
































var graph_Graph = /*#__PURE__*/function (_Basecoat) {
  Object(inherits["a" /* default */])(Graph, _Basecoat);

  var _super = Object(createSuper["a" /* default */])(Graph);

  function Graph(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Graph);

    _this = _super.call(this);
    _this.options = options_Options.get(options);
    _this.css = new css_CSSManager(Object(assertThisInitialized["a" /* default */])(_this));
    _this.hook = new hook_Hook(Object(assertThisInitialized["a" /* default */])(_this));
    _this.view = _this.hook.createView();
    _this.defs = _this.hook.createDefsManager();
    _this.coord = _this.hook.createCoordManager();
    _this.transform = _this.hook.createTransformManager();
    _this.highlight = _this.hook.createHighlightManager();
    _this.grid = _this.hook.createGridManager();
    _this.background = _this.hook.createBackgroundManager();
    _this.model = _this.hook.createModel();
    _this.renderer = _this.hook.createRenderer();
    _this.clipboard = _this.hook.createClipboardManager();
    _this.snapline = _this.hook.createSnaplineManager();
    _this.selection = _this.hook.createSelectionManager();
    _this.history = _this.hook.createHistoryManager();
    _this.scroller = _this.hook.createScrollerManager();
    _this.minimap = _this.hook.createMiniMapManager();
    _this.keyboard = _this.hook.createKeyboard();
    _this.mousewheel = _this.hook.createMouseWheel();
    _this.print = _this.hook.createPrintManager();
    _this.format = _this.hook.createFormatManager();

    _this.setup();

    return _this;
  }

  Object(createClass["a" /* default */])(Graph, [{
    key: "setup",
    value: function setup() {
      var _this2 = this;

      this.model.on('sorted', function () {
        return _this2.trigger('model:sorted');
      });
      this.model.on('reseted', function (args) {
        return _this2.trigger('model:reseted', args);
      });
      this.model.on('updated', function (args) {
        return _this2.trigger('model:updated', args);
      });
    } // #region model

  }, {
    key: "resetCells",
    value: function resetCells(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.model.resetCells(cells, options);
      return this;
    }
  }, {
    key: "clearCells",
    value: function clearCells() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.model.clear(options);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.model.toJSON(options);
    }
  }, {
    key: "parseJSON",
    value: function parseJSON(data) {
      return this.model.parseJSON(data);
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.model.fromJSON(data, options);
      return this;
    }
  }, {
    key: "getCellById",
    value: function getCellById(id) {
      return this.model.getCell(id);
    }
  }, {
    key: "addNode",
    value: function addNode(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.addNode(node, options);
    }
  }, {
    key: "createNode",
    value: function createNode(metadata) {
      return this.model.createNode(metadata);
    }
  }, {
    key: "removeNode",
    value: function removeNode(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.removeCell(node);
    }
  }, {
    key: "addEdge",
    value: function addEdge(edge) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.addEdge(edge, options);
    }
  }, {
    key: "removeEdge",
    value: function removeEdge(edge) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.removeCell(edge);
    }
  }, {
    key: "createEdge",
    value: function createEdge(metadata) {
      return this.model.createEdge(metadata);
    }
  }, {
    key: "addCell",
    value: function addCell(cell) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.model.addCell(cell, options);
      return this;
    }
  }, {
    key: "removeCell",
    value: function removeCell(cell) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.removeCell(cell, options);
    }
  }, {
    key: "removeCells",
    value: function removeCells(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.removeCells(cells, options);
    }
  }, {
    key: "removeConnectedEdges",
    value: function removeConnectedEdges(cell) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.removeConnectedEdges(cell, options);
    }
  }, {
    key: "disconnectEdges",
    value: function disconnectEdges(cell, options) {
      this.model.disconnectEdges(cell, options);
      return this;
    }
  }, {
    key: "hasCell",
    value: function hasCell(cell) {
      return this.model.has(cell);
    }
  }, {
    key: "getCell",
    value: function getCell(id) {
      return this.model.getCell(id);
    }
  }, {
    key: "getCells",
    value: function getCells() {
      return this.model.getCells();
    }
  }, {
    key: "getCellCount",
    value: function getCellCount() {
      return this.model.total();
    }
    /**
     * Returns all the nodes in the graph.
     */

  }, {
    key: "getNodes",
    value: function getNodes() {
      return this.model.getNodes();
    }
    /**
     * Returns all the edges in the graph.
     */

  }, {
    key: "getEdges",
    value: function getEdges() {
      return this.model.getEdges();
    }
    /**
     * Returns all outgoing edges for the node.
     */

  }, {
    key: "getOutgoingEdges",
    value: function getOutgoingEdges(cell) {
      return this.model.getOutgoingEdges(cell);
    }
    /**
     * Returns all incoming edges for the node.
     */

  }, {
    key: "getIncomingEdges",
    value: function getIncomingEdges(cell) {
      return this.model.getIncomingEdges(cell);
    }
    /**
     * Returns edges connected with cell.
     */

  }, {
    key: "getConnectedEdges",
    value: function getConnectedEdges(cell) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.getConnectedEdges(cell, options);
    }
    /**
     * Returns an array of all the roots of the graph.
     */

  }, {
    key: "getRootCells",
    value: function getRootCells() {
      return this.model.getRoots();
    }
    /**
     * Returns an array of all the leafs of the graph.
     */

  }, {
    key: "getLeafCells",
    value: function getLeafCells() {
      return this.model.getLeafs();
    }
    /**
     * Returns `true` if the node is a root node, i.e.
     * there is no  edges coming to the node.
     */

  }, {
    key: "isOriginCell",
    value: function isOriginCell(cell) {
      return this.model.isOrigin(cell);
    }
    /**
     * Returns `true` if the node is a leaf node, i.e.
     * there is no edges going out from the node.
     */

  }, {
    key: "isLeafCell",
    value: function isLeafCell(cell) {
      return this.model.isLeaf(cell);
    }
    /**
     * Returns all the neighbors of node in the graph. Neighbors are all
     * the nodes connected to node via either incoming or outgoing edge.
     */

  }, {
    key: "getNeighbors",
    value: function getNeighbors(cell) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.getNeighbors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a neighbor of `cell1`.
     */

  }, {
    key: "isNeighbor",
    value: function isNeighbor(cell1, cell2) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.model.isNeighbor(cell1, cell2, options);
    }
  }, {
    key: "getSuccessors",
    value: function getSuccessors(cell, options) {
      return this.model.getSuccessors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a successor of `cell1`.
     */

  }, {
    key: "isSuccessor",
    value: function isSuccessor(cell1, cell2) {
      return this.model.isSuccessor(cell1, cell2);
    }
  }, {
    key: "getPredecessors",
    value: function getPredecessors(cell, options) {
      return this.model.getPredecessors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a predecessor of `cell1`.
     */

  }, {
    key: "isPredecessor",
    value: function isPredecessor(cell1, cell2) {
      return this.model.isPredecessor(cell1, cell2);
    }
  }, {
    key: "getCommonAncestor",
    value: function getCommonAncestor() {
      var _this$model;

      return (_this$model = this.model).getCommonAncestor.apply(_this$model, arguments);
    }
    /**
     * Returns an array of cells that result from finding nodes/edges that
     * are connected to any of the cells in the cells array. This function
     * loops over cells and if the current cell is a edge, it collects its
     * source/target nodes; if it is an node, it collects its incoming and
     * outgoing edges if both the edge terminal (source/target) are in the
     * cells array.
     */

  }, {
    key: "getSubGraph",
    value: function getSubGraph(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.getSubGraph(cells, options);
    }
    /**
     * Clones the whole subgraph (including all the connected links whose
     * source/target is in the subgraph). If `options.deep` is `true`, also
     * take into account all the embedded cells of all the subgraph cells.
     *
     * Returns a map of the form: { [original cell ID]: [clone] }.
     */

  }, {
    key: "cloneSubGraph",
    value: function cloneSubGraph(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.cloneSubGraph(cells, options);
    }
  }, {
    key: "cloneCells",
    value: function cloneCells(cells) {
      return this.model.cloneCells(cells);
    }
  }, {
    key: "getNodesFromPoint",
    value: function getNodesFromPoint(x, y) {
      return this.getNodesFromPoint(x, y);
    }
  }, {
    key: "getNodesInArea",
    value: function getNodesInArea(x, y, w, h, options) {
      return this.model.getNodesInArea(x, y, w, h, options);
    }
  }, {
    key: "getNodesUnderNode",
    value: function getNodesUnderNode(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.getNodesUnderNode(node, options);
    }
  }, {
    key: "searchCell",
    value: function searchCell(cell, iterator) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.model.search(cell, iterator, options);
      return this;
    }
    /***
     * Returns an array of IDs of nodes on the shortest
     * path between source and target.
     */

  }, {
    key: "getShortestPath",
    value: function getShortestPath(source, target) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.model.getShortestPath(source, target, options);
    }
    /**
     * Returns the bounding box that surrounds all cells in the graph.
     */

  }, {
    key: "getAllCellsBBox",
    value: function getAllCellsBBox() {
      return this.model.getAllCellsBBox();
    }
    /**
     * Returns the bounding box that surrounds all the given cells.
     */

  }, {
    key: "getCellsBBox",
    value: function getCellsBBox(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.model.getCellsBBox(cells, options);
    }
  }, {
    key: "startBatch",
    value: function startBatch(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.model.startBatch(name, data);
    }
  }, {
    key: "stopBatch",
    value: function stopBatch(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.model.stopBatch(name, data);
    }
  }, {
    key: "batchUpdate",
    value: function batchUpdate(name, execute, data) {
      this.startBatch(name, data);
      var result = execute();
      this.stopBatch(name, data);
      return result;
    } //#endregion
    // #region cell

  }, {
    key: "isNode",
    value: function isNode(cell) {
      return cell.isNode();
    }
  }, {
    key: "isEdge",
    value: function isEdge(cell) {
      return cell.isEdge();
    } // #endregion
    // #region node
    // #endregion
    // #region edge
    // #endregion
    // #region view

  }, {
    key: "isFrozen",
    value: function isFrozen() {
      return this.renderer.isFrozen();
    }
  }, {
    key: "freeze",
    value: function freeze() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.renderer.freeze(options);
      return this;
    }
  }, {
    key: "unfreeze",
    value: function unfreeze() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.renderer.unfreeze(options);
      return this;
    }
  }, {
    key: "isAsync",
    value: function isAsync() {
      return this.renderer.isAsync();
    }
  }, {
    key: "findView",
    value: function findView(ref) {
      if (ref instanceof cell_Cell) {
        return this.findViewByCell(ref);
      }

      return this.findViewByElem(ref);
    }
  }, {
    key: "findViews",
    value: function findViews(ref) {
      if (rectangle_Rectangle.isRectangleLike(ref)) {
        return this.findViewsInArea(ref);
      }

      if (point_Point.isPointLike(ref)) {
        return this.findViewsFromPoint(ref);
      }

      return [];
    }
  }, {
    key: "findViewByCell",
    value: function findViewByCell(cell) {
      return this.renderer.findViewByCell(cell);
    }
  }, {
    key: "findViewByElem",
    value: function findViewByElem(elem) {
      return this.renderer.findViewByElem(elem);
    }
  }, {
    key: "findViewsFromPoint",
    value: function findViewsFromPoint(x, y) {
      var p = typeof x === 'number' ? {
        x: x,
        y: y
      } : x;
      return this.renderer.findViewsFromPoint(p);
    }
  }, {
    key: "findViewsInArea",
    value: function findViewsInArea(x, y, width, height, options) {
      var rect = typeof x === 'number' ? {
        x: x,
        y: y,
        width: width,
        height: height
      } : x;
      var localOptions = typeof x === 'number' ? options : y;
      return this.renderer.findViewsInArea(rect, localOptions);
    }
  }, {
    key: "isViewMounted",
    value: function isViewMounted(view) {
      return this.renderer.isViewMounted(view);
    }
  }, {
    key: "getMountedViews",
    value: function getMountedViews() {
      return this.renderer.getMountedViews();
    }
  }, {
    key: "getUnmountedViews",
    value: function getUnmountedViews() {
      return this.renderer.getUnmountedViews();
    }
  }, {
    key: "matrix",
    value: function matrix(mat) {
      if (typeof mat === 'undefined') {
        return this.transform.getMatrix();
      }

      this.transform.setMatrix(mat);
      return this;
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      if (this.scroller.widget) {
        this.scroller.resize(width, height);
      } else {
        this.transform.resize(width, height);
      }

      return this;
    }
  }, {
    key: "resizeGraph",
    value: function resizeGraph(width, height) {
      this.transform.resize(width, height);
      return this;
    }
  }, {
    key: "resizeScroller",
    value: function resizeScroller(width, height) {
      this.scroller.resize(width, height);
      return this;
    }
  }, {
    key: "getScale",
    value: function getScale() {
      return this.scale();
    }
  }, {
    key: "scale",
    value: function scale(sx) {
      var sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sx;
      var ox = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var oy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      if (typeof sx === 'undefined') {
        return this.transform.getScale();
      }

      this.transform.scale(sx, sy, ox, oy);
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(angle, cx, cy) {
      if (typeof angle === 'undefined') {
        return this.transform.getRotation();
      }

      this.transform.rotate(angle, cx, cy);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      if (typeof tx === 'undefined') {
        return this.transform.getTranslation();
      }

      this.transform.translate(tx, ty);
      return this;
    }
  }, {
    key: "setOrigin",
    value: function setOrigin(ox, oy) {
      return this.translate(ox || 0, oy || 0);
    }
  }, {
    key: "fitToContent",
    value: function fitToContent(gridWidth, gridHeight, padding, options) {
      return this.transform.fitToContent(gridWidth, gridHeight, padding, options);
    }
  }, {
    key: "scaleContentToFit",
    value: function scaleContentToFit() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.transform.scaleContentToFit(options);
      return this;
    }
  }, {
    key: "getContentArea",
    value: function getContentArea() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.transform.getContentArea(options);
    }
  }, {
    key: "getContentBBox",
    value: function getContentBBox() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.transform.getContentBBox(options);
    }
  }, {
    key: "getArea",
    value: function getArea() {
      return this.transform.getArea();
    }
  }, {
    key: "getRestrictArea",
    value: function getRestrictArea(view) {
      return this.transform.getRestrictArea(view);
    } // #endregion
    // #region coord

  }, {
    key: "getClientMatrix",
    value: function getClientMatrix() {
      return this.coord.getClientMatrix();
    }
    /**
     * Returns coordinates of the graph viewport, relative to the window.
     */

  }, {
    key: "getClientOffset",
    value: function getClientOffset() {
      return this.coord.getClientOffset();
    }
    /**
     * Returns coordinates of the graph viewport, relative to the document.
     */

  }, {
    key: "getPageOffset",
    value: function getPageOffset() {
      return this.coord.getPageOffset();
    }
  }, {
    key: "snapToGrid",
    value: function snapToGrid(x, y) {
      return this.coord.snapToGrid(x, y);
    }
  }, {
    key: "localToGraphPoint",
    value: function localToGraphPoint(x, y) {
      return this.coord.localToGraphPoint(x, y);
    }
  }, {
    key: "localToClientPoint",
    value: function localToClientPoint(x, y) {
      return this.coord.localToClientPoint(x, y);
    }
  }, {
    key: "localToPagePoint",
    value: function localToPagePoint(x, y) {
      return this.coord.localToPagePoint(x, y);
    }
  }, {
    key: "localToGraphRect",
    value: function localToGraphRect(x, y, width, height) {
      return this.coord.localToGraphRect(x, y, width, height);
    }
  }, {
    key: "localToClientRect",
    value: function localToClientRect(x, y, width, height) {
      return this.coord.localToClientRect(x, y, width, height);
    }
  }, {
    key: "localToPageRect",
    value: function localToPageRect(x, y, width, height) {
      return this.coord.localToPageRect(x, y, width, height);
    }
  }, {
    key: "graphToLocalPoint",
    value: function graphToLocalPoint(x, y) {
      return this.coord.graphToLocalPoint(x, y);
    }
  }, {
    key: "clientToLocalPoint",
    value: function clientToLocalPoint(x, y) {
      return this.coord.clientToLocalPoint(x, y);
    }
  }, {
    key: "pageToLocalPoint",
    value: function pageToLocalPoint(x, y) {
      return this.coord.pageToLocalPoint(x, y);
    }
  }, {
    key: "graphToLocalRect",
    value: function graphToLocalRect(x, y, width, height) {
      return this.coord.graphToLocalRect(x, y, width, height);
    }
  }, {
    key: "clientToLocalRect",
    value: function clientToLocalRect(x, y, width, height) {
      return this.coord.clientToLocalRect(x, y, width, height);
    }
  }, {
    key: "pageToLocalRect",
    value: function pageToLocalRect(x, y, width, height) {
      return this.coord.pageToLocalRect(x, y, width, height);
    } // #endregion
    // #region defs

  }, {
    key: "defineFilter",
    value: function defineFilter(options) {
      return this.defs.filter(options);
    }
  }, {
    key: "defineGradient",
    value: function defineGradient(options) {
      return this.defs.gradient(options);
    }
  }, {
    key: "defineMarker",
    value: function defineMarker(options) {
      return this.defs.marker(options);
    } // #endregion
    // #region grid

  }, {
    key: "getGridSize",
    value: function getGridSize() {
      return this.grid.getGridSize();
    }
  }, {
    key: "setGridSize",
    value: function setGridSize(gridSize) {
      this.grid.setGridSize(gridSize);
      return this;
    }
  }, {
    key: "showGrid",
    value: function showGrid() {
      this.grid.show();
      return this;
    }
  }, {
    key: "hideGrid",
    value: function hideGrid() {
      this.grid.hide();
      return this;
    }
  }, {
    key: "clearGrid",
    value: function clearGrid() {
      this.grid.clear();
      return this;
    }
  }, {
    key: "drawGrid",
    value: function drawGrid(options) {
      this.grid.draw(options);
      return this;
    } // #endregion
    // #region background

  }, {
    key: "updateBackground",
    value: function updateBackground() {
      this.background.update();
      return this;
    }
  }, {
    key: "drawBackground",
    value: function drawBackground(options) {
      this.background.draw(options);
      return this;
    }
  }, {
    key: "clearBackground",
    value: function clearBackground() {
      this.background.clear();
      return this;
    } // #endregion
    // #region clipboard

  }, {
    key: "isClipboardEnabled",
    value: function isClipboardEnabled() {
      return !this.clipboard.disabled;
    }
  }, {
    key: "enableClipboard",
    value: function enableClipboard() {
      this.clipboard.enable();
      return this;
    }
  }, {
    key: "disableClipboard",
    value: function disableClipboard() {
      this.clipboard.disable();
      return this;
    }
  }, {
    key: "toggleClipboard",
    value: function toggleClipboard(enabled) {
      if (enabled != null) {
        if (enabled !== this.isClipboardEnabled()) {
          if (enabled) {
            this.enableClipboard();
          } else {
            this.disableClipboard();
          }
        }
      } else {
        if (this.isClipboardEnabled()) {
          this.disableClipboard();
        } else {
          this.enableClipboard();
        }
      }

      return this;
    }
  }, {
    key: "isClipboardEmpty",
    value: function isClipboardEmpty() {
      return this.clipboard.isEmpty();
    }
  }, {
    key: "getCellsInClipboard",
    value: function getCellsInClipboard() {
      return this.clipboard.cells;
    }
  }, {
    key: "cleanClipboard",
    value: function cleanClipboard() {
      this.clipboard.clean();
      return this;
    }
  }, {
    key: "copy",
    value: function copy(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.clipboard.copy(cells, options);
      return this;
    }
  }, {
    key: "cut",
    value: function cut(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.clipboard.cut(cells, options);
      return this;
    }
  }, {
    key: "paste",
    value: function paste() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var graph = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
      return this.clipboard.paste(options, graph);
    } // #endregion
    // #region redo/undo

  }, {
    key: "isHistoryEnabled",
    value: function isHistoryEnabled() {
      return !this.history.disabled;
    }
  }, {
    key: "enableHistory",
    value: function enableHistory() {
      this.history.enable();
      return this;
    }
  }, {
    key: "disableHistory",
    value: function disableHistory() {
      this.history.disable();
      return this;
    }
  }, {
    key: "toggleHistory",
    value: function toggleHistory(enabled) {
      if (enabled != null) {
        if (enabled !== this.isHistoryEnabled()) {
          if (enabled) {
            this.enableHistory();
          } else {
            this.disableHistory();
          }
        }
      } else {
        if (this.isHistoryEnabled()) {
          this.disableHistory();
        } else {
          this.enableHistory();
        }
      }

      return this;
    }
  }, {
    key: "undo",
    value: function undo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.history.undo(options);
      return this;
    }
  }, {
    key: "undoAndCancel",
    value: function undoAndCancel() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.history.cancel(options);
      return this;
    }
  }, {
    key: "redo",
    value: function redo() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.history.redo(options);
      return this;
    }
  }, {
    key: "canUndo",
    value: function canUndo() {
      return this.history.canUndo();
    }
  }, {
    key: "canRedo",
    value: function canRedo() {
      return this.history.canRedo();
    }
  }, {
    key: "cleanHistory",
    value: function cleanHistory() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.history.clean(options);
    } // #endregion
    // #region keyboard

  }, {
    key: "isKeyboardEnabled",
    value: function isKeyboardEnabled() {
      return !this.keyboard.disabled;
    }
  }, {
    key: "enableKeyboard",
    value: function enableKeyboard() {
      this.keyboard.enable();
      return this;
    }
  }, {
    key: "disableKeyboard",
    value: function disableKeyboard() {
      this.keyboard.disable();
      return this;
    }
  }, {
    key: "toggleKeyboard",
    value: function toggleKeyboard(enabled) {
      if (enabled != null) {
        if (enabled !== this.isKeyboardEnabled()) {
          if (enabled) {
            this.enableKeyboard();
          } else {
            this.disableKeyboard();
          }
        }
      } else {
        if (this.isKeyboardEnabled()) {
          this.disableKeyboard();
        } else {
          this.enableKeyboard();
        }
      }

      return this;
    }
  }, {
    key: "bindKey",
    value: function bindKey(keys, callback, action) {
      this.keyboard.on(keys, callback, action);
      return this;
    }
  }, {
    key: "unbindKey",
    value: function unbindKey(keys, action) {
      this.keyboard.off(keys, action);
      return this;
    } // #endregion
    // #region mousewheel

  }, {
    key: "isMouseWheelEnabled",
    value: function isMouseWheelEnabled() {
      return !this.mousewheel.disabled;
    }
  }, {
    key: "enableMouseWheel",
    value: function enableMouseWheel() {
      this.mousewheel.enable();
      return this;
    }
  }, {
    key: "disableMouseWheel",
    value: function disableMouseWheel() {
      this.mousewheel.disable();
      return this;
    } // #endregion
    // #region scroller

  }, {
    key: "lockScroller",
    value: function lockScroller() {
      var _a;

      (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.lock();
    }
  }, {
    key: "unlockScroller",
    value: function unlockScroller() {
      var _a;

      (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.unlock();
    }
  }, {
    key: "updateScroller",
    value: function updateScroller() {
      var _a;

      (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.update();
    }
  }, {
    key: "getScrollbarPosition",
    value: function getScrollbarPosition() {
      var scroller = this.scroller.widget;
      return scroller.scrollbarPosition();
    }
  }, {
    key: "setScrollbarPosition",
    value: function setScrollbarPosition(left, top, options) {
      var scroller = this.scroller.widget;
      scroller.scrollbarPosition(left, top, options);
      return this;
    }
    /**
     * Try to scroll to ensure that the position (x,y) on the graph (in local
     * coordinates) is at the center of the viewport. If only one of the
     * coordinates is specified, only scroll in the specified dimension and
     * keep the other coordinate unchanged.
     */

  }, {
    key: "scrollToPoint",
    value: function scrollToPoint(x, y, options) {
      var scroller = this.scroller.widget;
      scroller.scrollToPoint(x, y, options);
      return this;
    }
    /**
     * Try to scroll to ensure that the center of graph content is at the
     * center of the viewport.
     */

  }, {
    key: "scrollToContent",
    value: function scrollToContent(options) {
      var scroller = this.scroller.widget;
      scroller.scrollToContent(options);
      return this;
    }
    /**
     * Try to scroll to ensure that the center of cell is at the center of
     * the viewport.
     */

  }, {
    key: "scrollToCell",
    value: function scrollToCell(cell, options) {
      var scroller = this.scroller.widget;
      scroller.scrollToCell(cell, options);
      return this;
    }
    /**
     * Position the center of graph to the center of the viewport.
     */

  }, {
    key: "center",
    value: function center(optons) {
      return this.centerPoint(optons);
    }
  }, {
    key: "centerPoint",
    value: function centerPoint(x, y, options) {
      var scroller = this.scroller.widget;
      scroller.centerPoint(x, y, options);
      return this;
    }
  }, {
    key: "centerContent",
    value: function centerContent(options) {
      var scroller = this.scroller.widget;
      scroller.centerContent(options);
      return this;
    }
  }, {
    key: "centerCell",
    value: function centerCell(cell, options) {
      var scroller = this.scroller.widget;
      scroller.centerCell(cell, options);
      return this;
    }
  }, {
    key: "positionContent",
    value: function positionContent(pos, options) {
      var scroller = this.scroller.widget;
      scroller.positionContent(pos, options);
      return this;
    }
  }, {
    key: "positionCell",
    value: function positionCell(cell, direction, options) {
      var scroller = this.scroller.widget;
      scroller.positionCell(cell, direction, options);
      return this;
    }
  }, {
    key: "positionRect",
    value: function positionRect(rect, direction, options) {
      var scroller = this.scroller.widget;
      scroller.positionRect(rect, direction, options);
      return this;
    }
  }, {
    key: "positionPoint",
    value: function positionPoint(point, x, y) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var scroller = this.scroller.widget;
      scroller.positionPoint(point, x, y, options);
      return this;
    }
  }, {
    key: "zoom",
    value: function zoom(factor, options) {
      var scroller = this.scroller.widget;

      if (factor == null) {
        return scroller.zoom();
      }

      scroller.zoom(factor, options);
      return this;
    }
  }, {
    key: "zoomTo",
    value: function zoomTo(factor) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var scroller = this.scroller.widget;
      scroller.zoom(factor, Object.assign(Object.assign({}, options), {
        absolute: true
      }));
    }
  }, {
    key: "zoomToRect",
    value: function zoomToRect(rect) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var scroller = this.scroller.widget;
      scroller.zoomToRect(rect, options);
      return this;
    }
  }, {
    key: "zoomToFit",
    value: function zoomToFit() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var scroller = this.scroller.widget;
      scroller.zoomToFit(options);
      return this;
    }
  }, {
    key: "transitionToPoint",
    value: function transitionToPoint(x, y, options) {
      var scroller = this.scroller.widget;
      scroller.transitionToPoint(x, y, options);
      return this;
    }
  }, {
    key: "transitionToRect",
    value: function transitionToRect(rect) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var scroller = this.scroller.widget;
      scroller.transitionToRect(rect, options);
      return this;
    }
  }, {
    key: "isPannable",
    value: function isPannable() {
      return this.scroller.pannable;
    }
  }, {
    key: "enablePanning",
    value: function enablePanning() {
      this.scroller.enablePanning();
      return this;
    }
  }, {
    key: "disablePanning",
    value: function disablePanning() {
      this.scroller.disablePanning();
      return this;
    }
  }, {
    key: "togglePanning",
    value: function togglePanning(pannable) {
      if (pannable == null) {
        if (this.isPannable()) {
          this.disablePanning();
        } else {
          this.enablePanning();
        }
      } else {
        if (pannable !== this.isPannable()) {
          if (pannable) {
            this.enablePanning();
          } else {
            this.disablePanning();
          }
        }
      }

      return this;
    } // #endregion
    // #region selection

  }, {
    key: "isSelectionEnabled",
    value: function isSelectionEnabled() {
      return !this.selection.disabled;
    }
  }, {
    key: "enableSelection",
    value: function enableSelection() {
      this.selection.enable();
      return this;
    }
  }, {
    key: "disableSelection",
    value: function disableSelection() {
      this.selection.disable();
      return this;
    }
  }, {
    key: "toggleSelection",
    value: function toggleSelection(enabled) {
      if (enabled != null) {
        if (enabled !== this.isSelectionEnabled()) {
          if (enabled) {
            this.enableSelection();
          } else {
            this.disableSelection();
          }
        }
      } else {
        if (this.isSelectionEnabled()) {
          this.disableSelection();
        } else {
          this.enableSelection();
        }
      }

      return this;
    }
  }, {
    key: "isMultipleSelection",
    value: function isMultipleSelection() {
      return this.selection.isMultiple();
    }
  }, {
    key: "enableMultipleSelection",
    value: function enableMultipleSelection() {
      this.selection.enableMultiple();
      return this;
    }
  }, {
    key: "disableMultipleSelection",
    value: function disableMultipleSelection() {
      this.selection.disableMultiple();
      return this;
    }
  }, {
    key: "toggleMultipleSelection",
    value: function toggleMultipleSelection(multiple) {
      if (multiple != null) {
        if (multiple !== this.isMultipleSelection()) {
          if (multiple) {
            this.enableMultipleSelection();
          } else {
            this.disableMultipleSelection();
          }
        }
      } else {
        if (this.isMultipleSelection()) {
          this.disableMultipleSelection();
        } else {
          this.enableMultipleSelection();
        }
      }

      return this;
    }
  }, {
    key: "isSelectionMovable",
    value: function isSelectionMovable() {
      return this.selection.widget.options.movable !== false;
    }
  }, {
    key: "enableSelectionMovable",
    value: function enableSelectionMovable() {
      this.selection.widget.options.movable = true;
      return this;
    }
  }, {
    key: "disableSelectionMovable",
    value: function disableSelectionMovable() {
      this.selection.widget.options.movable = false;
      return this;
    }
  }, {
    key: "toggleSelectionMovable",
    value: function toggleSelectionMovable(movable) {
      if (movable != null) {
        if (movable !== this.isSelectionMovable()) {
          if (movable) {
            this.enableSelectionMovable();
          } else {
            this.disableSelectionMovable();
          }
        }
      } else {
        if (this.isSelectionMovable()) {
          this.disableSelectionMovable();
        } else {
          this.enableSelectionMovable();
        }
      }

      return this;
    }
  }, {
    key: "isRubberbandEnabled",
    value: function isRubberbandEnabled() {
      return !this.selection.rubberbandDisabled;
    }
  }, {
    key: "enableRubberband",
    value: function enableRubberband() {
      this.selection.enableRubberband();
      return this;
    }
  }, {
    key: "disableRubberband",
    value: function disableRubberband() {
      this.selection.disableRubberband();
      return this;
    }
  }, {
    key: "toggleRubberband",
    value: function toggleRubberband(enabled) {
      if (enabled != null) {
        if (enabled !== this.isRubberbandEnabled()) {
          if (enabled) {
            this.enableRubberband();
          } else {
            this.disableRubberband();
          }
        }
      } else {
        if (this.isRubberbandEnabled()) {
          this.disableRubberband();
        } else {
          this.enableRubberband();
        }
      }

      return this;
    }
  }, {
    key: "isStrictRubberband",
    value: function isStrictRubberband() {
      return this.selection.widget.options.strict === true;
    }
  }, {
    key: "enableStrictRubberband",
    value: function enableStrictRubberband() {
      this.selection.widget.options.strict = true;
      return this;
    }
  }, {
    key: "disableStrictRubberband",
    value: function disableStrictRubberband() {
      this.selection.widget.options.strict = false;
      return this;
    }
  }, {
    key: "toggleStrictRubberband",
    value: function toggleStrictRubberband(strict) {
      if (strict != null) {
        if (strict !== this.isStrictRubberband()) {
          if (strict) {
            this.enableStrictRubberband();
          } else {
            this.disableStrictRubberband();
          }
        }
      } else {
        if (this.isStrictRubberband()) {
          this.disableStrictRubberband();
        } else {
          this.enableStrictRubberband();
        }
      }

      return this;
    }
  }, {
    key: "setRubberbandModifiers",
    value: function setRubberbandModifiers(modifiers) {
      this.selection.setModifiers(modifiers);
    }
  }, {
    key: "setSelectionFilter",
    value: function setSelectionFilter(filter) {
      this.selection.setFilter(filter);
      return this;
    }
  }, {
    key: "setSelectionDisplayContent",
    value: function setSelectionDisplayContent(content) {
      this.selection.setContent(content);
      return this;
    }
  }, {
    key: "isSelectionEmpty",
    value: function isSelectionEmpty() {
      return this.selection.isEmpty();
    }
  }, {
    key: "cleanSelection",
    value: function cleanSelection() {
      this.selection.clean();
      return this;
    }
  }, {
    key: "resetSelection",
    value: function resetSelection(cells) {
      this.selection.reset(cells);
      return this;
    }
  }, {
    key: "getSelectedCells",
    value: function getSelectedCells() {
      return this.selection.cells;
    }
  }, {
    key: "getSelectedCellCount",
    value: function getSelectedCellCount() {
      return this.selection.length;
    }
  }, {
    key: "isSelected",
    value: function isSelected(cell) {
      return this.selection.isSelected(cell);
    }
  }, {
    key: "select",
    value: function select(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.selection.select(cells, options);
      return this;
    }
  }, {
    key: "unselect",
    value: function unselect(cells) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.selection.unselect(cells, options);
      return this;
    } // #endregion
    // #region snapline

  }, {
    key: "isSnaplineEnabled",
    value: function isSnaplineEnabled() {
      return !this.snapline.widget.disabled;
    }
  }, {
    key: "enableSnapline",
    value: function enableSnapline() {
      this.snapline.widget.enable();
      return this;
    }
  }, {
    key: "disableSnapline",
    value: function disableSnapline() {
      this.snapline.widget.disable();
      return this;
    }
  }, {
    key: "toggleSnapline",
    value: function toggleSnapline(enabled) {
      if (enabled != null) {
        if (enabled !== this.isSnaplineEnabled()) {
          if (enabled) {
            this.enableSnapline();
          } else {
            this.disableSnapline();
          }
        }
      } else {
        if (this.isSnaplineEnabled()) {
          this.disableSnapline();
        } else {
          this.enableSnapline();
        }

        return this;
      }
    }
  }, {
    key: "hideSnapline",
    value: function hideSnapline() {
      this.snapline.widget.hide();
      return this;
    }
  }, {
    key: "setSnaplineFilter",
    value: function setSnaplineFilter(filter) {
      this.snapline.widget.setFilter(filter);
      return this;
    }
  }, {
    key: "isSnaplineOnResizingEnabled",
    value: function isSnaplineOnResizingEnabled() {
      return this.snapline.widget.options.resizing === true;
    }
  }, {
    key: "enableSnaplineOnResizing",
    value: function enableSnaplineOnResizing() {
      this.snapline.widget.options.resizing = true;
      return this;
    }
  }, {
    key: "disableSnaplineOnResizing",
    value: function disableSnaplineOnResizing() {
      this.snapline.widget.options.resizing = false;
      return this;
    }
  }, {
    key: "toggleSnaplineOnResizing",
    value: function toggleSnaplineOnResizing(enableOnResizing) {
      if (enableOnResizing != null) {
        if (enableOnResizing !== this.isSnaplineOnResizingEnabled()) {
          if (enableOnResizing) {
            this.enableSnaplineOnResizing();
          } else {
            this.disableSnaplineOnResizing();
          }
        }
      } else {
        if (this.isSnaplineOnResizingEnabled()) {
          this.disableSnaplineOnResizing();
        } else {
          this.enableSnaplineOnResizing();
        }
      }

      return this;
    }
  }, {
    key: "isSharpSnapline",
    value: function isSharpSnapline() {
      return this.snapline.widget.options.sharp === true;
    }
  }, {
    key: "enableSharpSnapline",
    value: function enableSharpSnapline() {
      this.snapline.widget.options.sharp = true;
      return this;
    }
  }, {
    key: "disableSharpSnapline",
    value: function disableSharpSnapline() {
      this.snapline.widget.options.sharp = false;
      return this;
    }
  }, {
    key: "toggleSharpSnapline",
    value: function toggleSharpSnapline(sharp) {
      if (sharp != null) {
        if (sharp !== this.isSharpSnapline()) {
          if (sharp) {
            this.enableSharpSnapline();
          } else {
            this.disableSharpSnapline();
          }
        }
      } else {
        if (this.isSharpSnapline()) {
          this.disableSharpSnapline();
        } else {
          this.enableSharpSnapline();
        }
      }

      return this;
    }
  }, {
    key: "getSnaplineTolerance",
    value: function getSnaplineTolerance() {
      return this.snapline.widget.options.tolerance;
    }
  }, {
    key: "setSnaplineTolerance",
    value: function setSnaplineTolerance(tolerance) {
      this.snapline.widget.options.tolerance = tolerance;
      return this;
    } // #endregion
    // #region tools

  }, {
    key: "removeTools",
    value: function removeTools() {
      this.emit('tools:remove');
      return this;
    }
  }, {
    key: "hideTools",
    value: function hideTools() {
      this.emit('tools:hide');
      return this;
    }
  }, {
    key: "showTools",
    value: function showTools() {
      this.emit('tools:show');
      return this;
    } // #endregion
    // #region format

  }, {
    key: "toSVG",
    value: function toSVG(callback) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.format.toSVG(callback, options);
    }
  }, {
    key: "toDataURL",
    value: function toDataURL(callback, options) {
      this.format.toDataURL(callback, options);
    }
  }, {
    key: "toPNG",
    value: function toPNG(callback) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.format.toPNG(callback, options);
    }
  }, {
    key: "toJPEG",
    value: function toJPEG(callback) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.format.toJPEG(callback, options);
    } // #endregion
    // #region print

  }, {
    key: "printPreview",
    value: function printPreview(options) {
      this.print.show(options);
    } // #endregion
    // #region dispose

  }, {
    key: "dispose",
    value: function dispose() {
      this.view.dispose();
      this.renderer.dispose();
    }
  }, {
    key: "container",
    get: function get() {
      return this.view.container;
    }
  }]);

  return Graph;
}(basecoat_Basecoat);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "lockScroller", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "unlockScroller", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "updateScroller", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "getScrollbarPosition", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "setScrollbarPosition", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "scrollToPoint", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "scrollToContent", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "scrollToCell", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "centerPoint", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "centerContent", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "centerCell", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "positionContent", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "positionCell", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "positionRect", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "positionPoint", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "zoom", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "zoomTo", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "zoomToRect", null);

graph_decorate([decorator_Decorator.checkScroller()], graph_Graph.prototype, "zoomToFit", null);

graph_decorate([basecoat_Basecoat.dispose()], graph_Graph.prototype, "dispose", null);

(function (Graph) {
  Graph.View = view_GraphView;
  Graph.Hook = hook_Hook;
  Graph.Renderer = renderer_Renderer;
  Graph.Keyboard = keyboard_Keyboard;
  Graph.MouseWheel = mousewheel_MouseWheel;
  Graph.BaseManager = graph_base_Base;
  Graph.DefsManager = defs_DefsManager;
  Graph.GridManager = grid_GridManager;
  Graph.CoordManager = coord_CoordManager;
  Graph.PrintManager = print_PrintManager;
  Graph.FormatManager = format_FormatManager;
  Graph.MiniMapManager = minimap_MiniMapManager;
  Graph.HistoryManager = history_HistoryManager;
  Graph.SnaplineManager = snapline_SnaplineManager;
  Graph.ScrollerManager = scroller_ScrollerManager;
  Graph.ClipboardManager = clipboard_ClipboardManager;
  Graph.TransformManager = transform_TransformManager;
  Graph.HighlightManager = highlight_HighlightManager;
  Graph.BackgroundManager = background_BackgroundManager;
  Graph.SelectionManager = selection_SelectionManager;
})(graph_Graph || (graph_Graph = {}));

(function (Graph) {
  function render(options, data) {
    var graph = options instanceof HTMLElement ? new Graph({
      container: options
    }) : new Graph(options);

    if (data != null) {
      graph.fromJSON(data);
    }

    return graph;
  }

  Graph.render = render;
})(graph_Graph || (graph_Graph = {}));

(function (Graph) {
  Graph.registerNode = node_Node.registry.register;
  Graph.registerEdge = edge_Edge.registry.register;
  Graph.registerView = cell_CellView.registry.register;
  Graph.registerAttr = attr_Attr.registry.register;
  Graph.registerGrid = grid_Grid.registry.register;
  Graph.registerFilter = filter_Filter.registry.register;
  Graph.registerNodeTool = tool_NodeTool.registry.register;
  Graph.registerEdgeTool = tool_EdgeTool.registry.register;
  Graph.registerBackground = background_Background.registry.register;
  Graph.registerHighlighter = highlighter_Highlighter.registry.register;
  Graph.registerPortLayout = port_layout_PortLayout.registry.register;
  Graph.registerPortLabelLayout = port_label_layout_PortLabelLayout.registry.register;
  Graph.registerMarker = marker_Marker.registry.register;
  Graph.registerRouter = router_Router.registry.register;
  Graph.registerConnector = connector_Connector.registry.register;
  Graph.registerAnchor = node_anchor_NodeAnchor.registry.register;
  Graph.registerEdgeAnchor = edge_anchor_EdgeAnchor.registry.register;
  Graph.registerConnectionPoint = connection_point_ConnectionPoint.registry.register;
  Graph.registerConnectionStrategy = connection_strategy_ConnectionStrategy.registry.register;
  Graph.registerHTMLComponent = html_HTML.componentRegistry.register;
})(graph_Graph || (graph_Graph = {}));

(function (Graph) {
  Graph.unregisterNode = node_Node.registry.unregister;
  Graph.unregisterEdge = edge_Edge.registry.unregister;
  Graph.unregisterView = cell_CellView.registry.unregister;
  Graph.unregisterAttr = attr_Attr.registry.unregister;
  Graph.unregisterGrid = grid_Grid.registry.unregister;
  Graph.unregisterFilter = filter_Filter.registry.unregister;
  Graph.unregisterNodeTool = tool_NodeTool.registry.unregister;
  Graph.unregisterEdgeTool = tool_EdgeTool.registry.unregister;
  Graph.unregisterBackground = background_Background.registry.unregister;
  Graph.unregisterHighlighter = highlighter_Highlighter.registry.unregister;
  Graph.unregisterPortLayout = port_layout_PortLayout.registry.unregister;
  Graph.unregisterPortLabelLayout = port_label_layout_PortLabelLayout.registry.unregister;
  Graph.unregisterMarker = marker_Marker.registry.unregister;
  Graph.unregisterRouter = router_Router.registry.unregister;
  Graph.unregisterConnector = connector_Connector.registry.unregister;
  Graph.unregisterAnchor = node_anchor_NodeAnchor.registry.unregister;
  Graph.unregisterEdgeAnchor = edge_anchor_EdgeAnchor.registry.unregister;
  Graph.unregisterConnectionPoint = connection_point_ConnectionPoint.registry.unregister;
  Graph.unregisterConnectionStrategy = connection_strategy_ConnectionStrategy.registry.unregister;
  Graph.unregisterHTMLComponent = html_HTML.componentRegistry.unregister;
})(graph_Graph || (graph_Graph = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/graph/index.js

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/util.js


var util_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



function util_getMarkup(tagName) {
  var noText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return "<g class=\"rotatable\"><g class=\"scalable\"><".concat(tagName, "/></g>").concat(noText ? '' : '<text/>', "</g>");
}
function util_getName(name) {
  return "basic.".concat(name);
}
function getImageUrlHook() {
  var attrName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'xlink:href';

  var hook = function hook(metadata) {
    var imageUrl = metadata.imageUrl,
        imageWidth = metadata.imageWidth,
        imageHeight = metadata.imageHeight,
        others = util_rest(metadata, ["imageUrl", "imageWidth", "imageHeight"]);

    if (imageUrl != null || imageWidth != null || imageHeight != null) {
      var apply = function apply() {
        if (others.attrs) {
          var image = others.attrs.image;

          if (imageUrl != null) {
            image[attrName] = imageUrl;
          }

          if (imageWidth != null) {
            image.width = imageWidth;
          }

          if (imageHeight != null) {
            image.height = imageHeight;
          }

          others.attrs.image = image;
        }
      };

      if (others.attrs) {
        if (others.attrs.image == null) {
          others.attrs.image = {};
        }

        apply();
      } else {
        others.attrs = {
          image: {}
        };
        apply();
      }
    }

    return others;
  };

  return hook;
}
function createShape(shape, config) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var name = util_getName(shape);
  var defaults = {
    constructorName: name,
    attrs: Object(defineProperty["a" /* default */])({
      '.': {
        fill: '#ffffff',
        stroke: 'none'
      }
    }, shape, {
      fill: '#ffffff',
      stroke: '#000000'
    })
  };

  if (!options.ignoreMarkup) {
    defaults.markup = util_getMarkup(shape, options.noText === true);
  }

  var base = options.parent || base_Base;
  return base.define(object_namespaceObject.merge(defaults, config, {
    shape: name
  }));
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/rect.js

var Rect = createShape('rect', {
  attrs: {
    rect: {
      width: 100,
      height: 60
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/circle.js

var Circle = createShape('circle', {
  width: 60,
  height: 60,
  attrs: {
    circle: {
      r: 30,
      cx: 30,
      cy: 30
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/ellipse.js

var basic_ellipse_Ellipse = createShape('ellipse', {
  width: 60,
  height: 40,
  attrs: {
    ellipse: {
      rx: 30,
      ry: 20,
      cx: 30,
      cy: 20
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/polygon.js

var Polygon = createShape('polygon', {
  width: 60,
  height: 40,
  attrs: {
    text: {
      refY: null,
      refDy: 16
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/polyline.js

var basic_polyline_Polyline = createShape('polyline', {
  width: 60,
  height: 40,
  attrs: {
    text: {
      refY: null,
      refDy: 16
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/image.js

var image_Image = createShape('image', {
  attrs: {
    text: {
      refY: null,
      refDy: 16
    }
  },
  propHooks: getImageUrlHook()
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/path.js
var basic_path_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



var basic_path_Path = createShape('path', {
  width: 60,
  height: 60,
  attrs: {
    text: {
      ref: 'path',
      refY: null,
      refDy: 16
    }
  },
  propHooks: function propHooks(metadata) {
    var d = metadata.d,
        others = basic_path_rest(metadata, ["d"]);

    if (d != null) {
      object_namespaceObject.setByPath(others, 'attrs/path/d', d);
    }

    return others;
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/rhombus.js


var Rhombus = createShape('rhombus', {
  d: 'M 30 0 L 60 30 30 60 0 30 z',
  attrs: {
    text: {
      refY: 0.5,
      refDy: null
    }
  }
}, {
  parent: basic_path_Path,
  ignoreMarkup: true
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/cylinder.js


var Cylinder = createShape('cylinder', {
  width: 40,
  height: 40,
  attrs: {
    path: {
      fill: '#FFFFFF',
      stroke: '#cbd2d7',
      strokeWidth: 3,
      d: ['M 0 10 C 10 5, 30 5, 40 10 C 30 15, 10 15, 0 10', 'L 0 20', 'C 10 25, 30 25, 40 20', 'L 40 10'].join(' ')
    },
    text: {
      refY: 0.7,
      refDy: null,
      fill: '#435460'
    }
  }
}, {
  parent: basic_path_Path,
  ignoreMarkup: true
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/text.js








var viewName = util_getName('text');
var text_Text = /*#__PURE__*/function (_createShape) {
  Object(inherits["a" /* default */])(Text, _createShape);

  var _super = Object(createSuper["a" /* default */])(Text);

  function Text() {
    Object(classCallCheck["a" /* default */])(this, Text);

    return _super.apply(this, arguments);
  }

  return Text;
}(createShape('text', {
  view: viewName,
  attrs: {
    text: {
      fontSize: 18,
      fill: '#000000',
      stroke: null,
      refX: 0.5,
      refY: 0.5
    }
  }
}, {
  noText: true
}));

(function (Text) {
  var View = /*#__PURE__*/function (_NodeView) {
    Object(inherits["a" /* default */])(View, _NodeView);

    var _super2 = Object(createSuper["a" /* default */])(View);

    function View() {
      Object(classCallCheck["a" /* default */])(this, View);

      return _super2.apply(this, arguments);
    }

    Object(createClass["a" /* default */])(View, [{
      key: "confirmUpdate",
      value: function confirmUpdate(flag) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var ret = Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(View.prototype), "confirmUpdate", this).call(this, flag, options);

        if (this.hasAction(ret, 'scale')) {
          this.resize();
          ret = this.removeAction(ret, 'scale');
        }

        return ret;
      }
    }]);

    return View;
  }(node_NodeView);

  Text.View = View;
  View.config({
    actions: {
      attrs: ['scale']
    }
  });
  node_NodeView.registry.register(viewName, View);
})(text_Text || (text_Text = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/text-block.js











var contentSelector = '.text-block-content';
var registryName = util_getName('text-block');
var text_block_TextBlock = /*#__PURE__*/function (_Node) {
  Object(inherits["a" /* default */])(TextBlock, _Node);

  var _super = Object(createSuper["a" /* default */])(TextBlock);

  function TextBlock() {
    Object(classCallCheck["a" /* default */])(this, TextBlock);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(TextBlock, [{
    key: "getContent",
    value: function getContent() {
      return this.store.get('content', '');
    }
  }, {
    key: "setContent",
    value: function setContent(content) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.store.set('content', content, options);
    }
  }, {
    key: "setup",
    value: function setup() {
      var _this = this;

      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(TextBlock.prototype), "setup", this).call(this);

      this.store.on('change:*', function (metadata) {
        var key = metadata.key;

        if (key === 'content') {
          _this.updateContent(_this.getContent());
        } else if (key === 'size') {
          _this.updateSize(_this.getSize());
        }
      });
      this.updateSize(this.getSize());
      this.updateContent(this.getContent());
    }
  }, {
    key: "updateSize",
    value: function updateSize(size) {
      if (platform["a" /* Platform */].SUPPORT_FOREIGNOBJECT) {
        this.setAttrs(Object(defineProperty["a" /* default */])({
          foreignObject: Object.assign({}, size)
        }, contentSelector, {
          style: Object.assign({}, size)
        }));
      }
    }
  }, {
    key: "updateContent",
    value: function updateContent(content) {
      if (platform["a" /* Platform */].SUPPORT_FOREIGNOBJECT) {
        this.setAttrs(Object(defineProperty["a" /* default */])({}, contentSelector, {
          html: content ? string_namespaceObject.sanitizeHTML(content) : ''
        }));
      } else {
        this.setAttrs(Object(defineProperty["a" /* default */])({}, contentSelector, {
          text: content
        }));
      }
    }
  }, {
    key: "content",
    get: function get() {
      return this.getContent();
    },
    set: function set(val) {
      this.setContent(val);
    }
  }]);

  return TextBlock;
}(node_Node);

(function (TextBlock) {
  TextBlock.config({
    type: registryName,
    view: registryName,
    markup: ['<g class="rotatable">', '<g class="scalable"><rect/></g>', platform["a" /* Platform */].SUPPORT_FOREIGNOBJECT ? ["<foreignObject>", "<body xmlns=\"http://www.w3.org/1999/xhtml\">", "<div class=\"".concat(contentSelector.substr(1), "\" />"), "</body>", "</foreignObject>"].join('') : "<text class=\"".concat(contentSelector.substr(1), "\"/>"), '</g>'].join(''),
    attrs: Object(defineProperty["a" /* default */])({
      '.': {
        fill: '#ffffff',
        stroke: 'none'
      },
      rect: {
        fill: '#ffffff',
        stroke: '#000000',
        width: 80,
        height: 100
      },
      text: {
        fill: '#000000',
        fontSize: 14,
        fontFamily: 'Arial, helvetica, sans-serif'
      },
      body: {
        style: {
          background: 'transparent',
          position: 'static',
          margin: 0,
          padding: 0
        }
      },
      foreignObject: {
        style: {
          overflow: 'hidden'
        }
      }
    }, contentSelector, {
      refX: 0.5,
      refY: 0.5,
      yAlign: 'middle',
      xAlign: 'middle',
      style: {
        textAlign: 'center',
        verticalAlign: 'middle',
        display: 'table-cell',
        padding: '0 5px',
        margin: 0
      }
    })
  });
  node_Node.registry.register(registryName, TextBlock);
})(text_block_TextBlock || (text_block_TextBlock = {}));

(function (TextBlock) {
  var contentAction = 'content';

  var View = /*#__PURE__*/function (_NodeView) {
    Object(inherits["a" /* default */])(View, _NodeView);

    var _super2 = Object(createSuper["a" /* default */])(View);

    function View() {
      Object(classCallCheck["a" /* default */])(this, View);

      return _super2.apply(this, arguments);
    }

    Object(createClass["a" /* default */])(View, [{
      key: "confirmUpdate",
      value: function confirmUpdate(flag) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var ret = Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(View.prototype), "confirmUpdate", this).call(this, flag, options);

        if (this.hasAction(ret, contentAction)) {
          this.updateContent();
          ret = this.removeAction(ret, contentAction);
        }

        return ret;
      }
    }, {
      key: "update",
      value: function update(partialAttrs) {
        if (platform["a" /* Platform */].SUPPORT_FOREIGNOBJECT) {
          Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(View.prototype), "update", this).call(this, partialAttrs);
        } else {
          var node = this.cell;
          var attrs = Object.assign({}, partialAttrs || node.getAttrs());
          delete attrs[contentSelector];

          Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(View.prototype), "update", this).call(this, attrs);

          if (!partialAttrs || object_namespaceObject.has(partialAttrs, contentSelector)) {
            this.updateContent(partialAttrs);
          }
        }
      }
    }, {
      key: "updateContent",
      value: function updateContent(partialAttrs) {
        if (platform["a" /* Platform */].SUPPORT_FOREIGNOBJECT) {
          Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(View.prototype), "update", this).call(this, partialAttrs);
        } else {
          var node = this.cell;
          var textAttrs = (partialAttrs || node.getAttrs())[contentSelector]; // Break the text to fit the node size taking into
          // account the attributes set on the node.

          var text = dom_main_namespaceObject.breakText(node.getContent(), node.getSize(), textAttrs, {
            svgDocument: this.graph.view.svg
          });

          var attrs = Object(defineProperty["a" /* default */])({}, contentSelector, object_namespaceObject.merge({}, textAttrs, {
            text: text
          }));

          Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(View.prototype), "update", this).call(this, attrs);
        }
      }
    }]);

    return View;
  }(node_NodeView);

  TextBlock.View = View;

  (function (View) {
    View.config({
      bootstrap: ['render', contentAction],
      actions: platform["a" /* Platform */].SUPPORT_FOREIGNOBJECT ? {} : {
        size: contentAction,
        content: contentAction
      }
    });
    node_NodeView.registry.register(registryName, View);
  })(View = TextBlock.View || (TextBlock.View = {}));
})(text_block_TextBlock || (text_block_TextBlock = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/basic/index.js











// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/util.js



function standard_util_getMarkup(tagName) {
  var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'body';
  return [{
    tagName: tagName,
    selector: selector
  }, {
    tagName: 'text',
    selector: 'label'
  }];
}
var bodyAttr = {
  fill: '#ffffff',
  stroke: '#333333',
  strokeWidth: 2
};
var labelAttr = {
  fontSize: 14,
  fill: '#333333',
  refX: '50%',
  refY: '50%',
  textAnchor: 'middle',
  textVerticalAnchor: 'middle'
};
function util_createShape(shape, config) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var defaults = {
    constructorName: shape,
    markup: standard_util_getMarkup(shape, options.selector),
    attrs: Object(defineProperty["a" /* default */])({}, shape, {
      fill: '#ffffff',
      stroke: '#333333',
      strokeWidth: 2
    })
  };
  var base = options.parent || base_Base;
  return base.define(object_namespaceObject.merge(defaults, config, {
    shape: shape
  }));
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/rect.js

var rect_Rect = util_createShape('rect', {
  attrs: {
    body: {
      refWidth: '100%',
      refHeight: '100%'
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/rect-headered.js


var HeaderedRect = node_Node.define({
  shape: 'rect-headered',
  markup: [{
    tagName: 'rect',
    selector: 'body'
  }, {
    tagName: 'rect',
    selector: 'header'
  }, {
    tagName: 'text',
    selector: 'headerText'
  }, {
    tagName: 'text',
    selector: 'bodyText'
  }],
  attrs: {
    body: Object.assign(Object.assign({}, bodyAttr), {
      refWidth: '100%',
      refHeight: '100%'
    }),
    header: Object.assign(Object.assign({}, bodyAttr), {
      refWidth: '100%',
      height: 30,
      stroke: '#000000'
    }),
    headerText: Object.assign(Object.assign({}, labelAttr), {
      refX: '50%',
      refY: 15,
      fontSize: 16
    }),
    bodyText: Object.assign(Object.assign({}, labelAttr), {
      refY2: 15
    })
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/circle.js

var circle_Circle = util_createShape('circle', {
  attrs: {
    body: {
      refCx: '50%',
      refCy: '50%',
      refR: '50%'
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/cylinder.js



var CYLINDER_TILT = 10;
var cylinder_Cylinder = base_Base.define({
  shape: 'cylinder',
  markup: [{
    tagName: 'path',
    selector: 'body'
  }, {
    tagName: 'ellipse',
    selector: 'top'
  }, {
    tagName: 'text',
    selector: 'label'
  }],
  attrs: {
    body: Object.assign(Object.assign({}, bodyAttr), {
      lateralArea: CYLINDER_TILT
    }),
    top: Object.assign(Object.assign({}, bodyAttr), {
      refCx: '50%',
      refRx: '50%',
      cy: CYLINDER_TILT,
      ry: CYLINDER_TILT
    })
  },
  attrHooks: {
    lateralArea: {
      set: function set(t, _ref) {
        var refBBox = _ref.refBBox;
        var isPercentage = number_namespaceObject.isPercentage(t);

        if (isPercentage) {
          // tslint:disable-next-line
          t = parseFloat(t) / 100;
        }

        var x = refBBox.x;
        var y = refBBox.y;
        var w = refBBox.width;
        var h = refBBox.height; // curve control point variables

        var rx = w / 2;
        var ry = isPercentage ? h * t : t;
        var kappa = 0.551784;
        var cx = kappa * rx;
        var cy = kappa * ry; // shape variables

        var xLeft = x;
        var xCenter = x + w / 2;
        var xRight = x + w;
        var ySideTop = y + ry;
        var yCurveTop = ySideTop - ry;
        var ySideBottom = y + h - ry;
        var yCurveBottom = y + h; // return calculated shape

        var data = ['M', xLeft, ySideTop, 'L', xLeft, ySideBottom, 'C', x, ySideBottom + cy, xCenter - cx, yCurveBottom, xCenter, yCurveBottom, 'C', xCenter + cx, yCurveBottom, xRight, ySideBottom + cy, xRight, ySideBottom, 'L', xRight, ySideTop, 'C', xRight, ySideTop - cy, xCenter + cx, yCurveTop, xCenter, yCurveTop, 'C', xCenter - cx, yCurveTop, xLeft, ySideTop - cy, xLeft, ySideTop, 'Z'];
        return {
          d: data.join(' ')
        };
      }
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/ellipse.js

var standard_ellipse_Ellipse = util_createShape('ellipse', {
  attrs: {
    body: {
      refCx: '50%',
      refCy: '50%',
      refRx: '50%',
      refRy: '50%'
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/poly.js





var poly_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




var poly_Poly = /*#__PURE__*/function (_Base) {
  Object(inherits["a" /* default */])(Poly, _Base);

  var _super = Object(createSuper["a" /* default */])(Poly);

  function Poly() {
    Object(classCallCheck["a" /* default */])(this, Poly);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Poly, [{
    key: "getPoints",
    value: function getPoints() {
      return this.getAttrByPath('body/refPoints');
    }
  }, {
    key: "setPoints",
    value: function setPoints(points, options) {
      if (points == null) {
        this.removePoints();
      } else {
        this.setAttrByPath('body/refPoints', Poly.pointsToString(points), options);
      }

      return this;
    }
  }, {
    key: "removePoints",
    value: function removePoints() {
      this.removeAttrByPath('body/refPoints');
      return this;
    }
  }, {
    key: "points",
    get: function get() {
      return this.getPoints();
    },
    set: function set(pts) {
      this.setPoints(pts);
    }
  }]);

  return Poly;
}(base_Base);

(function (Poly) {
  function pointsToString(points) {
    return typeof points === 'string' ? points : points.map(function (p) {
      if (Array.isArray(p)) {
        return p.join(',');
      }

      if (point_Point.isPointLike(p)) {
        return "".concat(p.x, ", ").concat(p.y);
      }

      return '';
    }).join(' ');
  }

  Poly.pointsToString = pointsToString;
  Poly.config({
    propHooks: function propHooks(metadata) {
      var points = metadata.points,
          others = poly_rest(metadata, ["points"]);

      if (points) {
        var data = pointsToString(points);

        if (data) {
          object_namespaceObject.setByPath(others, 'attrs/body/refPoints', data);
        }
      }

      return others;
    }
  });
})(poly_Poly || (poly_Poly = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/polygon.js


var polygon_Polygon = util_createShape('polygon', {
  attrs: {
    body: {
      refPoints: '0 0 10 0 10 10 0 10'
    }
  },
  parent: poly_Poly
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/polyline.js


var standard_polyline_Polyline = util_createShape('polyline', {
  attrs: {
    body: {
      refPoints: '0 0 10 0 10 10 0 10 0 0'
    }
  },
  parent: poly_Poly
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/path.js
var standard_path_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



var standard_path_Path = util_createShape('path', {
  attrs: {
    body: {
      refD: 'M 0 0 L 10 0 10 10 0 10 Z'
    }
  }
});
standard_path_Path.config({
  propHooks: function propHooks(metadata) {
    var path = metadata.path,
        others = standard_path_rest(metadata, ["path"]);

    if (path) {
      object_namespaceObject.setByPath(others, 'attrs/body/refD', path);
    }

    return others;
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/text-block.js




var standard_text_block_TextBlock = base_Base.define({
  shape: 'text-block',
  markup: [{
    tagName: 'rect',
    selector: 'body'
  }, platform["a" /* Platform */].SUPPORT_FOREIGNOBJECT ? {
    tagName: 'foreignObject',
    selector: 'foreignObject',
    children: [{
      tagName: 'div',
      ns: dom_main_namespaceObject.ns.xhtml,
      selector: 'label',
      style: {
        width: '100%',
        height: '100%',
        position: 'static',
        backgroundColor: 'transparent',
        textAlign: 'center',
        margin: 0,
        padding: '0px 5px',
        boxSizing: 'border-box',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }
    }]
  } : {
    tagName: 'text',
    selector: 'label',
    attrs: {
      textAnchor: 'middle'
    }
  }],
  attrs: {
    body: Object.assign(Object.assign({}, bodyAttr), {
      refWidth: '100%',
      refHeight: '100%'
    }),
    foreignObject: {
      refWidth: '100%',
      refHeight: '100%'
    },
    label: {
      style: {
        fontSize: 14
      }
    }
  },
  attrHooks: {
    text: {
      set: function set(text, _ref) {
        var cell = _ref.cell,
            view = _ref.view,
            refBBox = _ref.refBBox,
            elem = _ref.elem,
            attrs = _ref.attrs;

        if (elem instanceof HTMLElement) {
          elem.textContent = text;
        } else {
          // No foreign object
          var style = attrs.style || {};
          var wrapValue = {
            text: text,
            width: -5,
            height: '100%'
          };
          var wrapAttrs = Object.assign({
            textVerticalAnchor: 'middle'
          }, style);
          var textWrap = attr_Attr.presets.textWrap;
          main_namespaceObject.call(textWrap.set, this, wrapValue, {
            cell: cell,
            view: view,
            elem: elem,
            refBBox: refBBox,
            attrs: wrapAttrs
          });
          return {
            fill: style.color || null
          };
        }
      },
      position: function position(text, _ref2) {
        var refBBox = _ref2.refBBox,
            elem = _ref2.elem;

        if (elem instanceof SVGElement) {
          return refBBox.getCenter();
        }
      }
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/image.js


var standard_image_Image = util_createShape('image', {
  attrs: {
    body: {
      refWidth: '100%',
      refHeight: '100%'
    }
  },
  propHooks: getImageUrlHook()
}, {
  selector: 'image'
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/image-bordered.js


var BorderedImage = util_createShape('image-bordered', {
  markup: [{
    tagName: 'rect',
    selector: 'background',
    attrs: {
      stroke: 'none'
    }
  }, {
    tagName: 'image',
    selector: 'image'
  }, {
    tagName: 'rect',
    selector: 'border',
    attrs: {
      fill: 'none'
    }
  }, {
    tagName: 'text',
    selector: 'label'
  }],
  attrs: {
    background: {
      refWidth: -1,
      refHeight: -1,
      x: 0.5,
      y: 0.5,
      fill: '#ffffff'
    },
    border: {
      refWidth: '100%',
      refHeight: '100%',
      stroke: '#333333',
      strokeWidth: 2
    },
    image: {
      // xlinkHref: '[URL]'
      refWidth: -1,
      refHeight: -1,
      x: 0.5,
      y: 0.5
    }
  },
  propHooks: getImageUrlHook()
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/image-embedded.js


var EmbeddedImage = util_createShape('image-embedded', {
  markup: [{
    tagName: 'rect',
    selector: 'body'
  }, {
    tagName: 'image',
    selector: 'image'
  }, {
    tagName: 'text',
    selector: 'label'
  }],
  attrs: {
    body: {
      refWidth: '100%',
      refHeight: '100%',
      stroke: '#333333',
      fill: '#FFFFFF',
      strokeWidth: 2
    },
    image: {
      // xlinkHref: '[URL]'
      refWidth: '30%',
      refHeight: -20,
      x: 10,
      y: 10,
      preserveAspectRatio: 'xMidYMin'
    }
  },
  propHooks: getImageUrlHook()
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/image-inscribed.js


var InscribedImage = util_createShape('image-inscribed', {
  propHooks: getImageUrlHook(),
  markup: [{
    tagName: 'ellipse',
    selector: 'background'
  }, {
    tagName: 'image',
    selector: 'image'
  }, {
    tagName: 'ellipse',
    selector: 'border',
    attrs: {
      fill: 'none'
    }
  }, {
    tagName: 'text',
    selector: 'label'
  }],
  attrs: {
    border: {
      refRx: '50%',
      refRy: '50%',
      refCx: '50%',
      refCy: '50%',
      stroke: '#333333',
      strokeWidth: 2
    },
    background: {
      refRx: '50%',
      refRy: '50%',
      refCx: '50%',
      refCy: '50%',
      fill: '#ffffff'
    },
    image: {
      // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%
      refWidth: '68%',
      refHeight: '68%',
      // The image offset is calculated as (100% - 68%) / 2
      refX: '16%',
      refY: '16%',
      preserveAspectRatio: 'xMidYMid'
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/edge-shadow.js

var ShadowEdge = edge_Edge.define({
  shape: 'shadow-edge',
  markup: [{
    tagName: 'path',
    selector: 'shadow',
    attrs: {
      fill: 'none'
    }
  }, {
    tagName: 'path',
    selector: 'line',
    attrs: {
      fill: 'none'
    }
  }],
  attrs: {
    line: {
      connection: true,
      stroke: '#FF0000',
      strokeWidth: 20,
      strokeLinejoin: 'round',
      targetMarker: {
        tagName: 'path',
        stroke: 'none',
        d: 'M 0 -10 -10 0 0 10 z'
      },
      sourceMarker: {
        tagName: 'path',
        stroke: 'none',
        d: 'M -10 -10 0 0 -10 10 0 10 0 -10 z'
      }
    },
    shadow: {
      connection: true,
      refX: 3,
      refY: 6,
      stroke: '#000000',
      strokeOpacity: 0.2,
      strokeWidth: 20,
      strokeLinejoin: 'round',
      targetMarker: {
        tagName: 'path',
        d: 'M 0 -10 -10 0 0 10 z',
        stroke: 'none'
      },
      sourceMarker: {
        tagName: 'path',
        stroke: 'none',
        d: 'M -10 -10 0 0 -10 10 0 10 0 -10 z'
      }
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/edge-doubled.js

var DoubleEdge = edge_Edge.define({
  shape: 'double-edge',
  markup: [{
    tagName: 'path',
    selector: 'outline',
    attrs: {
      fill: 'none'
    }
  }, {
    tagName: 'path',
    selector: 'line',
    attrs: {
      fill: 'none'
    }
  }],
  attrs: {
    line: {
      connection: true,
      stroke: '#dddddd',
      strokeWidth: 4,
      strokeLinejoin: 'round',
      targetMarker: {
        tagName: 'path',
        stroke: '#000000',
        d: 'M 10 -3 10 -10 -2 0 10 10 10 3'
      }
    },
    outline: {
      connection: true,
      stroke: '#000000',
      strokeWidth: 6,
      strokeLinejoin: 'round'
    }
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/standard/index.js

















// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/shape/index.js



// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/autosave/index.js






var autosave_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};


var autosave_AutoSave = /*#__PURE__*/function (_Disablable) {
  Object(inherits["a" /* default */])(AutoSave, _Disablable);

  var _super = Object(createSuper["a" /* default */])(AutoSave);

  function AutoSave(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, AutoSave);

    _this = _super.call(this);
    _this.delay = 10;
    _this.throttle = 2;
    _this.threshold = 5;
    _this.changeCount = 0;
    _this.timestamp = 0;
    _this.options = Object.assign(Object.assign({}, AutoSave.defaultOptions), options);

    _this.graph.model.on('cell:change:*', _this.onModelChanged, Object(assertThisInitialized["a" /* default */])(_this));

    return _this;
  }

  Object(createClass["a" /* default */])(AutoSave, [{
    key: "onModelChanged",
    value: function onModelChanged() {
      if (this.disabled) {
        return;
      }

      var now = new Date().getTime();
      var dt = (now - this.timestamp) / 1000;

      if (dt > this.delay || this.changeCount >= this.threshold && dt > this.throttle) {
        this.save();
        this.reset();
      } else {
        this.changeCount += 1;
      }
    }
  }, {
    key: "save",
    value: function save() {
      this.trigger('save');
    }
  }, {
    key: "reset",
    value: function reset() {
      this.changeCount = 0;
      this.timestamp = new Date().getTime();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.graph.model.off('cell:change:*', this.onModelChanged, this);
    }
  }, {
    key: "graph",
    get: function get() {
      return this.options.graph;
    }
  }]);

  return AutoSave;
}(disablable_Disablable);

autosave_decorate([disablable_Disablable.dispose()], autosave_AutoSave.prototype, "dispose", null);

(function (AutoSave) {
  AutoSave.defaultOptions = {
    delay: 10,
    throttle: 2,
    threshold: 5
  };
})(autosave_AutoSave || (autosave_AutoSave = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/halo/node-preset.js







function getNodePreset(halo) {}
var node_preset_NodePreset = /*#__PURE__*/function () {
  function NodePreset(halo) {
    Object(classCallCheck["a" /* default */])(this, NodePreset);

    this.halo = halo;
  }

  Object(createClass["a" /* default */])(NodePreset, [{
    key: "getPresets",
    value: function getPresets() {
      var _this = this;

      return {
        className: 'type-node',
        handles: [{
          name: 'remove',
          position: 'nw',
          events: {
            mousedown: this.removeCell.bind(this)
          },
          icon: null
        }, {
          name: 'resize',
          position: 'se',
          events: {
            mousedown: this.startResize.bind(this),
            mousemove: this.doResize.bind(this),
            mouseup: function mouseup(_ref) {
              var e = _ref.e;

              _this.halo.stopBatch();

              if (_this.resized) {
                _this.resized = false;
                var view = _this.view;
                notify('node:resized', e, view);
              }
            }
          },
          icon: null
        }, {
          name: 'clone',
          position: 'n',
          events: {
            mousedown: this.startClone.bind(this),
            mousemove: this.doClone.bind(this),
            mouseup: this.stopClone.bind(this)
          },
          icon: null
        }, {
          name: 'link',
          position: 'e',
          events: {
            mousedown: this.startLink.bind(this),
            mousemove: this.doLink.bind(this),
            mouseup: this.stopLink.bind(this)
          },
          icon: null
        }, {
          name: 'fork',
          position: 'ne',
          events: {
            mousedown: this.startFork.bind(this),
            mousemove: this.doFork.bind(this),
            mouseup: this.stopFork.bind(this)
          },
          icon: null
        }, {
          name: 'unlink',
          position: 'w',
          events: {
            mousedown: this.unlink.bind(this)
          },
          icon: null
        }, {
          name: 'rotate',
          position: 'sw',
          events: {
            mousedown: this.startRotate.bind(this),
            mousemove: this.doRotate.bind(this),
            mouseup: function mouseup(_ref2) {
              var e = _ref2.e;

              _this.halo.stopBatch();

              if (_this.rotated) {
                _this.rotated = false;

                var data = _this.halo.getEventData(e);

                data.nodes.forEach(function (node) {
                  notify('node:rotated', e, _this.graph.findViewByCell(node));
                });
              }
            }
          },
          icon: null
        }],
        bbox: function bbox(view) {
          if (this.options.useCellGeometry) {
            var node = view.cell;
            return node.getBBox();
          }

          return view.getBBox();
        },
        content: function content(view) {
          var template = string_namespaceObject.template('x: <%= x %>, y: <%= y %>, width: <%= width %>, height: <%= height %>, angle: <%= angle %>');
          var cell = view.cell;
          var bbox = cell.getBBox();
          return template({
            x: Math.floor(bbox.x),
            y: Math.floor(bbox.y),
            width: Math.floor(bbox.width),
            height: Math.floor(bbox.height),
            angle: Math.floor(cell.getAngle())
          });
        },
        magnet: function magnet(view) {
          return view.container;
        },
        tinyThreshold: 40,
        smallThreshold: 80,
        loopEdgePreferredSide: 'top',
        loopEdgeWidth: 40,
        rotateGrid: 15,
        rotateEmbeds: false
      };
    }
  }, {
    key: "removeCell",
    value: function removeCell() {
      this.model.removeConnectedEdges(this.cell);
      this.cell.remove();
    } // #region create edge

  }, {
    key: "startLink",
    value: function startLink(_ref3) {
      var x = _ref3.x,
          y = _ref3.y;
      this.halo.startBatch();
      var graph = this.graph;
      var edge = this.createEdgeConnectedToSource();
      edge.setTarget({
        x: x,
        y: y
      });
      this.model.addEdge(edge, {
        validation: false,
        halo: this.halo.cid,
        async: false
      });
      graph.view.undelegateEvents();
      this.edgeView = graph.renderer.findViewByCell(edge);
      this.edgeView.prepareArrowheadDragging('target', {
        fallbackAction: 'remove'
      });
    }
  }, {
    key: "createEdgeConnectedToSource",
    value: function createEdgeConnectedToSource() {
      var magnet = this.getMagnet(this.view, 'source');
      var terminal = this.getEdgeTerminal(this.view, magnet);
      var edge = this.graph.hook.getDefaultEdge(this.view, magnet);
      edge.setSource(terminal);
      return edge;
    }
  }, {
    key: "getMagnet",
    value: function getMagnet(view, terminal) {
      var magnet = this.options.magnet;

      if (typeof magnet === 'function') {
        var val = main_namespaceObject.call(magnet, this.halo, view, terminal);

        if (val instanceof SVGElement) {
          return val;
        }
      }

      throw new Error('`magnet()` has to return an SVGElement');
    }
  }, {
    key: "getEdgeTerminal",
    value: function getEdgeTerminal(view, magnet) {
      var terminal = {
        cell: view.cell.id
      };

      if (magnet !== view.container) {
        var port = magnet.getAttribute('port');

        if (port) {
          terminal.port = port;
        } else {
          terminal.selector = view.getSelector(magnet);
        }
      }

      return terminal;
    }
  }, {
    key: "doLink",
    value: function doLink(_ref4) {
      var e = _ref4.e,
          x = _ref4.x,
          y = _ref4.y;

      if (this.edgeView) {
        this.edgeView.onMouseMove(e, x, y);
      }
    }
  }, {
    key: "stopLink",
    value: function stopLink(_ref5) {
      var e = _ref5.e,
          x = _ref5.x,
          y = _ref5.y;
      var edgeView = this.edgeView;

      if (edgeView) {
        edgeView.onMouseUp(e, x, y);
        var edge = edgeView.cell;

        if (edge.hasLoop()) {
          this.makeLoopEdge(edge);
        }

        this.halo.stopBatch();
        this.halo.trigger('action:edge:addde', {
          edge: edge
        });
        this.edgeView = null;
      }

      this.graph.view.delegateEvents();
    }
  }, {
    key: "makeLoopEdge",
    value: function makeLoopEdge(edge) {
      var vertex1 = null;
      var vertex2 = null;
      var loopEdgeWidth = this.options.loopEdgeWidth;
      var graphOptions = this.graph.options;
      var graphRect = new rectangle_Rectangle(0, 0, graphOptions.width, graphOptions.height);
      var bbox = this.graph.graphToLocalRect(this.view.getBBox());
      var found = [this.options.loopEdgePreferredSide, 'top', 'bottom', 'left', 'right'].some(function (position) {
        var point = null;
        var dx = 0;
        var dy = 0;

        switch (position) {
          case 'top':
            point = new point_Point(bbox.x + bbox.width / 2, bbox.y - loopEdgeWidth);
            dx = loopEdgeWidth / 2;
            break;

          case 'bottom':
            point = new point_Point(bbox.x + bbox.width / 2, bbox.y + bbox.height + loopEdgeWidth);
            dx = loopEdgeWidth / 2;
            break;

          case 'left':
            point = new point_Point(bbox.x - loopEdgeWidth, bbox.y + bbox.height / 2);
            dy = loopEdgeWidth / 2;
            break;

          case 'right':
            point = new point_Point(bbox.x + bbox.width + loopEdgeWidth, bbox.y + bbox.height / 2);
            dy = loopEdgeWidth / 2;
        }

        if (point) {
          vertex1 = point.translate(-dx, -dy);
          vertex2 = point.translate(dx, dy);
          return graphRect.containsPoint(vertex1) && graphRect.containsPoint(vertex2);
        }
      });

      if (found && vertex1 && vertex2) {
        edge.setVertices([vertex1, vertex2]);
      }
    } // #endregion
    // #region resize

  }, {
    key: "startResize",
    value: function startResize() {
      this.halo.startBatch();
      this.flip = [1, 0, 0, 1, 1, 0, 0, 1][Math.floor(Angle.normalize(this.node.getAngle()) / 45)];
    }
  }, {
    key: "doResize",
    value: function doResize(_ref6) {
      var dx = _ref6.dx,
          dy = _ref6.dy;
      var size = this.node.getSize();
      var width = Math.max(size.width + (this.flip ? dx : dy), 1);
      var height = Math.max(size.height + (this.flip ? dy : dx), 1);
      this.resized = true;
      this.node.resize(width, height, {
        absolute: true
      });
    } // #endregion
    // #region clone

  }, {
    key: "startClone",
    value: function startClone(_ref7) {
      var e = _ref7.e,
          x = _ref7.x,
          y = _ref7.y;
      this.halo.startBatch();
      var options = this.options;
      var cloned = options.clone(this.cell, {
        clone: true
      });

      if (!(cloned instanceof cell_Cell)) {
        throw new Error("option 'clone()' has to return a cell");
      }

      this.centerNodeAtCursor(cloned, x, y);
      this.model.addCell(cloned, {
        halo: this.halo.cid,
        async: false
      });
      var cloneView = this.graph.renderer.findViewByCell(cloned);
      cloneView.onMouseDown(e, x, y);
      this.halo.setEventData(e, {
        cloneView: cloneView
      });
    }
  }, {
    key: "centerNodeAtCursor",
    value: function centerNodeAtCursor(cell, x, y) {
      var center = cell.getBBox().getCenter();
      var dx = x - center.x;
      var dy = y - center.y;
      cell.translate(dx, dy);
    }
  }, {
    key: "doClone",
    value: function doClone(_ref8) {
      var e = _ref8.e,
          x = _ref8.x,
          y = _ref8.y;
      var view = this.halo.getEventData(e).cloneView;

      if (view) {
        view.onMouseMove(e, x, y);
      }
    }
  }, {
    key: "stopClone",
    value: function stopClone(_ref9) {
      var e = _ref9.e,
          x = _ref9.x,
          y = _ref9.y;
      var nodeView = this.halo.getEventData(e).cloneView;

      if (nodeView) {
        nodeView.onMouseUp(e, x, y);
      }

      this.halo.stopBatch();
    } // #endregion
    // #region fork

  }, {
    key: "startFork",
    value: function startFork(_ref10) {
      var e = _ref10.e,
          x = _ref10.x,
          y = _ref10.y;
      this.halo.startBatch();
      var cloned = this.options.clone(this.cell, {
        fork: true
      });

      if (!(cloned instanceof cell_Cell)) {
        throw new Error("option 'clone()' has to return a cell");
      }

      this.centerNodeAtCursor(cloned, x, y);
      this.model.addCell(cloned, {
        halo: this.halo.cid,
        async: false
      });
      var edge = this.createEdgeConnectedToSource();
      var cloneView = this.graph.renderer.findViewByCell(cloned);
      var magnet = this.getMagnet(cloneView, 'target');
      var terminal = this.getEdgeTerminal(cloneView, magnet);
      edge.setTarget(terminal);
      this.model.addEdge(edge, {
        halo: this.halo.cid,
        async: false
      });
      cloneView.onMouseDown(e, x, y);
      this.halo.setEventData(e, {
        cloneView: cloneView
      });
    }
  }, {
    key: "doFork",
    value: function doFork(_ref11) {
      var e = _ref11.e,
          x = _ref11.x,
          y = _ref11.y;
      var view = this.halo.getEventData(e).cloneView;

      if (view) {
        view.onMouseMove(e, x, y);
      }
    }
  }, {
    key: "stopFork",
    value: function stopFork(_ref12) {
      var e = _ref12.e,
          x = _ref12.x,
          y = _ref12.y;
      var view = this.halo.getEventData(e).cloneView;

      if (view) {
        view.onMouseUp(e, x, y);
      }

      this.halo.stopBatch();
    } // #endregion
    // #region rotate

  }, {
    key: "startRotate",
    value: function startRotate(_ref13) {
      var e = _ref13.e,
          x = _ref13.x,
          y = _ref13.y;
      this.halo.startBatch();
      var center = this.node.getBBox().getCenter();
      var nodes = [this.node];

      if (this.options.rotateEmbeds) {
        this.node.getDescendants({
          deep: true
        }).reduce(function (memo, cell) {
          if (cell.isNode()) {
            memo.push(cell);
          }

          return memo;
        }, nodes);
      }

      this.halo.setEventData(e, {
        center: center,
        nodes: nodes,
        rotateStartAngles: nodes.map(function (node) {
          return node.getAngle();
        }),
        clientStartAngle: new point_Point(x, y).theta(center)
      });
    }
  }, {
    key: "doRotate",
    value: function doRotate(_ref14) {
      var _this2 = this;

      var e = _ref14.e,
          x = _ref14.x,
          y = _ref14.y;
      var data = this.halo.getEventData(e);
      var delta = data.clientStartAngle - new point_Point(x, y).theta(data.center);
      this.rotated = true;
      data.nodes.forEach(function (node, index) {
        var startAngle = data.rotateStartAngles[index];
        var targetAngle = util_Util.snapToGrid(startAngle + delta, _this2.options.rotateGrid);
        node.rotate(targetAngle, {
          absolute: true,
          center: data.center,
          halo: _this2.halo.cid
        });
      });
    } // #endregion
    // #region unlink

  }, {
    key: "unlink",
    value: function unlink() {
      this.halo.startBatch();
      this.model.removeConnectedEdges(this.cell);
      this.halo.stopBatch();
    }
  }, {
    key: "options",
    get: function get() {
      return this.halo.options;
    }
  }, {
    key: "graph",
    get: function get() {
      return this.halo.graph;
    }
  }, {
    key: "model",
    get: function get() {
      return this.halo.model;
    }
  }, {
    key: "view",
    get: function get() {
      return this.halo.view;
    }
  }, {
    key: "cell",
    get: function get() {
      return this.halo.cell;
    }
  }, {
    key: "node",
    get: function get() {
      return this.cell;
    }
  }]);

  return NodePreset;
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/halo/edge-preset.js


var edge_preset_EdgePreset = /*#__PURE__*/function () {
  function EdgePreset(halo) {
    Object(classCallCheck["a" /* default */])(this, EdgePreset);

    this.halo = halo;
  }

  Object(createClass["a" /* default */])(EdgePreset, [{
    key: "getPresets",
    value: function getPresets() {
      return {
        className: 'type-edge',
        handles: [{
          name: 'remove',
          position: 'nw',
          icon: null,
          events: {
            mousedown: this.removeEdge.bind(this)
          }
        }, {
          name: 'direction',
          position: 'se',
          icon: null,
          events: {
            mousedown: this.directionSwap.bind(this)
          }
        }],
        content: false,
        bbox: function bbox(view) {
          return view.graph.localToGraphPoint(view.getPointAtRatio(0.5));
        },
        tinyThreshold: -1,
        smallThreshold: -1
      };
    }
  }, {
    key: "removeEdge",
    value: function removeEdge() {
      this.cell.remove();
    }
  }, {
    key: "directionSwap",
    value: function directionSwap() {
      var source = this.edge.getSource();
      var target = this.edge.getTarget();
      this.edge.prop({
        source: target,
        target: source
      });
    }
  }, {
    key: "options",
    get: function get() {
      return this.halo.options;
    }
  }, {
    key: "graph",
    get: function get() {
      return this.halo.graph;
    }
  }, {
    key: "model",
    get: function get() {
      return this.halo.model;
    }
  }, {
    key: "view",
    get: function get() {
      return this.halo.view;
    }
  }, {
    key: "cell",
    get: function get() {
      return this.halo.cell;
    }
  }, {
    key: "edge",
    get: function get() {
      return this.cell;
    }
  }]);

  return EdgePreset;
}();
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/halo/index.js











var halo_Halo = /*#__PURE__*/function (_Widget) {
  Object(inherits["a" /* default */])(Halo, _Widget);

  var _super = Object(createSuper["a" /* default */])(Halo);

  function Halo() {
    Object(classCallCheck["a" /* default */])(this, Halo);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Halo, [{
    key: "init",
    value: function init(options) {
      this.options = object_namespaceObject.merge(Halo.defaultOptions, this.cell.isNode() ? new node_preset_NodePreset(this).getPresets() : this.cell.isEdge() ? new edge_preset_EdgePreset(this).getPresets() : null, options);
      this.render();
      this.initHandles();
      this.update();
      this.startListening();
    }
  }, {
    key: "startListening",
    value: function startListening() {
      var model = this.model;
      var graph = this.graph;
      var cell = this.view.cell; // this.delegateEvents(
      //   {
      //     'mousedown .handle': 'onHandlePointerDown',
      //     'touchstart .handle': 'onHandlePointerDown',
      //   },
      //   true,
      // )

      cell.on('removed', this.remove, this);
      model.on('reseted', this.remove, this);
      graph.on('halo:destroy', this.remove, this);
      model.on('*', this.update, this);
      graph.on('scale', this.update, this);
      graph.on('translate', this.update, this);

      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(Halo.prototype), "startListening", this).call(this);
    }
  }, {
    key: "stopListening",
    value: function stopListening() {
      var model = this.model;
      var graph = this.graph;
      var cell = this.view.cell;
      this.undelegateEvents();
      cell.off('removed', this.remove, this);
      model.off('reseted', this.remove, this);
      graph.off('halo:destroy', this.remove, this);
      model.off('*', this.update, this);
      graph.off('scale', this.update, this);
      graph.off('translate', this.update, this);

      Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(Halo.prototype), "stopListening", this).call(this);
    }
  }, {
    key: "render",
    value: function render() {
      var options = this.options;
      var cls = this.prefixClassName('widget-halo');
      this.container = document.createElement('div');
      this.$container = this.$(this.container).addClass(cls).attr('data-shape', this.view.cell.shape);

      if (options.className) {
        this.$container.addClass(options.className);
      }

      this.$handleContainer = this.$('<div/>').addClass("".concat(cls, "-handles")).appendTo(this.container);
      this.$content = this.$('<div/>').addClass("".concat(cls, "-content")).appendTo(this.container);
      this.$container.appendTo(this.graph.container);
      return this;
    }
  }, {
    key: "remove",
    value: function remove() {
      this.stopBatch();
      return Object(esm_get["a" /* default */])(Object(getPrototypeOf["a" /* default */])(Halo.prototype), "remove", this).call(this);
    }
  }, {
    key: "update",
    value: function update() {
      if (this.isRendered()) {
        this.updateContent();
        var bbox = this.getBBox();
        var tinyThreshold = this.options.tinyThreshold || 0;
        var smallThreshold = this.options.smallThreshold || 0;
        this.$handleContainer.toggleClass("".concat(this.handleClassName, "-tiny"), bbox.width < tinyThreshold && bbox.height < tinyThreshold);
        var className = "".concat(this.handleClassName, "-small");
        this.$handleContainer.toggleClass(className, !this.$handleContainer.hasClass(className) && bbox.width < smallThreshold && bbox.height < smallThreshold);
        this.$container.css({
          width: bbox.width,
          height: bbox.height,
          left: bbox.x,
          top: bbox.y
        });

        if (this.hasHandle('unlink')) {
          this.toggleUnlink();
        }

        if (this.type === 'surround' || this.type === 'toolbar') {
          if (this.hasHandle('fork')) {
            this.toggleFork();
          }
        }
      }
    }
  }, {
    key: "updateContent",
    value: function updateContent() {
      var content = this.options.content;

      if (typeof content === 'function') {
        var ret = main_namespaceObject.call(content, this, this.view, this.$content[0]);

        if (ret) {
          this.$content.html(ret);
        }
      } else {
        if (content) {
          this.$content.html(content);
        } else {
          this.$content.remove();
        }
      }
    }
  }, {
    key: "getBBox",
    value: function getBBox() {
      var view = this.view;
      var bbox = this.options.bbox;
      var rect = typeof bbox === 'function' ? main_namespaceObject.call(bbox, this, view) : bbox;
      return rectangle_Rectangle.create(Object.assign({
        x: 0,
        y: 0,
        width: 1,
        height: 1
      }, rect));
    }
  }, {
    key: "removeCell",
    value: function removeCell() {
      this.cell.remove();
    }
  }, {
    key: "toggleFork",
    value: function toggleFork() {
      var cell = this.view.cell.clone();
      var view = this.graph.hook.createCellView(cell);
      var valid = this.graph.hook.validateConnection(this.view, null, view, null, 'target');
      this.$handleContainer.children('.fork').toggleClass('hidden', !valid);
      view.remove();
    }
  }, {
    key: "toggleUnlink",
    value: function toggleUnlink() {
      var hasEdges = this.model.getConnectedEdges(this.view.cell).length > 0;
      this.$handleContainer.children('.unlink').toggleClass('hidden', !hasEdges);
    } // #region batch

  }, {
    key: "startBatch",
    value: function startBatch() {
      this.model.startBatch('halo', {
        halo: this.cid
      });
    }
  }, {
    key: "stopBatch",
    value: function stopBatch() {
      if (this.model.hasActiveBatch('halo')) {
        this.model.stopBatch('halo', {
          halo: this.cid
        });
      }
    }
  }, {
    key: "type",
    get: function get() {
      return this.options.type || 'surround';
    }
  }, {
    key: "handleOptions",
    get: function get() {
      return this.options;
    }
  }]);

  return Halo;
}(widget_Widget);

(function (Halo) {
  Halo.defaultOptions = {
    type: 'surround',
    clearAll: true,
    clearOnBlankMouseDown: true,
    useCellGeometry: false,
    clone: function clone(cell) {
      return cell.clone().removeZIndex();
    }
  };
})(halo_Halo || (halo_Halo = {}));

Object.getOwnPropertyNames(handle_Handle.prototype).forEach(function (name) {
  if (name !== 'constructor') {
    Object.defineProperty(halo_Halo.prototype, name, Object.getOwnPropertyDescriptor(handle_Handle.prototype, name));
  }
});
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/path/drawer.js






 // need: <meta http-equiv="x-ua-compatible" content="IE=Edge" />

var drawer_PathDrawer = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(PathDrawer, _View);

  var _super = Object(createSuper["a" /* default */])(PathDrawer);

  function PathDrawer(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, PathDrawer);

    _this = _super.call(this);
    _this.MOVEMENT_DETECTION_THRESHOLD = 150;
    _this.options = object_namespaceObject.merge({}, PathDrawer.defaultOptions, options);
    _this.action = 'awaiting-input';

    _this.render();

    _this.startListening();

    return _this;
  }

  Object(createClass["a" /* default */])(PathDrawer, [{
    key: "render",
    value: function render() {
      var options = this.options;
      this.container = dom_main_namespaceObject.createSvgElement('g');
      dom_main_namespaceObject.addClass(this.container, this.prefixClassName('path-drawer'));
      this.pathTemplate = dom_main_namespaceObject.createSvgElement('path');
      dom_main_namespaceObject.attr(this.pathTemplate, options.pathAttributes);
      this.startPointElement = dom_main_namespaceObject.createVector(options.startPointMarkup).addClass('start-point').node;
      this.controlElement = dom_main_namespaceObject.createSvgElement('path');
      dom_main_namespaceObject.addClass(this.controlElement, 'control-path');
      dom_main_namespaceObject.createVector('rect', {
        x: 0,
        y: 0,
        width: '100%',
        height: '100%',
        fill: 'transparent',
        stroke: 'none'
      }).appendTo(this.container);
      this.options.target.appendChild(this.container);
      return this;
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.remove(this.pathElement);
      this.clear();
      this.stopListening();
    }
  }, {
    key: "startListening",
    value: function startListening() {
      this.delegateEvents({
        mousedown: 'onMouseDown',
        touchstart: 'onMouseDown',
        dblclick: 'onDoubleClick',
        contextmenu: 'onContextMenu',
        'mousedown .start-point': 'onStartPointMouseDown',
        'touchstart .start-point': 'onStartPointMouseDown'
      });
    }
  }, {
    key: "stopListening",
    value: function stopListening() {
      this.undelegateEvents();
    }
  }, {
    key: "clear",
    value: function clear() {
      var path = this.pathElement;

      if (path && path.pathSegList.numberOfItems <= 1) {
        this.remove(path);
      }

      this.startPointElement.remove();
      this.controlElement.remove();
      this.undelegateDocumentEvents();
      this.action = 'awaiting-input';
      this.emit('clear');
    }
  }, {
    key: "createPath",
    value: function createPath(x, y) {
      this.pathElement = this.pathTemplate.cloneNode(true);
      this.addMoveSegment(x, y);
      dom_main_namespaceObject.translate(this.startPointElement, x, y, {
        absolute: true
      });
      this.vel.before(this.pathElement);
      this.vel.append(this.startPointElement);
      this.emit('path:create', {
        path: this.pathElement
      });
    }
  }, {
    key: "closePath",
    value: function closePath() {
      var path = this.pathElement;
      var first = this.getPathSeg(path, 0);
      var last = this.getPathSeg(path, -1);

      if (last.pathSegType === SVGPathSeg.PATHSEG_LINETO_ABS) {
        path.pathSegList.replaceItem(path.createSVGPathSegClosePath(), path.pathSegList.numberOfItems - 1);
      } else {
        last.x = first.x;
        last.y = first.y;
        path.pathSegList.appendItem(path.createSVGPathSegClosePath());
      }

      this.finishPath('path:close');
    }
  }, {
    key: "finishPath",
    value: function finishPath(name) {
      var path = this.pathElement;

      if (path && 0 < this.numberOfVisibleSegments()) {
        this.emit('path:finish', {
          path: path
        });
        this.trigger(name, {
          path: path
        });
      } else {
        this.emit('path:abort', {
          path: path
        });
      }

      this.clear();
    }
  }, {
    key: "numberOfVisibleSegments",
    value: function numberOfVisibleSegments() {
      var path = this.pathElement;
      var remaining = path.pathSegList.numberOfItems;
      remaining = remaining - 1;
      var last = this.getPathSeg(path, -1);

      if (last.pathSegType === SVGPathSeg.PATHSEG_CLOSEPATH) {
        remaining = remaining - 1;
      }

      return remaining;
    }
  }, {
    key: "addMoveSegment",
    value: function addMoveSegment(x, y) {
      var path = this.pathElement;
      var seg = path.createSVGPathSegMovetoAbs(x, y);
      path.pathSegList.appendItem(seg);
      this.emit('path:segment:add', {
        path: path
      });
      this.emit('path:move-segment:add', {
        path: path
      });
    }
  }, {
    key: "addLineSegment",
    value: function addLineSegment(x, y) {
      var path = this.pathElement;
      var seg = path.createSVGPathSegLinetoAbs(x, y);
      path.pathSegList.appendItem(seg);
      this.emit('path:segment:add', {
        path: path
      });
      this.emit('path:line-segment:add', {
        path: path
      });
    }
  }, {
    key: "addCurveSegment",
    value: function addCurveSegment(x, y, x1, y1, x2, y2) {
      var path = this.pathElement;
      var seg = path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2 || x, y2 || y);
      path.pathSegList.appendItem(seg);
      this.emit('path:segment:add', {
        path: path
      });
      this.emit('path:curve-segment:add', {
        path: path
      });
    }
  }, {
    key: "adjustLastSegment",
    value: function adjustLastSegment(x, y, x1, y1, x2, y2) {
      var path = this.pathElement;
      var snapRadius = this.options.snapRadius;

      if (snapRadius && x != null && y != null) {
        var snaped = this.snapLastSegmentCoordinates(x, y, snapRadius);
        x = snaped.x; // tslint:disable-line

        y = snaped.y; // tslint:disable-line
      }

      var seg = this.getPathSeg(path, -1);

      if (x != null) {
        seg.x = x;
      }

      if (y != null) {
        seg.y = y;
      }

      if (x1 != null) {
        seg.x1 = x1;
      }

      if (y1 != null) {
        seg.y1 = y1;
      }

      if (x2 != null) {
        seg.x2 = x2;
      }

      if (y2 != null) {
        seg.y2 = y2;
      }

      this.emit('path:edit', {
        path: path
      });
      this.emit('path:last-segment:adjust', {
        path: path
      });
    }
  }, {
    key: "snapLastSegmentCoordinates",
    value: function snapLastSegmentCoordinates(x, y, snapRadius) {
      var path = this.pathElement;
      var xSnaped = false;
      var ySnaped = false;
      var targetX = x;
      var targetY = y;

      for (var i = path.pathSegList.numberOfItems - 2; 0 <= i && (!xSnaped || !ySnaped); i -= 1) {
        var seg = this.getPathSeg(path, i);

        if (!xSnaped && Math.abs(seg.x - x) < snapRadius) {
          targetX = seg.x;
          xSnaped = true;
        }

        if (!ySnaped && Math.abs(seg.y - y) < snapRadius) {
          targetY = seg.y;
          ySnaped = true;
        }
      }

      return new point_Point(targetX, targetY);
    }
  }, {
    key: "removeLastSegment",
    value: function removeLastSegment() {
      var path = this.pathElement;
      path.pathSegList.removeItem(path.pathSegList.numberOfItems - 1);
      this.emit('path:edit', {
        path: path
      });
      this.emit('path:last-segment:remove', {
        path: path
      });
    }
  }, {
    key: "findControlPoint",
    value: function findControlPoint(x, y) {
      var path = this.pathElement;
      var seg = this.getPathSeg(path, -1);
      return new point_Point(x, y).reflection(seg);
    }
  }, {
    key: "replaceLastSegmentWithCurve",
    value: function replaceLastSegmentWithCurve() {
      var path = this.pathElement;
      var last = this.getPathSeg(path, -1);
      var prev = this.getPathSeg(path, -2);
      var seg = path.createSVGPathSegCurvetoCubicAbs(last.x, last.y, prev.x, prev.y, last.x, last.y);
      path.pathSegList.replaceItem(seg, path.pathSegList.numberOfItems - 1);
      this.emit('path:edit', {
        path: path
      });
      this.emit('path:last-segment:replace-with-curve', {
        path: path
      });
    }
  }, {
    key: "adjustControlPath",
    value: function adjustControlPath(x1, y1, x2, y2) {
      var controlPathElement = this.controlElement;
      controlPathElement.pathSegList.initialize(controlPathElement.createSVGPathSegMovetoAbs(x1, y1));
      controlPathElement.pathSegList.appendItem(controlPathElement.createSVGPathSegLinetoAbs(x2, y2));
      this.vel.append(controlPathElement);
      var path = this.pathElement;
      this.emit('path:interact', {
        path: path
      });
      this.emit('path:control:adjust', {
        path: path
      });
    }
  }, {
    key: "removeControlPath",
    value: function removeControlPath() {
      var path = this.pathElement;
      var svgControl = this.controlElement;
      svgControl.pathSegList.clear();
      this.vel.append(svgControl);
      this.emit('path:interact', {
        path: path
      });
      this.emit('path:control:remove', {
        path: path
      });
    }
  }, {
    key: "getPathSeg",
    value: function getPathSeg(path, index) {
      var i = index < 0 ? path.pathSegList.numberOfItems + index : index;
      return path.pathSegList.getItem(i);
    }
  }, {
    key: "onMouseDown",
    value: function onMouseDown(evt) {
      var e = this.normalizeEvent(evt);
      e.stopPropagation();

      if (this.isLeftMouseDown(e) && this.isSamePositionEvent(e) && this.container.parentNode) {
        var local = this.vel.toLocalPoint(e.clientX, e.clientY);

        switch (this.action) {
          case 'awaiting-input':
            this.createPath(local.x, local.y);
            this.action = 'path-created';
            this.delegateDocumentEvents(PathDrawer.documentEvents);
            break;

          case 'adjusting-line-end':
            this.action = 'awaiting-line-end';
            break;

          case 'adjusting-curve-end':
            this.action = 'awaiting-curve-control-2';
        }

        this.timeStamp = e.timeStamp;
      }
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(evt) {
      var e = this.normalizeEvent(evt);
      e.stopPropagation();

      if ('awaiting-input' !== this.action) {
        var local = this.vel.toLocalPoint(e.clientX, e.clientY);
        var timeStamp = this.timeStamp;

        if (timeStamp) {
          if (e.timeStamp - timeStamp < this.MOVEMENT_DETECTION_THRESHOLD) {
            switch (this.action) {
              case 'path-created':
                {
                  var translate = dom_main_namespaceObject.translate(this.startPointElement);
                  this.adjustControlPath(translate.tx, translate.ty, local.x, local.y);
                  break;
                }

              case 'awaiting-line-end':
              case 'adjusting-curve-control-1':
                {
                  this.adjustLastSegment(local.x, local.y);
                  break;
                }

              case 'awaiting-curve-control-2':
                {
                  this.adjustLastSegment(local.x, local.y, null, null, local.x, local.y);
                }
            }
          } else {
            switch (this.action) {
              case 'path-created':
                this.action = 'adjusting-curve-control-1';
                break;

              case 'awaiting-line-end':
                this.replaceLastSegmentWithCurve();
                this.action = 'adjusting-curve-control-2';
                break;

              case 'awaiting-curve-control-2':
                this.action = 'adjusting-curve-control-2';
                break;

              case 'adjusting-curve-control-1':
                {
                  var _translate = dom_main_namespaceObject.translate(this.startPointElement);

                  this.adjustControlPath(_translate.tx, _translate.ty, local.x, local.y);
                  break;
                }

              case 'adjusting-curve-control-2':
                {
                  var controlPoint = this.findControlPoint(local.x, local.y);
                  this.adjustLastSegment(null, null, null, null, controlPoint.x, controlPoint.y);
                  this.adjustControlPath(controlPoint.x, controlPoint.y, local.x, local.y);
                }
            }
          }
        } else {
          switch (this.action) {
            case 'adjusting-line-end':
              this.adjustLastSegment(local.x, local.y);
              break;

            case 'adjusting-curve-end':
              this.adjustLastSegment(local.x, local.y, null, null, local.x, local.y);
          }
        }
      }
    }
  }, {
    key: "onPointerUp",
    value: function onPointerUp(evt) {
      this.timeStamp = null;
      var e = this.normalizeEvent(evt);
      e.stopPropagation();

      if (this.isLeftMouseDown(e) && this.isSamePositionEvent(e)) {
        var local = this.vel.toLocalPoint(e.clientX, e.clientY);

        switch (this.action) {
          case 'path-created':
          case 'awaiting-line-end':
            this.addLineSegment(local.x, local.y);
            this.action = 'adjusting-line-end';
            break;

          case 'awaiting-curve-control-2':
            this.removeControlPath();
            this.addLineSegment(local.x, local.y);
            this.action = 'adjusting-line-end';
            break;

          case 'adjusting-curve-control-1':
          case 'adjusting-curve-control-2':
            this.addCurveSegment(local.x, local.y, local.x, local.y);
            this.action = 'adjusting-curve-end';
        }
      }
    }
  }, {
    key: "onStartPointMouseDown",
    value: function onStartPointMouseDown(evt) {
      var e = this.normalizeEvent(evt);
      e.stopPropagation();

      if (this.isLeftMouseDown(e) && this.isSamePositionEvent(e)) {
        this.closePath();
      }
    }
  }, {
    key: "onDoubleClick",
    value: function onDoubleClick(evt) {
      var e = this.normalizeEvent(evt);
      e.preventDefault();
      e.stopPropagation();

      if (this.isLeftMouseDown(e)) {
        if (this.pathElement && 0 < this.numberOfVisibleSegments()) {
          this.removeLastSegment();
          this.finishPath('path:stop');
        }
      }
    }
  }, {
    key: "onContextMenu",
    value: function onContextMenu(evt) {
      var e = this.normalizeEvent(evt);
      e.preventDefault();
      e.stopPropagation();

      if (this.isSamePositionEvent(e)) {
        if (this.pathElement && 0 < this.numberOfVisibleSegments()) {
          this.removeLastSegment();
          this.finishPath('path:stop');
        }
      }
    }
  }, {
    key: "isLeftMouseDown",
    value: function isLeftMouseDown(e) {
      return (e.which || 0) <= 1;
    }
  }, {
    key: "isSamePositionEvent",
    value: function isSamePositionEvent(e) {
      var originalEvent = e.originalEvent;
      return originalEvent == null || originalEvent.detail <= 1;
    }
  }, {
    key: "vel",
    get: function get() {
      return dom_main_namespaceObject.createVector(this.container);
    }
  }]);

  return PathDrawer;
}(view_View);

(function (PathDrawer) {
  PathDrawer.defaultOptions = {
    pathAttributes: {
      class: null,
      fill: '#ffffff',
      stroke: '#000000',
      'stroke-width': 1,
      'pointer-events': 'none'
    },
    startPointMarkup: '<circle r="5"/>',
    snapRadius: 0
  };
  PathDrawer.documentEvents = {
    mousemove: 'onMouseMove',
    touchmove: 'onMouseMove',
    mouseup: 'onMouseUp',
    touchend: 'onMouseUp',
    touchcancel: 'onMouseUp'
  };
})(drawer_PathDrawer || (drawer_PathDrawer = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/path/index.js

// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/dnd/index.js









var dnd_Dnd = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(Dnd, _View);

  var _super = Object(createSuper["a" /* default */])(Dnd);

  function Dnd(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Dnd);

    _this = _super.call(this);
    _this.options = Object.assign(Object.assign({}, Dnd.defaults), options);
    _this.container = document.createElement('div');
    _this.$container = _this.$(_this.container).addClass(_this.prefixClassName('widget-dnd'));
    _this.delegateGraph = new graph_Graph(Object.assign(Object.assign({}, _this.options.delegateGraphOptions), {
      container: document.createElement('div'),
      width: 1,
      height: 1
    }));

    _this.$container.append(_this.delegateGraph.container);

    return _this;
  }

  Object(createClass["a" /* default */])(Dnd, [{
    key: "start",
    value: function start(node, evt) {
      var e = evt;
      e.preventDefault();
      this.targetModel.startBatch('dnd');
      this.$container.addClass('dragging').appendTo(document.body);
      this.prepareDragging(node, e.clientX, e.clientY);
      var local = this.updateNodePosition(e.clientX, e.clientY);

      if (this.isSnaplineEnabled()) {
        this.snapline.captureCursorOffset({
          e: e,
          node: node,
          cell: node,
          view: this.draggingView,
          x: local.x,
          y: local.y
        });
        this.draggingNode.on('change:position', this.snap, this);
      }

      this.delegateDocumentEvents(Dnd.documentEvents, e.data);
    }
  }, {
    key: "isSnaplineEnabled",
    value: function isSnaplineEnabled() {
      return this.snapline && !this.snapline.disabled;
    }
  }, {
    key: "prepareDragging",
    value: function prepareDragging(node, clientX, clientY) {
      var delegateGraph = this.delegateGraph;
      var delegateModel = delegateGraph.model;
      var delegateNode = this.options.getDragNode(node).position(0, 0);
      var padding = 5;

      if (this.isSnaplineEnabled()) {
        padding += this.snapline.options.tolerance || 0;
      }

      if (this.isSnaplineEnabled() || this.options.scaled) {
        var scale = this.targetGraph.scale();
        delegateGraph.scale(scale.sx, scale.sy);
        padding *= Math.max(scale.sx, scale.sy);
      } else {
        delegateGraph.scale(1, 1);
      }

      this.clearDragging();

      if (this.options.animation) {
        this.$container.stop(true, true);
      }

      delegateModel.resetCells([delegateNode]);
      var delegateView = delegateGraph.findViewByCell(delegateNode);
      delegateView.undelegateEvents();
      delegateView.cell.off('changed');
      delegateGraph.fitToContent({
        padding: padding,
        allowNewOrigin: 'any'
      });
      var bbox = delegateView.getBBox();
      this.geometryBBox = delegateView.getBBox({
        useCellGeometry: true
      });
      this.delta = this.geometryBBox.getTopLeft().diff(bbox.getTopLeft());
      this.draggingNode = delegateNode;
      this.draggingView = delegateView;
      this.delegateBBox = delegateNode.getBBox();
      this.padding = padding;
      this.originOffset = this.updateGraphPosition(clientX, clientY);
    }
  }, {
    key: "updateGraphPosition",
    value: function updateGraphPosition(clientX, clientY) {
      var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
      var delta = this.delta;
      var nodeBBox = this.geometryBBox;
      var padding = this.padding || 5;
      var offset = {
        left: clientX - delta.x - nodeBBox.width / 2 - padding,
        top: clientY - delta.y - nodeBBox.height / 2 - padding + scrollTop
      };

      if (this.delegateGraph) {
        this.$container.offset(offset);
      }

      return offset;
    }
  }, {
    key: "updateNodePosition",
    value: function updateNodePosition(x, y) {
      var local = this.targetGraph.clientToLocalPoint(x, y);
      var bbox = this.delegateBBox;
      local.x -= bbox.width / 2;
      local.y -= bbox.height / 2;
      this.draggingNode.position(local.x, local.y);
      return local;
    }
  }, {
    key: "snap",
    value: function snap(_ref) {
      var cell = _ref.cell,
          current = _ref.current,
          options = _ref.options;
      var node = cell;

      if (options.snapped) {
        var bbox = this.delegateBBox;
        node.position(bbox.x + options.tx, bbox.y + options.ty, {
          silent: true
        });
        this.draggingView.translate();
        node.position(current.x, current.y, {
          silent: true
        });
        this.snapOffset = {
          x: options.tx,
          y: options.ty
        };
      } else {
        this.snapOffset = null;
      }
    }
  }, {
    key: "onDragging",
    value: function onDragging(evt) {
      var draggingView = this.draggingView;

      if (draggingView) {
        evt.preventDefault();
        var e = this.normalizeEvent(evt);
        var clientX = e.clientX;
        var clientY = e.clientY;
        this.updateGraphPosition(clientX, clientY);
        var local = this.updateNodePosition(clientX, clientY);
        var embeddingMode = this.targetGraph.options.embedding.enabled;
        var isValidArea = (embeddingMode || this.isSnaplineEnabled()) && this.isInsideValidArea({
          x: clientX,
          y: clientY
        });

        if (embeddingMode) {
          draggingView.setEventData(e, {
            graph: this.targetGraph
          });
          var data = draggingView.getEventData(e);

          if (isValidArea) {
            draggingView.processEmbedding(data);
          } else {
            draggingView.clearEmbedding(data);
          }
        } // update snapline


        if (this.isSnaplineEnabled()) {
          if (isValidArea) {
            this.snapline.snapOnMoving({
              e: e,
              view: draggingView,
              x: local.x,
              y: local.y
            });
          } else {
            this.snapline.hide();
          }
        }
      }
    }
  }, {
    key: "onDragEnd",
    value: function onDragEnd(evt) {
      var _this2 = this;

      var draggingNode = this.draggingNode;

      if (draggingNode) {
        var e = this.normalizeEvent(evt);
        var draggingView = this.draggingView;
        var draggingBBox = this.delegateBBox;
        var snapOffset = this.snapOffset;
        var x = draggingBBox.x;
        var y = draggingBBox.y;

        if (snapOffset) {
          x = x + snapOffset.x;
          y = y + snapOffset.y;
        }

        draggingNode.position(x, y, {
          silent: true
        });
        var node = this.options.getDropNode(draggingNode);
        var ret = this.drop(node, {
          x: e.clientX,
          y: e.clientY
        });

        var callback = function callback(valid) {
          if (valid) {
            _this2.onDropped(draggingNode);
          } else {
            _this2.onDropInvalid();
          }

          if (_this2.targetGraph.options.embedding.enabled && draggingView) {
            draggingView.setEventData(e, {
              cell: node,
              graph: _this2.targetGraph
            });
            draggingView.finalizeEmbedding(draggingView.getEventData(e));
          }

          _this2.targetModel.stopBatch('dnd');
        };

        if (typeof ret === 'boolean') {
          callback(ret);
        } else {
          ret.then(callback);
        }
      }
    }
  }, {
    key: "clearDragging",
    value: function clearDragging() {
      if (this.draggingNode) {
        this.draggingNode.remove();
        this.draggingNode = null;
        this.draggingView = null;
        this.delta = null;
        this.padding = null;
        this.snapOffset = null;
        this.originOffset = null;
      }
    }
  }, {
    key: "onDropped",
    value: function onDropped(draggingNode) {
      if (this.draggingNode === draggingNode) {
        this.clearDragging();
        this.$container.removeClass('dragging').remove();
      }
    }
  }, {
    key: "onDropInvalid",
    value: function onDropInvalid() {
      var _this3 = this;

      var draggingNode = this.draggingNode;

      if (draggingNode) {
        var anim = this.options.animation;

        if (anim) {
          var duration = typeof anim === 'object' && anim.duration || 150;
          var easing = typeof anim === 'object' && anim.easing || 'swing';
          this.draggingView = null;
          this.$container.animate(this.originOffset, duration, easing, function () {
            return _this3.onDropped(draggingNode);
          });
        } else {
          this.onDropped(draggingNode);
        }
      }
    }
  }, {
    key: "isInsideValidArea",
    value: function isInsideValidArea(p) {
      var targetRect;
      var targetGraph = this.targetGraph;
      var targetScroller = this.targetScroller;

      if (targetScroller) {
        if (targetScroller.options.autoResize) {
          targetRect = this.getDropArea(targetScroller.container);
        } else {
          var outter = this.getDropArea(targetScroller.container);
          targetRect = this.getDropArea(targetGraph.container).intersect(outter);
        }
      } else {
        targetRect = this.getDropArea(targetGraph.container);
      }

      return targetRect && targetRect.containsPoint(p);
    }
  }, {
    key: "getDropArea",
    value: function getDropArea(elem) {
      var $elem = this.$(elem);
      var offset = $elem.offset();
      var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
      var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;
      return rectangle_Rectangle.create({
        x: offset.left + parseInt($elem.css('border-left-width'), 10) - scrollLeft,
        y: offset.top + parseInt($elem.css('border-top-width'), 10) - scrollTop,
        width: $elem.innerWidth(),
        height: $elem.innerHeight()
      });
    }
  }, {
    key: "drop",
    value: function drop(node, pos) {
      var _this4 = this;

      var targetGraph = this.targetGraph;
      var targetModel = targetGraph.model;

      if (this.isInsideValidArea(pos)) {
        var local = targetGraph.clientToLocalPoint(pos);
        var bbox = node.getBBox();
        local.x += bbox.x - bbox.width / 2;
        local.y += bbox.y - bbox.height / 2;
        var gridSize = this.snapOffset ? 1 : targetGraph.getGridSize();
        node.position(util_Util.snapToGrid(local.x, gridSize), util_Util.snapToGrid(local.y, gridSize));
        node.removeZIndex();
        var validateNode = this.options.validateNode;
        var ret = validateNode ? main_namespaceObject.call(validateNode, targetGraph, node) : true;

        if (typeof ret === 'boolean') {
          if (ret) {
            targetModel.addCell(node, {
              stencil: this.cid
            });
          }

          return ret;
        }

        return main_namespaceObject.toDeferredBoolean(ret).then(function (valid) {
          if (valid) {
            targetModel.addCell(node, {
              stencil: _this4.cid
            });
          }

          return valid;
        });
      }

      return false;
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      if (this.delegateGraph) {
        this.delegateGraph.view.remove();
      }
    }
  }, {
    key: "targetScroller",
    get: function get() {
      var target = this.options.target;
      return target instanceof graph_Graph ? target.scroller.widget : target;
    }
  }, {
    key: "targetGraph",
    get: function get() {
      var target = this.options.target;
      return target instanceof graph_Graph ? target : target.graph;
    }
  }, {
    key: "targetModel",
    get: function get() {
      return this.targetGraph.model;
    }
  }, {
    key: "snapline",
    get: function get() {
      return this.targetGraph.snapline.widget;
    }
  }]);

  return Dnd;
}(view_View);

(function (Dnd) {
  Dnd.defaults = {
    animation: false,
    getDragNode: function getDragNode(node) {
      return node.clone();
    },
    getDropNode: function getDropNode(node) {
      return node.clone();
    }
  };
  Dnd.documentEvents = {
    mousemove: 'onDragging',
    touchmove: 'onDragging',
    mouseup: 'onDragEnd',
    touchend: 'onDragEnd',
    touchcancel: 'onDragEnd'
  };
})(dnd_Dnd || (dnd_Dnd = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/layout/grid.js

function grid_grid(cells) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var model = cells instanceof model_Model ? cells : new model_Model().resetCells(cells, {
    sort: false,
    dryrun: true
  });
  var nodes = model.getNodes();
  var columns = options.columns || 1;
  var rows = Math.ceil(nodes.length / columns);
  var dx = options.dx || 0;
  var dy = options.dy || 0;
  var centre = options.center !== false;
  var resizeToFit = options.resizeToFit === true;
  var marginX = options.marginX || 0;
  var marginY = options.marginY || 0;
  var columnWidths = [];
  var columnWidth = options.columnWidth;

  if ('compact' === columnWidth) {
    for (var j = 0; j < columns; j += 1) {
      var items = GridLayout.getNodesInColumn(nodes, j, columns);
      columnWidths.push(GridLayout.getMaxDim(items, 'width') + dx);
    }
  } else {
    if (columnWidth == null || columnWidth === 'auto') {
      columnWidth = GridLayout.getMaxDim(nodes, 'width') + dx;
    }

    for (var i = 0; i < columns; i += 1) {
      columnWidths.push(columnWidth);
    }
  }

  var columnLefts = GridLayout.accumulate(columnWidths, marginX);
  var rowHeights = [];
  var rowHeight = options.rowHeight;

  if ('compact' === rowHeight) {
    for (var _i = 0; _i < rows; _i += 1) {
      var _items = GridLayout.getNodesInRow(nodes, _i, columns);

      rowHeights.push(GridLayout.getMaxDim(_items, 'height') + dy);
    }
  } else {
    if (rowHeight == null || rowHeight === 'auto') {
      rowHeight = GridLayout.getMaxDim(nodes, 'height') + dy;
    }

    for (var _i2 = 0; _i2 < rows; _i2 += 1) {
      rowHeights.push(rowHeight);
    }
  }

  var rowTops = GridLayout.accumulate(rowHeights, marginY);
  model.startBatch('layout');
  nodes.forEach(function (node, index) {
    var rowIndex = index % columns;
    var columnIndex = Math.floor(index / columns);
    var columnWidth = columnWidths[rowIndex];
    var rowHeight = rowHeights[columnIndex];
    var cx = 0;
    var cy = 0;
    var size = node.getSize();

    if (resizeToFit) {
      var width = columnWidth - 2 * dx;
      var height = rowHeight - 2 * dy;
      var calcHeight = size.height * (size.width ? width / size.width : 1);
      var calcWidth = size.width * (size.height ? height / size.height : 1);

      if (rowHeight < calcHeight) {
        width = calcWidth;
      } else {
        height = calcHeight;
      }

      size = {
        width: width,
        height: height
      };
      node.setSize(size, options);
    }

    if (centre) {
      cx = (columnWidth - size.width) / 2;
      cy = (rowHeight - size.height) / 2;
    }

    node.position(columnLefts[rowIndex] + dx + cx, rowTops[columnIndex] + dy + cy, options);
  });
  model.stopBatch('layout');
}
var GridLayout;

(function (GridLayout) {
  function getMaxDim(nodes, name) {
    return nodes.reduce(function (memo, node) {
      return Math.max(node.getSize()[name], memo);
    }, 0);
  }

  GridLayout.getMaxDim = getMaxDim;

  function getNodesInRow(nodes, rowIndex, columnCount) {
    var res = [];

    for (var i = columnCount * rowIndex, ii = i + columnCount; i < ii; i += 1) {
      res.push(nodes[i]);
    }

    return res;
  }

  GridLayout.getNodesInRow = getNodesInRow;

  function getNodesInColumn(nodes, columnIndex, columnCount) {
    var res = [];

    for (var i = columnIndex, ii = nodes.length; i < ii; i = i + columnCount) {
      res.push(nodes[i]);
    }

    return res;
  }

  GridLayout.getNodesInColumn = getNodesInColumn;

  function accumulate(items, start) {
    return items.reduce(function (memo, item, i) {
      memo.push(memo[i] + item);
      return memo;
    }, [start || 0]);
  }

  GridLayout.accumulate = accumulate;
})(GridLayout || (GridLayout = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/stencil/index.js














var stencil_Stencil = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(Stencil, _View);

  var _super = Object(createSuper["a" /* default */])(Stencil);

  function Stencil(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Stencil);

    _this = _super.call(this);
    _this.graphs = {};
    _this.$groups = {};
    _this.options = Object.assign(Object.assign({}, Stencil.defaultOptions), options);
    _this.dnd = new dnd_Dnd(_this.options);
    _this.onSearch = main_namespaceObject.debounce(_this.onSearch, 200);
    _this.container = document.createElement('div');
    _this.$container = _this.$(_this.container).addClass(_this.prefixClassName(stencil_ClassNames.base));
    _this.options.collapsable = options.collapsable && options.groups && options.groups.some(function (group) {
      return group.collapsable !== false;
    });

    if (_this.options.collapsable) {
      _this.$container.addClass('collapsable');

      var collapsed = options.groups && options.groups.every(function (group) {
        return group.collapsed || group.collapsable === false;
      });

      if (collapsed) {
        _this.$container.addClass('collapsed');
      }
    }

    _this.$('<div/>').addClass(_this.prefixClassName(stencil_ClassNames.title)).html(_this.options.title).appendTo(_this.$container);

    if (options.search) {
      _this.$container.addClass('searchable').append(_this.renderSearch());
    }

    _this.$content = _this.$('<div/>').addClass(_this.prefixClassName(stencil_ClassNames.content)).appendTo(_this.$container);
    var globalGraphOptions = options.stencilGraphOptions || {};

    if (options.groups && options.groups.length) {
      options.groups.forEach(function (group) {
        var $group = _this.$('<div/>').addClass(_this.prefixClassName(stencil_ClassNames.group)).attr('data-name', group.name);

        if (group.collapsable == null && options.collapsable || group.collapsable !== false) {
          $group.addClass('collapsable');
        }

        $group.toggleClass('collapsed', group.collapsed === true);

        var $title = _this.$('<h3/>').addClass(_this.prefixClassName(stencil_ClassNames.groupTitle)).html(group.title || group.name);

        var $content = _this.$('<div/>').addClass(_this.prefixClassName(stencil_ClassNames.groupContent));

        var graphOptionsInGroup = group.graphOptions;
        var graph = new graph_Graph(Object.assign(Object.assign(Object.assign({}, globalGraphOptions), graphOptionsInGroup), {
          container: document.createElement('div'),
          model: globalGraphOptions.model || new model_Model(),
          width: group.graphWidth || options.stencilGraphWidth,
          height: group.graphHeight || options.stencilGraphHeight,
          interacting: false,
          preventDefaultBlankAction: false
        }));
        $content.append(graph.container);
        $group.append($title, $content).appendTo(_this.$content);
        _this.$groups[group.name] = $group;
        _this.graphs[group.name] = graph;
      });
    } else {
      var graph = new graph_Graph(Object.assign(Object.assign({}, globalGraphOptions), {
        container: document.createElement('div'),
        model: globalGraphOptions.model || new model_Model(),
        width: options.stencilGraphWidth,
        height: options.stencilGraphHeight,
        interacting: false,
        preventDefaultBlankAction: false
      }));

      _this.$content.append(graph.container);

      _this.graphs[stencil_Private.defaultGroupName] = graph;
    }

    _this.startListening();

    return Object(possibleConstructorReturn["a" /* default */])(_this, Object(assertThisInitialized["a" /* default */])(_this));
  }

  Object(createClass["a" /* default */])(Stencil, [{
    key: "renderSearch",
    value: function renderSearch() {
      return this.$('<div/>').addClass(this.prefixClassName(stencil_ClassNames.search)).append(this.$('<input/>').attr({
        type: 'search',
        placeholder: 'Search'
      }).addClass(this.prefixClassName(stencil_ClassNames.searchText)));
    }
  }, {
    key: "startListening",
    value: function startListening() {
      var _this$delegateEvents,
          _this2 = this;

      var title = this.prefixClassName(stencil_ClassNames.title);
      var searchText = this.prefixClassName(stencil_ClassNames.searchText);
      var groupTitle = this.prefixClassName(stencil_ClassNames.groupTitle);
      this.delegateEvents((_this$delegateEvents = {}, Object(defineProperty["a" /* default */])(_this$delegateEvents, "click .".concat(title), 'onTitleClick'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "touchstart .".concat(title), 'onTitleClick'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "click .".concat(groupTitle), 'onGroupTitleClick'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "touchstart .".concat(groupTitle), 'onGroupTitleClick'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "input .".concat(searchText), 'onSearch'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "focusin .".concat(searchText), 'onSearchFocusIn'), Object(defineProperty["a" /* default */])(_this$delegateEvents, "focusout .".concat(searchText), 'onSearchFocusOut'), _this$delegateEvents));
      Object.keys(this.graphs).forEach(function (groupName) {
        var graph = _this2.graphs[groupName];
        graph.on('cell:mousedown', _this2.onDragStart, _this2);
      });
    }
  }, {
    key: "stopListening",
    value: function stopListening() {
      var _this3 = this;

      this.undelegateEvents();
      Object.keys(this.graphs).forEach(function (groupName) {
        var graph = _this3.graphs[groupName];
        graph.off('cell:mousedown', _this3.onDragStart, _this3);
      });
    }
  }, {
    key: "load",
    value: function load(data, groupName) {
      var _this4 = this;

      if (Array.isArray(data)) {
        this.loadGroup(data, groupName);
      } else {
        if (this.options.groups) {
          Object.keys(this.options.groups).forEach(function (groupName) {
            if (data[groupName]) {
              _this4.loadGroup(data[groupName], groupName);
            }
          });
        }
      }

      return this;
    }
  }, {
    key: "loadGroup",
    value: function loadGroup(cells, groupName) {
      var model = this.getModel(groupName);

      if (model) {
        var nodes = cells.map(function (cell) {
          return cell instanceof node_Node ? cell : node_Node.create(cell);
        });
        model.resetCells(nodes);
      }

      var group = this.getGroup(groupName);
      var height = this.options.stencilGraphHeight;

      if (group && group.graphHeight != null) {
        height = group.graphHeight;
      }

      var layout = group && group.layout || this.options.layout;

      if (layout && model) {
        main_namespaceObject.call(layout, this, model, group);
      }

      if (!height) {
        var graph = this.getGraph(groupName);
        graph.fitToContent({
          minWidth: graph.options.width,
          gridHeight: 1,
          padding: group && group.graphPadding || this.options.stencilGraphPadding || 10
        });
      }

      return this;
    }
  }, {
    key: "onDragStart",
    value: function onDragStart(args) {
      var e = args.e,
          node = args.node;
      this.dnd.start(node, e);
    }
  }, {
    key: "filter",
    value: function filter(keyworld, _filter) {
      var _this5 = this;

      var found = Object.keys(this.graphs).reduce(function (memo, groupName) {
        var graph = _this5.graphs[groupName];
        var name = groupName === stencil_Private.defaultGroupName ? null : groupName;
        var items = graph.model.getNodes().filter(function (cell) {
          var matched = false;
          matched = typeof _filter === 'function' ? main_namespaceObject.call(_filter, _this5, cell, keyworld, name, _this5) : _this5.isCellMatched(cell, keyworld, typeof _filter === 'boolean' ? {} : _filter, keyworld.toLowerCase() !== keyworld);
          var view = graph.renderer.findViewByCell(cell);

          if (view) {
            view.$(view.container).toggleClass('unmatched', !matched);
          }

          return matched;
        });
        var found = items.length > 0;
        var options = _this5.options;
        var model = new model_Model();
        model.resetCells(items);

        if (options.layout) {
          main_namespaceObject.call(options.layout, _this5, model, _this5.getGroup(groupName));
        }

        if (_this5.$groups[groupName]) {
          _this5.$groups[groupName].toggleClass('unmatched', !found);
        }

        graph.fitToContent({
          gridWidth: 1,
          gridHeight: 1,
          padding: options.stencilGraphPadding || 10
        });
        return memo || found;
      }, false);
      this.$container.toggleClass('not-found', !found);
    }
  }, {
    key: "isCellMatched",
    value: function isCellMatched(cell, keyworld, filters, ignoreCase) {
      if (keyworld && filters) {
        return Object.keys(filters).some(function (shape) {
          var paths = filters[shape];
          return ('*' === shape || cell.shape === shape) && paths.some(function (path) {
            var val = cell.getPropByPath(path);

            if (val != null) {
              val = "".concat(val);

              if (ignoreCase) {
                val = val.toLowerCase();
              }

              return val.indexOf(keyworld) >= 0;
            }
          });
        });
      }

      return true;
    }
  }, {
    key: "onSearch",
    value: function onSearch(evt) {
      this.filter(evt.target.value, this.options.search);
    }
  }, {
    key: "onSearchFocusIn",
    value: function onSearchFocusIn() {
      this.$container.addClass('is-focused');
    }
  }, {
    key: "onSearchFocusOut",
    value: function onSearchFocusOut() {
      this.$container.removeClass('is-focused');
    }
  }, {
    key: "onTitleClick",
    value: function onTitleClick() {
      if (this.options.collapsable) {
        this.$container.toggleClass('collapsed');

        if (this.$container.hasClass('collapsed')) {
          this.collapseGroups();
        } else {
          this.expandGroups();
        }
      }
    }
  }, {
    key: "onGroupTitleClick",
    value: function onGroupTitleClick(evt) {
      var _this6 = this;

      var $group = this.$(evt.target).closest(".".concat(this.prefixClassName(stencil_ClassNames.group)));
      this.toggleGroup($group.attr('data-name') || '');
      var allCollapsed = Object.keys(this.$groups).every(function (name) {
        var group = _this6.getGroup(name);

        var $group = _this6.$groups[name];
        return group && group.collapsable === false || $group.hasClass('collapsed');
      });
      this.$container.toggleClass('collapsed', allCollapsed);
    }
  }, {
    key: "getModel",
    value: function getModel(groupName) {
      var graph = this.getGraph(groupName);
      return graph ? graph.model : null;
    }
  }, {
    key: "getGraph",
    value: function getGraph(groupName) {
      return this.graphs[groupName || stencil_Private.defaultGroupName];
    }
  }, {
    key: "getGroup",
    value: function getGroup(groupName) {
      var groups = this.options.groups;

      if (groupName != null && groups && groups.length) {
        return groups.find(function (group) {
          return group.name === groupName;
        });
      }

      return null;
    }
  }, {
    key: "toggleGroup",
    value: function toggleGroup(groupName) {
      if (this.isGroupCollapsed(groupName)) {
        this.expandGroup(groupName);
      } else {
        this.collapseGroup(groupName);
      }

      return this;
    }
  }, {
    key: "collapseGroup",
    value: function collapseGroup(groupName) {
      if (this.isGroupCollapsable(groupName)) {
        var $group = this.$groups[groupName];

        if ($group && !this.isGroupCollapsed(groupName)) {
          this.trigger('group:collapse', {
            name: groupName
          });
          $group.addClass('collapsed');
        }
      }

      return this;
    }
  }, {
    key: "expandGroup",
    value: function expandGroup(groupName) {
      if (this.isGroupCollapsable(groupName)) {
        var $group = this.$groups[groupName];

        if ($group && this.isGroupCollapsed(groupName)) {
          this.trigger('group:expand', {
            name: groupName
          });
          $group.removeClass('collapsed');
        }
      }

      return this;
    }
  }, {
    key: "isGroupCollapsable",
    value: function isGroupCollapsable(groupName) {
      var $group = this.$groups[groupName];
      return $group.hasClass('collapsable');
    }
  }, {
    key: "isGroupCollapsed",
    value: function isGroupCollapsed(groupName) {
      var $group = this.$groups[groupName];
      return $group && $group.hasClass('collapsed');
    }
  }, {
    key: "collapseGroups",
    value: function collapseGroups() {
      var _this7 = this;

      Object.keys(this.$groups).forEach(function (groupName) {
        return _this7.collapseGroup(groupName);
      });
      return this;
    }
  }, {
    key: "expandGroups",
    value: function expandGroups() {
      var _this8 = this;

      Object.keys(this.$groups).forEach(function (groupName) {
        return _this8.expandGroup(groupName);
      });
      return this;
    }
  }, {
    key: "onRemove",
    value: function onRemove() {
      var _this9 = this;

      Object.keys(this.graphs).forEach(function (groupName) {
        var graph = _this9.graphs[groupName];
        graph.view.remove();
        delete _this9.graphs[groupName];
      });
      this.dnd.remove();
      this.stopListening();
      this.undelegateDocumentEvents();
    }
  }, {
    key: "targetScroller",
    get: function get() {
      var target = this.options.target;
      return target instanceof graph_Graph ? target.scroller.widget : target;
    }
  }, {
    key: "targetGraph",
    get: function get() {
      var target = this.options.target;
      return target instanceof graph_Graph ? target : target.graph;
    }
  }, {
    key: "targetModel",
    get: function get() {
      return this.targetGraph.model;
    }
  }]);

  return Stencil;
}(view_View);

(function (Stencil) {
  Stencil.defaultOptions = Object.assign({
    stencilGraphWidth: 200,
    stencilGraphHeight: 800,
    title: 'Stencil',
    collapsable: false,
    layout: function layout(model, group) {
      var options = {
        columnWidth: this.options.stencilGraphWidth / 2 - 10,
        columns: 2,
        rowHeight: 80,
        resizeToFit: false,
        dx: 10,
        dy: 10
      };
      grid_grid(model, Object.assign(Object.assign(Object.assign({}, options), this.options.layoutOptions), group ? group.layoutOptions : {}));
    }
  }, dnd_Dnd.defaults);
})(stencil_Stencil || (stencil_Stencil = {}));

var stencil_ClassNames;

(function (ClassNames) {
  ClassNames.base = 'widget-stencil';
  ClassNames.title = "".concat(ClassNames.base, "-title");
  ClassNames.search = "".concat(ClassNames.base, "-search");
  ClassNames.searchText = "".concat(ClassNames.search, "-text");
  ClassNames.content = "".concat(ClassNames.base, "-content");
  ClassNames.group = "".concat(ClassNames.base, "-group");
  ClassNames.groupTitle = "".concat(ClassNames.group, "-title");
  ClassNames.groupContent = "".concat(ClassNames.group, "-content");
})(stencil_ClassNames || (stencil_ClassNames = {}));

var stencil_Private;

(function (Private) {
  Private.defaultGroupName = '__default__';
})(stencil_Private || (stencil_Private = {}));
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/addon/index.js











// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/global/track.js



if ( true && Config.trackable) {
  setTimeout(function () {
    var host = 'https://kcart.alipay.com/web/bi.do';
    var image = new Image();
    var meta = Object.assign(Object.assign({}, Config.trackInfo), {
      version: version,
      pg: document.URL,
      r: new Date().getTime(),
      x6: true,
      page_type: 'syslog'
    });
    var d = encodeURIComponent(JSON.stringify([meta]));
    image.src = "".concat(host, "?BIProfile=merge&d=").concat(d);
  }, 3000);
}
// CONCATENATED MODULE: /home/runner/work/X6/X6/packages/x6/es/index.js










 // start track
// -----------


// EXTERNAL MODULE: ./src/app.css
var app = __webpack_require__(190);

// CONCATENATED MODULE: ./src/app.tsx
var app_Example=/*#__PURE__*/function(_React$Component){Object(inherits["a" /* default */])(Example,_React$Component);var _super=Object(createSuper["a" /* default */])(Example);function Example(){var _this;Object(classCallCheck["a" /* default */])(this,Example);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_super.call.apply(_super,[this].concat(args));_this.container=void 0;_this.refContainer=function(container){_this.container=container;};return _this;}Object(createClass["a" /* default */])(Example,[{key:"componentDidMount",value:function componentDidMount(){var graph=new graph_Graph({container:this.container,grid:true});var rect1=graph.addNode({x:30,y:30,width:100,height:40,label:'hello'});var rect2=graph.addNode({x:300,y:240,width:100,height:40,label:'world'});graph.addEdge({source:rect1,target:rect2,vertices:[{x:100,y:200},{x:300,y:120}],connector:{name:'normal'}});}},{key:"render",value:function render(){return/*#__PURE__*/react_default.a.createElement("div",{className:"app"},/*#__PURE__*/react_default.a.createElement("div",{className:"app-content",ref:this.refContainer}));}}]);return Example;}(react_default.a.Component);
// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/@ant-design/icons/es/icons/ReloadOutlined.js + 1 modules
var ReloadOutlined = __webpack_require__(280);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/@ant-design/icons/es/components/Icon.js
var Icon = __webpack_require__(270);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/@ant-design/icons/es/icons/GithubOutlined.js + 1 modules
var GithubOutlined = __webpack_require__(281);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/@ant-design/icons/es/icons/CodeSandboxOutlined.js + 1 modules
var CodeSandboxOutlined = __webpack_require__(282);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/@ant-design/icons/es/icons/ThunderboltOutlined.js + 1 modules
var ThunderboltOutlined = __webpack_require__(283);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/antd/es/tooltip/index.js + 7 modules
var tooltip = __webpack_require__(273);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/antd/dist/antd.css
var antd = __webpack_require__(191);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/@stackblitz/sdk/bundles/sdk.m.js
var sdk_m = __webpack_require__(165);

// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/codesandbox/lib/api/define.js
var api_define = __webpack_require__(166);

// EXTERNAL MODULE: /home/runner/work/X6/X6/examples/x6-example-sites-helper/es/toolbar/index.css
var toolbar = __webpack_require__(195);

// CONCATENATED MODULE: /home/runner/work/X6/X6/examples/x6-example-sites-helper/es/toolbar/index.js











var repo = __webpack_require__(194);



var toolbar_iconOpenInNewWindow = function iconOpenInNewWindow() {
  return react_default.a.createElement("svg", {
    width: "15",
    height: "12",
    viewBox: "0 0 15 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, react_default.a.createElement("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M14.4545 0H10.5C10.1988 0 10 0.198754 10 0.5C10 0.801246 10.1988 1 10.5 1H13L9.5 4.5L10.5 5.5L14 2V4.5C14 4.80125 14.1988 5 14.5 5C14.8012 5 15 4.80125 15 4.5V0.545455C15 0.244208 14.7558 0 14.4545 0ZM1.73333 1H8.00001V1.86667H1.73333C1.25469 1.86667 0.866667 2.25469 0.866667 2.73333V9.32003C0.866667 9.79868 1.25469 10.1867 1.73333 10.1867H12.1333C12.612 10.1867 13 9.79868 13 9.32004V7.00003H13.8667V9.32004C13.8667 10.2773 13.0906 11.0534 12.1333 11.0534H1.73333C0.776041 11.0534 0 10.2773 0 9.32003V2.73333C0 1.77604 0.77604 1 1.73333 1Z",
    fill: "currentcolor"
  }));
};

var toolbar_Toolbar = /*#__PURE__*/function (_React$Component) {
  Object(inherits["a" /* default */])(Toolbar, _React$Component);

  var _super = Object(createSuper["a" /* default */])(Toolbar);

  function Toolbar() {
    Object(classCallCheck["a" /* default */])(this, Toolbar);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Toolbar, [{
    key: "render",
    value: function render() {
      return react_default.a.createElement("div", {
        className: "demo-toolbar"
      }, react_default.a.createElement(tooltip["a" /* default */], {
        placement: "bottomLeft",
        arrowPointAtCenter: true,
        title: "\u91CD\u65B0\u52A0\u8F7D",
        mouseEnterDelay: 0.5
      }, react_default.a.createElement(ReloadOutlined["a" /* default */], {
        onClick: function onClick() {
          window.location.reload();
        }
      })), window.frameElement && react_default.a.createElement(tooltip["a" /* default */], {
        placement: "bottomLeft",
        arrowPointAtCenter: true,
        title: "\u5728\u65B0\u7A97\u53E3\u6253\u5F00",
        mouseEnterDelay: 0.5
      }, react_default.a.createElement("a", {
        href: "".concat(window.location.href),
        rel: "noopener noreferrer",
        target: "_blank"
      }, react_default.a.createElement(Icon["a" /* default */], {
        component: toolbar_iconOpenInNewWindow
      }))), react_default.a.createElement(tooltip["a" /* default */], {
        placement: "bottomLeft",
        arrowPointAtCenter: true,
        title: "\u5728 Github \u4E2D\u67E5\u770B",
        mouseEnterDelay: 0.5
      }, react_default.a.createElement("a", {
        href: "".concat(repo.host),
        rel: "noopener noreferrer",
        target: "_blank"
      }, react_default.a.createElement(GithubOutlined["a" /* default */], null))), react_default.a.createElement(tooltip["a" /* default */], {
        arrowPointAtCenter: true,
        placement: "bottomLeft",
        title: "\u5728 CodeSandbox \u4E2D\u6253\u5F00",
        mouseEnterDelay: 0.5
      }, react_default.a.createElement("form", {
        action: "https://codesandbox.io/api/v1/sandboxes/define",
        method: "POST",
        target: "_blank"
      }, react_default.a.createElement("input", {
        type: "hidden",
        name: "parameters",
        value: Object(api_define["getParameters"])(repo.getCodeSandboxParams())
      }), react_default.a.createElement("button", {
        type: "submit"
      }, react_default.a.createElement(CodeSandboxOutlined["a" /* default */], null)))), react_default.a.createElement(tooltip["a" /* default */], {
        placement: "bottomLeft",
        arrowPointAtCenter: true,
        title: "\u5728 StackBlitz \u4E2D\u6253\u5F00",
        mouseEnterDelay: 0.5
      }, react_default.a.createElement(ThunderboltOutlined["a" /* default */], {
        onClick: function onClick() {
          sdk_m["a" /* default */].openProject(repo.getStackblitzPrefillConfig(), {
            openFile: 'src/app.tsx'
          });
        }
      })));
    }
  }]);

  return Toolbar;
}(react_default.a.Component);
// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/antd/es/alert/index.js + 2 modules
var es_alert = __webpack_require__(277);

// EXTERNAL MODULE: /home/runner/work/X6/X6/examples/x6-example-sites-helper/es/wrap/content.css
var wrap_content = __webpack_require__(211);

// CONCATENATED MODULE: /home/runner/work/X6/X6/examples/x6-example-sites-helper/es/wrap/content.js







var content_Content = /*#__PURE__*/function (_React$Component) {
  Object(inherits["a" /* default */])(Content, _React$Component);

  var _super = Object(createSuper["a" /* default */])(Content);

  function Content(props) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Content);

    _this = _super.call(this, props);

    _this.refContainer = function (container) {
      _this.container = container;
    };

    Content.restoreIframeSize();
    return _this;
  }

  Object(createClass["a" /* default */])(Content, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.updateIframeSize();

      if (window.ResizeObserver) {
        var ro = new window.ResizeObserver(function () {
          _this2.updateIframeSize();
        });
        ro.observe(this.container);
      } else {
        window.addEventListener('resize', function () {
          return _this2.updateIframeSize();
        });
      }
    }
  }, {
    key: "updateIframeSize",
    value: function updateIframeSize() {
      var iframe = window.frameElement;

      if (iframe) {
        var height = this.container.scrollHeight || this.container.clientHeight;
        iframe.style.width = '100%';
        iframe.style.height = "".concat(height + 16, "px");
        iframe.style.border = '0';
        iframe.style.overflow = 'hidden';
        Content.saveIframeSize();
      }
    }
  }, {
    key: "render",
    value: function render() {
      return react_default.a.createElement("div", {
        className: "demo-wrap",
        ref: this.refContainer
      }, react_default.a.createElement(toolbar_Toolbar, null), this.props.children);
    }
  }]);

  return Content;
}(react_default.a.Component);

(function (Content) {
  var STORE_KEY = window.location.pathname;
  var STORE_ROOT = 'x6-iframe-size';

  function getData() {
    var raw = localStorage.getItem(STORE_ROOT);
    var data;

    if (raw) {
      try {
        data = JSON.parse(raw);
      } catch (error) {}
    } else {
      data = {};
    }

    return data;
  }

  function saveIframeSize() {
    var iframe = window.frameElement;

    if (iframe) {
      var style = iframe.style;
      var size = {
        width: style.width,
        height: style.height
      };
      var data = getData();
      data[STORE_KEY] = size;
      localStorage.setItem(STORE_ROOT, JSON.stringify(data));
    }
  }

  Content.saveIframeSize = saveIframeSize;

  function restoreIframeSize() {
    var iframe = window.frameElement;

    if (iframe) {
      var data = getData();
      var size = data[STORE_KEY];

      if (size) {
        iframe.style.width = size.width || '100%';
        iframe.style.height = size.height || 'auto';
      }
    }
  }

  Content.restoreIframeSize = restoreIframeSize;
})(content_Content || (content_Content = {}));
// EXTERNAL MODULE: /home/runner/work/X6/X6/node_modules/antd/es/alert/style/index.css
var alert_style = __webpack_require__(212);

// CONCATENATED MODULE: /home/runner/work/X6/X6/examples/x6-example-sites-helper/es/wrap/index.js




var wrap_Wrap = function Wrap(_ref) {
  var children = _ref.children;
  return react_default.a.createElement(es_alert["a" /* default */].ErrorBoundary, null, react_default.a.createElement(content_Content, null, children));
};
// CONCATENATED MODULE: /home/runner/work/X6/X6/examples/x6-example-sites-helper/es/index.js


// CONCATENATED MODULE: ./src/index.tsx
react_dom_default.a.render(/*#__PURE__*/react_default.a.createElement(wrap_Wrap,null,/*#__PURE__*/react_default.a.createElement(app_Example,null)),document.getElementById('root'));

/***/ })

},[[184,1,2]]]);